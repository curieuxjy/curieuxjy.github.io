---
title: "📃Rotating without Seeing"
description: Towards In-hand Dexterity through Touch
date: "2024-11-30"
categories: [paper, tactile, rl, hand]
toc: true
number-sections: true
image: ../../images/2024-11-23-rotating-without-seeing/flow.png
format:
  html:
    code-fold: true
jupyter: python3
---

<center>
<img src="../../images/2024-11-30-rotating-without-seeing/1.png" alt="22" width="100%" />
</center>

이번 포스팅에서 리뷰할 논문은 [Rotating without Seeing: Towards In-hand Dexterity through Touch](https://arxiv.org/abs/2303.10880) 입니다. RSS(Robotics: Science and Systems) [2023 학회](https://roboticsconference.org/2023/)에서 발표된 해당 논문은 사람이 **시각 없이 촉각만으로** 손안에서 물체를 정교하게 조작하는 능력을 로봇 핸드에 구현하고자, 손바닥, 손가락 관절, 손끝 전체에 넓게 분포된 **저비용의 이진 촉각 센서를 활용**하여, 시뮬레이션에서 **강화학습으로 학습한 정책을 실제 로봇 손에 적용**하고, 이를 통해 학습한 물체뿐만 아니라 **학습하지 않은 새로운 물체까지 조작**할 수 있는 시스템인 **`Touch Dexterity`**를 제안합니다.

# Introduction

대다수의 기존 연구들은 점점 더 `고품질`의 센서를 활용하여 `정밀하고 세밀한 접촉`을 다루는 데 초점을 맞추었습니다. 하지만 이러한 연구들은 대개 `비싼 센서를 그리퍼나 손의 손가락 끝부분에만 부착`할 수 있어, **조작기 전체를 감지하지 못한다는 한계**를 가지고 있습니다. 이로 인해 수행할 수 있는 작업의 범위가 제한됩니다. 또한 복잡한 작업을 위해 대량의 학습 데이터를 필요로 하지만, 고정밀의 센서들을 사용하는 경우 더욱더 벌어지는 Sim2Real 간의 차이로 인해 시뮬레이터를 활용하기 어려운 문제가 존재합니다. 

Touch Dexterity는 물체를 "보고" 조작하는 대신 단순히 **접촉만으로 물체를 회전하거나 조작하는 기술**입니다. 이 접근법은 **손의 한쪽 면(손가락 끝, 링크, 손바닥)에 부착된 저비용의 binary force 센서를 활용**합니다. 이러한 **센서는 접촉 여부만을 판단**하며, 이를 통해 물체의 상태를 "느낄 수" 있게 합니다. 16개의 센서를 조합하면 최대 2¹⁶가지 상태를 표현할 수 있어 강력한 표현력을 가질 수 있고, 또한 Sim2Real 격차는 시뮬레이션을 통해 충분한 데이터를 확보함으로써 해결 가능하며, 이 때 binary 센서는 단순한 구조로 인해 노이즈에 덜 민감하다는 장점이 있습니다.

<center>
<img src="../../images/2024-11-30-rotating-without-seeing/3.png" alt="22" width="100%" />
<figcaption>Amazon에서 약 8달러 정도로 저렴하게 판매되고 있는 FSR 센서를 부착한 모습</figcaption>
</center>
Touch Dexterity는 다중 손가락 로봇 손을 사용하여 **"보이지 않는" 물체를 x, y, z 축으로 회전시키는 작업**에 초점을 맞추고 있으며, 이는 in-hand re-orientation task의 단순화된 버전으로 볼 수 있습니다. 여기서 `보이지 않는` 물체란 단순히 시각 센서가 없는 것을 의미할 뿐만 아니라, 학습 중에 보지 못한 물체들을 의미하기도 합니다. 강화 학습(RL) 정책은 binary touch sensing 정보와 로봇의 내부 상태를 입력으로 받아 각 시간 단계에서 폐루프(closed loop) 제어를 위한 행동을 예측합니다. 강화학습 Agent는 물체의 3D 구조와 자세를 암묵적으로 학습하여 이를 기반으로 회전을 수행하며 실제 로봇 시스템 테스트에서는 10개의 다양한 물체를 활용하여 실험을 진행했습니다. 아래의 그림은 Unseen 물체였던 오리 인형을 real world에서 in-hand manipulation을 하는 장면입니다.

<center>
<img src="../../images/2024-11-30-rotating-without-seeing/2.png" alt="22" width="100%" />
<figcaption>Rotate the rubber duck for two cycles without falling, even if it is never presented in training</figcaption>
</center>


**Dexterous Manipulation**



기존의 분석적 모델 기반 접근법은 물체와 컨트롤러에 대한 지나치게 많은 가정을 필요로 하여 복잡한 문제로 확장하는 데 한계가 있습니다. 모방 학습(imitation learning)은 주로 시각 입력에 의존하며, proprioception 데이터 내에 포함된 암묵적인 촉각 정보를 통해 물체의 정보를 추론할 수 있지만, 주로 손가락 끝에서의 물체 회전이나 제한된 물체 집합의 회전에만 초점을 맞춥니다. 반면, Touch Dexterity는 촉각 센서를 사용하여 손과 물체 간의 상호작용을 명시적으로 인지하고, 다양한 종류의 물체에 대해 손바닥 위에서의 물체 회전 문제를 풉니다. 이는 복잡한 물체의 움직임을 포함하며, 훨씬 더 도전적인 문제를 다룰 수 있고 학습되지 않은 새로운 물체에 대해서도 일반화가 가능하다는 장점을 가지고 있습니다.



**Tactile Robotic Manipulation**

`What type of touch information is essential?`

기존 연구들은 다양한 센서를 활용하여 조작을 지원하기 위해 국소적인 형상 정보(local geometry), 힘과 토크, 접촉 이벤트, 물질 특성을 추출하는 방법을 제안해왔습니다. 심지어 간단한 binary 접촉 신호를 sparse sensor array로 제공받는 경우에도 high-dimensional manipulation task에서 유용할 수 있습니다. 일례로, [Shadow Hand](https://en.wikipedia.org/wiki/Shadow_Hand)에 손바닥에 밀집된 센서 레이아웃을 활용한 [연구](https://ieeexplore.ieee.org/document/7353568)도 있었습니다. 

`How can tactile events be simulated to facilitate Sim2Real transfer?`

일반적으로 접촉 표면(contact surface)에서 normal & shear tactile force field을 시뮬레이션합니다. 반면, Touch Dexterity는 별도의 시뮬레이션 설계를 요구하지 않고, 기존 물리 시뮬레이터의 내장된 contact 시뮬레이션을 활용할 수 있다는 점에서 효율적이라고 볼 수 있습니다.



# Learning Touch Dexterity



논문에서 제안된 Touch Dexterity의 AI 모듈이 학습되는 과정에 대해 살펴보겠습니다.



## Problem Formulation

Touch Dexterity는 강화학습 방법으로 제어를 하기 때문에 강화학습의 문제 정의 방식인 MDP(Markov Decision Process)의 요소들, State, Action, Reward 순으로 확인해보겠습니다.

### State

State는 Hand Robot Agent의 상태를 나타내는 요소들로 이루어집니다. Allegro hand 로봇의의 joint position(16 차원), sensor observation(16차원), 이전 position target(16차원), 그리고 rotation axis(2차원)로 구성되어 있습니다. 핸드 로봇의 관절(joint) 부분들이 작은 모터들 16개로 이루어져 있고, FSR([Force Sensing Resistor](https://en.wikipedia.org/wiki/Force-sensing_resistor)) 센서들도 총 16개가 아래 그림처럼 손가락과 손바닥에 분포되어 있어 State 벡터의 차원들이 다음과 같이 구성되게 됩니다. 이렇게 구성된 State가 학습 시에 Policy Network의 Input으로 들어가게 되는데 1 time step 정보만으로는 학습하기에 부족한 정보량이기 때문에 현재 시점 기준 이전 스텝 2 time step을 합쳐(concatenation), 총 **3 time step 을 쌓아서** policy network에 input으로 넣어줍니다.

<center>
<img src="../../images/2024-11-30-rotating-without-seeing/4.png" alt="22" width="100%" />
<figcaption>State 구성요소</figcaption>
</center>


### Action

Hand Agent가 움직이는 Action은 로봇의 각 관절(joint) 모터들이 움직이는 것으로 생각할 수 있습니다. 따라서 Policy network에서는 16차원의 모터와 관련된 어떠한 command 정보가 나오게 됩니다. 하지만 Policy network의 output인 $a_t$를 바로 쓰는 것이 아닌 [PD Controller](https://en.wikipedia.org/wiki/Proportional%E2%80%93integral%E2%80%93derivative_controller)에 적용하기 위한 값으로 변환하는 과정을 거치게 됩니다. 결과적으로 PD Controller에서 사용하는 값은 $\tilde{q}_{t+1}$ (현재 time step이 $t$ 이므로 앞으로 제어할 position의 time step 첨자는 $t+1$)인 것 입니다.

하지만 여기서 $\tilde{q}_{t+1}$을 바로 적용할 경우 생기는 문제가 있습니다. policy network output 값들이 연속적인 시간 순으로 봤을때 갭이 큰 값들이 나타나게 되면 부드러운 움직임을 가질 수 없습니다. 따라서 해당연구에서는 [Exponential moving average](https://en.wikipedia.org/wiki/Moving_average) 방법을 사용하여 smoothing하는 과정을 거치게 됩니다.




<center>
<img src="../../images/2024-11-30-rotating-without-seeing/5.png" alt="22" width="100%" />
<figcaption>Action이 적용되는 과정</figcaption>
</center>
아래 그래프는 논문에서 제시한 파라미터($\eta$, 2 consecutive steps)로 랜덤한 포인트들을 가지고 smoothing하는 모습을 보여줍니다.

```{python}
import matplotlib.pyplot as plt
import numpy as np

# Parameters
eta = 0.8  # Smoothing factor
steps = 2  # Step size for x-axis
n_points = 200  # Number of points

# Generate data
x = np.arange(0, n_points, steps)
data = np.sin(x / 5) + np.random.normal(0, 0.3, len(x))  # Random data with noise
ema = []

# Calculate EMA
for i, point in enumerate(data):
    if i == 0:
        ema.append(point)  # Initialize EMA with the first data point
    else:
        ema.append(eta * point + (1 - eta) * ema[-1])

# Plot
plt.figure(figsize=(8, 3))
plt.plot(x, data, label="Data", marker="o", linestyle="--", alpha=0.6)
plt.plot(x, ema, label="Exponential Moving Average (EMA)", linewidth=2)
plt.xlabel("Step")
plt.ylabel("Value")
plt.title(f"Exponential Moving Average (eta={eta}, step={steps}) ")
plt.legend()
plt.grid(True)
plt.show()

```

이렇게 최종적으로 계산된 Action값으로 Hand Agent의 모션이 만들어지게 됩니다.




## Domain Randomization



## Training Procedure





# Tactile Dexterous Manipulation System


## Setup


<center>
<img src="../../images/2024-11-23-rotating-without-seeing/flow.png" alt="22" width="70%" />
    <figcaption>overview</figcaption>
</center>

## Discussion

# Experiments



# Reference

- [Original Paper]()
- [Project Homepage](https://touchdexterity.github.io/)