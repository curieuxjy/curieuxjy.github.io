---
title: "ğŸ‘©â€ğŸ’»ROS2 code ê°œì„ "
toc: true
number-sections: true
date: "2025-10-31"
description: ê¸°ì¡´ì˜ ROS1 ì œì–´ ì½”ë“œì—ì„œ ROS2 ì œì–´ ì½”ë“œë¡œ ë¦¬í™í† ë§
categories: [ros2, python, code]
execute:
  freeze: auto
---

# ROS2 ì œì–´ ì½”ë“œ ê°œì„ : ì‹¤ì‹œê°„ì„±ê³¼ ì•ˆì •ì„±ì„ ìœ„í•œ ì¢…í•© ê°€ì´ë“œ

ROS1 ê¸°ë°˜ì˜ ì œì–´ ì½”ë“œë¥¼ ROS2ë¡œ ì „í™˜í•˜ë©´ì„œ ê°€ì¥ ì¤‘ìš”í•˜ê²Œ ìƒê°í•œ ì ì€ ë‹¨ìˆœíˆ APIë¥¼ ë°”ê¾¸ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ROS2ì˜ íŠ¹ì„±ì„ í™œìš©í•´ ì‹¤ì‹œê°„ì„±ê³¼ ì•ˆì •ì„±ì„ ê·¼ë³¸ì ìœ¼ë¡œ í–¥ìƒì‹œí‚¤ëŠ” ê²ƒì´ì—ˆìŠµë‹ˆë‹¤. ì´ ê¸€ì—ì„œëŠ” ê¸°ì¡´ ì½”ë“œê°€ ê°€ì§„ ë¬¸ì œì ë“¤ì„ í•˜ë‚˜ì”© ì§šì–´ë³´ê³ , ì–´ë–»ê²Œ ê°œì„ í–ˆëŠ”ì§€ ê·¸ ê³¼ì •ê³¼ ì´ìœ ë¥¼ ìƒì„¸íˆ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤.

## ì œì–´ ë£¨í”„ì˜ ê·¼ë³¸ì ì¸ ì „í™˜

ê¸°ì¡´ ì½”ë“œëŠ” `while True` ë£¨í”„ ì•ˆì—ì„œ `time.sleep()`ì„ ì‚¬ìš©í•´ ì£¼ê¸°ë¥¼ ë§ì¶”ëŠ” ë°©ì‹ì´ì—ˆìŠµë‹ˆë‹¤. ì–¼í• ë³´ë©´ ê°„ë‹¨í•˜ê³  ì§ê´€ì ì´ì§€ë§Œ, ì‹¤ì œë¡œëŠ” ì—¬ëŸ¬ ë¬¸ì œë¥¼ ì•ˆê³  ìˆì—ˆìŠµë‹ˆë‹¤. ìš´ì˜ì²´ì œì˜ ìŠ¤ì¼€ì¤„ë§ ì •ì±…, íŒŒì´ì¬ì˜ GIL(Global Interpreter Lock), ê¹Šì€ í•¨ìˆ˜ í˜¸ì¶œ ìŠ¤íƒ ë“±ì´ ë³µí•©ì ìœ¼ë¡œ ì‘ìš©í•˜ë©´ì„œ ì œì–´ ì£¼ê¸°ì— í° ì§€í„°(jitter)ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. íŠ¹íˆ ROS ì½œë°±ì´ë‚˜ êµ¬ë…ì ì²˜ë¦¬ì™€ ë™ì‹œì— ì‹¤í–‰ë  ë•ŒëŠ” ì£¼ê¸°ê°€ ë”ìš± ë¶ˆì•ˆì •í•´ì§€ëŠ” ë¬¸ì œê°€ ìˆì—ˆìŠµë‹ˆë‹¤.

ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ROS2ì˜ íƒ€ì´ë¨¸ ë©”ì»¤ë‹ˆì¦˜ì„ ë„ì…í–ˆìŠµë‹ˆë‹¤. `self.allegro.create_timer(period, self._control_step)`ì²˜ëŸ¼ íƒ€ì´ë¨¸ë¥¼ ë“±ë¡í•˜ë©´, ROS2ì˜ ì‹¤í–‰ê¸°(executor)ê°€ ì§€ì •ëœ ì£¼ê¸°ë§ˆë‹¤ ì½œë°± í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì¤ë‹ˆë‹¤. ì´ ë°©ì‹ì˜ ì¥ì ì€ ì œì–´ ì£¼ê¸°ê°€ ROS ì‹¤í–‰ê¸°ì— ì˜í•´ ê´€ë¦¬ë˜ê¸° ë•Œë¬¸ì— ì§€í„°ê°€ í¬ê²Œ ê°ì†Œí•œë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ë©”ì¸ ìŠ¤ë ˆë“œëŠ” íƒ€ì´ë¨¸ë§Œ ì²˜ë¦¬í•˜ê³ , I/O ì‘ì—…ì´ë‚˜ ë‹¤ë¥¸ ì½œë°±ì€ ì‹¤í–‰ê¸°ê°€ ì ì ˆíˆ ìŠ¤ì¼€ì¤„ë§í•´ì£¼ê¸° ë•Œë¬¸ì— ìì› ê²½í•©ë„ ì¤„ì–´ë“­ë‹ˆë‹¤.

## ì‹¤í–‰ê¸° ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬ì˜ ì•ˆì •í™”

ì´ˆê¸° êµ¬í˜„ì—ì„œëŠ” rclpyì˜ ë‚´ë¶€ APIì¸ `rclpy.executors._util`ì´ë‚˜ `_thread`ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ëŠ” ê³µì‹ì ìœ¼ë¡œ ì§€ì›ë˜ì§€ ì•ŠëŠ” private APIì˜€ê³ , ROS2 ë²„ì „ì´ ë‹¬ë¼ì§€ë©´ `AttributeError`ê°€ ë°œìƒí•˜ëŠ” ì‹¬ê°í•œ ë¬¸ì œê°€ ìˆì—ˆìŠµë‹ˆë‹¤. ì‹¤ì œë¡œ ë‹¤ë¥¸ í™˜ê²½ì—ì„œ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë ¤ê³  í•  ë•Œ ì´ ë¬¸ì œë¡œ ì¸í•´ ì½”ë“œê°€ ë™ì‘í•˜ì§€ ì•ŠëŠ” ê²½ìš°ê°€ ë¹ˆë²ˆí–ˆìŠµë‹ˆë‹¤.

ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì¸ `threading.Thread`ì™€ ROS2ì˜ `SingleThreadedExecutor`ë¥¼ ì¡°í•©í•œ ì•ˆì •ì ì¸ ë°©ì‹ìœ¼ë¡œ ì „í™˜í–ˆìŠµë‹ˆë‹¤. ë³„ë„ì˜ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ê¸°ë¥¼ ëŒë¦¬ë©´ì„œ ROS2 ë…¸ë“œê°€ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì•ˆì „í•˜ê²Œ ë™ì‘í•˜ë„ë¡ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ íƒ€ì´ë¨¸ ì½œë°±ê³¼ êµ¬ë…ì ì½œë°±ì´ ì„œë¡œ ë§‰íˆì§€ ì•Šê³  ì›í™œí•˜ê²Œ ì²˜ë¦¬ë©ë‹ˆë‹¤. ê³µì‹ APIë§Œ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì— ë²„ì „ í˜¸í™˜ì„± ë¬¸ì œë„ ì™„ì „íˆ í•´ê²°ë˜ì—ˆìŠµë‹ˆë‹¤.

## ì¥ì¹˜ ì¼ê´€ì„± ë¬¸ì œì˜ í•´ê²°

ë”¥ëŸ¬ë‹ ëª¨ë¸ì„ ì‚¬ìš©í•  ë•Œ ê°€ì¥ í”í•˜ê²Œ ë§ˆì£¼ì¹˜ëŠ” ë¬¸ì œ ì¤‘ í•˜ë‚˜ê°€ í…ì„œ, ëª¨ë¸, ì •ê·œí™” ê°ì²´ë“¤ì´ ì„œë¡œ ë‹¤ë¥¸ ë””ë°”ì´ìŠ¤(CUDA GPU ë˜ëŠ” CPU)ì— ìˆì„ ë•Œ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ì…ë‹ˆë‹¤. "Expected all tensors to be on the same device"ë¼ëŠ” ëŸ°íƒ€ì„ ì—ëŸ¬ê°€ ë°œìƒí•˜ë©´ ë””ë²„ê¹…ì´ ë§¤ìš° ì–´ë µìŠµë‹ˆë‹¤.

ì´ë¥¼ ê·¼ë³¸ì ìœ¼ë¡œ í•´ê²°í•˜ê¸° ìœ„í•´ `self.device`ë¥¼ ë‹¨ì¼ ì§„ì‹¤ ê³µê¸‰ì›(single source of truth)ìœ¼ë¡œ ì„¤ì •í•˜ê³ , ëª¨ë¸, running_mean_std, sa_mean_stdëŠ” ë¬¼ë¡ ì´ê³  ê´€ì¸¡ ë²„í¼ì¸ `obs_buf`, ê³ ìœ  ìˆ˜ìš© íˆìŠ¤í† ë¦¬ ë²„í¼ì¸ `proprio_hist_buf`ê¹Œì§€ ëª¨ë‘ ê°™ì€ ë””ë°”ì´ìŠ¤ì— ìƒì„±í•˜ê³  ì´ë™ì‹œì¼°ìŠµë‹ˆë‹¤. í•˜ë“œì›¨ì–´ë¡œ ëª…ë ¹ì„ ë³´ë‚´ì•¼ í•  ë•Œë§Œ `self.cur_target.detach().to('cpu').numpy()`ì²˜ëŸ¼ CPUë¡œ ë³€í™˜í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ë””ë°”ì´ìŠ¤ ê°„ ì´ë™ì„ ìµœì†Œí™”í•´ ì†ë„ê°€ í–¥ìƒë˜ê³ , ë””ë°”ì´ìŠ¤ ë¶ˆì¼ì¹˜ ì—ëŸ¬ë„ ì™„ì „íˆ ì‚¬ë¼ì§‘ë‹ˆë‹¤.

## ì¶”ë¡  ì„±ëŠ¥ ìµœì í™”

ì œì–´ ë£¨í”„ì—ì„œëŠ” ëª¨ë¸ì˜ ìˆœì „íŒŒë§Œ í•„ìš”í•˜ê³  ì—­ì „íŒŒëŠ” ì „í˜€ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ê¸°ë³¸ì ìœ¼ë¡œ PyTorchëŠ” ê·¸ë˜ë””ì–¸íŠ¸ íŠ¸ë˜í‚¹ì„ ìˆ˜í–‰í•˜ê¸° ë•Œë¬¸ì— ë¶ˆí•„ìš”í•œ ë©”ëª¨ë¦¬ì™€ ì—°ì‚° ë¹„ìš©ì´ ë°œìƒí•©ë‹ˆë‹¤. ë˜í•œ ì½”ë“œ ê³³ê³³ì—ì„œ `.clone()`ì„ ë‚¨ë°œí•˜ë©´ ë©”ëª¨ë¦¬ ë³µì‚¬ ì˜¤ë²„í—¤ë“œê°€ ì»¤ì§‘ë‹ˆë‹¤.

íƒ€ì´ë¨¸ ì½œë°± í•¨ìˆ˜ì¸ `_control_step`ì— `@torch.inference_mode()` ë°ì½”ë ˆì´í„°ë¥¼ ì ìš©í•´ ì¶”ë¡  ëª¨ë“œì„ì„ ëª…ì‹œì ìœ¼ë¡œ ì„ ì–¸í–ˆìŠµë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ê·¸ë˜ë””ì–¸íŠ¸ ê³„ì‚°ê³¼ ê´€ë ¨ëœ ëª¨ë“  ì˜¤ë²„í—¤ë“œê°€ ì œê±°ë©ë‹ˆë‹¤. ë˜í•œ ì½”ë“œë¥¼ ì „ì²´ì ìœ¼ë¡œ ê²€í† í•´ì„œ ê¼­ í•„ìš”í•œ ìœ„ì¹˜ì—ì„œë§Œ `clone()`ì„ ì‚¬ìš©í•˜ë„ë¡ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ìµœì í™”ë¥¼ í†µí•´ ì¶”ë¡  ì‹œê°„ì´ ì•ˆì •í™”ë˜ê³  ì „ì²´ì ì¸ ì œì–´ ì£¼ê¸°ê°€ ì¼ì •í•˜ê²Œ ìœ ì§€ë©ë‹ˆë‹¤.

## ê´€ì¸¡ ë“œëì— ëŒ€í•œ ë¡œë²„ìŠ¤íŠ¸í•œ ëŒ€ì‘

ì‹¤ì‹œê°„ ì œì–´ ì‹œìŠ¤í…œì—ì„œ í”¼í•  ìˆ˜ ì—†ëŠ” ë¬¸ì œ ì¤‘ í•˜ë‚˜ê°€ ì„¼ì„œ ë°ì´í„°ì˜ ì§€ì—°ì´ë‚˜ ëˆ„ë½ì…ë‹ˆë‹¤. íƒ€ì´ë¨¸ ì£¼ê¸°ì™€ `/joint_states` í† í”½ì˜ í¼ë¸”ë¦¬ì‹œ ì£¼ê¸°ê°€ ì™„ë²½í•˜ê²Œ ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´, ì–´ë–¤ ì œì–´ í‹±ì—ì„œëŠ” ìƒˆë¡œìš´ ê´€ì¸¡ ë°ì´í„°ê°€ ë„ì°©í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë•Œ ë¸”ë¡œí‚¹ ë°©ì‹ìœ¼ë¡œ ë°ì´í„°ë¥¼ ê¸°ë‹¤ë¦¬ë©´ ì œì–´ ì£¼ê¸° ìì²´ê°€ ê¹¨ì ¸ë²„ë¦½ë‹ˆë‹¤.

ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë…¼ë¸”ë¡œí‚¹ ë°©ì‹ì¸ `wait=False`ë¡œ ë°ì´í„°ë¥¼ ì½ë„ë¡ ë³€ê²½í–ˆìŠµë‹ˆë‹¤. ìƒˆë¡œìš´ ìƒ˜í”Œì´ ì—†ìœ¼ë©´ ì§ì „ì— ìœ íš¨í–ˆë˜ ê´€ì¸¡ê°’ì¸ `_last_obs_q`ë¥¼ ì¬ì‚¬ìš©í•©ë‹ˆë‹¤. ë™ì‹œì— ë“œëëœ íšŸìˆ˜ë¥¼ `_skipped` ì¹´ìš´í„°ë¡œ ê¸°ë¡í•´ì„œ ë¡œê¹…í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ì„¼ì„œ ë°ì´í„°ê°€ ì¼ì‹œì ìœ¼ë¡œ ì§€ì—°ë˜ë”ë¼ë„ ì œì–´ ì£¼ê¸°ëŠ” ê³„ì† ìœ ì§€ë˜ê³ , ì‹œìŠ¤í…œì´ ë¡œë²„ìŠ¤íŠ¸í•˜ê²Œ ë™ì‘í•©ë‹ˆë‹¤. ë“œë íšŸìˆ˜ë¥¼ ëª¨ë‹ˆí„°ë§í•¨ìœ¼ë¡œì¨ ì„¼ì„œ í†µì‹ ì— ë¬¸ì œê°€ ìˆëŠ”ì§€ë„ íŒŒì•…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ë²„í¼ ë¡¤ë§ì˜ ì•ˆì „í•œ êµ¬í˜„

ì‹œê³„ì—´ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•  ë•Œ ë²„í¼ë¥¼ ì‹œí”„íŠ¸í•˜ëŠ” ì‘ì—…ì´ ìì£¼ í•„ìš”í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ `self.obs_buf[:, :64] = self.obs_buf[:, 32:]`ì²˜ëŸ¼ ê°™ì€ í…ì„œ ë‚´ì—ì„œ ê²¹ì¹˜ëŠ” ë©”ëª¨ë¦¬ ì˜ì—­ì— ëŒ€ì…í•˜ë©´ PyTorchê°€ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤. ì´ëŠ” ë©”ëª¨ë¦¬ ì•ˆì •ì„±ì„ ìœ„í•œ ì„¤ê³„ ê²°ì •ì¸ë°, ì˜¬ë°”ë¥´ê²Œ ì²˜ë¦¬í•˜ì§€ ì•Šìœ¼ë©´ ëŸ°íƒ€ì„ ì—ëŸ¬ë¡œ ì´ì–´ì§‘ë‹ˆë‹¤.

ì´ë¥¼ í•´ê²°í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ ë‘ ê°€ì§€ë¥¼ ì œì‹œí–ˆìŠµë‹ˆë‹¤. ì²« ë²ˆì§¸ëŠ” `clone()`ì„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤. `src = self.obs_buf[:, 32:96].clone()`ì²˜ëŸ¼ ì›ë³¸ ë°ì´í„°ë¥¼ ë¨¼ì € ë³µì‚¬í•œ í›„ ëŒ€ì…í•˜ë©´ ì•ˆì „í•©ë‹ˆë‹¤. ë‘ ë²ˆì§¸ëŠ” `torch.roll()`ì„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤. `rolled = torch.roll(self.obs_buf, shifts=-32, dims=1)`ë¡œ ì „ì²´ ë²„í¼ë¥¼ ì‹œí”„íŠ¸í•œ í›„ `self.obs_buf.copy_(rolled)`ë¡œ ë³µì‚¬í•˜ë©´ ë©ë‹ˆë‹¤. ë‘ ë°©ë²• ëª¨ë‘ ì•ˆì „í•˜ê³  ëª…í™•í•˜ë©°, ì˜ˆì™¸ ì—†ì´ ë™ì‘í•©ë‹ˆë‹¤.

## ë””ë²„ê¹…ì„ ìœ„í•œ í¬ì§€ì…˜ ê°­ í¼ë¸”ë¦¬ì…”

ë¡œë´‡ ì œì–´ì—ì„œ ëª…ë ¹ê°’ê³¼ ì‹¤ì œ ìœ„ì¹˜ ì‚¬ì´ì˜ ì˜¤ì°¨ëŠ” ë§¤ìš° ì¤‘ìš”í•œ ì§€í‘œì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ê¸°ì¡´ ì½”ë“œì—ì„œëŠ” ì´ë¥¼ ì™¸ë¶€ì—ì„œ í™•ì¸í•  ë°©ë²•ì´ ì—†ì—ˆìŠµë‹ˆë‹¤. ë””ë²„ê¹…ì´ë‚˜ ì„±ëŠ¥ ë¶„ì„ì„ í•  ë•Œ ì´ ì •ë³´ê°€ ë§¤ìš° ìœ ìš©í•©ë‹ˆë‹¤.

ì´ë¥¼ ìœ„í•´ `/position_gap` í† í”½ì„ ìƒˆë¡œ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤. `sensor_msgs/JointState` ë©”ì‹œì§€ íƒ€ì…ì„ ì‚¬ìš©í•´ì„œ ROS ìƒíƒœê³„ì˜ í‘œì¤€ ë„êµ¬ë“¤ê³¼ í˜¸í™˜ë˜ë„ë¡ í–ˆìŠµë‹ˆë‹¤. `header.stamp`ì—ëŠ” `node.get_clock().now().to_msg()`ë¡œ ì •í™•í•œ ROS íƒ€ì„ìŠ¤íƒ¬í”„ë¥¼ ê¸°ë¡í•˜ê³ , `name` í•„ë“œì—ëŠ” 16ê°œ ì¡°ì¸íŠ¸ì˜ ì´ë¦„ì„, `position` í•„ë“œì—ëŠ” ëª…ë ¹ê°’ê³¼ ì‹¤ì¸¡ê°’ì˜ ì°¨ì´ë¥¼ ë‹´ìŠµë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ rqt_plotìœ¼ë¡œ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ì„ í•˜ê±°ë‚˜, rosbagìœ¼ë¡œ ê¸°ë¡í•´ì„œ ë‚˜ì¤‘ì— ë¶„ì„í•˜ëŠ” ê²ƒì´ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.

ê°­ì„ ì¸¡ì •í•˜ëŠ” íƒ€ì´ë°ë„ ì¤‘ìš”í•©ë‹ˆë‹¤. ì´ˆê¸°ì—ëŠ” "ëª…ë ¹ ì „ì†¡ â†’ ì§§ì€ sleep â†’ ê°­ ì¸¡ì •"ì„ ê³ ë ¤í–ˆì§€ë§Œ, ìµœì¢… êµ¬ì¡°ì—ì„œëŠ” íƒ€ì´ë¨¸ ì½œë°±ì´ ë§¤ í‹±ë§ˆë‹¤ ìµœì‹  ìƒíƒœë¥¼ ë°˜ì˜í•˜ê¸° ë•Œë¬¸ì— ë³„ë„ì˜ sleepì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤. I/O ë…¸ë“œê°€ í•­ìƒ ìµœì‹  `/joint_states`ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë…¼ë¸”ë¡œí‚¹ ë°©ì‹ìœ¼ë¡œ ê°­ì„ ê³„ì‚°í•˜ë¯€ë¡œ ì œì–´ ì£¼ê¸°ë¥¼ ì „í˜€ ë°©í•´í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

## ì‹ ì¤‘í•œ ì´ˆê¸°í™” ê³¼ì •

ì œì–´ë¥¼ ì‹œì‘í•˜ê¸° ì „ì˜ ì´ˆê¸°í™” ê³¼ì •ë„ ë§¤ìš° ì¤‘ìš”í•©ë‹ˆë‹¤. ì›Œë°ì—… ë‹¨ê³„ì—ì„œëŠ” ì œì–´ ì£¼íŒŒìˆ˜ì˜ 4ë°°ì— í•´ë‹¹í•˜ëŠ” íšŸìˆ˜ë§Œí¼ ì´ˆê¸° ìì„¸ ëª…ë ¹ì„ ë³´ëƒ…ë‹ˆë‹¤. ì´ëŠ” ëª¨í„° ë“œë¼ì´ë²„ê°€ ì•ˆì •í™”ë˜ë„ë¡ í•˜ê¸° ìœ„í•¨ì…ë‹ˆë‹¤.

ì²« ë²ˆì§¸ ê´€ì¸¡ì€ íŠ¹ë³„í•˜ê²Œ ì²˜ë¦¬í•©ë‹ˆë‹¤. `wait=True, timeout=5.0`ìœ¼ë¡œ ë¸”ë¡œí‚¹ ë°©ì‹ìœ¼ë¡œ í•œ ë²ˆë§Œ ì½ì–´ì„œ ìœ íš¨í•œ ë°ì´í„°ê°€ í™•ì‹¤íˆ ë“¤ì–´ì™”ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. íƒ€ì„ì•„ì›ƒì„ ì„¤ì •í•´ì„œ ë¬´í•œì • ê¸°ë‹¤ë¦¬ëŠ” ê²ƒì„ ë°©ì§€í•©ë‹ˆë‹¤. ì´í›„ë¶€í„°ëŠ” ëª¨ë‘ ë…¼ë¸”ë¡œí‚¹ ë°©ì‹ìœ¼ë¡œ ì „í™˜í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ì´ˆê¸° ë²„í¼ ìƒíƒœê°€ ì •ìƒì ìœ¼ë¡œ ì„¤ì •ë˜ê³ , ê·¸ ë‹¤ìŒë¶€í„°ëŠ” ì œì–´ ì£¼ê¸°ê°€ ê¹¨ì§€ì§€ ì•ŠìŠµë‹ˆë‹¤.

## íš¨ìœ¨ì ì¸ ë¡œê¹… ì „ëµ

ë””ë²„ê¹…ì„ ìœ„í•´ ë¡œê¹…ì€ í•„ìˆ˜ì ì´ì§€ë§Œ, ë§¤ ì œì–´ í‹±ë§ˆë‹¤ ì¶œë ¥í•˜ë©´ ì„±ëŠ¥ì´ í¬ê²Œ ì €í•˜ë©ë‹ˆë‹¤. íŠ¹íˆ ê³ ì£¼íŒŒìˆ˜ë¡œ ë™ì‘í•˜ëŠ” ì œì–´ ë£¨í”„ì—ì„œëŠ” ë¡œê¹… ìì²´ê°€ ë³‘ëª©ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ê°„í—ì  ë¡œê¹… ì „ëµì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ 5ì´ˆì— í•œ ë²ˆì”©ë§Œ ì£¼ê¸°ì™€ ì§€í„° ì •ë³´ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤. `skipped` ì¹´ìš´í„°ëŠ” ê³„ì† ì—…ë°ì´íŠ¸í•˜ë˜, ì¶œë ¥ì€ ì£¼ê¸°ì ìœ¼ë¡œë§Œ í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ í•„ìš”í•œ ì •ë³´ëŠ” ì–»ìœ¼ë©´ì„œë„ ì„±ëŠ¥ ì €í•˜ë¥¼ ìµœì†Œí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ROS2 APIì˜ ì˜¬ë°”ë¥¸ ì‚¬ìš©

ROS2ë¥¼ ì‚¬ìš©í•  ë•ŒëŠ” ê³µì‹ APIë§Œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë§¤ìš° ì¤‘ìš”í•©ë‹ˆë‹¤. ì•ì„œ ì–¸ê¸‰í•œ ê²ƒì²˜ëŸ¼ ë‚´ë¶€ APIë¥¼ ì‚¬ìš©í•˜ë©´ ë²„ì „ í˜¸í™˜ì„± ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. `SingleThreadedExecutor`ë¡œë„ ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ì¶©ë¶„í•˜ì§€ë§Œ, ë§Œì•½ ì½œë°± ê°„ì˜ ê²½í•©ì´ ì‹¬í•˜ë‹¤ë©´ `MultiThreadedExecutor`ë¥¼ ê³ ë ¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•  ë•Œë„ ì˜¬ë°”ë¥¸ ìˆœì„œê°€ ì¤‘ìš”í•©ë‹ˆë‹¤. `stop_allegro_io()` í•¨ìˆ˜ì—ì„œ `executor.shutdown()`ì„ ë¨¼ì € í˜¸ì¶œí•´ì„œ ì‹¤í–‰ê¸°ë¥¼ ì •ë¦¬í•˜ê³ , `node.destroy_node()`ë¡œ ë…¸ë“œë¥¼ íŒŒê´´í•œ ë‹¤ìŒ, ë§ˆì§€ë§‰ìœ¼ë¡œ `rclpy.shutdown()`ì„ í˜¸ì¶œí•©ë‹ˆë‹¤. ì´ ìˆœì„œë¥¼ ì§€í‚¤ë©´ ë¦¬ì†ŒìŠ¤ê°€ ê¹¨ë—í•˜ê²Œ ì •ë¦¬ë˜ê³  ì˜ˆê¸°ì¹˜ ì•Šì€ ì—ëŸ¬ë¥¼ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ì¶”ê°€ ìµœì í™” ê°€ëŠ¥ì„±

ë” ë‚˜ì•„ê°€ ì„±ëŠ¥ì„ ê·¹ëŒ€í™”í•˜ê³  ì‹¶ë‹¤ë©´ ëª‡ ê°€ì§€ ì„ íƒì ì¸ ìµœì í™” ê¸°ë²•ì„ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. FP16ì´ë‚˜ TF32ë¥¼ ì‚¬ìš©í•˜ë©´ ëª¨ë¸ì„ half precisionìœ¼ë¡œ ë³€í™˜í•´ì„œ ì¶”ë¡  ì§€ì—°ì„ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¨, ì´ëŠ” CUDAë¥¼ ì‚¬ìš©í•  ë•Œë§Œ ê°€ëŠ¥í•˜ê³  ì…ë ¥ ë°ì´í„°ë„ ê°™ì€ íƒ€ì…ìœ¼ë¡œ ë§ì¶°ì•¼ í•©ë‹ˆë‹¤.

ì…ë ¥ shapeì´ ê³ ì •ë˜ì–´ ìˆë‹¤ë©´ CUDA Graphë¥¼ í™œìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë˜í”„ë¥¼ í•œ ë²ˆ ìº¡ì²˜í•œ í›„ ì¬ì‚¬ìš©í•˜ë©´ ì»¤ë„ ëŸ°ì¹­ ì˜¤ë²„í—¤ë“œê°€ ì¤„ì–´ë“¤ì–´ ì§€í„°ê°€ ê°ì†Œí•©ë‹ˆë‹¤. MLP ë„¤íŠ¸ì›Œí¬ì˜ `actor_units`ì´ë‚˜ `priv_mlp_units` ì°¨ì›ì„ ì¤„ì´ëŠ” ê²ƒë„ ì‹¤ì‹œê°„ì„±ì„ í–¥ìƒì‹œí‚¤ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

íƒ€ì´ë¨¸ ì£¼ê¸° ì„¤ì •ë„ ì‹ ì¤‘í•´ì•¼ í•©ë‹ˆë‹¤. í•˜ë“œì›¨ì–´ì™€ ë“œë¼ì´ë²„ì˜ ì§€ì—°ì„ ê³ ë ¤í•´ì„œ 20Hzë¶€í„° ì‹œì‘í•˜ëŠ” ê²ƒì´ ì•ˆì „í•©ë‹ˆë‹¤. ì‹œìŠ¤í…œì´ ì•ˆì •ì ìœ¼ë¡œ ë™ì‘í•˜ëŠ” ê²ƒì„ í™•ì¸í•œ í›„ ì ì§„ì ìœ¼ë¡œ ì£¼íŒŒìˆ˜ë¥¼ ë†’ì´ë©´ ë©ë‹ˆë‹¤.

## ë¡œì§ì˜ ì¼ê´€ì„± ìœ ì§€

ì´ ëª¨ë“  ê°œì„  ê³¼ì •ì—ì„œ ê°€ì¥ ì¤‘ìš”í•˜ê²Œ ìƒê°í•œ ê²ƒì€ ROS1ê³¼ ROS2 ì‚¬ì´ì˜ ë¡œì§ ì¼ê´€ì„±ì…ë‹ˆë‹¤. ê´€ì¸¡ ë°ì´í„°ë¥¼ ë°›ì•„ì„œ ì •ê·œí™”í•˜ê³ , ë²„í¼ë¥¼ ì—…ë°ì´íŠ¸í•˜ê³ , ëª¨ë¸ë¡œ ì¶”ë¡ í•˜ê³ , ì•¡ì…˜ì„ ìŠ¤ì¼€ì¼ë§í•˜ê³  í´ë¦¬í•‘í•´ì„œ íƒ€ê¹ƒì„ ê°±ì‹ í•˜ê³ , ëª…ë ¹ì„ ì „ì†¡í•˜ê³ , ë‹¤ìŒ ê´€ì¸¡ì„ ë°›ëŠ” ì „ì²´ íŒŒì´í”„ë¼ì¸ì€ ë™ì¼í•©ë‹ˆë‹¤.

ì°¨ì´ì ì€ ì¡°ì¸íŠ¸ ìˆœì„œ ë³€í™˜ê³¼ í† í”½ ì¸í„°í˜ì´ìŠ¤ë¿ì…ë‹ˆë‹¤. ROS1ê³¼ ROS2ëŠ” ì¡°ì¸íŠ¸ ìˆœì„œê°€ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— ì´ë¥¼ ë³€í™˜í•˜ëŠ” ë¡œì§ì´ í•„ìš”í•˜ê³ , í† í”½ ì´ë¦„ì´ë‚˜ ë©”ì‹œì§€ íƒ€ì…ì´ ì•½ê°„ ë‹¤ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ í•µì‹¬ ì œì–´ ë¡œì§ì€ ì™„ì „íˆ ë™ì¼í•˜ê²Œ ìœ ì§€í–ˆìŠµë‹ˆë‹¤.

## ê²°ë¡ 

ì´ë²ˆ ë¦¬íŒ©í† ë§ì˜ í•µì‹¬ì€ ROS2ì˜ íŠ¹ì„±ì„ ì œëŒ€ë¡œ í™œìš©í•´ì„œ ì‹¤ì‹œê°„ì„±ê³¼ ì•ˆì •ì„±ì„ ê·¹ëŒ€í™”í•˜ëŠ” ê²ƒì´ì—ˆìŠµë‹ˆë‹¤. íƒ€ì´ë¨¸ ê¸°ë°˜ ì œì–´ ë£¨í”„ë¡œ ì „í™˜í•´ì„œ ì •í™•í•œ ì œì–´ ì£¼ê¸°ë¥¼ ë‹¬ì„±í–ˆê³ , ë””ë°”ì´ìŠ¤ ì¼ê´€ì„±ê³¼ ë²„í¼ ê´€ë¦¬ë¥¼ ê°œì„ í•´ì„œ ì•ˆì •ì„±ì„ ë†’ì˜€ìŠµë‹ˆë‹¤. í¬ì§€ì…˜ ê°­ í¼ë¸”ë¦¬ì…”ë¥¼ ì¶”ê°€í•´ì„œ ë¶„ì„ ê°€ëŠ¥ì„±ì„ í–¥ìƒì‹œì¼°ê³ , inference_modeì™€ ìµœì í™” ê¸°ë²•ì„ ì ìš©í•´ì„œ ì„±ëŠ¥ì„ ê°œì„ í–ˆìŠµë‹ˆë‹¤.

ì´ëŸ¬í•œ ê°œì„ ë“¤ì€ ê°œë³„ì ìœ¼ë¡œë„ ì˜ë¯¸ê°€ ìˆì§€ë§Œ, í•¨ê»˜ ì ìš©í–ˆì„ ë•Œ ì‹œë„ˆì§€ íš¨ê³¼ê°€ í½ë‹ˆë‹¤. ì •í™•í•œ ì œì–´ ì£¼ê¸°, ì•ˆì •ì ì¸ ë™ì‘, íš¨ìœ¨ì ì¸ ì„±ëŠ¥, ê·¸ë¦¬ê³  ë””ë²„ê¹… ê°€ëŠ¥ì„±ì´ ëª¨ë‘ í–¥ìƒë˜ì–´ ì‹¤ì œ ë¡œë´‡ ì œì–´ ì‹œìŠ¤í…œì—ì„œ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì½”ë“œê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.

::: {.callout-note collapse="true"}

# ROS2 ì œì–´ ì½”ë“œ ê°œì„ : Before/After í•µì‹¬ ì½”ë“œ ë¹„êµ

## 1. ì œì–´ ë£¨í”„: while+sleep â†’ ROS2 Timer

### âŒ Before: ë¶ˆì•ˆì •í•œ while ë£¨í”„
```python
def deploy(self):
    self.allegro = start_allegro_io(side='right')
    hz = 20

    # ... ì´ˆê¸°í™” ...

    timestep = 0
    try:
        while True:
            loop_start = time.perf_counter()

            # ê´€ì¸¡ ì •ê·œí™”
            self.obs_buf = self.running_mean_std(self.obs_buf.clone())

            # ì¶”ë¡ 
            input_dict = {
                "obs": self.obs_buf,
                "proprio_hist": self.sa_mean_std(self.proprio_hist_buf.clone()),
            }
            action = torch.clamp(self.model.act_inference(input_dict), -1.0, 1.0)

            # ì œì–´
            self.pre_physics_step(action)
            cmd = self.cur_target.detach().to('cpu').numpy()[0]
            ros1 = _action_hora2allegro(cmd)
            ros2 = _reorder_imrt2timr(ros1)
            self.allegro.command_joint_position(ros2)

            # ë¸”ë¡œí‚¹ìœ¼ë¡œ ê´€ì¸¡ ëŒ€ê¸°
            q_pos = self.allegro.poll_joint_position(wait=True, timeout=0.2)
            ros1_q = _reorder_timr2imrt(q_pos)
            hora_q = _obs_allegro2hora(ros1_q)
            obs_q = torch.from_numpy(hora_q.astype(np.float32)).to(self.device)

            self.post_physics_step(obs_q)

            time.sleep(0.03)  # ì£¼ê¸°ê°€ ë¶ˆì•ˆì •!
            timestep += 1

            freq = 1.0 / (time.perf_counter() - loop_start)
            print(f"Hz={freq:.2f}")
```

**ë¬¸ì œì :**
- `time.sleep(0.03)`ëŠ” OS ìŠ¤ì¼€ì¤„ë§ì— ì˜ì¡´ â†’ ì§€í„° ë°œìƒ
- ë¸”ë¡œí‚¹ I/O(`wait=True`)ë¡œ ì£¼ê¸° ê¹¨ì§
- ë§¤ í‹±ë§ˆë‹¤ ì£¼íŒŒìˆ˜ ì¶œë ¥ â†’ ì„±ëŠ¥ ì €í•˜

### âœ… After: ROS2 Timer + ë…¼ë¸”ë¡œí‚¹
```python
def deploy(self):
    self.allegro = start_allegro_io(side='right')

    # ... ì´ˆê¸°í™” ...

    # Timer ë“±ë¡ (ì •í™•í•œ ì£¼ê¸° ë³´ì¥)
    period = 1.0 / self.hz
    self.timer = self.allegro.create_timer(period, self._control_step)
    print(f"Deployment started (timer-based {self.hz:.1f} Hz).")

    # ë©”ì¸ ìŠ¤ë ˆë“œëŠ” ì‹œê·¸ë„ë§Œ ì²˜ë¦¬
    interrupted = False
    def _sigint(_sig, _frm):
        nonlocal interrupted
        interrupted = True
    signal.signal(signal.SIGINT, _sigint)

    try:
        while not interrupted:
            time.sleep(0.2)
    finally:
        if self.timer is not None:
            self.timer.cancel()
        self.allegro.go_safe()
        stop_allegro_io(self.allegro)

@torch.inference_mode()  # ê·¸ë˜ë””ì–¸íŠ¸ íŠ¸ë˜í‚¹ ë¹„í™œì„±í™”
def _control_step(self):
    t0 = time.perf_counter()

    # 1) ì •ê·œí™”
    obs_norm = self.running_mean_std(self.obs_buf)

    # 2) ì¶”ë¡ 
    input_dict = {
        "obs": obs_norm,
        "proprio_hist": self.sa_mean_std(self.proprio_hist_buf),
    }
    action = torch.clamp(self.model.act_inference(input_dict), -1.0, 1.0)

    # 3) íƒ€ê¹ƒ ì—…ë°ì´íŠ¸
    self._pre_physics_step(action)

    # 4) ëª…ë ¹ ì „ì†¡
    cmd = self.cur_target.detach().to("cpu").numpy()[0]
    ros1 = _action_hora2allegro(cmd)
    ros2 = _reorder_imrt2timr(ros1)
    self.allegro.command_joint_position(ros2)

    # 5) ë…¼ë¸”ë¡œí‚¹ ê´€ì¸¡ (ë“œë ì‹œ last-good ì‚¬ìš©)
    q_pos = self.allegro.poll_joint_position(wait=False, timeout=0.0)
    if q_pos is not None:
        ros1_q = _reorder_timr2imrt(q_pos)
        hora_q = _obs_allegro2hora(ros1_q)
        obs_q = torch.from_numpy(hora_q.astype(np.float32)).to(self.device)
        self._last_obs_q = obs_q
    else:
        obs_q = self._last_obs_q  # ì¬ì‚¬ìš©
        self._skipped += 1

    if obs_q is not None:
        self._post_physics_step(obs_q)

    # 6) ê°„í—ì  ë¡œê¹… (5ì´ˆë§ˆë‹¤)
    if self._last_step_t is not None:
        dt = t0 - self._last_step_t
        if int(time.time()) % 5 == 0:
            hz_est = 1.0 / max(dt, 1e-6)
            print(f"[timer] {hz_est:.2f} Hz, skipped={self._skipped}")
    self._last_step_t = t0
```

**ê°œì„  íš¨ê³¼:**

- âœ… ROS2 ì‹¤í–‰ê¸°ê°€ ì£¼ê¸° ê´€ë¦¬ â†’ ì§€í„° ê°ì†Œ
- âœ… ë…¼ë¸”ë¡œí‚¹ I/O â†’ ì£¼ê¸° ìœ ì§€
- âœ… `@torch.inference_mode()` â†’ ì¶”ë¡  ì˜¤ë²„í—¤ë“œ ì œê±°
- âœ… ê°„í—ì  ë¡œê¹… â†’ ì„±ëŠ¥ ì €í•˜ ìµœì†Œí™”

---

## 2. ROS2 ì‹¤í–‰ê¸°: ë‚´ë¶€ API â†’ í‘œì¤€ threading

### âŒ Before: ë¶ˆì•ˆì •í•œ ë‚´ë¶€ API
```python
class _Runner:
    def __init__(self, node: AllegroHandIO):
        self.node = node
        self.exec = SingleThreadedExecutor()
        self.exec.add_node(node)
        # âš ï¸ ë‚´ë¶€ API ì‚¬ìš© - ë²„ì „ í˜¸í™˜ì„± ë¬¸ì œ!
        self.thread = threading.Thread(target=self.exec.spin, daemon=True)

    def start(self):
        self.thread.start()

    def stop(self):
        try:
            self.exec.shutdown()
        finally:
            self.node.destroy_node()
```

### âœ… After: ì•ˆì „í•œ í‘œì¤€ API
```python
import threading
from rclpy.executors import SingleThreadedExecutor

class _Runner:
    def __init__(self, node: 'AllegroHandIO'):
        self.node = node
        self.exec = SingleThreadedExecutor()
        self.exec.add_node(node)
        # âœ… í‘œì¤€ threading ì‚¬ìš©
        self.thread = threading.Thread(target=self.exec.spin, daemon=True)

    def start(self):
        self.thread.start()

    def stop(self):
        try:
            self.exec.shutdown()          # 1. executor ì¤‘ì§€
        finally:
            try:
                self.node.destroy_node()  # 2. ë…¸ë“œ íŒŒê´´
            finally:
                # 3. ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸° (íƒ€ì„ì•„ì›ƒ ì„¤ì •)
                self.thread.join(timeout=2.0)
```

**ê°œì„  íš¨ê³¼:**

- âœ… ê³µì‹ APIë§Œ ì‚¬ìš© â†’ ë²„ì „ í˜¸í™˜ì„± ë³´ì¥
- âœ… ì˜¬ë°”ë¥¸ ì¢…ë£Œ ìˆœì„œ â†’ ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜ ë°©ì§€

---

## 3. ì¥ì¹˜ ì¼ê´€ì„±: ë””ë°”ì´ìŠ¤ ë¶ˆì¼ì¹˜ í•´ê²°

### âŒ Before: ì‚°ë°œì ì¸ ë””ë°”ì´ìŠ¤ í• ë‹¹
```python
def __init__(self):
    self.device = "cuda"

    # ëª¨ë¸ì€ CUDAë¡œ
    self.model = ActorCritic(net_config).to(self.device).eval()
    self.running_mean_std = RunningMeanStd(obs_shape).to(self.device).eval()

    # âš ï¸ ë²„í¼ëŠ” ë””ë°”ì´ìŠ¤ ëª…ì‹œ ì—†ìŒ - CPUì— ìƒì„±ë¨!
    self.obs_buf = torch.zeros((1, 16 * 3 * 2), dtype=torch.float32)
    self.proprio_hist_buf = torch.zeros((1, 30, 16 * 2), dtype=torch.float32)

    # limitsë„ ë””ë°”ì´ìŠ¤ ëª…ì‹œ
    self.allegro_dof_lower = torch.tensor([...], dtype=torch.float32, device=self.device)

    # âš ï¸ targetsëŠ” ë””ë°”ì´ìŠ¤ ëª…ì‹œ ì—†ìŒ
    self.prev_target = torch.zeros((1, 16), dtype=torch.float32)
```

### âœ… After: ëª¨ë“  í…ì„œë¥¼ ê°™ì€ ë””ë°”ì´ìŠ¤ë¡œ
```python
def __init__(self, hz: float = 20.0, device: str = "cuda"):
    torch.set_grad_enabled(False)
    self.hz = float(hz)
    self.device = device  # âœ… ë‹¨ì¼ ì§„ì‹¤ ê³µê¸‰ì›

    # ëª¨ë¸ê³¼ RMS
    self.model = ActorCritic(net_config).to(self.device).eval()
    self.running_mean_std = RunningMeanStd(obs_shape).to(self.device).eval()
    self.sa_mean_std = RunningMeanStd((30, 32)).to(self.device).eval()

    # âœ… ëª¨ë“  ë²„í¼ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ê°™ì€ ë””ë°”ì´ìŠ¤ì— ìƒì„±
    self.obs_buf = torch.zeros((1, 96), dtype=torch.float32, device=self.device)
    self.proprio_hist_buf = torch.zeros((1, 30, 32), dtype=torch.float32, device=self.device)

    # âœ… limitsë„ ê°™ì€ ë””ë°”ì´ìŠ¤
    self.allegro_dof_lower = torch.tensor([...], dtype=torch.float32, device=self.device)
    self.allegro_dof_upper = torch.tensor([...], dtype=torch.float32, device=self.device)

    # âœ… targetsë„ ê°™ì€ ë””ë°”ì´ìŠ¤
    self.prev_target = torch.zeros((1, 16), dtype=torch.float32, device=self.device)
    self.cur_target = torch.zeros((1, 16), dtype=torch.float32, device=self.device)

# âœ… í•˜ë“œì›¨ì–´ I/O ì§ì „ì—ë§Œ CPUë¡œ ì´ë™
def _control_step(self):
    # ... ì¶”ë¡  ...

    # CPUë¡œ ì´ë™ì€ ëª…ë ¹ ì „ì†¡ ì‹œì—ë§Œ
    cmd = self.cur_target.detach().to("cpu").numpy()[0]
    self.allegro.command_joint_position(ros2)

    # ê´€ì¸¡ ì½ê¸° í›„ ë°”ë¡œ ë””ë°”ì´ìŠ¤ë¡œ
    q_pos = self.allegro.poll_joint_position(wait=False)
    if q_pos is not None:
        # ... ë³€í™˜ ...
        obs_q = torch.from_numpy(hora_q.astype(np.float32)).to(self.device)
```

**ê°œì„  íš¨ê³¼:**

- âœ… "Expected all tensors to be on the same device" ì—ëŸ¬ ì œê±°
- âœ… ë¶ˆí•„ìš”í•œ ë””ë°”ì´ìŠ¤ ì´ë™ ìµœì†Œí™” â†’ ì†ë„ í–¥ìƒ

---

## 4. ë²„í¼ ë¡¤ë§: ê²¹ì¹¨ ì˜¤ë¥˜ ìˆ˜ì •

### âŒ Before: ë©”ëª¨ë¦¬ ê²¹ì¹¨ ì˜¤ë¥˜
```python
def post_physics_step(self, obses):
    self.cur_obs_buf = self.unscale(obses, ...)[None]

    # âš ï¸ ê°™ì€ í…ì„œ ë‚´ ê²¹ì¹˜ëŠ” ë©”ëª¨ë¦¬ ì˜ì—­ì— ëŒ€ì…!
    # obs_buf[:, 32:96]ì˜ ì¼ë¶€ê°€ [:, :64]ì™€ ê²¹ì¹¨
    self.prev_obs_buf = self.obs_buf[:, 32:].clone()
    self.obs_buf[:, :64] = self.prev_obs_buf  # RuntimeError!
    self.obs_buf[:, 64:80] = self.cur_obs_buf.clone()
    self.obs_buf[:, 80:96] = self.cur_target.clone()

    # proprio historyë„ ë™ì¼ ë¬¸ì œ
    cur = torch.cat([cur_norm_t, cur_tgt_t], dim=-1)
    prev = self.proprio_hist_buf[:, 1:30, :].clone()
    self.proprio_hist_buf[:] = torch.cat([prev, cur], dim=1)  # ë¹„íš¨ìœ¨ì 
```

### âœ… After: ì•ˆì „í•œ ë²„í¼ ì‹œí”„íŠ¸

**ë°©ë²• 1: clone() ì‚¬ìš©**
```python
def _post_physics_step(self, obses):
    # 1) í˜„ì¬ ê´€ì¸¡ ì •ê·œí™”
    cur_obs = self._unscale(
        obses.view(-1), self.allegro_dof_lower, self.allegro_dof_upper
    ).view(1, 16)

    # 2) obs_buf ë¡¤ë§ - âœ… ì†ŒìŠ¤ë¥¼ ë¨¼ì € clone()
    src64 = self.obs_buf[:, 32:96].clone()     # (1,64) ë³µì‚¬
    self.obs_buf[:, 0:64] = src64              # ì•ˆì „í•œ ëŒ€ì…
    self.obs_buf[:, 64:80] = cur_obs
    self.obs_buf[:, 80:96] = self.cur_target

    # 3) proprio_hist_buf ë¡¤ë§ - âœ… ì†ŒìŠ¤ë¥¼ ë¨¼ì € clone()
    src_hist = self.proprio_hist_buf[:, 1:, :].clone()  # (1,29,32)
    self.proprio_hist_buf[:, 0:-1, :] = src_hist
    self.proprio_hist_buf[:, -1, :16] = cur_obs
    self.proprio_hist_buf[:, -1, 16:32] = self.cur_target
```

**ë°©ë²• 2: torch.roll ì‚¬ìš© (ëŒ€ì•ˆ)**
```python
def _post_physics_step(self, obses):
    cur_obs = self._unscale(obses.view(-1), ...).view(1, 16)

    # âœ… rollì„ ì‚¬ìš©í•œ ì‹œí”„íŠ¸
    rolled = torch.roll(self.obs_buf, shifts=-32, dims=1)
    self.obs_buf[:, :-32].copy_(rolled[:, :-32])  # ì• 64ì¹¸
    self.obs_buf[:, 64:80] = cur_obs
    self.obs_buf[:, 80:96] = self.cur_target
```

**ê°œì„  íš¨ê³¼:**

- âœ… RuntimeError ì™„ì „ ì œê±°
- âœ… ëª…í™•í•œ ì‹œí”„íŠ¸ ë¡œì§

---

## 5. ê´€ì¸¡ ë“œë ëŒ€ì‘: ë¸”ë¡œí‚¹ â†’ ë…¼ë¸”ë¡œí‚¹ + last-good

### âŒ Before: ë¸”ë¡œí‚¹ìœ¼ë¡œ ì£¼ê¸° ê¹¨ì§
```python
# ë§¤ í‹±ë§ˆë‹¤ ë¸”ë¡œí‚¹ ëŒ€ê¸°
q_pos = self.allegro.poll_joint_position(wait=True, timeout=0.2)
if q_pos is None:
    # ë°ì´í„° ì—†ìœ¼ë©´ ì—ëŸ¬...
    print("âŒ failed to read")

ros1_q = _reorder_timr2imrt(q_pos)
# ... ì²˜ë¦¬ ...
```

### âœ… After: ë…¼ë¸”ë¡œí‚¹ + ì¬ì‚¬ìš©
```python
def __init__(self, ...):
    # ...
    self._last_obs_q = None  # âœ… ë§ˆì§€ë§‰ ìœ íš¨ ê´€ì¸¡ ì €ì¥
    self._skipped = 0        # âœ… ë“œë ì¹´ìš´í„°

def _control_step(self):
    # ... ëª…ë ¹ ì „ì†¡ ...

    # âœ… ë…¼ë¸”ë¡œí‚¹ìœ¼ë¡œ ì½ê¸°
    q_pos = self.allegro.poll_joint_position(wait=False, timeout=0.0)

    if q_pos is not None:
        # ìƒˆ ë°ì´í„° ìˆìœ¼ë©´ ê°±ì‹ 
        ros1_q = _reorder_timr2imrt(q_pos)
        hora_q = _obs_allegro2hora(ros1_q)
        obs_q = torch.from_numpy(hora_q.astype(np.float32)).to(self.device)
        self._last_obs_q = obs_q  # âœ… ì €ì¥
    else:
        # ìƒˆ ë°ì´í„° ì—†ìœ¼ë©´ ì´ì „ ê²ƒ ì¬ì‚¬ìš©
        obs_q = self._last_obs_q
        self._skipped += 1  # âœ… ì¹´ìš´íŠ¸

    if obs_q is not None:
        self._post_physics_step(obs_q)

    # ë¡œê¹… (5ì´ˆë§ˆë‹¤)
    if int(time.time()) % 5 == 0:
        print(f"skipped={self._skipped}")
```

**ê°œì„  íš¨ê³¼:**

- âœ… ì œì–´ ì£¼ê¸° ìœ ì§€ (ì‹¤ì‹œê°„ì„±â†‘)
- âœ… ì„¼ì„œ ì§€ì—°ì— ê°•ê±´í•œ ë™ì‘
- âœ… ë“œë íšŸìˆ˜ ëª¨ë‹ˆí„°ë§ ê°€ëŠ¥

---

## 6. Position Gap í¼ë¸”ë¦¬ì…”: íƒ€ì„ìŠ¤íƒ¬í”„ + ì¡°ì¸íŠ¸ ì´ë¦„

### âŒ Before: Gap ì¸¡ì •ì— ì§§ì€ sleep ì‚½ì…

```python
def command_joint_position(self, positions: List[float]) -> bool:
    # ëª…ë ¹ í¼ë¸”ë¦¬ì‹œ
    msg = Float64MultiArray()
    msg.data = data
    self._cmd_pub.publish(msg)
    self._last_cmd = np.asarray(data, dtype=float)

    # âš ï¸ ëª…ë ¹ ì§í›„ ì§§ê²Œ ëŒ€ê¸° (ë¹„íš¨ìœ¨ì )
    if self._gap_after_cmd_delay > 0:
        time.sleep(self._gap_after_cmd_delay)  # 0.02ì´ˆ

    # gap 1íšŒ í¼ë¸”ë¦¬ì‹œ
    self._publish_position_gap()
    return True

def _publish_position_gap(self):
    if self._last_cmd is None or self._last_js is None:
        return
    cur = self.poll_joint_position(wait=False)
    if cur is None or cur.size != 16:
        return

    cmd = np.asarray(self._last_cmd, dtype=float).reshape(16)
    gap = (cmd - cur).astype(float)

    # âš ï¸ Header ì •ë³´ ë¶€ì¡±
    msg = JointState()
    msg.header.stamp = self.get_clock().now().to_msg()
    msg.header.frame_id = ""
    msg.name = list(self._desired_names)
    msg.position = gap.tolist()
    self._gap_pub.publish(msg)
```

### âœ… After: íƒ€ì´ë¨¸ ì½œë°± ë‚´ì—ì„œ ìµœì‹  ìƒíƒœë¡œ
```python
def command_joint_position(self, positions: List[float]) -> bool:
    msg = Float64MultiArray()
    msg.data = data
    self._cmd_pub.publish(msg)
    self._last_cmd = np.asarray(data, dtype=float)

    # âœ… sleep ì—†ì´ ë°”ë¡œ gap í¼ë¸”ë¦¬ì‹œ (ë…¼ë¸”ë¡œí‚¹)
    self._publish_position_gap()
    return True

def _publish_position_gap(self):
    if self._last_cmd is None or self._last_js is None:
        return

    # âœ… ë…¼ë¸”ë¡œí‚¹ìœ¼ë¡œ í˜„ì¬ ìµœì‹  ìƒíƒœ ì½ê¸°
    cur = self.poll_joint_position(wait=False)
    if cur is None or cur.size != 16:
        return

    gap = (self._last_cmd - cur).astype(float)

    # âœ… ì™„ì „í•œ JointState ë©”ì‹œì§€
    js = JointState()
    js.header.stamp = self.get_clock().now().to_msg()  # ROS íƒ€ì„ìŠ¤íƒ¬í”„
    js.header.frame_id = ""                            # ë˜ëŠ” "allegro"
    js.name = list(self._desired_names)                # 16ê°œ ì¡°ì¸íŠ¸ ì´ë¦„
    js.position = gap.tolist()                         # gap ê°’
    # velocity/effortëŠ” ë¹ˆ ë¦¬ìŠ¤íŠ¸ (ë¯¸ì‚¬ìš©)

    self._gap_pub.publish(js)
```

**ê°œì„  íš¨ê³¼:**

- âœ… sleep ì œê±° â†’ ì£¼ê¸° ì•ˆì •ì„±â†‘
- âœ… íƒ€ì„ìŠ¤íƒ¬í”„ + ì¡°ì¸íŠ¸ ì´ë¦„ â†’ rqt_plot, rosbag í˜¸í™˜
- âœ… íƒ€ì´ë¨¸ ì½œë°±ì´ ë§¤ í‹±ë§ˆë‹¤ ìµœì‹  ìƒíƒœ ë°˜ì˜

---

## 7. ì´ˆê¸°í™”: ì›Œë°ì—… + ì²« ê´€ì¸¡ ë¸”ë¡œí‚¹

### âœ… ì•ˆì „í•œ ì´ˆê¸°í™” ìˆœì„œ
```python
def deploy(self):
    self.allegro = start_allegro_io(side='right')

    # 1) âœ… ì›Œë°ì—… (í•˜ë“œì›¨ì–´ ì•ˆì •í™”)
    warmup = int(self.hz * 4)
    for t in range(warmup):
        tprint(f"setup {t} / {warmup}")
        pose = _reorder_imrt2timr(np.array(self.init_pose, dtype=np.float64))
        self.allegro.command_joint_position(pose)
        time.sleep(1.0 / self.hz)

    # 2) âœ… ì²« ê´€ì¸¡ë§Œ ë¸”ë¡œí‚¹ (íƒ€ì„ì•„ì›ƒ ì„¤ì •)
    q_pos = self.allegro.poll_joint_position(wait=True, timeout=5.0)
    if q_pos is None:
        print("âŒ failed to read joint state.")
        stop_allegro_io(self.allegro)
        return

    # 3) âœ… ë²„í¼ ì´ˆê¸°í™”
    ros1_q = _reorder_timr2imrt(q_pos)
    hora_q = _obs_allegro2hora(ros1_q)
    obs_q = torch.from_numpy(hora_q.astype(np.float32)).to(self.device)
    self._last_obs_q = obs_q

    cur_obs_buf = self._unscale(obs_q, self.allegro_dof_lower, self.allegro_dof_upper)[None]
    self.prev_target = obs_q[None]

    # obs_buf 3 íƒ€ì„ìŠ¤í… ì±„ìš°ê¸°
    for i in range(3):
        self.obs_buf[:, i*32:i*32+16] = cur_obs_buf
        self.obs_buf[:, i*32+16:i*32+32] = self.prev_target

    # proprio_hist_buf 30 íƒ€ì„ìŠ¤í… ì±„ìš°ê¸°
    self.proprio_hist_buf[:, :, :16] = cur_obs_buf
    self.proprio_hist_buf[:, :, 16:32] = self.prev_target

    # 4) âœ… íƒ€ì´ë¨¸ ì‹œì‘ (ì´í›„ëŠ” ëª¨ë‘ ë…¼ë¸”ë¡œí‚¹)
    period = 1.0 / self.hz
    self.timer = self.allegro.create_timer(period, self._control_step)
```

**ê°œì„  íš¨ê³¼:**

- âœ… ì›Œë°ì—…ìœ¼ë¡œ ëª¨í„° ë“œë¼ì´ë²„ ì•ˆì •í™”
- âœ… ì²« ê´€ì¸¡ ë¸”ë¡œí‚¹ìœ¼ë¡œ ìœ íš¨í•œ ì´ˆê¸° ìƒíƒœ í™•ë³´
- âœ… ì´í›„ëŠ” ë…¼ë¸”ë¡œí‚¹ìœ¼ë¡œ ì£¼ê¸° ìœ ì§€

---

## ìš”ì•½: í•µì‹¬ ê°œì„  ì‚¬í•­

| í•­ëª© | Before | After | íš¨ê³¼ |
|------|--------|-------|------|
| **ì œì–´ ë£¨í”„** | `while` + `sleep` | ROS2 Timer | ì§€í„°â†“, ì£¼ê¸° ì •í™•ë„â†‘ |
| **ì‹¤í–‰ê¸°** | ë‚´ë¶€ API | í‘œì¤€ `threading` | ë²„ì „ í˜¸í™˜ì„±â†‘ |
| **ë””ë°”ì´ìŠ¤** | ì‚°ë°œì  í• ë‹¹ | ë‹¨ì¼ ì†ŒìŠ¤ í†µì¼ | ì—ëŸ¬ ì œê±°, ì†ë„â†‘ |
| **ë²„í¼ ë¡¤ë§** | ê²¹ì¹¨ ëŒ€ì… | `clone()` ì‚¬ìš© | RuntimeError ì œê±° |
| **ê´€ì¸¡ ì½ê¸°** | ë¸”ë¡œí‚¹ | ë…¼ë¸”ë¡œí‚¹ + ì¬ì‚¬ìš© | ì‹¤ì‹œê°„ì„±â†‘, ê°•ê±´ì„±â†‘ |
| **ì¶”ë¡ ** | ì¼ë°˜ ëª¨ë“œ | `@inference_mode()` | ì˜¤ë²„í—¤ë“œâ†“ |
| **ë¡œê¹…** | ë§¤ í‹± ì¶œë ¥ | 5ì´ˆë§ˆë‹¤ ì¶œë ¥ | ì„±ëŠ¥ ì €í•˜ ìµœì†Œí™” |
| **Gap** | sleep í›„ ì¸¡ì • | ë…¼ë¸”ë¡œí‚¹ ì¸¡ì • | ì£¼ê¸° ì•ˆì •ì„±â†‘ |

:::

<!--

:::::: {.callout-note}

# Before Code

```python
#!/usr/bin/env python3
import os
import time
import numpy as np
import torch

from hora.algo.models.models import ActorCritic
from hora.algo.models.running_mean_std import RunningMeanStd
from hora.utils.misc import tprint


import threading
import time
from typing import List, Optional

import numpy as np
import rclpy
from rclpy.executors import SingleThreadedExecutor
from rclpy.node import Node
from sensor_msgs.msg import JointState
from std_msgs.msg import Float64MultiArray, Header


DEFAULT_ORDER = {
    "right": [
        "ah_joint00", "ah_joint01", "ah_joint02", "ah_joint03",
        "ah_joint10", "ah_joint11", "ah_joint12", "ah_joint13",
        "ah_joint20", "ah_joint21", "ah_joint22", "ah_joint23",
        "ah_joint30", "ah_joint31", "ah_joint32", "ah_joint33",
    ],
}


class AllegroHandIO(Node):
    """
    Minimal ROS 2 node for Allegro hand.
    - Publishes commands to /<controller_name>/commands
    - Subscribes to /joint_states and returns a 16-D vector in Allegro order
    - Publishes position gap (command - current) to /position_gap (JointState)
    """

    def __init__(
        self,
        side: str = "right",
        controller_name: Optional[str] = None,
        joint_states_topic: str = "/joint_states",
        command_topic: Optional[str] = None,
    ):
        super().__init__("allegro_hand_io")

        side = (side or "right").lower()
        if side not in ("right", "left"):
            self.get_logger().warn(f"Unknown side '{side}', defaulting to 'right'.")
            side = "right"
        self.side = side

        # ì»¨íŠ¸ë¡¤ëŸ¬ëª… ê³ ì • (í•„ìš” ì‹œ ì™¸ë¶€ ì¸ìë¡œ ë°”ê¿”ë„ ë¨)
        controller_name = controller_name or "allegro_hand_position_controller"

        if command_topic is None:
            command_topic = f"/{controller_name}/commands"

        # Publishers / Subscribers
        self._cmd_pub = self.create_publisher(Float64MultiArray, command_topic, 10)
        self._gap_pub = self.create_publisher(JointState, "/position_gap", 10)
        self.create_subscription(JointState, joint_states_topic, self._on_js, 10)

        # ìµœê·¼ ìƒíƒœ / ë§¤í•‘ / ëª…ë ¹ ì €ì¥
        self._last_js: Optional[JointState] = None
        self._index_map: Optional[List[int]] = None
        self._last_cmd: Optional[np.ndarray] = None  # ëª…ë ¹ 16D (Allegro ìˆœì„œ)

        # Allegro ì¡°ì¸íŠ¸ ì´ë¦„(ì›í•˜ëŠ” ì •ë ¬ ìˆœì„œ)
        self._desired_names = DEFAULT_ORDER["right"] if self.side == "right" else DEFAULT_ORDER["left"]

        # ëª…ë ¹ ì§í›„ gap ì¸¡ì • ì „ì— ì§§ì€ ëŒ€ê¸° (joint_states ë°˜ì˜ ìœ ë„)
        self._gap_after_cmd_delay = 0.02  # seconds

        # ì•ˆì „ í¬ì¦ˆ
        self.safe_pose = np.array([
            0.5, 0.2, 0.0, 0.0,   # Thumb
            0.0, 0.0, 0.0, 0.0,   # Index
            0.0, 0.0, 0.0, 0.0,   # Middle
            0.0, 0.0, 0.0, 0.0,   # Ring
        ], dtype=float)

        self.get_logger().info(f"[AllegroHandIO] side={self.side}")
        self.get_logger().info(f"[AllegroHandIO] cmd topic={command_topic}")
        self.get_logger().info(f"[AllegroHandIO] joint_states topic={joint_states_topic}")
        self.get_logger().info(f"[AllegroHandIO] gap topic=/position_gap")

    # -------------------- Public APIs --------------------

    def command_joint_position(self, positions: List[float]) -> bool:
        """16D ëª©í‘œ ìì„¸ ëª…ë ¹ í¼ë¸”ë¦¬ì‹œ + ì§í›„ position gap 1íšŒ í¼ë¸”ë¦¬ì‹œ."""
        try:
            data = [float(x) for x in list(positions)]
        except Exception:
            self.get_logger().warn("command_joint_position: positions must be a sequence of numbers.")
            return False

        if len(data) != 16:
            self.get_logger().warn(f"command_joint_position: expected 16 elements, got {len(data)}.")
            return False

        # ëª…ë ¹ í¼ë¸”ë¦¬ì‹œ
        msg = Float64MultiArray()
        msg.data = data
        self._cmd_pub.publish(msg)

        # ë§ˆì§€ë§‰ ëª…ë ¹ ê¸°ì–µ
        self._last_cmd = np.asarray(data, dtype=float)

        # ì•„ì£¼ ì§§ê²Œ ëŒ€ê¸° â†’ ìµœì‹  /joint_states ë°˜ì˜ ìœ ë„ (ë°±ê·¸ë¼ìš´ë“œ ìŠ¤í”¼ë„ˆê°€ ì½œë°± ì‹¤í–‰)
        if self._gap_after_cmd_delay > 0:
            time.sleep(self._gap_after_cmd_delay)

        # ëª…ë ¹ ì§í›„ gap 1íšŒ í¼ë¸”ë¦¬ì‹œ
        self._publish_position_gap()

        return True

    def poll_joint_position(
        self, wait: bool = False, timeout: float = 3.0
    ) -> Optional[np.ndarray]:
        """í˜„ì¬ ì¡°ì¸íŠ¸ ìœ„ì¹˜ë¥¼ Allegro ìˆœì„œ(16-D)ë¡œ ë°˜í™˜.

        Args:
            wait (bool): ë°ì´í„°ë¥¼ ê¸°ë‹¤ë¦´ì§€ ì—¬ë¶€ (Trueì´ë©´ timeoutê¹Œì§€ spin)
            timeout (float): ìµœëŒ€ ëŒ€ê¸° ì‹œê°„(ì´ˆ)

        Returns:
            np.ndarray | None: 16-D ì¡°ì¸íŠ¸ ë²¡í„° ë˜ëŠ” None
        """

        # 1) JointState ìˆ˜ì‹  ëŒ€ê¸°
        if self._last_js is None and wait:
            start_time = time.time()
            while self._last_js is None and (time.time() - start_time) < timeout:
                rclpy.spin_once(self, timeout_sec=0.05)

        js = self._last_js
        if js is None or not js.position:
            return None

        # 2) ì´ë¦„ ê¸°ë°˜ ì¸ë±ìŠ¤ ë§¤í•‘ ì´ˆê¸°í™” (ì²« ìˆ˜ì‹  ì‹œ 1íšŒë§Œ)
        if self._index_map is None and js.name:
            self._index_map = self._build_index_map(js.name)

        # 3) ì¸ë±ìŠ¤ ë§¤í•‘ ì„±ê³µ ì‹œ ê·¸ëŒ€ë¡œ ì •ë ¬í•˜ì—¬ ë°˜í™˜
        if self._index_map:
            try:
                vec = np.array([js.position[i] for i in self._index_map], dtype=float)
                if vec.size == 16:
                    return vec
            except Exception:
                self.get_logger().warn("poll_joint_position: index mapping failed, fallback to raw order.")

        # 4) ë§¤í•‘ ì‹¤íŒ¨ ì‹œ fallback â€” ì• 16ê°œ ì‚¬ìš©
        if len(js.position) >= 16:
            return np.array(js.position[:16], dtype=float)

        return None

    def go_safe(self):
        """ì•ˆì „ í¬ì¦ˆë¡œ ì´ë™."""
        self.command_joint_position(self.safe_pose)

    # -------------------- Internals --------------------

    def _publish_position_gap(self):
        """ë§ˆì§€ë§‰ ëª…ë ¹(self._last_cmd)ê³¼ í˜„ì¬ ê´€ì¸¡ì„ ë¹„êµí•´ gapì„ /position_gapìœ¼ë¡œ í¼ë¸”ë¦¬ì‹œ."""
        if self._last_cmd is None or self._last_js is None:
            return

        # í˜„ì¬ ìœ„ì¹˜(16D, Allegro ìˆœì„œ) ì½ê¸°
        cur = self.poll_joint_position(wait=False)
        if cur is None or cur.size != 16:
            return

        cmd = np.asarray(self._last_cmd, dtype=float).reshape(16)
        gap = (cmd - cur).astype(float)

        msg = JointState()
        msg.header.stamp = self.get_clock().now().to_msg()
        # frame_idëŠ” ë¹ˆ ë¬¸ìì—´ë¡œ ë‘ê±°ë‚˜ í•„ìš” ì‹œ "allegro" ë“±ìœ¼ë¡œ ì§€ì •
        msg.header.frame_id = ""
        msg.name = list(self._desired_names)  # 16ê°œ ì¡°ì¸íŠ¸ ì´ë¦„
        msg.position = gap.tolist()           # gap(16D)ì„ position í•„ë“œì— ë‹´ìŒ
        # velocity/effortëŠ” ë¯¸ì‚¬ìš© (ë¹ˆ ë¦¬ìŠ¤íŠ¸)
        self._gap_pub.publish(msg)

    def _build_index_map(self, joint_names: List[str]) -> Optional[List[int]]:
        """joint_statesì˜ ì´ë¦„ ë¦¬ìŠ¤íŠ¸ë¡œë¶€í„° Allegro 16D ì¸ë±ìŠ¤ ë§¤í•‘ ìƒì„±."""
        name_to_index = {n.lower(): i for i, n in enumerate(joint_names)}
        index_map = []

        for desired in self._desired_names:
            idx = name_to_index.get(desired.lower())
            if idx is None:
                # í•˜ë‚˜ë¼ë„ ë§¤ì¹­ ì‹¤íŒ¨í•˜ë©´ ì „ì²´ ë§¤í•‘ ë¬´íš¨í™”
                self.get_logger().warn(f"Missing joint name in /joint_states: '{desired}'")
                return None
            index_map.append(idx)

        return index_map if len(index_map) == 16 else None

    def _on_js(self, msg: JointState):
        self._last_js = msg


################### one hand io runner ####################

class _Runner:
    def __init__(self, node: AllegroHandIO):
        self.node = node
        self.exec = SingleThreadedExecutor()
        self.exec.add_node(node)
        self.thread = threading.Thread(target=self.exec.spin, daemon=True)

    def start(self):
        self.thread.start()

    def stop(self):
        try:
            self.exec.shutdown()
        finally:
            self.node.destroy_node()


def start_allegro_io(side: str = "right") -> AllegroHandIO:
    if not rclpy.ok():
        rclpy.init()
    io = AllegroHandIO(side=side)
    io._runner = _Runner(io)   # keep reference
    io._runner.start()
    return io


def stop_allegro_io(io: AllegroHandIO):
    if hasattr(io, "_runner") and io._runner:
        io._runner.stop()
    if rclpy.ok():
        try:
            rclpy.shutdown()
        except Exception:
            pass



# ---------- Reorder helpers ----------
def _action_hora2allegro(actions):
    if isinstance(actions, torch.Tensor):
        if actions.dim() > 1:
            actions = actions.view(-1)
        cmd_act = actions.clone()
        temp = actions[[4, 5, 6, 7]].clone()
        cmd_act[[4, 5, 6, 7]] = actions[[8, 9, 10, 11]]
        cmd_act[[12, 13, 14, 15]] = temp
        cmd_act[[8, 9, 10, 11]] = actions[[12, 13, 14, 15]]
        return cmd_act
    else:
        a = np.asarray(actions).flatten()
        cmd = a.copy()
        temp = a[[4, 5, 6, 7]].copy()
        cmd[[4, 5, 6, 7]] = a[[8, 9, 10, 11]]
        cmd[[12, 13, 14, 15]] = temp
        cmd[[8, 9, 10, 11]] = a[[12, 13, 14, 15]]
        return cmd


def _obs_allegro2hora(o):
    # allegro: index - middle - ring - thumb
    # hora  : index, thumb, middle, ring
    return np.concatenate([o[0:4], o[12:16], o[4:8], o[8:12]]).astype(np.float64)


def _reorder_imrt2timr(imrt):
    # [ROS1] index - middle - ring - thumb  ->  [ROS2] thumb - index - middle - ring
    return np.concatenate([imrt[12:16], imrt[0:12]]).astype(np.float64)


def _reorder_timr2imrt(timr):
    # [ROS2] thumb - index - middle - ring  ->  [ROS1] index - middle - ring - thumb
    return np.concatenate([timr[4:16], timr[0:4]]).astype(np.float64)


class HardwarePlayer(object):
    def __init__(self):
        self.action_scale = 1 / 24
        self.actions_num = 16
        self.device = "cuda"  # â† ì—¬ê¸°ì„œ ë””ë°”ì´ìŠ¤ í†µì¼

        # ===== Model / RMS =====
        obs_shape = (96,)
        net_config = {
            "actions_num": self.actions_num,
            "input_shape": obs_shape,
            "actor_units": [512, 256, 128],
            "priv_mlp_units": [256, 128, 8],
            "priv_info": True,
            "proprio_adapt": True,
            "priv_info_dim": 9,
        }

        self.model = ActorCritic(net_config).to(self.device).eval()
        self.running_mean_std = RunningMeanStd(obs_shape).to(self.device).eval()
        self.sa_mean_std = RunningMeanStd((30, 32)).to(self.device).eval()

        # ===== Runtime buffers (device í†µì¼) =====
        self.obs_buf = torch.zeros((1, 16 * 3 * 2), dtype=torch.float32, device=self.device)           # 96
        self.proprio_hist_buf = torch.zeros((1, 30, 16 * 2), dtype=torch.float32, device=self.device)  # (1,30,32)

        # ===== Allegro joint limits =====
        self.allegro_dof_lower = torch.tensor([
            -0.4700, -0.1960, -0.1740, -0.2270,   # Index
             0.2630, -0.1050, -0.1890, -0.1620,   # Thumb
            -0.4700, -0.1960, -0.1740, -0.2270,   # Middle
            -0.4700, -0.1960, -0.1740, -0.2270,   # Ring
        ], dtype=torch.float32, device=self.device)

        self.allegro_dof_upper = torch.tensor([
             0.4700, 1.6100, 1.7090, 1.6180,      # Index
             1.3960, 1.1630, 1.6440, 1.7190,      # Thumb
             0.4700, 1.6100, 1.7090, 1.6180,      # Middle
             0.4700, 1.6100, 1.7090, 1.6180,      # Ring
        ], dtype=torch.float32, device=self.device)

        # ===== Poses =====
        self.init_pose = [
            0.0627, 1.2923, 0.3383, 0.1088,
            0.0724, 1.1983, 0.1551, 0.1499,
            0.1343, 1.1736, 0.5355, 0.2164,
            1.1202, 1.1374, 0.8535, -0.0852,
        ]

        # ===== Targets (rad) =====
        self.prev_target = torch.zeros((1, 16), dtype=torch.float32, device=self.device)
        self.cur_target  = torch.zeros((1, 16), dtype=torch.float32, device=self.device)

    # ---------- Steps ----------
    def pre_physics_step(self, action):
        self.action = action.clone()
        target = self.prev_target + self.action_scale * self.action
        self.cur_target = torch.clip(target, self.allegro_dof_lower, self.allegro_dof_upper)
        self.prev_target = self.cur_target.clone()

    def post_physics_step(self, obses):
        # normalize current obs (obses: real q) -> (1,16)
        self.cur_obs_buf = self.unscale(
            obses, self.allegro_dof_lower, self.allegro_dof_upper
        )[None]

        # obs_buf roll
        self.prev_obs_buf = self.obs_buf[:, 32:].clone()
        self.obs_buf[:, :64]   = self.prev_obs_buf
        self.obs_buf[:, 64:80] = self.cur_obs_buf.clone()
        self.obs_buf[:, 80:96] = self.cur_target.clone()  # real target

        # proprio history (30)
        cur_norm_t = self.cur_obs_buf.unsqueeze(1)          # (1,1,16)
        cur_tgt_t  = self.cur_target.unsqueeze(1)           # (1,1,16)
        cur = torch.cat([cur_norm_t, cur_tgt_t], dim=-1)    # (1,1,32)
        prev = self.proprio_hist_buf[:, 1:30, :].clone()    # (1,29,32)
        self.proprio_hist_buf[:] = torch.cat([prev, cur], dim=1)

    # ---------- Utils ----------
    def unscale(self, x, lower, upper):
        return (2.0 * x - upper - lower) / (upper - lower)

    # ---------- Deploy ----------
    def deploy(self):
        # 1) Allegro I/O ë…¸ë“œ ì‹œì‘
        self.allegro = start_allegro_io(side='right')

        hz = 20

        # 2) ì´ˆê¸° ì…‹ì—… ë£¨í”„
        warmup = hz * 4
        for t in range(warmup):
            tprint(f"setup {t} / {warmup}")
            pose = _reorder_imrt2timr(np.array(self.init_pose, dtype=np.float64))
            self.allegro.command_joint_position(pose)
            time.sleep(1/hz)

        # 3) ì²« ê´€ì¸¡
        q_pos = self.allegro.poll_joint_position(wait=True, timeout=5.0)
        if q_pos is None:
            print("âŒ failed to read joint state.")
            stop_allegro_io(self.allegro)
            return

        ros1_q = _reorder_timr2imrt(q_pos)
        hora_q = _obs_allegro2hora(ros1_q)
        obs_q = torch.from_numpy(hora_q.astype(np.float32)).to(self.device)  # â† device í†µì¼

        # qê°’ì€ normalize(=unscale) í•´ì„œ ë²„í¼ì— ì €ì¥ // isaacgym ìˆœì„œ
        self.cur_obs_buf = self.unscale(obs_q, self.allegro_dof_lower, self.allegro_dof_upper)[None]
        # prev_targetì€ ì‹¤ì¸¡(rad)
        self.prev_target = obs_q[None].clone()

        # obs_buf ì´ˆê¸°í™”
        for i in range(3):
            print(f"init fill: {i*32}:{i*32+16}, {i*32+16}:{i*32+32}")
            self.obs_buf[:, i*32:i*32+16] = self.cur_obs_buf      # q_t
            self.obs_buf[:, i*32+16:i*32+32] = self.prev_target   # a_{t-1}

        # proprio_hist_buf ì´ˆê¸°í™”
        self.proprio_hist_buf[:, :, :16] = self.cur_obs_buf
        self.proprio_hist_buf[:, :, 16:32] = self.prev_target

        timestep = 0
        print("Deployment started. Press Ctrl+C to stop.")
        try:
            while True:
                loop_start = time.perf_counter()

                # Normalize the observation buffer (device ë™ì¼)
                self.obs_buf = self.running_mean_std(self.obs_buf.clone())

                input_dict = {
                    "obs": self.obs_buf,
                    "proprio_hist": self.sa_mean_std(self.proprio_hist_buf.clone()),
                }
                action = torch.clamp(self.model.act_inference(input_dict), -1.0, 1.0)

                # control
                self.pre_physics_step(action)

                # ëª…ë ¹ ì „ì†¡: í•˜ë“œì›¨ì–´ I/O ì§ì „ì—ë§Œ CPUë¡œ ë‚´ë¦¼
                cmd = self.cur_target.detach().to('cpu').numpy()[0]
                ros1 = _action_hora2allegro(cmd)
                ros2 = _reorder_imrt2timr(ros1)
                self.allegro.command_joint_position(ros2)

                # ê´€ì¸¡ ì—…ë°ì´íŠ¸ / o_{t+1}
                q_pos = self.allegro.poll_joint_position(wait=True, timeout=0.2)
                ros1_q = _reorder_timr2imrt(q_pos)
                hora_q = _obs_allegro2hora(ros1_q)
                obs_q = torch.from_numpy(hora_q.astype(np.float32)).to(self.device)  # â† device í†µì¼

                self.post_physics_step(obs_q)  # buffer ì—…ë°ì´íŠ¸

                time.sleep(0.03)  # ~20 Hz
                timestep += 1

                freq = 1.0 / (time.perf_counter() - loop_start)
                print(f"Hz={freq:.2f}")

        except KeyboardInterrupt:
            print("KeyboardInterrupt, stopping...")
        finally:
            # ì•ˆì „ ì •ì§€
            try:
                self.allegro.go_safe()
            except Exception:
                pass
            stop_allegro_io(self.allegro)
            print("ğŸ§  Deployment stopped cleanly.")

    # ---------- checkpoint restore ----------
    def restore(self, fn):
        # ì²´í¬í¬ì¸íŠ¸ ë¡œë”© ì‹œì—ë„ device ë§¤í•‘ í†µì¼
        checkpoint = torch.load(fn, map_location=self.device)
        self.running_mean_std.load_state_dict(checkpoint["running_mean_std"])
        self.model.load_state_dict(checkpoint["model"])
        self.sa_mean_std.load_state_dict(checkpoint["sa_mean_std"])

```

:::

:::::: {.callout-note}

# After Code

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os
import time
import signal
from typing import List, Optional

import numpy as np
import torch

import rclpy
from rclpy.executors import SingleThreadedExecutor
from rclpy.node import Node
from sensor_msgs.msg import JointState
from std_msgs.msg import Float64MultiArray

from hora.algo.models.models import ActorCritic
from hora.algo.models.running_mean_std import RunningMeanStd
from hora.utils.misc import tprint


# =========================================================
# Allegro ROS2 I/O (ë°±ê·¸ë¼ìš´ë“œ ìŠ¤í”¼ë„ˆ + position_gap í¼ë¸”ë¦¬ì…”)
# =========================================================

DEFAULT_ORDER = {
    "right": [
        "ah_joint00", "ah_joint01", "ah_joint02", "ah_joint03",
        "ah_joint10", "ah_joint11", "ah_joint12", "ah_joint13",
        "ah_joint20", "ah_joint21", "ah_joint22", "ah_joint23",
        "ah_joint30", "ah_joint31", "ah_joint32", "ah_joint33",
    ],
}


class AllegroHandIO(Node):
    """ROS2 Allegro I/O ë…¸ë“œ: ëª…ë ¹ í¼ë¸”ë¦¬ì‹œ + joint_states êµ¬ë… + /position_gap í¼ë¸”ë¦¬ì‹œ"""
    def __init__(
        self,
        side: str = "right",
        controller_name: Optional[str] = None,
        joint_states_topic: str = "/joint_states",
        command_topic: Optional[str] = None,
    ):
        super().__init__("allegro_hand_io")

        side = (side or "right").lower()
        if side not in ("right", "left"):
            self.get_logger().warn(f"Unknown side '{side}', defaulting to 'right'.")
            side = "right"
        self.side = side

        controller_name = controller_name or "allegro_hand_position_controller"
        if command_topic is None:
            command_topic = f"/{controller_name}/commands"

        # pubs/subs
        self._cmd_pub = self.create_publisher(Float64MultiArray, command_topic, 10)
        self._gap_pub = self.create_publisher(JointState, "/position_gap", 10)
        self.create_subscription(JointState, joint_states_topic, self._on_js, 50)

        # state
        self._last_js: Optional[JointState] = None
        self._index_map: Optional[List[int]] = None
        self._last_cmd: Optional[np.ndarray] = None

        self._desired_names = DEFAULT_ORDER["right"]

        # ì•ˆì „ í¬ì¦ˆ
        self.safe_pose = np.array([
            0.5, 0.2, 0.0, 0.0,   # Thumb
            0.0, 0.0, 0.0, 0.0,   # Index
            0.0, 0.0, 0.0, 0.0,   # Middle
            0.0, 0.0, 0.0, 0.0,   # Ring
        ], dtype=float)

        self.get_logger().info(f"[AllegroHandIO] side={self.side}")
        self.get_logger().info(f"[AllegroHandIO] cmd topic={command_topic}")
        self.get_logger().info(f"[AllegroHandIO] joint_states topic={joint_states_topic}")
        self.get_logger().info(f"[AllegroHandIO] gap topic=/position_gap")

    # ---------- public ----------
    def command_joint_position(self, positions: List[float]) -> bool:
        """16D ëª©í‘œ ìì„¸ í¼ë¸”ë¦¬ì‹œ + ì§í›„ 1íšŒ gap í¼ë¸”ë¦¬ì‹œ"""
        try:
            data = [float(x) for x in positions]
        except Exception:
            self.get_logger().warn("command_joint_position: positions must be a sequence of numbers.")
            return False
        if len(data) != 16:
            self.get_logger().warn(f"command_joint_position: expected 16 elements, got {len(data)}.")
            return False

        msg = Float64MultiArray()
        msg.data = data
        self._cmd_pub.publish(msg)
        self._last_cmd = np.asarray(data, dtype=float)

        # í˜„ì¬ ìµœì‹  ìƒíƒœë¡œ gap í•œë²ˆ í¼ë¸”ë¦¬ì‹œ(ë…¼ë¸”ë¡œí‚¹)
        self._publish_position_gap()
        return True

    def poll_joint_position(self, wait: bool = False, timeout: float = 0.0) -> Optional[np.ndarray]:
        """í˜„ì¬ ì¡°ì¸íŠ¸ë¥¼ Allegro ìˆœì„œ(16D)ë¡œ ë°˜í™˜"""
        if self._last_js is None and wait:
            # timer ì½œë°±ì—ì„œ ë¸”ë¡œí‚¹ì€ ê¶Œì¥í•˜ì§€ ì•Šìœ¼ë‚˜, ì´ˆê¸°í™” ì‹œì—ëŠ” ì‚¬ìš© ê°€ëŠ¥
            end_t = time.perf_counter() + max(0.0, float(timeout))
            while self._last_js is None and time.perf_counter() < end_t:
                rclpy.spin_once(self, timeout_sec=0.02)

        js = self._last_js
        if js is None or not js.position:
            return None

        if self._index_map is None and js.name:
            self._index_map = self._build_index_map(js.name)

        if self._index_map:
            try:
                vec = np.array([js.position[i] for i in self._index_map], dtype=float)
                if vec.size == 16:
                    return vec
            except Exception:
                self.get_logger().warn("poll_joint_position: index mapping failed, fallback to raw order.")

        if len(js.position) >= 16:
            return np.array(js.position[:16], dtype=float)
        return None

    def go_safe(self):
        self.command_joint_position(self.safe_pose)

    # ---------- internals ----------
    def _on_js(self, msg: JointState):
        self._last_js = msg

    def _build_index_map(self, joint_names: List[str]) -> Optional[List[int]]:
        mp = {n.lower(): i for i, n in enumerate(joint_names)}
        out = []
        for desired in self._desired_names:
            idx = mp.get(desired.lower())
            if idx is None:
                self.get_logger().warn(f"Missing joint name in /joint_states: '{desired}'")
                return None
            out.append(idx)
        return out if len(out) == 16 else None

    def _publish_position_gap(self):
        if self._last_cmd is None or self._last_js is None:
            return
        cur = self.poll_joint_position(wait=False)
        if cur is None or cur.size != 16:
            return
        gap = (self._last_cmd - cur).astype(float)
        js = JointState()
        js.header.stamp = self.get_clock().now().to_msg()
        js.header.frame_id = ""
        js.name = list(self._desired_names)
        js.position = gap.tolist()
        self._gap_pub.publish(js)


# ========== FIX: Runnerë¥¼ í‘œì¤€ threading ê¸°ë°˜ìœ¼ë¡œ ==========

import threading
from rclpy.executors import SingleThreadedExecutor

class _Runner:
    def __init__(self, node: 'AllegroHandIO'):
        self.node = node
        self.exec = SingleThreadedExecutor()
        self.exec.add_node(node)
        self.thread = threading.Thread(target=self.exec.spin, daemon=True)

    def start(self):
        self.thread.start()

    def stop(self):
        try:
            self.exec.shutdown()          # executor ì¤‘ì§€
        finally:
            try:
                self.node.destroy_node()  # ë…¸ë“œ íŒŒê´´
            finally:
                # ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸° (ë„ˆë¬´ ì˜¤ë˜ ê¸°ë‹¤ë¦¬ì§€ ì•Šë„ë¡ íƒ€ì„ì•„ì›ƒ)
                self.thread.join(timeout=2.0)



def start_allegro_io(side: str = "right") -> 'AllegroHandIO':
    if not rclpy.ok():
        rclpy.init()
    io = AllegroHandIO(side=side)
    io._runner = _Runner(io)
    io._runner.start()
    return io

def stop_allegro_io(io: 'AllegroHandIO'):
    if hasattr(io, "_runner") and io._runner:
        io._runner.stop()
    if rclpy.ok():
        try:
            rclpy.shutdown()
        except Exception:
            pass


# =========================================================
# ë³€í™˜/ì¬ë°°ì—´ ìœ í‹¸
# =========================================================

def _action_hora2allegro(actions):
    if isinstance(actions, torch.Tensor):
        if actions.dim() > 1:
            actions = actions.view(-1)
        cmd_act = actions.clone()
        temp = actions[[4, 5, 6, 7]].clone()
        cmd_act[[4, 5, 6, 7]] = actions[[8, 9, 10, 11]]
        cmd_act[[12, 13, 14, 15]] = temp
        cmd_act[[8, 9, 10, 11]] = actions[[12, 13, 14, 15]]
        return cmd_act
    else:
        a = np.asarray(actions).flatten()
        cmd = a.copy()
        temp = a[[4, 5, 6, 7]].copy()
        cmd[[4, 5, 6, 7]] = a[[8, 9, 10, 11]]
        cmd[[12, 13, 14, 15]] = temp
        cmd[[8, 9, 10, 11]] = a[[12, 13, 14, 15]]
        return cmd


def _obs_allegro2hora(o):
    # allegro: index - middle - ring - thumb
    # hora   : index, thumb, middle, ring
    return np.concatenate([o[0:4], o[12:16], o[4:8], o[8:12]]).astype(np.float64)


def _reorder_imrt2timr(imrt):
    # [ROS1] index-middle-ring-thumb â†’ [ROS2] thumb-index-middle-ring
    return np.concatenate([imrt[12:16], imrt[0:12]]).astype(np.float64)


def _reorder_timr2imrt(timr):
    # [ROS2] thumb-index-middle-ring â†’ [ROS1] index-middle-ring-thumb
    return np.concatenate([timr[4:16], timr[0:4]]).astype(np.float64)


# =========================================================
# ì œì–´ ì—ì´ì „íŠ¸ (Timer ê¸°ë°˜)
# =========================================================

class HardwarePlayer:
    def __init__(self, hz: float = 20.0, device: str = "cuda"):
        torch.set_grad_enabled(False)
        self.hz = float(hz)
        self.device = device

        # model / rms
        obs_shape = (96,)
        net_config = {
            "actions_num": 16,
            "input_shape": obs_shape,
            "actor_units": [512, 256, 128],
            "priv_mlp_units": [256, 128, 8],
            "priv_info": True,
            "proprio_adapt": True,
            "priv_info_dim": 9,
        }
        self.model = ActorCritic(net_config).to(self.device).eval()
        self.running_mean_std = RunningMeanStd(obs_shape).to(self.device).eval()
        self.sa_mean_std = RunningMeanStd((30, 32)).to(self.device).eval()

        # buffers
        self.obs_buf = torch.zeros((1, 96), dtype=torch.float32, device=self.device)
        self.proprio_hist_buf = torch.zeros((1, 30, 32), dtype=torch.float32, device=self.device)

        # limits
        self.allegro_dof_lower = torch.tensor([
            -0.4700, -0.1960, -0.1740, -0.2270,   # Index
             0.2630, -0.1050, -0.1890, -0.1620,   # Thumb
            -0.4700, -0.1960, -0.1740, -0.2270,   # Middle
            -0.4700, -0.1960, -0.1740, -0.2270,   # Ring
        ], dtype=torch.float32, device=self.device)
        self.allegro_dof_upper = torch.tensor([
             0.4700, 1.6100, 1.7090, 1.6180,      # Index
             1.3960, 1.1630, 1.6440, 1.7190,      # Thumb
             0.4700, 1.6100, 1.7090, 1.6180,      # Middle
             0.4700, 1.6100, 1.7090, 1.6180,      # Ring
        ], dtype=torch.float32, device=self.device)

        # poses
        self.init_pose = [
            0.0627, 1.2923, 0.3383, 0.1088,
            0.0724, 1.1983, 0.1551, 0.1499,
            0.1343, 1.1736, 0.5355, 0.2164,
            1.1202, 1.1374, 0.8535, -0.0852,
        ]

        # state
        self.action_scale = 1.0 / 24.0
        self.prev_target = torch.zeros((1, 16), dtype=torch.float32, device=self.device)
        self.cur_target  = torch.zeros((1, 16), dtype=torch.float32, device=self.device)
        self._last_obs_q = None
        self._skipped = 0
        self._last_step_t = None

        # ros
        self.timer = None
        self.allegro = None

    # ---------- utils ----------
    @staticmethod
    def _unscale(x, lower, upper):
        return (2.0 * x - upper - lower) / (upper - lower)

    def _pre_physics_step(self, action):
        target = self.prev_target + self.action_scale * action
        self.cur_target = torch.clamp(target, min=self.allegro_dof_lower, max=self.allegro_dof_upper)
        self.prev_target = self.cur_target

    def _post_physics_step(self, obses):
        # 1) í˜„ì¬ ê´€ì¸¡ ì •ê·œí™” (obses: (16,) ë˜ëŠ” (1,16) í…ì„œ on self.device)
        #    ê²°ê³¼ë¥¼ (1,16)ë¡œ ë³´ì¥
        cur_obs = self._unscale(
            obses.view(-1), self.allegro_dof_lower, self.allegro_dof_upper
        ).view(1, 16)

        # 2) obs_buf ë¡¤ë§ (96 = 32*3)
        #    [0:64] <- [32:96],  [64:80] <- cur_obs,  [80:96] <- cur_target
        #    âš ï¸ ê²¹ì¹¨ ë°©ì§€: ì†ŒìŠ¤ ë¶€ë¶„ì„ ë¨¼ì € clone() í•´ì„œ ì„ì‹œ ë³´ê´€
        src64 = self.obs_buf[:, 32:96].clone()     # (1,64)
        self.obs_buf[:, 0:64] = src64              # ì• 64ì¹¸ìœ¼ë¡œ ë‹¹ê¹€
        self.obs_buf[:, 64:80] = cur_obs           # í˜„ì¬ ê´€ì¸¡(ì •ê·œí™”)
        self.obs_buf[:, 80:96] = self.cur_target   # ìµœì‹  íƒ€ê¹ƒ(rad)

        # 3) proprio_hist_buf ë¡¤ë§ (T=30)
        #    [:, 0:-1, :] <- [:, 1:, :];  ë§ˆì§€ë§‰ stepì— [cur_obs | cur_target]
        #    âš ï¸ ë™ì¼ í…ì„œ ë‚´ ê²¹ì¹¨ ë°©ì§€: ì†ŒìŠ¤ clone()
        src_hist = self.proprio_hist_buf[:, 1:, :].clone()  # (1,29,32)
        self.proprio_hist_buf[:, 0:-1, :] = src_hist
        self.proprio_hist_buf[:, -1, :16] = cur_obs
        self.proprio_hist_buf[:, -1, 16:32] = self.cur_target

    # ---------- timer callback ----------
    @torch.inference_mode()
    def _control_step(self):
        t0 = time.perf_counter()

        # 1) norm
        obs_norm = self.running_mean_std(self.obs_buf)

        # 2) inference
        input_dict = {
            "obs": obs_norm,
            "proprio_hist": self.sa_mean_std(self.proprio_hist_buf),
        }
        action = torch.clamp(self.model.act_inference(input_dict), -1.0, 1.0)

        # 3) update target
        self._pre_physics_step(action)

        # 4) publish command (CPUë¡œë§Œ ë‚´ë¦´ ë•Œ ë³€í™˜)
        cmd = self.cur_target.detach().to("cpu").numpy()[0]
        ros1 = _action_hora2allegro(cmd)
        ros2 = _reorder_imrt2timr(ros1)
        self.allegro.command_joint_position(ros2)

        # 5) non-blocking obs update (ë“œë ì‹œ ë§ˆì§€ë§‰ ìœ íš¨ ê´€ì¸¡ ì‚¬ìš©)
        q_pos = self.allegro.poll_joint_position(wait=False, timeout=0.0)
        if q_pos is not None:
            ros1_q = _reorder_timr2imrt(q_pos)
            hora_q = _obs_allegro2hora(ros1_q)
            obs_q = torch.from_numpy(hora_q.astype(np.float32)).to(self.device)
            self._last_obs_q = obs_q
        else:
            obs_q = self._last_obs_q
            self._skipped += 1

        if obs_q is not None:
            self._post_physics_step(obs_q)

        # 6) light jitter log
        if self._last_step_t is None:
            self._last_step_t = t0
        else:
            dt = t0 - self._last_step_t
            self._last_step_t = t0
            # 5ì´ˆë§ˆë‹¤ í•œ ë²ˆë§Œ ì¶œë ¥
            if int(time.time()) % 5 == 0:
                hz_est = 1.0 / max(dt, 1e-6)
                print(f"[timer] {hz_est:.2f} Hz, skipped={self._skipped}")

    # ---------- deploy ----------
    def deploy(self):
        # ROS2 I/O ì‹œì‘(ë°±ê·¸ë¼ìš´ë“œ ì‹¤í–‰ê¸°)
        self.allegro = start_allegro_io(side='right')

        # ì›Œë°ì—…(ë¸”ë¡œí‚¹) â€” í•˜ë“œì›¨ì–´ settle
        warmup = int(self.hz * 4)
        for t in range(warmup):
            tprint(f"setup {t} / {warmup}")
            pose = _reorder_imrt2timr(np.array(self.init_pose, dtype=np.float64))
            self.allegro.command_joint_position(pose)
            time.sleep(1.0 / self.hz)

        # ì²« ê´€ì¸¡(ë¸”ë¡œí‚¹ 1íšŒ â€” ì´ˆê¸°í™” ì•ˆì •)
        q_pos = self.allegro.poll_joint_position(wait=True, timeout=5.0)
        if q_pos is None:
            print("âŒ failed to read joint state.")
            stop_allegro_io(self.allegro)
            return

        ros1_q = _reorder_timr2imrt(q_pos)
        hora_q = _obs_allegro2hora(ros1_q)
        obs_q = torch.from_numpy(hora_q.astype(np.float32)).to(self.device)
        self._last_obs_q = obs_q

        # buffers ì´ˆê¸°í™”
        cur_obs_buf = self._unscale(obs_q, self.allegro_dof_lower, self.allegro_dof_upper)[None]
        self.prev_target = obs_q[None]
        for i in range(3):
            self.obs_buf[:, i*32:i*32+16] = cur_obs_buf
            self.obs_buf[:, i*32+16:i*32+32] = self.prev_target
        self.proprio_hist_buf[:, :, :16] = cur_obs_buf
        self.proprio_hist_buf[:, :, 16:32] = self.prev_target

        # Timer ë“±ë¡ (ì •í™• ì£¼ê¸°)
        period = 1.0 / self.hz
        self.timer = self.allegro.create_timer(period, self._control_step)
        print(f"Deployment started (timer-based {self.hz:.1f} Hz). Ctrl+C to stop.")

        # ë©”ì¸ ìŠ¤ë ˆë“œ: ì‹œê·¸ë„ ì²˜ë¦¬ + ìœ ì§€
        interrupted = False

        def _sigint(_sig, _frm):
            nonlocal interrupted
            interrupted = True
        signal.signal(signal.SIGINT, _sigint)

        try:
            while not interrupted:
                time.sleep(0.2)
        finally:
            try:
                if self.timer is not None:
                    self.timer.cancel()
            except Exception:
                pass
            try:
                self.allegro.go_safe()
            except Exception:
                pass
            stop_allegro_io(self.allegro)
            print("ğŸ§  Deployment stopped cleanly.")

    # ---------- checkpoint ----------
    def restore(self, fn):
        ckpt = torch.load(fn, map_location=self.device)
        self.running_mean_std.load_state_dict(ckpt["running_mean_std"])
        self.model.load_state_dict(ckpt["model"])
        self.sa_mean_std.load_state_dict(ckpt["sa_mean_std"])


# =========================================================
# ì‹¤í–‰ ì˜ˆì‹œ
# =========================================================
if __name__ == "__main__":
    # ì˜ˆ: CUDAê°€ ì—†ìœ¼ë©´ device="cpu"ë¡œ ë³€ê²½
    agent = HardwarePlayer(hz=20.0, device="cuda" if torch.cuda.is_available() else "cpu")
    # í•„ìš”í•œ ê²½ìš° ì²´í¬í¬ì¸íŠ¸ ë¡œë“œ
    # agent.restore("/path/to/checkpoint.pth")
    agent.deploy()

```

:::



> ROS1/ROS2 ê³µí†µ ë¡œì§ì€ ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ë©´ì„œ, ROS2 íŠ¹ì„±ì— ë§ì¶° ì‹¤ì‹œê°„ì„±/ì•ˆì •ì„±ì„ ëŒì–´ì˜¬ë¦¬ëŠ” ë° ì´ˆì 

# 1) while+sleep ë£¨í”„ â†’ ROS2 Timer ê¸°ë°˜ ì œì–´ ë£¨í”„

* **ë¬¸ì œ**: `while True` + `time.sleep()`ëŠ” OS ìŠ¤ì¼€ì¤„ë§Â·íŒŒì´ì¬ GILÂ·ê¹Šì€ ì½œ ìŠ¤íƒ ë“±ì— ì˜í•´ ì§€í„°ê°€ ì»¤ì§€ê³ , ì½œë°±/êµ¬ë…ìì™€ ê²½í•©í•  ë•Œ ì£¼ê¸°ê°€ ë” í‹€ì–´ì§ˆ ìˆ˜ ìˆì–´.
* **ê°œì„ **: `self.allegro.create_timer(period, self._control_step)`ë¡œ **ì£¼ê¸° ì½œë°±**ì„ ë“±ë¡.
* **íš¨ê³¼**

  * ì œì–´ ì£¼ê¸°ê°€ ROS ì‹¤í–‰ê¸°ì— ì˜í•´ ìœ ì§€ë¼ ì§€í„°ê°€ ê°ì†Œ.
  * ë©”ì¸ ìŠ¤ë ˆë“œëŠ” íƒ€ì´ë¨¸ë§Œ ëŒê³ , I/Oì™€ ì½œë°±ì€ ì‹¤í–‰ê¸°ê°€ ì ì ˆíˆ ìŠ¤ì¼€ì¤„ë§.

---

# 2) rclpy ì‹¤í–‰ê¸°(Executor) ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œí™” (ê³µì‹ APIë§Œ ì‚¬ìš©)

* **ë¬¸ì œ**: rclpyì˜ ë‚´ë¶€(private) API(`rclpy.executors._util`, `_thread`)ë¥¼ ì“°ë©´ ë²„ì „ ì°¨ì´ë¡œ **AttributeError**ê°€ ë°œìƒ.
* **ê°œì„ **: **í‘œì¤€ `threading.Thread` + `SingleThreadedExecutor`** ë¡œ ì•ˆì •ì ì¸ ë°±ê·¸ë¼ìš´ë“œ ìŠ¤í”¼ë„ˆ êµ¬í˜„.
* **íš¨ê³¼**: ROS2 ë…¸ë“œëŠ” ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì•ˆì „í•˜ê²Œ ëŒê³ , íƒ€ì´ë¨¸/êµ¬ë… ì½œë°±ì´ ë§‰í˜ ì—†ì´ ì²˜ë¦¬ë¨.

---

# 3) ì¥ì¹˜(device) ì¼ê´€ì„± ìœ ì§€ (cuda/cpu mismatch ë°©ì§€)

* **ë¬¸ì œ**: í…ì„œ/ëª¨ë¸/RMSê°€ ì„œë¡œ ë‹¤ë¥¸ ë””ë°”ì´ìŠ¤(cuï»¿daÂ·cpu)ì— ìˆìœ¼ë©´ `Expected all tensors to be on the same device` ëŸ°íƒ€ì„ ì˜¤ë¥˜ ë°œìƒ.
* **ê°œì„ **

  * `self.device`ë¥¼ ë‹¨ì¼ ì†ŒìŠ¤ë¡œ ë‘ê³ , `model`, `running_mean_std`, `sa_mean_std`, **ë²„í¼(`obs_buf`, `proprio_hist_buf`)**ê¹Œì§€ ì „ë¶€ ê°™ì€ ë””ë°”ì´ìŠ¤ë¡œ ìƒì„±/ì´ë™.
  * í•˜ë“œì›¨ì–´ I/O ì§ì „ **í•„ìš”í•  ë•Œë§Œ** CPUë¡œ ë‚´ë¦¼: `self.cur_target.detach().to('cpu').numpy()`
* **íš¨ê³¼**: ë””ë°”ì´ìŠ¤ ì´ë™ ìµœì†Œí™”ë¡œ ì†ë„â†‘, ë””ë°”ì´ìŠ¤ ë¶ˆì¼ì¹˜ ì—ëŸ¬â†“.

---

# 4) `@torch.inference_mode()` + ë¶ˆí•„ìš”í•œ clone ìµœì†Œí™”

* **ë¬¸ì œ**: ì¶”ë¡  ì¤‘ ê·¸ë˜ë””ì–¸íŠ¸ íŠ¸ë˜í‚¹ì€ ë‚­ë¹„ì´ë©°, ì¦ì€ `.clone()`ì€ ë©”ëª¨ë¦¬/ì‹œê°„ ë¹„ìš©.
* **ê°œì„ **

  * íƒ€ì´ë¨¸ ì½œë°±(`_control_step`)ì— `@torch.inference_mode()` ì ìš©.
  * ê¼­ í•„ìš”í•œ ìœ„ì¹˜ì—ì„œë§Œ `clone()` ì‚¬ìš©.
* **íš¨ê³¼**: ì¶”ë¡  ì‹œ ì˜¤ë²„í—¤ë“œ ê°ì†Œ, ì†ë„ ì•ˆì •í™”.

---

# 5) ê´€ì¸¡ ë“œë(ë¯¸ìˆ˜ì‹ ) ëŒ€ë¹„: **last-good sample ì¬ì‚¬ìš©**

* **ë¬¸ì œ**: íƒ€ì´ë¨¸ ì£¼ê¸°ì™€ `/joint_states` ì£¼ê¸°ê°€ ë”± ë§ì§€ ì•Šìœ¼ë©´ ì–´ë–¤ í‹±ì—ì„œ ê´€ì¸¡ì´ **ì—†ì„ ìˆ˜** ìˆìŒ. ê·¸ë•Œ ë¸”ë¡œí‚¹(`wait=True`)ì„ ê±¸ë©´ ì œì–´ ì£¼ê¸°ê°€ ê¹¨ì§.
* **ê°œì„ **: ë…¼ë¸”ë¡œí‚¹ `wait=False`ë¡œ ì½ê³ , ìƒ˜í”Œì´ ì—†ìœ¼ë©´ **ì§ì „ ìœ íš¨ ê´€ì¸¡(`_last_obs_q`) ì¬ì‚¬ìš©**. ë“œë íšŸìˆ˜ `_skipped` ë¡œê¹….
* **íš¨ê³¼**: ì œì–´ ì£¼ê¸° ìœ ì§€(ì‹¤ì‹œê°„ì„±â†‘), ê´€ì¸¡ ì§€ì—°ì— ëŒ€í•œ **ë¡œë²„ìŠ¤íŠ¸**í•œ ë™ì‘.

---

# 6) ë²„í¼ ë¡¤ë§(overlap) ì˜¤ë¥˜ ìˆ˜ì •

* **ë¬¸ì œ**: `self.obs_buf[:, :64] = self.obs_buf[:, 32:]` ì²˜ëŸ¼ ê°™ì€ í…ì„œ ë‚´ **ê²¹ì¹˜ëŠ” ë©”ëª¨ë¦¬**ì— ëŒ€ì…í•˜ë©´ PyTorchê°€ ì˜ˆì™¸ë¥¼ ë˜ì§.
* **ê°œì„  (ë‘ ê°€ì§€ ë²„ì „ ì œê³µ)**

  1. **clone ì‚¬ìš©**: `src = self.obs_buf[:, 32:96].clone(); self.obs_buf[:, :64] = src`
  2. **`torch.roll` ì‚¬ìš©**: `rolled = torch.roll(self.obs_buf, shifts=-32, dims=1); self.obs_buf.copy_(rolled)`
* **íš¨ê³¼**: ì•ˆì „í•˜ê³  ëª…í™•í•œ ì‹œí”„íŠ¸, ì˜ˆì™¸ ì œê±°.

---

# 7) position gap í¼ë¸”ë¦¬ì…” ì¶”ê°€ + Header/Name ì„¸íŒ…

* **ë¬¸ì œ**: ëª…ë ¹ê³¼ ì‹¤ì œ ìœ„ì¹˜ ì‚¬ì´ ì˜¤ì°¨ë¥¼ ì™¸ë¶€ì—ì„œ ë³´ê¸° ì–´ë ¤ì›€.
* **ê°œì„ **

  * `/position_gap` í† í”½ì— **`sensor_msgs/JointState`**ë¡œ í¼ë¸”ë¦¬ì‹œ.
  * `header.stamp = node.get_clock().now().to_msg()` (ROS ì‹œê°„), `name`ì— 16ê°œ ì¡°ì¸íŠ¸ ì´ë¦„, `position`ì— gap(ëª…ë ¹-ì‹¤ì¸¡) ê¸°ë¡.
* **íš¨ê³¼**: rqt_plot, bag ê¸°ë¡ ë“±ì—ì„œ **ì •í™•í•œ íƒ€ì„ìŠ¤íƒ¬í”„**ë¡œ ì‹œê°í™”/ë¶„ì„ ê°€ëŠ¥.

---

# 8) ëª…ë ¹ ì§í›„ gap ì¸¡ì • (ì§§ì€ ì§€ì—° ëŒ€ì‹  â€œë‹¤ìŒ ì½œë°±ì—ì„œ ìµœì‹  ìƒíƒœâ€)

* ì´ˆê¸°ì— â€œëª…ë ¹ â†’ ì•„ì£¼ ì§§ê²Œ sleep â†’ gap ë°œí–‰â€ë„ ë³´ì—¬ì¤¬ì§€ë§Œ, ìµœì¢… êµ¬ì¡°ì—ì„  **íƒ€ì´ë¨¸ ì½œë°± ì•ˆ**ì—ì„œ ë§¤ í‹±ë§ˆë‹¤ ìµœì‹  ìƒíƒœë¡œ ê°±ì‹ ë˜ë¯€ë¡œ ë³„ë„ sleepì´ í•„ìš” ì—†ìŒ.
* gapì€ I/O ë…¸ë“œê°€ **í•­ìƒ ìµœì‹  `/joint_states` ê¸°ì¤€**ìœ¼ë¡œ ê³„ì‚°(ë…¼ë¸”ë¡œí‚¹) â†’ ì£¼ê¸° ìœ ì§€.

---

# 9) ì´ˆê¸°í™” ë£¨í‹´(ì›Œë°ì—… + ì²« ê´€ì¸¡ ë¸”ë¡œí‚¹ 1íšŒ)

* **ì›Œë°ì—…**: `hz*4`ë§Œí¼ ì´ˆê¸° ìì„¸ ëª…ë ¹ì„ ë³´ë‚´ **ë“œë¼ì´ë¸Œ settle**.
* **ì²« ê´€ì¸¡**: `wait=True, timeout=5.0`ìœ¼ë¡œ ë¸”ë¡œí‚¹ 1íšŒë§Œ ìˆ˜í–‰ â†’ ì´í›„ëŠ” ë…¼ë¸”ë¡œí‚¹.
* **íš¨ê³¼**: ì´ˆê¸° ë²„í¼ ìƒíƒœê°€ ì •ìƒì ì´ê³ , ê·¸ ë‹¤ìŒì—” ì£¼ê¸°ë¥¼ ê¹¨ì§€ ì•ŠìŒ.

---

# 10) ê°€ë²¼ìš´ ì£¼ê¸°/ì§€í„° ë¡œê¹…

* ë§¤ í‹±ë§ˆë‹¤ ì¶œë ¥í•˜ë©´ ì„±ëŠ¥ ì €í•˜ â†’ **ê°„í—(ì˜ˆ: 5ì´ˆì— í•œ ë²ˆ)** ë¡œê¹….
* `skipped` ì¹´ìš´í„°ë¡œ ê´€ì¸¡ ë“œë ì •ë„ë¥¼ í™•ì¸ ê°€ëŠ¥.

---

# 11) ROS2 API ì•ˆì „í•œ ì‚¬ìš©

* ë‚´ë¶€ API ì œê±°(ì•ì„  AttributeError í•´ê²°).
* `SingleThreadedExecutor`ë¡œë„ ì¶©ë¶„í•˜ë‚˜, ì½œë°± ê²½í•©ì´ ì»¤ì§€ë©´ `MultiThreadedExecutor` ê³ ë ¤ ê°€ëŠ¥.
* `stop_allegro_io()`ì—ì„œ `executor.shutdown()` â†’ `node.destroy_node()` â†’ `rclpy.shutdown()` ìˆœì„œë¡œ ì•ˆì „ ì¢…ë£Œ.

---

# 12) ìˆ˜ì¹˜ ì•ˆì •ì„± ë° ì„±ëŠ¥ íŒ(ì„ íƒì )

* **FP16/TF32**: `model.half()` ë° ì…ë ¥ë„ halfë¡œ ë§ì¶”ë©´ ì¶”ë¡  ì§€ì—°ì´ ê°ì†Œ(CUDA í•„ìš”).
* **CUDA Graph**: ì…ë ¥ shape ê³ ì • ì‹œ ê·¸ë˜í”„ ìº¡ì²˜ í›„ ì¬ì‚¬ìš©ìœ¼ë¡œ ì§€í„° ê°ì†Œ.
* **MLP ì¶•ì†Œ**: `actor_units`/`priv_mlp_units` ì°¨ì› ì¤„ì—¬ ì‹¤ì‹œê°„ì„±â†‘.
* **íƒ€ì´ë¨¸ ì£¼ê¸°**: í•˜ë“œì›¨ì–´Â·ë“œë¼ì´ë²„ ì§€ì—°ì„ ê³ ë ¤í•´ 20 Hzë¶€í„° ì‹œì‘, ì—¬ìœ ë˜ë©´ ìƒí–¥.

---

# 13) ROS1/ROS2 ë¡œì§ ì¼ê´€ì„± ìœ ì§€

* **ê´€ì¸¡ â†’ ì •ê·œí™”(unscale) â†’ obs_buf/proprio_hist ì—…ë°ì´íŠ¸ â†’ ëª¨ë¸ ì¶”ë¡  â†’ ì•¡ì…˜ ìŠ¤ì¼€ì¼Â·í´ë¦¬í•‘ â†’ íƒ€ê¹ƒ ê°±ì‹  â†’ ëª…ë ¹ ì „ì†¡ â†’ ë‹¤ìŒ ê´€ì¸¡**ì˜ íŒŒì´í”„ë¼ì¸ì€ ë™ì¼.
* ì°¨ì´ëŠ” **ì¡°ì¸íŠ¸ ìˆœì„œ ë³€í™˜(ROS1â†”ROS2)** ê³¼ **í† í”½ ì¸í„°í˜ì´ìŠ¤**ë¿.

---

## ìš”ì•½

* **ì •í™•í•œ ì œì–´ ì£¼ê¸°**: ROS2 Timerë¡œ ì „í™˜, ë¸”ë¡œí‚¹ ì œê±°, ë…¼ë¸”ë¡œí‚¹ ê´€ì¸¡ + last-good ì¬ì‚¬ìš©.
* **ì•ˆì •ì„±**: ë””ë°”ì´ìŠ¤ ì¼ê´€ì„±, ê²¹ì¹¨ ëŒ€ì… ìˆ˜ì •, ì•ˆì „ ì¢…ë£Œ ìˆœì„œ ì ìš©.
* **ë¶„ì„ ê°€ëŠ¥ì„±**: `/position_gap`ì— íƒ€ì„ìŠ¤íƒ¬í”„/ì´ë¦„ í¬í•¨ í¼ë¸”ë¦¬ì‹œ.
* **ì„±ëŠ¥**: inference_mode, ìµœì†Œí™”ëœ `.clone()`, í•„ìš” ì‹œ FP16Â·CUDA Graphë¡œ í™•ì¥ ê°€ëŠ¥.
-->
