---
draft: true
title: "👩‍💻ROS2 code 개선"
toc: true
number-sections: false
date: "2025-11-01"
description: GPT는 최고의 코더이다
categories: [ros2, python, code]
execute:
  freeze: auto
---

물론! 지금까지 내가 적용해 준 변경·최적화 포인트를 **왜** 그렇게 했는지까지 포함해 한 번에 정리해줄게. (ROS1/ROS2 공통 로직은 그대로 유지하면서, ROS2 특성에 맞춰 실시간성/안정성을 끌어올리는 데 초점을 뒀어.)

---

# 1) while+sleep 루프 → ROS2 Timer 기반 제어 루프

* **문제**: `while True` + `time.sleep()`는 OS 스케줄링·파이썬 GIL·깊은 콜 스택 등에 의해 지터가 커지고, 콜백/구독자와 경합할 때 주기가 더 틀어질 수 있어.
* **개선**: `self.allegro.create_timer(period, self._control_step)`로 **주기 콜백**을 등록.
* **효과**

  * 제어 주기가 ROS 실행기에 의해 유지돼 지터가 감소.
  * 메인 스레드는 타이머만 돌고, I/O와 콜백은 실행기가 적절히 스케줄링.

---

# 2) rclpy 실행기(Executor) 백그라운드 스레드화 (공식 API만 사용)

* **문제**: rclpy의 내부(private) API(`rclpy.executors._util`, `_thread`)를 쓰면 버전 차이로 **AttributeError**가 발생.
* **개선**: **표준 `threading.Thread` + `SingleThreadedExecutor`** 로 안정적인 백그라운드 스피너 구현.
* **효과**: ROS2 노드는 백그라운드에서 안전하게 돌고, 타이머/구독 콜백이 막힘 없이 처리됨.

---

# 3) 장치(device) 일관성 유지 (cuda/cpu mismatch 방지)

* **문제**: 텐서/모델/RMS가 서로 다른 디바이스(cu﻿da·cpu)에 있으면 `Expected all tensors to be on the same device` 런타임 오류 발생.
* **개선**

  * `self.device`를 단일 소스로 두고, `model`, `running_mean_std`, `sa_mean_std`, **버퍼(`obs_buf`, `proprio_hist_buf`)**까지 전부 같은 디바이스로 생성/이동.
  * 하드웨어 I/O 직전 **필요할 때만** CPU로 내림: `self.cur_target.detach().to('cpu').numpy()`
* **효과**: 디바이스 이동 최소화로 속도↑, 디바이스 불일치 에러↓.

---

# 4) `@torch.inference_mode()` + 불필요한 clone 최소화

* **문제**: 추론 중 그래디언트 트래킹은 낭비이며, 잦은 `.clone()`은 메모리/시간 비용.
* **개선**

  * 타이머 콜백(`_control_step`)에 `@torch.inference_mode()` 적용.
  * 꼭 필요한 위치에서만 `clone()` 사용.
* **효과**: 추론 시 오버헤드 감소, 속도 안정화.

---

# 5) 관측 드랍(미수신) 대비: **last-good sample 재사용**

* **문제**: 타이머 주기와 `/joint_states` 주기가 딱 맞지 않으면 어떤 틱에서 관측이 **없을 수** 있음. 그때 블로킹(`wait=True`)을 걸면 제어 주기가 깨짐.
* **개선**: 논블로킹 `wait=False`로 읽고, 샘플이 없으면 **직전 유효 관측(`_last_obs_q`) 재사용**. 드랍 횟수 `_skipped` 로깅.
* **효과**: 제어 주기 유지(실시간성↑), 관측 지연에 대한 **로버스트**한 동작.

---

# 6) 버퍼 롤링(overlap) 오류 수정

* **문제**: `self.obs_buf[:, :64] = self.obs_buf[:, 32:]` 처럼 같은 텐서 내 **겹치는 메모리**에 대입하면 PyTorch가 예외를 던짐.
* **개선 (두 가지 버전 제공)**

  1. **clone 사용**: `src = self.obs_buf[:, 32:96].clone(); self.obs_buf[:, :64] = src`
  2. **`torch.roll` 사용**: `rolled = torch.roll(self.obs_buf, shifts=-32, dims=1); self.obs_buf.copy_(rolled)`
* **효과**: 안전하고 명확한 시프트, 예외 제거.

---

# 7) position gap 퍼블리셔 추가 + Header/Name 세팅

* **문제**: 명령과 실제 위치 사이 오차를 외부에서 보기 어려움.
* **개선**

  * `/position_gap` 토픽에 **`sensor_msgs/JointState`**로 퍼블리시.
  * `header.stamp = node.get_clock().now().to_msg()` (ROS 시간), `name`에 16개 조인트 이름, `position`에 gap(명령-실측) 기록.
* **효과**: rqt_plot, bag 기록 등에서 **정확한 타임스탬프**로 시각화/분석 가능.

---

# 8) 명령 직후 gap 측정 (짧은 지연 대신 “다음 콜백에서 최신 상태”)

* 초기에 “명령 → 아주 짧게 sleep → gap 발행”도 보여줬지만, 최종 구조에선 **타이머 콜백 안**에서 매 틱마다 최신 상태로 갱신되므로 별도 sleep이 필요 없음.
* gap은 I/O 노드가 **항상 최신 `/joint_states` 기준**으로 계산(논블로킹) → 주기 유지.

---

# 9) 초기화 루틴(워밍업 + 첫 관측 블로킹 1회)

* **워밍업**: `hz*4`만큼 초기 자세 명령을 보내 **드라이브 settle**.
* **첫 관측**: `wait=True, timeout=5.0`으로 블로킹 1회만 수행 → 이후는 논블로킹.
* **효과**: 초기 버퍼 상태가 정상적이고, 그 다음엔 주기를 깨지 않음.

---

# 10) 가벼운 주기/지터 로깅

* 매 틱마다 출력하면 성능 저하 → **간헐(예: 5초에 한 번)** 로깅.
* `skipped` 카운터로 관측 드랍 정도를 확인 가능.

---

# 11) ROS2 API 안전한 사용

* 내부 API 제거(앞선 AttributeError 해결).
* `SingleThreadedExecutor`로도 충분하나, 콜백 경합이 커지면 `MultiThreadedExecutor` 고려 가능.
* `stop_allegro_io()`에서 `executor.shutdown()` → `node.destroy_node()` → `rclpy.shutdown()` 순서로 안전 종료.

---

# 12) 수치 안정성 및 성능 팁(선택적)

* **FP16/TF32**: `model.half()` 및 입력도 half로 맞추면 추론 지연이 감소(CUDA 필요).
* **CUDA Graph**: 입력 shape 고정 시 그래프 캡처 후 재사용으로 지터 감소.
* **MLP 축소**: `actor_units`/`priv_mlp_units` 차원 줄여 실시간성↑.
* **타이머 주기**: 하드웨어·드라이버 지연을 고려해 20 Hz부터 시작, 여유되면 상향.

---

# 13) ROS1/ROS2 로직 일관성 유지

* **관측 → 정규화(unscale) → obs_buf/proprio_hist 업데이트 → 모델 추론 → 액션 스케일·클리핑 → 타깃 갱신 → 명령 전송 → 다음 관측**의 파이프라인은 동일.
* 차이는 **조인트 순서 변환(ROS1↔ROS2)** 과 **토픽 인터페이스**뿐.

---

## 요약

* **정확한 제어 주기**: ROS2 Timer로 전환, 블로킹 제거, 논블로킹 관측 + last-good 재사용.
* **안정성**: 디바이스 일관성, 겹침 대입 수정, 안전 종료 순서 적용.
* **분석 가능성**: `/position_gap`에 타임스탬프/이름 포함 퍼블리시.
* **성능**: inference_mode, 최소화된 `.clone()`, 필요 시 FP16·CUDA Graph로 확장 가능.

원하면 지금 상태의 **최종 통합본**(한 파일) 다시 정리해서 드릴게.
