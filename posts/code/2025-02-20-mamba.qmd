---
draft: true
title: "👩‍💻Mamba Package Manager"
toc: true
date: "2025-02-20"
description: Conda를 떠나 Mamba 톺아보기
categories: [mamba, code]
execute:
  freeze: auto
image: https://mamba.readthedocs.io/en/latest/_static/logo.png
---


# Introduction

What is Mamba?

<center>
<img src="https://mamba.readthedocs.io/en/latest/_static/logo.png" width="60%" />
</center>

# Key Feature

Speed… The main motivation for starting Mamba was to solve the performance issues of conda, both in terms of speed and memory usage.

Conda's poor performance is particularly striking in the case of large software repositories (such as conda-forge) where the entire repository index is parsed using the standard Python JSON parser. Tens of thousands of Python objects are created (as many as there are objects in the JSON index file) and processed before being input in the SAT solver.
On the other hand, Mamba makes use of openSUSE's libsolv dependency resolver, bypassing most of that processing to resolve dependencies.

# Examples

# Build Issue

- error
```shell
Error while loading conda entry point: conda-libmamba-solver (libarchive.so.19: cannot open shared object file: No such file or directory)
```

- solution
```shell
$ conda install --solver=classic conda-forge::conda-libmamba-solver conda-forge::libmamba conda-forge::libmambapy conda-forge::libarchive
```

### Reference

- https://github.com/mamba-org/mamba
- https://mamba.readthedocs.io/en/latest/
- https://stackoverflow.com/questions/77617946/solve-conda-libmamba-solver-libarchive-so-19-error-after-updating-conda-to-23

---

아래에서는 **conda**, **mamba**, **pip**의 차이점과 각각의 특징을 비교하고, 환경 설정을 저장하거나 재현할 때 “유연성”에서 “엄격함(Strictness)”으로 나열하는 방법들을 설명하겠습니다.

---

## 1. Conda, Mamba, Pip 비교

### **Conda**
- **특징**:
  - Python뿐 아니라 C/C++ 라이브러리 등 다양한 언어와 바이너리 패키지를 관리할 수 있는 범용 패키지 관리자입니다.
  - 환경 생성, 패키지 설치, 의존성 해결 등에서 강력하며, 채널 정보를 이용해 다양한 소스에서 패키지를 제공합니다.
- **장점**:
  - 다양한 플랫폼과 언어를 지원합니다.
  - 환경을 격리하여 관리할 수 있어 재현성이 높습니다.
  - YAML 파일 등으로 환경 전체를 내보내고 복원할 수 있습니다.
- **단점**:
  - 복잡한 환경에서는 의존성 해결 속도가 다소 느릴 수 있습니다.

---

### **Mamba**
- **특징**:
  - conda와 거의 동일한 명령어와 환경 설정을 사용하지만, 내부적으로 C++ 및 libsolv 라이브러리를 활용하여 의존성 해결 및 설치 속도를 대폭 향상시킵니다.
- **장점**:
  - conda보다 훨씬 빠른 설치 및 의존성 해결 속도.
  - conda와 완벽하게 호환되므로 기존 conda 환경 설정 파일(YAML) 등 그대로 사용할 수 있습니다.
- **단점**:
  - 상대적으로 최근에 등장하여 모든 상황에서 완벽한 안정성을 보장하지 않을 수 있습니다.
  - conda의 일부 고급 기능이나 특정 상황에서는 미세한 차이가 있을 수 있습니다.

---

### **Pip**
- **특징**:
  - Python 패키지 관리 도구로, PyPI에 등록된 순수 Python 패키지 중심의 설치 및 관리에 특화되어 있습니다.
- **장점**:
  - Python 생태계에서 가장 널리 사용되며, 설치 속도가 빠르고 사용법이 간단합니다.
  - requirements.txt 파일을 이용해 의존성을 관리할 수 있습니다.
- **단점**:
  - Python 이외의 바이너리 패키지나 시스템 의존성은 관리하지 못합니다.
  - conda에서 관리하는 환경과는 별도로 관리되기 때문에, conda 환경 내에서 pip로 설치한 패키지와 conda 패키지 간의 충돌이 발생할 수 있습니다.
  - 의존성 해결에서 conda보다 덜 엄격하여, 재현성에 있어서 한계가 있을 수 있습니다.

---

## 2. 환경 설정 저장 방법 – 유연성에서 엄격함(Strictness) 순

환경 재현을 위한 설정 파일은 “유연성(flexibility)”과 “엄격함(strictness)”이라는 두 관점으로 볼 수 있습니다.
- **유연한 방법**: 기본적으로 사용자가 명시적으로 설치한 패키지 목록만을 기록하여, 최신 버전이 설치되거나 약간의 변화가 있을 수 있으나, 개발 시 빠른 환경 구성이 가능합니다.
- **엄격한 방법**: 설치된 패키지의 정확한 버전, 빌드, 의존성까지 모두 기록하여, 아주 동일한 환경을 재현하는 데 중점을 둡니다.

아래에 유연한 방법부터 가장 엄격한 방법까지 나열해 보겠습니다.

### **(1) Conda 환경 내보내기 – from-history 옵션 (가장 유연)**
- **명령어**:
  ```bash
  conda env export --from-history > environment.yml
  ```
- **특징**:
  - 사용자가 직접 설치한(명시적으로 요청한) 패키지만 기록합니다.
  - 이후 환경을 생성할 때 최신 버전의 의존성을 받아들여 유연하게 환경을 구성할 수 있습니다.
- **장점**:
  - 환경 파일이 간결해지며, 불필요한 의존성이 배제됩니다.
- **단점**:
  - 동일한 환경을 완벽하게 재현하기 어렵습니다.

---

### **(2) Conda 환경 내보내기 – 전체 내보내기**
- **명령어**:
  ```bash
  conda env export > environment.yml
  ```
- **특징**:
  - 환경에 설치된 모든 패키지(의존성 포함)와 채널 정보까지 모두 기록합니다.
- **장점**:
  - 환경을 보다 완벽하게 재현할 수 있습니다.
- **단점**:
  - 기록된 파일이 복잡해지고, 불필요한 패키지까지 포함될 수 있어 약간의 오버헤드가 있습니다.

---

### **(3) Pip Freeze / Requirements 파일 (유연 → 약간 엄격)**
- **명령어**:
  ```bash
  pip freeze > requirements.txt
  ```
- **특징**:
  - pip로 설치한 모든 패키지와 버전을 기록합니다.
- **장점**:
  - 텍스트 파일로 관리가 용이하며, Python 프로젝트에서 널리 사용됩니다.
- **단점**:
  - conda 환경의 전체 재현(예, 시스템 라이브러리, conda 패키지)은 어렵습니다.
  - 패키지 간의 의존성 관계가 단순 목록으로만 기록되어, 환경 구성에 따라 약간의 차이가 발생할 수 있습니다.

---

### **(4) Conda 명시적(Explicit) 목록 – 가장 엄격**
- **명령어**:
  ```bash
  conda list --explicit > spec-file.txt
  ```
- **특징**:
  - 현재 환경의 패키지들을 URL, 빌드 번호 등까지 포함해 명시적으로 기록합니다.
- **장점**:
  - 정확히 동일한 패키지와 빌드 번호로 환경을 재현할 수 있어, 재현성이 극대화됩니다.
- **단점**:
  - 시간이 지나거나 채널의 URL이 변경되면 복원에 문제가 생길 수 있습니다.
  - 파일이 다소 읽기 어려우며, 관리 및 유지보수가 번거로울 수 있습니다.

---

### **추가 방법: Conda Pack**
- **도구**:
  ```bash
  conda-pack
  ```
- **특징**:
  - 현재 conda 환경 전체를 tarball 형태로 압축하여, 그대로 다른 시스템에 배포할 수 있습니다.
- **장점**:
  - 환경 전체를 “포장(pack)”하여 재현성이 매우 높습니다.
- **단점**:
  - 환경을 압축 파일에서 풀어야 하며, 경로 문제나 OS 차이로 인한 이슈가 발생할 수 있습니다.
  - 일반적인 YAML 기반 환경 복원보다 사용법이 번거로울 수 있습니다.

---

## 결론

- **패키지 관리 도구 비교**:
  - **Conda**: 범용 패키지 관리 및 환경 격리에 강하며, YAML 파일로 환경을 저장하는 등 재현성이 높습니다. 다만, 의존성 해결 속도가 느릴 수 있습니다.
  - **Mamba**: conda와 동일한 인터페이스를 사용하면서도 빠른 속도로 대체할 수 있는 도구입니다. 복잡한 환경에서 특히 유리합니다.
  - **Pip**: Python 전용 패키지 관리 도구로, 간단하고 빠르지만 conda가 제공하는 시스템 라이브러리나 바이너리 패키지는 다루지 못합니다.

- **환경 설정 저장 방법 (유연성 → 엄격함)**:
  1. **conda env export --from-history**: 가장 유연하여 사용자가 지정한 패키지만 기록.
  2. **conda env export (전체)**: 전체 패키지와 채널 정보를 포함하여 재현성을 높임.
  3. **pip freeze / requirements.txt**: Python 패키지 중심으로 관리, 재현성은 환경에 따라 약간 달라질 수 있음.
  4. **conda list --explicit**: URL과 빌드 정보까지 기록해, 가장 엄격하고 동일한 환경을 재현할 수 있음.
  - 추가로, **conda-pack**은 이미 구성된 환경을 그대로 묶어 배포하는 방법으로, 재현성은 높지만 사용 및 배포 방식이 다소 번거로울 수 있습니다.

상황에 따라 유연하게 환경을 구성할지, 아니면 엄격하게 동일한 환경을 재현할지를 결정하여 위 방법들을 적절히 선택하면 됩니다.


---

아래는 **패키지 관리 도구(Conda, Mamba, Pip)**와 **환경 설정 저장 방법**을 유연성에서 엄격함까지 정리한 표입니다.

---

### 1. 패키지 관리 도구 비교

| 도구   | 특징 및 설명                                                   | 장점                                                      | 단점                                                     |
|--------|----------------------------------------------------------------|-----------------------------------------------------------|----------------------------------------------------------|
| **Conda**  | - Python뿐 아니라 다양한 바이너리 패키지 및 언어 지원<br>- 환경 생성, 의존성 관리, 채널 기반 설치 지원 | - 다양한 플랫폼 및 언어 지원<br>- 환경 격리와 재현성이 뛰어남   | - 복잡한 환경에서는 의존성 해결 속도가 느릴 수 있음         |
| **Mamba**  | - Conda와 동일한 인터페이스 사용<br>- C++ 기반으로 빠른 의존성 해결 및 설치 제공 | - Conda보다 훨씬 빠른 설치 및 의존성 해결<br>- Conda와 완벽 호환 | - 일부 고급 기능이나 특정 상황에서 미세한 차이가 있을 수 있음  |
| **Pip**    | - Python 전용 패키지 관리자<br>- PyPI 기반 패키지 설치에 최적화              | - 사용법이 간단하고 속도가 빠름<br>- requirements.txt로 의존성 관리 용이 | - Python 이외의 바이너리 패키지 및 시스템 의존성은 관리하지 못함<br>- Conda 환경과 혼용 시 충돌 위험 존재 |

---

### 2. 환경 설정 저장 방법 (유연성 → 엄격함)

| 순서  | 저장 방법 및 명령어                                | 특징 및 설명                                                     | 장점                                                      | 단점                                                     |
|-------|--------------------------------------------------|-----------------------------------------------------------------|-----------------------------------------------------------|----------------------------------------------------------|
| **1** | `conda env export --from-history > environment.yml` | - 사용자가 직접 설치한(명시한) 패키지만 기록<br>- 최신 의존성으로 유연하게 구성 | - 파일이 간결하여 관리하기 쉬움<br>- 개발 중 빠른 환경 구성 가능  | - 완전히 동일한 환경 재현은 어려울 수 있음                |
| **2** | `conda env export > environment.yml`             | - 설치된 모든 패키지, 의존성, 채널 정보를 포함                   | - 보다 완벽하게 환경을 재현할 수 있음                        | - 불필요한 의존성까지 포함되어 파일이 복잡해질 수 있음       |
| **3** | `pip freeze > requirements.txt`                  | - pip로 설치된 모든 Python 패키지와 버전을 기록                   | - 텍스트 파일로 관리가 용이하고, Python 프로젝트에 널리 사용됨  | - Conda 패키지나 시스템 의존성은 포함되지 않아 재현성에 한계 있음 |
| **4** | `conda list --explicit > spec-file.txt`          | - URL, 빌드 번호 등까지 포함해 명시적으로 모든 패키지를 기록         | - 정확히 동일한 패키지와 빌드를 재현할 수 있어 재현성이 극대화됨  | - 시간이 지나 채널 URL 변경 등으로 복원에 문제가 발생할 수 있음 |

> **추가 옵션**:
> **conda-pack** – 현재 환경을 tarball 형태로 압축하여 배포할 수 있습니다.
> - **장점**: 환경 전체를 그대로 옮길 수 있어 재현성이 매우 높음
> - **단점**: OS나 경로 차이로 인한 이슈 발생 가능, 일반 YAML 방식보다 사용법이 다소 번거로움

---

이 표를 참고하여, 필요에 따라 패키지 관리 도구와 환경 재현 방법을 선택하시면 됩니다.
