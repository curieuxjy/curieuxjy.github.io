---
draft: true
title: "ğŸ“ROS2 - hardware interface"
toc: true
date: "2024-11-25"
description: C++ study 001
categories: [study, c++, 2024]
format:
  html:
    code-fold: true
    code-summary: "Show the code"
---

# ì „ì²´ ì½”ë“œ

```{.cpp filename="system_interface.hpp" }
// Copyright 2020 - 2021 ros2_control Development Team

#ifndef HARDWARE_INTERFACE__SYSTEM_INTERFACE_HPP_
#define HARDWARE_INTERFACE__SYSTEM_INTERFACE_HPP_

#include <limits>
#include <memory>
#include <string>
#include <unordered_map>
#include <utility>
#include <vector>

// í•˜ë“œì›¨ì–´ ì¸í„°í˜ì´ìŠ¤ì™€ ê´€ë ¨ëœ ì—¬ëŸ¬ í—¤ë” íŒŒì¼ë“¤ì„ í¬í•¨
#include "hardware_interface/component_parser.hpp"
#include "hardware_interface/handle.hpp"
#include "hardware_interface/hardware_info.hpp"
#include "hardware_interface/types/hardware_interface_return_values.hpp"
#include "hardware_interface/types/hardware_interface_type_values.hpp"
#include "hardware_interface/types/lifecycle_state_names.hpp"
#include "lifecycle_msgs/msg/state.hpp"
#include "rclcpp/duration.hpp"
#include "rclcpp/logger.hpp"
#include "rclcpp/logging.hpp"
#include "rclcpp/node_interfaces/node_clock_interface.hpp"
#include "rclcpp/time.hpp"
#include "rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp"
#include "rclcpp_lifecycle/state.hpp"

namespace hardware_interface
{
// ë³µì¡í•œ ì‹œìŠ¤í…œì„ ros2_controlì— í†µí•©í•  ë•Œ êµ¬í˜„í•´ì•¼ í•˜ëŠ” ê°€ìƒ í´ë˜ìŠ¤
/**
 * ì´ í´ë˜ìŠ¤ëŠ” ë‹¤ê´€ì ˆ ë¡œë´‡ì´ë‚˜ ì„¼ì„œë¥¼ í¬í•¨í•˜ëŠ” ì‹œìŠ¤í…œ ë“±ì„ ros2_controlì— í†µí•©í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.
 * 
 * í•˜ë“œì›¨ì–´ì˜ ìƒíƒœëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë‹¨ê³„ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆìŠµë‹ˆë‹¤:
 *
 * - UNCONFIGURED (on_init, on_cleanup): í•˜ë“œì›¨ì–´ëŠ” ì´ˆê¸°í™”ë˜ì—ˆìœ¼ë‚˜ í†µì‹ ì€ ì‹œì‘ë˜ì§€ ì•Šì€ ìƒíƒœ
 * - INACTIVE (on_configure, on_deactivate): í•˜ë“œì›¨ì–´ê°€ ì„¤ì •ë˜ê³  í†µì‹ ì´ ì‹œì‘ë˜ì—ˆìœ¼ë‚˜ ì›€ì§ì„ ì œì–´ëŠ” ë¹„í™œì„±í™”ëœ ìƒíƒœ
 * - FINALIZED (on_shutdown): í•˜ë“œì›¨ì–´ ì¸í„°í˜ì´ìŠ¤ê°€ ì–¸ë¡œë“œ ë˜ëŠ” íŒŒê´´ë¥¼ ì¤€ë¹„í•˜ëŠ” ìƒíƒœ
 * - ACTIVE (on_activate): í•˜ë“œì›¨ì–´ê°€ í™œì„±í™”ë˜ê³  ì‹¤ì œë¡œ ì›€ì§ì¼ ìˆ˜ ìˆëŠ” ìƒíƒœ
 */

using CallbackReturn = rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn;

class SystemInterface : public rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface
{
public:
  // ìƒì„±ì: ë¼ì´í”„ì‚¬ì´í´ ìƒíƒœì™€ ë¡œê±° ì´ˆê¸°í™”
  SystemInterface()
  : lifecycle_state_(rclcpp_lifecycle::State(
      lifecycle_msgs::msg::State::PRIMARY_STATE_UNKNOWN, lifecycle_state_names::UNKNOWN)),
    system_logger_(rclcpp::get_logger("system_interface"))
  {
  }

  // ë³µì‚¬ ìƒì„±ìë¥¼ ë¹„í™œì„±í™” (ê³ ìœ  ì†Œìœ ê¶Œì„ ê°€ì§€ë¯€ë¡œ ë³µì‚¬ ë¶ˆê°€ëŠ¥)
  SystemInterface(const SystemInterface & other) = delete;

  SystemInterface(SystemInterface && other) = default;

  virtual ~SystemInterface() = default;

  // í•˜ë“œì›¨ì–´ ì¸í„°í˜ì´ìŠ¤ ì´ˆê¸°í™” ë©”ì†Œë“œ
  CallbackReturn init(
    const HardwareInfo & hardware_info, rclcpp::Logger logger,
    rclcpp::node_interfaces::NodeClockInterface::SharedPtr clock_interface)
  {
    clock_interface_ = clock_interface;
    system_logger_ = logger.get_child("hardware_component.system." + hardware_info.name);
    info_ = hardware_info;
    return on_init(hardware_info);
  };

  // í•˜ë“œì›¨ì–´ ì´ˆê¸°í™”ë¥¼ ìœ„í•œ ê°€ìƒ ë©”ì†Œë“œ (í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ êµ¬í˜„)
  virtual CallbackReturn on_init(const HardwareInfo & hardware_info)
  {
    info_ = hardware_info;
    parse_state_interface_descriptions(info_.joints, joint_state_interfaces_);
    parse_state_interface_descriptions(info_.sensors, sensor_state_interfaces_);
    parse_state_interface_descriptions(info_.gpios, gpio_state_interfaces_);
    parse_command_interface_descriptions(info_.joints, joint_command_interfaces_);
    parse_command_interface_descriptions(info_.gpios, gpio_command_interfaces_);
    return CallbackReturn::SUCCESS;
  };

  // ìƒíƒœ ì¸í„°í˜ì´ìŠ¤ ë‚´ë³´ë‚´ê¸°
  [[deprecated(
    "Replaced by vector<StateInterface::ConstSharedPtr> on_export_state_interfaces() method. "
    "Exporting is handled "
    "by the Framework.")]] virtual std::vector<StateInterface>
  export_state_interfaces()
  {
    return {};
  }

  // URDF íŒŒì¼ì— ì •ì˜ë˜ì§€ ì•Šì€ ì‚¬ìš©ì ì •ì˜ ìƒíƒœ ì¸í„°í˜ì´ìŠ¤ë¥¼ ë‚´ë³´ë‚´ê¸° ìœ„í•œ ë©”ì†Œë“œ
  virtual std::vector<hardware_interface::InterfaceDescription>
  export_unlisted_state_interface_descriptions()
  {
    return {};
  }

  // ìƒíƒœ ì¸í„°í˜ì´ìŠ¤ë¥¼ ê¸°ë³¸ìœ¼ë¡œ ë‚´ë³´ë‚´ëŠ” ë©”ì†Œë“œ
  std::vector<StateInterface::ConstSharedPtr> on_export_state_interfaces()
  {
    // ì‚¬ìš©ì ì •ì˜ ìƒíƒœ ì¸í„°í˜ì´ìŠ¤ ê°€ì ¸ì˜¤ê¸°
    std::vector<hardware_interface::InterfaceDescription> unlisted_interface_descriptions =
      export_unlisted_state_interface_descriptions();

    // ìƒíƒœ ì¸í„°í˜ì´ìŠ¤ë“¤ì„ ë²¡í„°ì— ì €ì¥ í›„ ë°˜í™˜
    std::vector<StateInterface::ConstSharedPtr> state_interfaces;
    state_interfaces.reserve(
      unlisted_interface_descriptions.size() + joint_state_interfaces_.size() +
      sensor_state_interfaces_.size() + gpio_state_interfaces_.size());

    for (const auto & description : unlisted_interface_descriptions)
    {
      auto name = description.get_name();
      unlisted_state_interfaces_.insert(std::make_pair(name, description));
      auto state_interface = std::make_shared<StateInterface>(description);
      system_states_.insert(std::make_pair(name, state_interface));
      unlisted_states_.push_back(state_interface);
      state_interfaces.push_back(std::const_pointer_cast<const StateInterface>(state_interface));
    }

    for (const auto & [name, descr] : joint_state_interfaces_)
    {
      auto state_interface = std::make_shared<StateInterface>(descr);
      system_states_.insert(std::make_pair(name, state_interface));
      joint_states_.push_back(state_interface);
      state_interfaces.push_back(std::const_pointer_cast<const StateInterface>(state_interface));
    }

    // ì„¼ì„œ ë° GPIO ìƒíƒœ ì¸í„°í˜ì´ìŠ¤ ì¶”ê°€
    for (const auto & [name, descr] : sensor_state_interfaces_)
    {
      auto state_interface = std::make_shared<StateInterface>(descr);
      system_states_.insert(std::make_pair(name, state_interface));
      sensor_states_.push_back(state_interface);
      state_interfaces.push_back(std::const_pointer_cast<const StateInterface>(state_interface));
    }

    for (const auto & [name, descr] : gpio_state_interfaces_)
    {
      auto state_interface = std::make_shared<StateInterface>(descr);
      system_states_.insert(std::make_pair(name, state_interface));
      gpio_states_.push_back(state_interface);
      state_interfaces.push_back(std::const_pointer_cast<const StateInterface>(state_interface));
    }

    return state_interfaces;
  }

  // ëª…ë ¹ ì¸í„°í˜ì´ìŠ¤ë¥¼ ë‚´ë³´ë‚´ê¸° ìœ„í•œ ë©”ì†Œë“œ
  [[deprecated(
    "Replaced by vector<CommandInterface::SharedPtr> on_export_command_interfaces() method. "
    "Exporting is "
    "handled "
    "by the Framework.")]] virtual std::vector<CommandInterface>
  export_command_interfaces()
  {
    return {};
  }

  virtual std::vector<hardware_interface::InterfaceDescription>
  export_unlisted_command_interface_descriptions()
  {
    return {};
  }

  std::vector<CommandInterface::SharedPtr> on_export_command_interfaces()
  {
    std::vector<hardware_interface::InterfaceDescription> unlisted_interface_descriptions =
      export_unlisted_command_interface_descriptions();

    std::vector<CommandInterface::SharedPtr> command_interfaces;
    command_interfaces.reserve(
      unlisted_interface_descriptions.size() + joint_command_interfaces_.size() +
      gpio_command_interfaces_.size());

    for (const auto & description : unlisted_interface_descriptions)
    {
      auto name = description.get_name();
      unlisted_command_interfaces_.insert(std::make_pair(name, description));
      auto command_interface = std::make_shared<CommandInterface>(description);
      system_commands_.insert(std::make_pair(name, command_interface));
      unlisted_commands_.push_back(command_interface);
      command_interfaces.push_back(command_interface);
    }

    for (const auto & [name, descr] : joint_command_interfaces_)
    {
      auto command_interface = std::make_shared<CommandInterface>(descr);
      system_commands_.insert(std::make_pair(name, command_interface));
      joint_commands_.push_back(command_interface);
      command_interfaces.push_back(command_interface);
    }

    for (const auto & [name, descr] : gpio_command_interfaces_)
    {
      auto command_interface = std::make_shared<CommandInterface>(descr);
      system_commands_.insert(std::make_pair(name, command_interface));
      gpio_commands_.push_back(command_interface);
      command_interfaces.push_back(command_interface);
    }
    return command_interfaces;
  }

  // ëª…ë ¹ ëª¨ë“œ ì „í™˜ ì¤€ë¹„ë¥¼ ìœ„í•œ ë©”ì†Œë“œ (ë¹„ì‹¤ì‹œê°„ ì‹¤í–‰)
  virtual return_type prepare_command_mode_switch(
    const std::vector<std::string> & /*start_interfaces*/,
    const std::vector<std::string> & /*stop_interfaces*/)
  {
    return return_type::OK;
  }

  // ëª…ë ¹ ëª¨ë“œ ì „í™˜ì„ ìˆ˜í–‰í•˜ëŠ” ë©”ì†Œë“œ (ì‹¤ì‹œê°„ ì‹¤í–‰)
  virtual return_type perform_command_mode_switch(
    const std::vector<std::string> & /*start_interfaces*/,
    const std::vector<std::string> & /*stop_interfaces*/)
  {
    return return_type::OK;
  }

  // í˜„ì¬ ìƒíƒœ ê°’ì„ ì½ì–´ì˜¤ëŠ” ë©”ì†Œë“œ
  virtual return_type read(const rclcpp::Time & time, const rclcpp::Duration & period) = 0;

  // í˜„ì¬ ëª…ë ¹ ê°’ì„ ì•¡ì¶”ì—ì´í„°ì— ì“°ëŠ” ë©”ì†Œë“œ
  virtual return_type write(const rclcpp::Time & time, const rclcpp::Duration & period) = 0;

  // í•˜ë“œì›¨ì–´ ì´ë¦„ì„ ë°˜í™˜
  virtual std::string get_name() const { return info_.name; }

  // í•˜ë“œì›¨ì–´ ê·¸ë£¹ ì´ë¦„ì„ ë°˜í™˜
  virtual std::string get_group_name() const { return info_.group; }

  // í•˜ë“œì›¨ì–´ì˜ ë¼ì´í”„ì‚¬ì´í´ ìƒíƒœ ë°˜í™˜
  const rclcpp_lifecycle::State & get_lifecycle_state() const { return lifecycle_state_; }

  // í•˜ë“œì›¨ì–´ì˜ ë¼ì´í”„ì‚¬ì´í´ ìƒíƒœ ì„¤ì •
  void set_lifecycle_state(const rclcpp_lifecycle::State & new_state)
  {
    lifecycle_state_ = new_state;
  }

  // íŠ¹ì • ì¸í„°í˜ì´ìŠ¤ ìƒíƒœ ê°’ì„ ì„¤ì •
  void set_state(const std::string & interface_name, const double & value)
  {
    system_states_.at(interface_name)->set_value(value);
  }

  // íŠ¹ì • ì¸í„°í˜ì´ìŠ¤ ìƒíƒœ ê°’ì„ ë°˜í™˜
  double get_state(const std::string & interface_name) const
  {
    return system_states_.at(interface_name)->get_value();
  }

  // íŠ¹ì • ëª…ë ¹ ê°’ì„ ì„¤ì •
  void set_command(const std::string & interface_name, const double & value)
  {
    system_commands_.at(interface_name)->set_value(value);
  }

  // íŠ¹ì • ëª…ë ¹ ê°’ì„ ë°˜í™˜
  double get_command(const std::string & interface_name) const
  {
    return system_commands_.at(interface_name)->get_value();
  }

  // SystemInterfaceì˜ ë¡œê±° ë°˜í™˜
  rclcpp::Logger get_logger() const { return system_logger_; }

  // SystemInterfaceì˜ ì‹œê³„ ë°˜í™˜
  rclcpp::Clock::SharedPtr get_clock() const { return clock_interface_->get_clock(); }

  // SystemInterfaceì˜ í•˜ë“œì›¨ì–´ ì •ë³´ ë°˜í™˜
  const HardwareInfo & get_hardware_info() const { return info_; }

protected:
  // í•˜ë“œì›¨ì–´ ì •ë³´ êµ¬ì¡°ì²´
  HardwareInfo info_;

  // ìƒíƒœ ì¸í„°í˜ì´ìŠ¤ì™€ ëª…ë ¹ ì¸í„°í˜ì´ìŠ¤ ê´€ë ¨ ì •ë³´ ì €ì¥
  std::unordered_map<std::string, InterfaceDescription> joint_state_interfaces_;
  std::unordered_map<std::string, InterfaceDescription> joint_command_interfaces_;
  std::unordered_map<std::string, InterfaceDescription> sensor_state_interfaces_;
  std::unordered_map<std::string, InterfaceDescription> gpio_state_interfaces_;
  std::unordered_map<std::string, InterfaceDescription> gpio_command_interfaces_;
  std::unordered_map<std::string, InterfaceDescription> unlisted_state_interfaces_;
  std::unordered_map<std::string, InterfaceDescription> unlisted_command_interfaces_;

  // ë¼ì´í”„ì‚¬ì´í´ ìƒíƒœ
  rclcpp_lifecycle::State lifecycle_state_;

  // ëª…ë ¹ ë° ìƒíƒœ ì¸í„°í˜ì´ìŠ¤ì˜ í¬ì¸í„° ì €ì¥
  std::vector<StateInterface::SharedPtr> joint_states_;
  std::vector<CommandInterface::SharedPtr> joint_commands_;
  std::vector<StateInterface::SharedPtr> sensor_states_;
  std::vector<StateInterface::SharedPtr> gpio_states_;
  std::vector<CommandInterface::SharedPtr> gpio_commands_;
  std::vector<StateInterface::SharedPtr> unlisted_states_;
  std::vector<CommandInterface::SharedPtr> unlisted_commands_;

private:
  // ì‹œê³„ ë° ë¡œê±° ê´€ë ¨ ë©¤ë²„ ë³€ìˆ˜
  rclcpp::node_interfaces::NodeClockInterface::SharedPtr clock_interface_;
  rclcpp::Logger system_logger_;

  // ìƒíƒœ ë° ëª…ë ¹ ì¸í„°í˜ì´ìŠ¤ì˜ í¬ì¸í„° ë§µ
  std::unordered_map<std::string, StateInterface::SharedPtr> system_states_;
  std::unordered_map<std::string, CommandInterface::SharedPtr> system_commands_;
};

}  // namespace hardware_interface
#endif  // HARDWARE_INTERFACE__SYSTEM_INTERFACE_HPP_


```

# ì£¼ìš” ì‚¬í•­

ì†ŒìŠ¤ì½”ë“œë¥¼ ì´í•´í•˜ê¸° ìœ„í•œ 10ê°€ì§€ ì‚¬í•­ë“¤ì„ í™•ì¸í•´ë³´ë©° c++ ì½”ë“œë¥¼ ê³µë¶€í•©ë‹ˆë‹¤.

### 1. **ìŠ¤ë§ˆíŠ¸ í¬ì¸í„° ì‚¬ìš© (`std::shared_ptr`, `std::unique_ptr`)**
ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ì¸ `std::shared_ptr`ëŠ” í•˜ë“œì›¨ì–´ ì¸í„°í˜ì´ìŠ¤ì™€ ê´€ë ¨ëœ ìƒíƒœì™€ ëª…ë ¹ ì¸í„°í˜ì´ìŠ¤ë¥¼ ê´€ë¦¬í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.
```cpp
std::vector<StateInterface::ConstSharedPtr> on_export_state_interfaces()
{
  auto state_interface = std::make_shared<StateInterface>(description);
  state_interfaces.push_back(std::const_pointer_cast<const StateInterface>(state_interface));
}
```

### 2. **ë³µì‚¬ ìƒì„±ì ì‚­ì œ (`= delete`)**
ë³µì‚¬ ìƒì„±ìë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì‚­ì œí•˜ì—¬ ê°ì²´ê°€ ë³µì‚¬ë˜ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤.
```cpp
SystemInterface(const SystemInterface & other) = delete;
```

### 3. **ì´ë™ ìƒì„±ì (`= default`)**
ì´ë™ ìƒì„±ìë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •í•˜ì—¬ ê°ì²´ ì´ë™ì„ í—ˆìš©í•˜ì§€ë§Œ ë³µì‚¬ëŠ” ë°©ì§€í•©ë‹ˆë‹¤.
```cpp
SystemInterface(SystemInterface && other) = default;
```

### 4. **`virtual` í‚¤ì›Œë“œì™€ ê°€ìƒ í•¨ìˆ˜**
`virtual` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ ì¬ì •ì˜ ê°€ëŠ¥í•œ ë©”ì„œë“œë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
```cpp
virtual CallbackReturn on_init(const HardwareInfo & hardware_info)
{
  // ì´ˆê¸°í™” ë¡œì§
}
```
ë˜í•œ ê°€ìƒ ì†Œë©¸ìë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒì†ëœ í´ë˜ìŠ¤ì—ì„œë„ ì˜¬ë°”ë¥´ê²Œ ì†Œë©¸ìë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
```cpp
virtual ~SystemInterface() = default;
```

### 5. **`[[deprecated]]` ì†ì„±**
íŠ¹ì • ë©”ì„œë“œë¥¼ ë” ì´ìƒ ê¶Œì¥ë˜ì§€ ì•ŠìŒì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ `[[deprecated]]` ì†ì„±ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
```cpp
[[deprecated(
  "Replaced by vector<StateInterface::ConstSharedPtr> on_export_state_interfaces() method. "
  "Exporting is handled by the Framework.")]] 
virtual std::vector<StateInterface> export_state_interfaces()
{
  return {};
}
```

### 6. **C++11ì˜ `override` í‚¤ì›Œë“œ**
í•˜ìœ„ í´ë˜ìŠ¤ì—ì„œ ê¸°ë³¸ í´ë˜ìŠ¤ì˜ ê°€ìƒ í•¨ìˆ˜ë¥¼ ì¬ì •ì˜í•  ë•Œ `override` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ì¬ì •ì˜ë¥¼ ëª…í™•íˆ í•©ë‹ˆë‹¤. (ì´ ì½”ë“œì—ì„œëŠ” `override`ëŠ” ì—†ì§€ë§Œ ì´ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ì€ ë°©ë²•ì…ë‹ˆë‹¤.)

```cpp
virtual CallbackReturn read(const rclcpp::Time & time, const rclcpp::Duration & period) override;
```

### 7. **`const`ì™€ `&`ì˜ ì‚¬ìš©**
ê°ì²´ì˜ ë©¤ë²„ë¥¼ ë³€ê²½í•˜ì§€ ì•Šë„ë¡ ë³´ì¥í•˜ê¸° ìœ„í•´ `const`ë¥¼ ì‚¬ìš©í•˜ê³ , ì°¸ì¡°ë¡œ ì „ë‹¬í•˜ì—¬ ë³µì‚¬ ë¹„ìš©ì„ ì¤„ì…ë‹ˆë‹¤.
```cpp
virtual std::string get_name() const { return info_.name; }

double get_state(const std::string & interface_name) const
{
  return system_states_.at(interface_name)->get_value();
}
```

### 8. **ì–¸ì–´ í™•ì¥ ì†ì„± (`[[nodiscard]]`, `[[deprecated]]` ë“±)**
ì´ ì½”ë“œì—ì„œëŠ” `[[deprecated]]`ë¥¼ ì‚¬ìš©í•˜ì—¬ ë©”ì„œë“œê°€ ë” ì´ìƒ ê¶Œì¥ë˜ì§€ ì•ŠìŒì„ ë‚˜íƒ€ë‚´ê³  ìˆìŠµë‹ˆë‹¤.
```cpp
[[deprecated(
  "Replaced by vector<StateInterface::ConstSharedPtr> on_export_state_interfaces() method. "
  "Exporting is handled by the Framework.")]]
virtual std::vector<StateInterface> export_state_interfaces()
{
  return {};
}
```

### 9. **ë‹¤ì¤‘ ë°˜í™˜ ë°©ì‹ (CallbackReturn)**
`CallbackReturn` íƒ€ì…ì„ ì‚¬ìš©í•˜ì—¬ í•¨ìˆ˜ê°€ ì—¬ëŸ¬ ê°€ì§€ ê²°ê³¼ ìƒíƒœë¥¼ ë°˜í™˜í•˜ë„ë¡ í•©ë‹ˆë‹¤.
```cpp
CallbackReturn init(
  const HardwareInfo & hardware_info, rclcpp::Logger logger,
  rclcpp::node_interfaces::NodeClockInterface::SharedPtr clock_interface)
{
  return CallbackReturn::SUCCESS;
}
```

### 10. **`std::unordered_map`ì˜ ì‚¬ìš©**
ì—¬ëŸ¬ ì¸í„°í˜ì´ìŠ¤ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ê¸° ìœ„í•´ `std::unordered_map`ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
```cpp
std::unordered_map<std::string, InterfaceDescription> joint_state_interfaces_;
std::unordered_map<std::string, CommandInterface::SharedPtr> system_commands_;
```

<!--
### 11. **ì½”ë”© ìŠ¤íƒ€ì¼ íŒ**
ì ‘ê·¼ ì œí•œì(`public`, `protected`, `private`)ë¥¼ ëª…í™•íˆ êµ¬ë¶„í•˜ì—¬ ê° ë ˆë²¨ì˜ ì ‘ê·¼ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
```cpp
public:
  SystemInterface();
  virtual ~SystemInterface();

protected:
  HardwareInfo info_;
  rclcpp_lifecycle::State lifecycle_state_;

private:
  rclcpp::node_interfaces::NodeClockInterface::SharedPtr clock_interface_;
  rclcpp::Logger system_logger_;
```
ë˜í•œ í•¨ìˆ˜ì˜ ì—­í• ê³¼ ë°˜í™˜ ê°’ì„ ì„¤ëª…í•˜ëŠ” ì£¼ì„ì„ ì¶©ë¶„íˆ ì‚¬ìš©í•˜ê³  ìˆìŠµë‹ˆë‹¤.
```cpp
/// í•˜ë“œì›¨ì–´ ì¸í„°í˜ì´ìŠ¤ì˜ ì´ë¦„ì„ ë°˜í™˜í•˜ëŠ” ë©”ì†Œë“œ
/**
 * \return í•˜ë“œì›¨ì–´ì˜ ì´ë¦„ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
 */
virtual std::string get_name() const { return info_.name; }
```

ì´ì™€ ê°™ì€ ì½”ë”© íŒê³¼ C++ì˜ íŠ¹ë³„í•œ ë¬¸ë²•ì„ í™œìš©í•˜ë©´ ì½”ë“œì˜ ì•ˆì „ì„±, ìœ ì§€ë³´ìˆ˜ì„±, ê·¸ë¦¬ê³  ê°€ë…ì„±ì„ í¬ê²Œ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

-->
---

**Reference**

- [Original Code Repository](https://github.com/ros-controls/ros2_control/blob/master/hardware_interface/include/hardware_interface/system_interface.hpp)