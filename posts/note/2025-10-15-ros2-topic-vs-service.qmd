---
title: "📝ROS2 topic VS. service"
toc: true
date: "2025-10-15"
description: topic vs. service
categories: [ros2, topic, service, 2025]
format:
  html:
    code-fold: true
    code-summary: "Show the code"
---


# 요약

간단히 말하면:

* **토픽(Topic)**은 발행/구독(비동기적 스트리밍)에 적합하고, 상태·센서·지속적 명령에 주로 사용합니다.
* **서비스(Service)**는 요청-응답(단발성 RPC)에 적합합니다.
* **액션(Action)**은 장시간 실행되는 작업(목표/피드백/결과/취소)이 필요할 때 쓰는 상위 추상으로, 내부적으로는 토픽+서비스 패턴을 사용합니다.

아래에서 차이와 장단점, 언제 어떤 걸 쓰면 좋은지 실무 관점에서 정리해 드릴게요.

# 핵심 비교 (한눈에)

| 항목        |                                      Topic |                        Service |                              Action |
| --------- | -----------------------------------------: | -----------------------------: | ----------------------------------: |
| 통신방식      |              publish/subscribe (비동기, 스트리밍) |         request/response (RPC) | goal/feedback/result (상태ful, 취소 가능) |
| 사용사례      |      센서 데이터, 상태 브로드캐스트, 지속 명령 (예: cmd_vel) | 파라미터 조회, 단발 명령(예: 초기화), 간단한 쿼리 |      내비게이션 목표, 그립 동작(장시간), 운동 계획 실행 |
| 피드백       |                          없음(별도 토픽으로 구현 가능) |                            응답만 |                       주기적 피드백 제공 가능 |
| 취소/중단     |                                 별도 메커니즘 필요 |            없음(요청 단위라 중단 개념 없음) |                         표준 취소/중단 제공 |
| 다중구독/다중발행 |                         자연스럽게 지원(1:N, N:1) |                  클라이언트-서버(1:1) |               클라이언트-서버(여러 클라이언트 가능) |
| QoS 제어    | 상세 QoS 설정 가능 (reliable, transient_local 등) |            QoS 사용 가능하나 일반적은 낮음 |         내부적으로 토픽/서비스 사용 → QoS 영향 받음 |
| 구현 복잡도    |                                         낮음 |                             낮음 |             약간 높음 (action 인터페이스 필요) |

# 언제 무엇을 써야 할까 (실무 가이드)

1. **지속적인 스트리밍(실시간 센서, 주기적 상태, 로우레벨 제어)**
   → **Topic**. 예: LiDAR, 카메라, IMU, 로봇의 현재 조인트 상태, `cmd_vel` 같은 주기적 velocity 명령.
   이유: 저지연, 다수 구독자/발행자 OK, QoS로 내구성/신뢰성 조정 가능.

2. **단발성 요청과 응답(즉각적인 처리)**
   → **Service**. 예: 맵 초기화, 로그 다운로드, 파라미터 조회/설정, 간단한 계산 요청.
   이유: 요청-응답 형태가 자연스럽고 구현이 간단. 동기 호출이 기본이라 로직 단순화 가능.

3. **목표 기반의 장시간 작업(중간 피드백 필요, 취소 가능)**
   → **Action**. 예: 이동 로봇의 목표 지점, 팔의 복잡한 포즈 트래젝토리, 그립/조작 시퀀스.
   이유: 목표 전송 → 주기적 피드백(진행률) → 결과/상태/취소 흐름을 표준화함.

# 장단점 상세

## Topic 장점

* 단순하고 경량. 낮은 오버헤드.
* 다중 수신자/발행자에 적합.
* QoS로 전송 보장/일시적 구독자 복구(transient_local) 등 제어 가능.

## Topic 단점

* 요청-응답, 피드백, 취소 같은 패턴을 직접 구현해야 함(복잡해질 수 있음).
* 상태 추적(logic 상태 기계)이 필요하면 토픽만으로는 관리가 번거로움.

## Service 장점

* 동기적(또는 비동기 Future)으로 간단한 RPC 패턴 구현 쉬움.
* 호출과 응답이 명확해 오류 처리/타임아웃 관리가 편함.

## Service 단점

* 긴 시간 작업에는 부적합(블로킹 위험, 클라이언트 구현 복잡).
* 피드백 또는 중간 상태 전송 표준화 없음.

## Action 장점

* 장시간 작업에 적합: 목표, 주기적 피드백, 최종 결과, 취소를 표준화.
* 클라이언트가 상태(accepted, executing, canceled, succeeded 등)를 관찰 가능.
* 내장된 취소 메커니즘과 결과 코드로 안정적인 제어 흐름 제공.

## Action 단점

* 토픽/서비스보다 구현 복잡도 ↑ (액션 정의 파일, 서버/클라이언트 보일러플레이트).
* 오버헤드가 있어서 단순/초저지연 메시지에는 불필요할 수 있음.
* QoS에 주의: 액션 내부 통신의 QoS 설정 필요하면 복잡해짐.

# 기술적 고려사항 (성능·신뢰성·QoS 등)

* **지연(latency)**: 토픽은 설계에 따라 매우 낮은 지연을 줄 수 있음. 서비스/액션은 RPC 흐름/상태 관리 때문에 토픽보다 약간의 오버헤드 존재.
* **QoS**: ROS2에서는 토픽·서비스·액션 모두 QoS를 설정 가능(특히 토픽). 센서 같은 중요한 데이터는 `reliable` 또는 `transient_local` 고려.
* **스케일링**: 다수의 구독자가 필요하면 토픽이 자연스럽다. 서비스는 1:1 패턴이기 때문에 동시 요청 처리를 고려해야 함(서버에서 스레드/큐 처리).
* **에러 처리**: 액션은 결과 상태로 실패/취소/타임아웃을 표준화해서 보낼 수 있어 에러 처리 구조화에 유리.

# 실무 디자인 패턴 & 권장

* 센서 → 토픽
* 로우레벨 제어 명령(주기적) → 토픽 (`cmd_vel`, `joint_commands` 등)
* 단발성 명령(설정, 질의) → 서비스
* 목표기반 장시간 작업 → 액션
* **혼합 사용 권장**: 예) 로컬 컨트롤러는 토픽으로 주기적 제어, 상위 제어기는 액션으로 목표 전송(진행 피드백 수신), 필요시 서비스로 설정/쿼리.
* **상태 전파**: 시스템 상태는 토픽으로 브로드캐스트 (예: `/robot/state`) → 여러 모듈이 구독.

# 작은 예시 (개념)

* Topic: 퍼블리셔 `geometry_msgs/Twist` 로 10Hz로 속도 발행 → 로컬 컨트롤러가 구독해 모터 제어.
* Service: `/reset_odometry` 호출 → 서버가 즉시 odom reset 후 성공 응답 반환.
* Action: `/navigate_to` goal(목표 좌표) 전송 → 주기적 피드백(거리/진행률) 수신 → 도중에 취소 가능 → 완료 시 result(성공/실패 코드).

# 결정 트리(빠르게 선택하기)

1. 작업이 **지속적/스트리밍**인가? → Topic
2. 작업이 **단발성 요청-응답**인가? → Service
3. 작업이 **목표 기반/장시간/피드백·취소 필요**인가? → Action

# 마무리 (권장)

대부분 시스템은 **토픽 + 액션 + 서비스를 혼합**해서 씁니다. 토픽은 데이터 파이프라인(센서/상태), 서비스는 구성·설정·쿼리, 액션은 복잡한 목표 실행 흐름을 맡기면 아키텍처가 깔끔해집니다.
원하시면 지금 만드시는 로봇의 구체적 시나리오(예: 주행+팔 조작+비전)는 말해주시면 어떤 토픽/서비스/액션으로 쪼개면 좋은지 구체적으로 설계해 드릴게요.
