<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-07-17">
<meta name="description" content="Parallelized Collision-Free Minimum-Jerk Robot Motion Generation">

<title>📃CuRobo 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-bc185b5c5bdbcb35c2eb49d8a876ef70.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-5a614c35f1f90bfd0a5b2992298a8538.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review"><span class="header-section-number">1</span> Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review"><span class="header-section-number">2</span> Detail Review</a>
  <ul class="collapse">
  <li><a href="#소개-gpu로-가속한-차세대-로봇-모션-플래너" id="toc-소개-gpu로-가속한-차세대-로봇-모션-플래너" class="nav-link" data-scroll-target="#소개-gpu로-가속한-차세대-로봇-모션-플래너"><span class="header-section-number">2.1</span> 소개: GPU로 가속한 차세대 로봇 모션 플래너</a></li>
  <li><a href="#curobo의-핵심-아이디어와-구조" id="toc-curobo의-핵심-아이디어와-구조" class="nav-link" data-scroll-target="#curobo의-핵심-아이디어와-구조"><span class="header-section-number">2.2</span> cuRobo의 핵심 아이디어와 구조</a></li>
  <li><a href="#gpu-병렬화-전략과-최적화-기법" id="toc-gpu-병렬화-전략과-최적화-기법" class="nav-link" data-scroll-target="#gpu-병렬화-전략과-최적화-기법"><span class="header-section-number">2.3</span> GPU 병렬화 전략과 최적화 기법</a></li>
  <li><a href="#성능-평가-속도-성공률-그리고-동작-안정성" id="toc-성능-평가-속도-성공률-그리고-동작-안정성" class="nav-link" data-scroll-target="#성능-평가-속도-성공률-그리고-동작-안정성"><span class="header-section-number">2.4</span> 성능 평가: 속도, 성공률 그리고 동작 안정성</a></li>
  <li><a href="#구현-난이도와-오픈소스-활용" id="toc-구현-난이도와-오픈소스-활용" class="nav-link" data-scroll-target="#구현-난이도와-오픈소스-활용"><span class="header-section-number">2.5</span> 구현 난이도와 오픈소스 활용</a></li>
  <li><a href="#기존-모션-생성-기법과의-비교" id="toc-기존-모션-생성-기법과의-비교" class="nav-link" data-scroll-target="#기존-모션-생성-기법과의-비교"><span class="header-section-number">2.6</span> 기존 모션 생성 기법과의 비교</a></li>
  <li><a href="#주요-실험-결과-및-활용-시나리오" id="toc-주요-실험-결과-및-활용-시나리오" class="nav-link" data-scroll-target="#주요-실험-결과-및-활용-시나리오"><span class="header-section-number">2.7</span> 주요 실험 결과 및 활용 시나리오</a></li>
  <li><a href="#결론-curobo의-장점과-한계-향후-발전-방향" id="toc-결론-curobo의-장점과-한계-향후-발전-방향" class="nav-link" data-scroll-target="#결론-curobo의-장점과-한계-향후-발전-방향"><span class="header-section-number">2.8</span> 결론: cuRobo의 장점과 한계, 향후 발전 방향</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃CuRobo 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">sim2real</div>
    <div class="quarto-category">adaptive</div>
    <div class="quarto-category">rl</div>
    <div class="quarto-category">hand</div>
  </div>
  </div>

<div>
  <div class="description">
    Parallelized Collision-Free Minimum-Jerk Robot Motion Generation
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 17, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://arxiv.org/pdf/2310.17274">Paper Link</a></li>
<li><a href="https://github.com/NVlabs/curobo">Github Link</a></li>
<li><a href="https://curobo.org/">Documentation Link</a></li>
</ul>
<ol type="1">
<li>📚 본 논문은 GPU 가속을 활용하여 로봇을 위한 충돌 없는 최소 저크(minimum-jerk) 모션 생성을 병렬 최적화 문제로 공식화하고, 이를 해결하는 <code>cuRobo</code> 라이브러리를 제안합니다.</li>
<li>💡 <code>cuRobo</code>는 고성능 CUDA 커널 기반의 운동학 및 Signed Distance 함수, 병렬 L-BFGS 및 파티클 기반 최적화, 그리고 병렬 기하학적 플래너를 통합하여 전체 모션 생성 파이프라인을 가속화합니다.</li>
<li>🚀 그 결과, <code>cuRobo</code>는 기존 최신 방법보다 모션 생성에서 평균 60배, 충돌 없는 Inverse Kinematics에서 80배 이상 빨라졌으며, 더 짧은 경로와 낮은 저크(jerk)의 고품질 궤적을 제공하며 실제 로봇 및 저전력 장치에서 성능이 검증되었습니다.</li>
</ol>
<center>
<img src="../../images/2025-07-17-curobo/1.png" width="100%">
<figcaption>
Collision-free motion generation for a manipulator to move from a start configuration to a desired gripper pose
</figcaption>
</center>
<hr>
<section id="brief-review" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Brief Review</h1>
<p>이 논문은 로봇 매니퓰레이터의 충돌 없는 모션 생성(collision-free motion generation) 문제를 전역 모션 최적화(global motion optimization) 문제로 공식화하고, 이를 방대한 GPU 병렬 처리를 활용하여 매우 빠르게 해결하는 방법을 제시합니다. 기존 최첨단(SOTA) 궤적 최적화(trajectory optimization) 방법보다 평균 60배 빠른 속도로 평균 50ms 이내에 모션 생성을 달성하며, NVIDIA Jetson AGX Orin과 같은 저전력 장치에서도 탁월한 성능을 보입니다.</p>
<p><strong>핵심 기여:</strong></p>
<ul>
<li><strong>고성능 Kinematics 및 Signed Distance Kernel:</strong> 로봇 Kinematics 및 Signed Distance 계산을 위한 고성능 CUDA Kernel을 개발하여 기존 CPU 기반 방식보다 최대 10,000배 빠른 속도를 달성했습니다. 이는 PyTorch에서 미분 가능한 함수로 제공되어 다른 로봇 공학 작업에도 활용될 수 있습니다.</li>
<li><strong>미분 가능한 연속 충돌 검사(Differentiable Continuous Collision Checking):</strong> Swept Collision Check를 위해 점 쿼리 Signed Distance 함수와 그래디언트 계산을 위한 가장 가까운 점(closest point)만 요구하는 독창적인 연속 충돌 검사 알고리즘을 제안합니다. 이는 Primitive, Mesh, Occupancy Map 등 다양한 World Representation에서 연속 충돌 검사를 가능하게 합니다.</li>
<li><strong>병렬 최적화:</strong> GPU Batch L-BFGS Optimizer를 개발했습니다. 이는 근사 병렬 Line Search Scheme과 파티클 기반 최적화(particle-based optimizer)를 결합하여 난이도가 높은 모션 생성 문제를 해결합니다. 이 솔버는 기존 CPU 기반 솔버 대비 역기구학(Inverse Kinematics, IK)에서 23배, 충돌 없는 역기구학(Collision-Free IK)에서 80배, 충돌 없는 궤적 최적화에서 87배 더 빠릅니다.</li>
<li><strong>최첨단 IK 솔버:</strong> 개발된 고성능 Kernel을 활용하여 초당 37000개의 IK 문제를 해결할 수 있는 세계 최고 수준의 IK 솔버를 구현했습니다 (TracIK 대비 23배 빠름). 또한 초당 7600개의 충돌 없는 IK 문제를 해결할 수 있습니다 (TracIK + Bullet 대비 80배 빠름).</li>
<li><strong>병렬 기하학적 플래너(Parallel Geometric Planner):</strong> 병렬 Steering 알고리즘을 갖춘 기하학적 플래너를 개발하여 20ms 이내에 충돌 없는 경로를 생성합니다.</li>
<li><strong>전역 모션 생성 파이프라인:</strong> 위의 모든 기여를 결합하여, 시작 Configuration에서 목표 Gripper Pose까지의 충돌 없는 모션 생성을 평균 50ms 이내에 완료하는 전역 모션 생성 파이프라인을 구축했습니다.</li>
<li><strong>저전력 장치 검증:</strong> NVIDIA Jetson AGX Orin (60W 및 15W 전력 예산)에서 검증 결과, 기존 CPU 기반 방법보다 평균 28배(60W) 및 21배(15W) 더 빠름을 입증했습니다.</li>
<li><strong>cuRobo 라이브러리 공개:</strong> GPU 가속 로봇 알고리즘 모음인 cuRobo 라이브러리를 공개하여 로봇 공학 커뮤니티의 대규모 문제 탐색을 지원합니다.</li>
</ul>
<p><strong>핵심 방법론 상세 설명:</strong></p>
<p>이 논문은 로봇 모션 생성을 시작 관절 Configuration <span class="math inline">\theta_0</span>에서 로봇의 End-Effector가 목표 Cartesian Pose <span class="math inline">X_g</span>에 도달하는 최종 관절 Configuration <span class="math inline">\theta_T</span>까지의 시간 이산화된 궤적 최적화 문제로 공식화합니다. 목적 함수는 End-Effector의 목표 Pose 도달 비용과 궤적의 부드러움(smoothness)을 위한 비용의 합으로 정의됩니다. <span class="math display"> \arg \min_{\theta_{[1,T]}} C_{\text{task}}(X_g, \theta_T) + \sum_{t=1}^T C_{\text{smooth}}(\cdot) </span> 여기서 다음 제약 조건들이 적용됩니다: * 관절 위치, 속도, 가속도, 저크(jerk) 한계: <span class="math inline">\theta^- \preceq \theta_t \preceq \theta^+</span>, <span class="math inline">\dot{\theta}^- \preceq \dot{\theta}_t \preceq \dot{\theta}^+</span>, <span class="math inline">\ddot{\theta}^- \preceq \ddot{\theta}_t \preceq \ddot{\theta}^+</span>, <span class="math inline">\dddot{\theta}^- \preceq \dddot{\theta}_t \preceq \dddot{\theta}^+</span> * 최종 시점에서의 속도, 가속도, 저크 0 제약: <span class="math inline">\dot{\theta}_T, \ddot{\theta}_T, \dddot{\theta}_T = 0</span> * 자기 충돌(self-collision) 및 세계 충돌(world-collision) 회피: <span class="math inline">C_r(K_s(\theta_t)) \preceq 0</span>, <span class="math inline">C_w(K_s(\theta_t)) \preceq 0</span></p>
<p><strong>Kinematics 및 충돌 회피:</strong></p>
<p>로봇의 Kinematics <span class="math inline">K_s(\cdot)</span>는 관절 Configuration을 로봇의 모든 geometry의 Cartesian Pose로 매핑합니다. Kinematics 계산은 본질적으로 순차적이지만, 이 논문에서는 transformation을 4x4 동차 행렬로 표현하고 4개의 병렬 스레드를 사용하여 행렬 곱셈을 계산함으로써 병렬화를 달성합니다. 역방향 Kinematics(Backward Kinematics)의 경우 16개의 스레드를 사용하여 그래디언트를 Cartesian 공간에서 Joint 공간으로 투영합니다. 자기 충돌 회피를 위해 로봇 볼륨을 구(sphere) 집합으로 표현하고, 자기 충돌 비용 <span class="math inline">C_r</span>은 구 쌍 간의 최대 침투 거리를 계산합니다. <span class="math display"> C_r(K_s(\theta_t)) = \beta_1 \max_{i,j \in S} (\max(0, s_{i,r} + s_{j,r} - ||s_{i,x} - s_{j,x}||)) </span> 여기서 <span class="math inline">s_{i,x}, s_{j,x}</span>는 구의 위치, <span class="math inline">s_{i,r}, s_{j,r}</span>은 구의 반지름이며, <span class="math inline">S</span>는 자기 충돌 검사가 필요한 구 쌍의 집합입니다. 세계 충돌 회피는 장애물 표면 근처의 불연속성을 완화하기 위해 활성화 거리 <span class="math inline">\eta</span>를 갖는 이차 비용 프로파일(<span class="math inline">d_c</span>)을 사용합니다. <span class="math display"> d_c = \begin{cases} d + 0.5\eta &amp; \text{if } d &gt; 0 \\ 0.5\eta (d + \eta)^2 &amp; \text{if } -\eta &lt; d &lt; 0 \\ 0 &amp; \text{otherwise} \end{cases} </span> 또한, 최적화가 장애물을 빠르게 통과하는 것을 방지하기 위해 충돌 비용을 로봇의 속도에 비례하여 스케일링하는 속도 측정항목(<span class="math inline">\dot{s}</span>)을 도입합니다. 즉, <span class="math inline">d_s = \dot{s} d_c</span>를 사용합니다. 경로 이탈에 대한 강건성을 위해 <span class="math inline">\eta</span> 거리 내에서는 로봇의 속도에 페널티를 부여합니다. 연속 충돌 검사(Continuous Collision Checking)는 얇은 장애물과의 충돌을 놓치지 않도록 중요하며, 이 논문에서는 Swept Volume 대신 World Representation에서 점 쿼리 Signed Distance 함수만 요구하는 새로운 방법을 제시합니다. 궤적의 각 시점에서 구의 위치를 기준으로 전방 및 후방 Sweeping을 수행하여 충돌을 검사하고, 이 과정은 그래디언트 계산의 병렬화를 가능하게 합니다. 최종 세계 충돌 비용 <span class="math inline">C_w</span>는 다음과 같이 정의됩니다. <span class="math display"> C_w(S_{t-1,t,t+1}) = \beta_2 \text{speed}(S_{t-1,t,t+1})\text{smooth}(\text{sweep}(S_{t-1,t,t+1})) </span> 여기서 <span class="math inline">\beta_2</span>는 비용 스케일링, <span class="math inline">\text{sweep}(\cdot)</span>는 연속 충돌 검사, <span class="math inline">\text{smooth}(\cdot)</span>는 이차 smoothing, <span class="math inline">\text{speed}(\cdot)</span>는 속도 스케일링을 나타냅니다.</p>
<p><strong>병렬 최적화 솔버:</strong></p>
<p>주요 최적화 솔버로 L-BFGS를 사용하며, 이는 대규모 최적화 문제에 적합하고 병렬화에 용이합니다. L-BFGS의 Step Direction 계산 후, 병렬 노이즈 라인 탐색(Parallel Noisy Line Search)을 수행합니다. 이는 이산적인 스케일 값 집합을 병렬로 평가하여 최적의 Step 크기를 찾습니다. 노이즈 스텝(예: 0.01)은 라인 탐색이 조건을 만족하지 못할 때도 최적화 변수 간의 지속적인 교란을 제공하여 NaN 값을 방지하고 수렴률을 향상시킵니다. L-BFGS의 지역 최적해(local optima) 도달 능력을 향상시키기 위해 파티클 기반 최적화(Particle-Based Optimization)를 결합합니다. L-BFGS 시작 전에 파티클 기반 최적화를 몇 번 반복하여 초기화합니다. 초기 평균 궤적 <span class="math inline">\Theta_\mu</span>와 공분산 <span class="math inline">\Theta_\sigma</span>에서 <span class="math inline">n</span>개의 파티클 <span class="math inline">\theta_{n,[1,T]}</span>를 샘플링하고, 각 파티클의 비용을 계산한 후, Exponential Utility <span class="math inline">w</span>를 사용하여 평균과 공분산을 업데이트합니다. <span class="math display"> \Theta_{\mu} = (1 - k_{\mu})\Theta_{\mu-1} + (k_{\mu})w * \theta_{n,[1,T]} </span> <span class="math display"> \Theta_{\sigma} = (1 - k_{\sigma})\Theta_{\sigma-1} + w * (\theta^2_{n,[1,T]} - \Theta_{\mu-1}) </span> 여기서 <span class="math inline">k_{\mu}</span>와 <span class="math inline">k_{\sigma}</span>는 학습률(learning rate)입니다. 이 방법은 L-BFGS의 수렴 속도와 성공률을 크게 높입니다.</p>
<p><strong>병렬 기하학적 플래너:</strong></p>
<p>기하학적 플래너는 시작에서 목표 Configuration까지 충돌 없는 경로를 생성하며, 특히 그래프 구축의 세 가지 핵심 구성 요소를 GPU에서 병렬로 실행합니다: 충돌 없는 노드 샘플링, 그래프 내 K-Nearest 노드 찾기, 그리고 각 샘플링된 노드에서 K-Nearest 노드로의 병렬 Steering. 특히 병렬 Steering 알고리즘은 여러 정점 간의 Steering 시도를 동시에 처리하여 경로 생성을 가속화합니다.</p>
<p><strong>실험 결과:</strong></p>
<p>cuRobo는 Kinematics, 충돌 검사, IK, Trajectory Optimization, Geometric Planning 등 모든 핵심 모듈에서 기존 최첨단 CPU 기반 방법론 대비 압도적인 계산 시간 단축을 보여줍니다. 예를 들어, Kinematics는 10만 배치에서 최대 891배, Signed Distance 쿼리는 10만 배치에서 최대 16,000배 빠릅니다. 전체 모션 생성 파이프라인은 PC에서 Tesseract 대비 평균 60배 빠르며, Jetson ORIN 15W에서도 Tesseract PC 버전보다 빠른 성능을 보여 저전력 에지 장치에의 배포 가능성을 입증합니다. 모션 품질 측면에서는 cuRobo가 기존 방법보다 더 짧은 경로 길이를 제공하며, 특히 Jerk를 최소화하는 궤적을 생성하여 기존 Trajectory Optimization 기법보다 Jerk가 4배 낮고, 기존 Time Parameterization 방법보다 12배 낮습니다. 이는 로봇이 더 부드럽고 효율적으로 움직일 수 있도록 하여 실제 로봇의 추적 성능 향상에 기여합니다. 실제 UR5e 및 UR10 로봇에서의 검증을 통해, cuRobo가 생성한 최소 저크(minimum-jerk) 궤적이 높은 정확도로 추적되며, 계획 시간이 전체 작업 사이클 시간의 6% 미만임을 보여주어 실시간 애플리케이션에 매우 적합함을 입증합니다.</p>
<p>이 논문은 고품질의 충돌 없는 로봇 모션 생성을 실시간에 가깝게 수행할 수 있는 GPU 기반 병렬 처리의 잠재력을 완전히 보여주며, cuRobo 라이브러리 공개를 통해 로봇 공학 연구 및 산업 발전에 크게 기여할 것으로 기대됩니다.</p>
<hr>
</section>
<section id="detail-review" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Detail Review</h1>
<blockquote class="blockquote">
<p>cuRobo: 병렬화된 충돌 회피 <strong>최소-저크</strong> 로봇 모션 생성</p>
</blockquote>
<section id="소개-gpu로-가속한-차세대-로봇-모션-플래너" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="소개-gpu로-가속한-차세대-로봇-모션-플래너"><span class="header-section-number">2.1</span> 소개: GPU로 가속한 차세대 로봇 모션 플래너</h2>
<p>로봇 팔(Manipulator)의 <strong>모션 생성</strong> 문제는, 높은 자유도를 가진 로봇이 복잡한 환경에서 <strong>충돌 없이</strong> 목표 지점까지 이동할 경로와 속도를 찾아내는 것을 의미합니다. 기존의 모션 플래너들은 경로를 찾는 데 시간이 오래 걸리거나, 경로는 찾지만 움직임이 불안정한 경우가 많았습니다. <strong>cuRobo</strong>는 이러한 문제를 해결하기 위해 제안된 새로운 모션 생성 프레임워크로, <strong>GPU 병렬 컴퓨팅</strong>을 적극 활용하여 <strong>전역 최적화</strong> 수준에서 경로를 탐색합니다. cuRobo는 특히 <strong>“최소-저크(minimum-jerk)”</strong> 기준으로 궤적을 최적화하여 부드럽고 안정적인 움직임을 생성하며, 로봇과 환경 간 <strong>충돌 회피</strong>를 통합적으로 고려합니다. 놀랍게도 이 모든 처리를 <strong>평균 50ms 이내</strong>에 수행하여, 기존 기법 대비 약 <strong>60배 이상의 속도</strong> 향상을 달성합니다. 본 포스트에서는 cuRobo의 핵심 아이디어와 아키텍처를 살펴보고, 성능 평가 결과와 기존 방법들과의 비교를 통해 그 장점과 한계를 깊이 있게 알아보겠습니다.</p>
</section>
<section id="curobo의-핵심-아이디어와-구조" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="curobo의-핵심-아이디어와-구조"><span class="header-section-number">2.2</span> cuRobo의 핵심 아이디어와 구조</h2>
<p><strong>cuRobo</strong>는 로봇 모션 생성을 하나의 <strong>최적화 문제</strong>로 정식화합니다. 목표는 로봇의 시작 자세에서 <strong>목표 그리퍼 위치/자세</strong>에 도달하는 <strong>시간에 따른 관절 궤적</strong>을 찾는 것입니다. 이때 궤적은 가능한 한 <strong>부드럽게</strong> (가속도의 시간 변화율인 <strong>저크(jerk)</strong>를 최소화) 움직이면서도 <strong>경로 상의 장애물과 충돌하지 않도록</strong> 만들어야 합니다. 이를 달성하기 위해 cuRobo는 다음과 같은 단계들을 포함하는 <strong>구조적 파이프라인</strong>을 가지고 있습니다:</p>
<ul>
<li><p><strong>목표 자세 IK 계산</strong>: 먼저 목표 그리퍼 자세(위치 및 방향)에 대응하는 <strong>목표 관절각</strong>을 찾아야 합니다. cuRobo는 자체 개발한 <strong>병렬화된 역기구학(IK) 솔버</strong>를 이용해 다수의 IK 해를 동시에 시도하여, 그 중 <strong>충돌이 없고</strong> 로봇 관절 범위 내에 있는 해를 빠르게 찾아냅니다. 이 IK 솔버는 GPU 병렬화를 통해 초당 <strong>7000회 이상의 IK 연산</strong>을 수행할 수 있을 정도로 고속이며, 필요하면 수십 개의 해를 생성해 이후 단계의 후보로 활용합니다 (실험적으로 1000개의 자세를 131ms만에 모두 <strong>충돌 검사까지 포함</strong> 해결하여 기존 TracIK 기반 접근보다 <strong>80배 이상 빠름</strong>).</p></li>
<li><p><strong>여러 초기 궤적 시드 생성</strong>: IK로 얻은 목표 자세(관절 구성)로부터, 시작 자세와 목표 자세를 연결하는 <strong>여러 개의 초기 경로 시나리오(시드)</strong>를 만듭니다. 예를 들면,</p>
<ol type="1">
<li><strong>직선 인터폴레이션 경로</strong>: 시작 관절각과 목표 관절각을 선형 보간하여 얻은 경로,</li>
<li><strong>후퇴 동작을 포함한 경로</strong>: 초기에 로봇 팔을 살짝 뒤로 빼는 등 <strong>특정 중간 자세</strong>(retract configuration)를 경유하도록 만든 경로,</li>
<li><strong>병렬 기하학 플래너 기반 경로</strong>: cuRobo에 내장된 <strong>GPU 가속 샘플링 플래너</strong>를 사용해 얻은 <strong>충돌 없는</strong> 경로 등이 있습니다.</li>
</ol>
<p>이러한 여러 경로 후보를 한꺼번에 준비하는 이유는 <strong>전역 최적해</strong>를 찾기 위함입니다. 로봇 모션 최적화 문제는 장애물에 의해 <strong>비선형적</strong>이고 <strong>다중 극소해</strong>를 가질 수 있기 때문에, 단일 초기 값으로 시작하면 최적해를 놓치거나 충돌을 피하지 못할 수 있습니다. cuRobo는 다양한 시드들을 병렬로 탐색함으로써 이러한 지역 해 한계를 극복하려 합니다. 실험적으로도 <strong>다중 시드</strong> 및 <strong>연속 충돌 검사</strong>를 도입하면 단 한번의 최적화 시도로도 문제의 <strong>85% 이상</strong>을 성공적으로 풀 수 있을 정도로 성공률이 높아진다고 보고합니다.</p></li>
<li><p><strong>병렬 궤적 최적화 (Minimum-Jerk)</strong>: 준비된 다수의 시드 궤적 각각에 대해 <strong>동시에</strong> 최적화 연산을 수행합니다. 여기서 코스트 함수는 크게 두 부분으로 구성됩니다:</p>
<ol type="1">
<li><strong>경로의 목적지 도달 오차</strong>: 최종 시점에 엔드 이펙터가 목표 자세에 도달하도록 유도하는 비용으로, 위치 오차와 자세(quaternion) 오차를 포함합니다. 이 항은 목표에 가까워질수록 세밀하게, 멀리 떨어져 있을 때는 안정적으로 작용하도록 스케일링되어 있어, 목표 근처에서 높은 정확도를 보장하면서도 초기에는 완만한 경사로 효율적 탐색을 돕습니다.</li>
<li><strong>경로의 길이 및 매끄러움</strong>: <strong>가속도 및 저크(jerk)</strong>에 대한 페널티를 줌으로써 불필요하게 <strong>굽은 경로나 급격한 속도 변화</strong>를 억제합니다. 가속도 제곱합을 최소화하는 것은 곧 로봇 <strong>관절 속도의 급격한 변화</strong>를 줄여 경로를 부드럽게 만들고, 결과적으로 <strong>짧고 효율적인 경로</strong>가 나오도록 합니다. 여기에 한 단계 더 나아가, <strong>저크(jerk)</strong> 항을 함께 최소화함으로써 속도의 변화율까지 억제하는 <strong>최소-저크</strong> 궤적을 추구합니다. 이러한 저크 최소화는 특히 로봇이 정지 상태에서 <strong>고속으로 움직이기 시작하거나 멈출 때</strong> 발생하는 충격을 줄여주며, 실제 로봇 제어 시 <strong>진동 감소 및 추종 안정성 향상</strong>에 크게 기여합니다.</li>
</ol>
<p>추가로, 경로 상에서 <strong>관절 각도 한계</strong>를 넘지 않도록 페널티를 부과하고 (하드 제약을 일단 큰 페널티로 완화하여 최적화), 필요한 경우 로봇 모델에 따른 작업공간 제약(예: 특정 높이 유지나 말단의 방향 유지)도 비용으로 넣을 수 있습니다. 다만 cuRobo 논문에서는 이런 <strong>작업-제약 경로</strong>(예: 끝단 공구의 일정한 자세 유지 등)에 대한 처리는 초기 실험만 해보았고 아직 본격적으로 통합하진 않았다고 밝혔습니다.</p>
<p><strong>충돌 회피</strong>는 코스트 함수의 필수 요소입니다. cuRobo는 <strong>로봇 자체 충돌(셀프-콜리전)</strong>과 <strong>환경 장애물 충돌</strong>을 모두 고려하기 위해, 로봇 및 물체의 기하를 특수한 방식으로 다룹니다. 일반적으로 충돌 검출은 로봇의 각 링크 형상을 매번 위치시켜 <strong>메시(mesh) 간 충돌 여부나 거리</strong>를 계산하는 방식을 취하는데, 이는 매우 계산 집약적입니다 (예: ROS MoveIt에서는 오픈소스 <strong>FCL</strong>(Flexible Collision Library)로 이러한 연산을 CPU에서 수행하며, 복잡한 로봇-환경 간 충돌 계산이 병목이 되곤 합니다). <strong>cuRobo는 로봇의 각 링크를 복수의 구(sphere)로 근사 표현</strong>하여 이 문제를 해결합니다. 각 구의 중심 좌표를 기반으로 <strong>충돌 비용 함수를 연속적으로 계산</strong>하는데, 방법은 다음과 같습니다:</p>
<ul>
<li><strong>환경 충돌 비용</strong>: 구와 장애물 간 거리를 계산하여, 만약 거리가 구의 반지름보다 크면 (충돌 여유가 충분하면) 비용 0, 어느 임계 거리 이내로 가까워지면 부드러운 <strong>2차 함수 형태로 비용이 증가</strong>하도록 만듭니다. 이렇게 하면 로봇이 장애물에 근접할수록 큰 패널티를 받아 <strong>자연스럽게 멀어지도록</strong> 최적화됩니다. 장애물은 사전에 <strong>직육면체(collaboration box)</strong>나 <strong>서명거리장(Signed Distance Field)</strong> 등으로 표현하여, 각 구의 중심까지의 거리 연산을 빠르게 병렬 계산합니다. (논문에서는 실험 시 원기둥 형태의 장애물을 동일한 부피의 직육면체로 근사했다고 언급합니다. 이러한 근사는 속도를 높여주지만 약간의 오차를 수반하여, 일부 엣지 케이스에선 목표 자세 자체가 장애물과 겹쳐 유효 경로가 없는데도 근사 충돌 검사상 간과되는 등의 사례가 있었습니다.)</li>
<li><strong>자기 충돌 비용</strong>: 로봇 링크들 간 일정 거리 이상 근접하지 않도록, 각 링크를 대표하는 구들 사이의 간격을 계산해 비용을 부여합니다. 인접한 링크 (예: 바로 이웃 관절 사이)는 어느 정도 가까워지는 것이 허용되므로, <strong>특정 구 쌍들만 선택적으로 검사</strong>하여 불필요한 충돌 계산을 줄이고 로봇의 정상 동작 범위는 방해하지 않도록 했습니다.</li>
</ul>
<p>특히 cuRobo는 <strong>연속적(Continuous) 충돌 검사</strong>를 수행하여 <strong>시간축을 따라 부드럽게 움직이는 동안에도</strong> 중간에 발생할 수 있는 충돌을 놓치지 않습니다. 이는 각 타임스텝 별 로봇 자세뿐만 아니라, 인접 시간 구간에서 로봇의 궤적이 지나가는 경로까지 확인하는 기법입니다. 예를 들어 관절 각도 사이를 선형보간한 세부자세들도 모두 위 구-장애물 거리 계산을 통해 충돌이었는지 확인하며, 필요하면 시간 분할을 조정해가며 <strong>완전한 충돌 프리 경로</strong>를 보장합니다.</p>
<p>마지막으로, 최적화는 <strong>병렬화된 L-BFGS</strong> 최적화 알고리즘으로 수행됩니다. 각 시드 경로에 대해 그래디언트를 계산하고 L-BFGS 방식으로 <strong>동시에</strong> 경로를 수정해 나가되, cuRobo는 여기에 독자적인 <strong>병렬 노이즈 Line Search</strong> 기법을 더했습니다. 일반적인 L-BFGS 알고리즘은 새로운 스텝 크기를 찾을 때 직렬적으로 탐색(line search)을 하지만, cuRobo는 <strong>여러 후보 스텝을 동시에 시도</strong>하고 약간의 무작위성도 부여하여 지역 최적해에 갇히는 것을 방지합니다. 또한 초기 몇 회의 반복(iteration)은 <strong>“파티클 기반 최적화”</strong>라 불리는 방식을 사용하여 시드 경로들이 더 <strong>좋은 영역으로 이동</strong>하도록 유도하고, 이후 L-BFGS로 빠르게 수렴시키는 하이브리드 전략을 취합니다. 여기서 파티클 기반 최적화는 시드들을 일종의 <strong>스웜(swarm)</strong>으로 간주하여 개략적인 전역 탐색을 하는 단계로 볼 수 있습니다 (논문에서는 구체적인 구현으로 샘플 기반 MPPI법 등을 활용한 것으로 보입니다). 요약하면, <strong>다중 시드 + 파티클 탐색 + L-BFGS 미세조정</strong>의 조합으로, 높은 성공률과 빠른 수렴 속도를 동시에 얻는 것입니다.</p></li>
<li><p><strong>시간 최적화 및 최종 출력</strong>: 궤적 최적화가 끝나면 결과로 얻은 경로는 관절 공간에서의 움직임 순서일 뿐 아니라, <strong>시간 프로파일</strong>이 할당되어야 실제 로봇이 따라갈 수 있습니다. cuRobo는 처음에는 일정한 간격으로 시간 간격(dt)을 놓고 최적화를 수행하지만, 일단 <strong>충돌 없는</strong> 경로가 나오면 그 경로를 따라 움직일 때 로봇의 <strong>속도/가속도 한계</strong>를 검토합니다. 만약 어느 구간에서 속도나 가속도 한계를 넘는다면 시간을 늘리고, 여유가 많다면 시간을 단축하는 식으로 <strong>시간 스케일을 재조정</strong>합니다. 그리고 필요하다면 그 새로운 시간 간격에 맞추어 다시 한번 궤적을 미세 조정하여, 최종적으로 <strong>로봇의 동작 한계 내에서 가장 빠르게 움직일 수 있는</strong> 시간을 갖는 궤적을 완성합니다. 이렇게 산출된 결과 궤적 θ[0,T]는 시작부터 목표까지 각 시점별 관절값과, 해당 움직임에 걸리는 시간 (속도 프로파일)이 모두 정해진 형태로, 로봇에 <strong>실행 명령</strong>으로 보낼 준비가 된 상태가 됩니다.</p></li>
</ul>
<p>요약하자면, cuRobo의 구조는 (i) <strong>병렬 IK</strong>로 목표 자세 도달 가능성 확인, (ii) 다수의 <strong>초기 경로 생성</strong>, (iii) <strong>병렬 궤적 최적화</strong>로 충돌 없고 최소-저크인 경로 탐색, (iv) <strong>시간 재조정</strong>으로 로봇 한계 내 최적 속도 달성을 포함합니다. 이러한 복잡한 작업을 모두 포함함에도, 강력한 GPU 병렬화를 통해 <strong>수십 밀리초 수준의 속도</strong>를 이루어낸 것이 cuRobo의 가장 큰 혁신입니다. 다음 섹션에서는 cuRobo가 어떻게 GPU를 활용해 이러한 성능을 얻는지 살펴보겠습니다.</p>
</section>
<section id="gpu-병렬화-전략과-최적화-기법" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="gpu-병렬화-전략과-최적화-기법"><span class="header-section-number">2.3</span> GPU 병렬화 전략과 최적화 기법</h2>
<p>cuRobo의 뛰어난 성능의 비결은 <strong>전략적인 병렬화(parallelization)</strong>와 GPU 최적화에 있습니다. 일반적으로 로봇 모션 계획의 각 구성요소(예: IK 계산, 경로 충돌 검사, 최적화 반복 등)는 <strong>순차적으로</strong> 수행되던 작업이었습니다. cuRobo는 이를 가능한 모든 단계에서 병렬화하여, GPU의 수천 개 스레드를 활용함으로써 <strong>동시에 많은 연산을 처리</strong>합니다.</p>
<ul>
<li><p><strong>다중 시드 병렬 최적화</strong>: 앞서 설명했듯이 cuRobo는 여러 개의 초기 경로 시드를 둡니다. 이 각각의 시드 경로 최적화는 <strong>독립적인 계산</strong>이므로, GPU의 여러 스레드블록에 분배하여 동시에 진행합니다. 논문에서는 <strong>한 시드당 하나의 CUDA 블록</strong>을 할당하고, 수십 개의 시드가 각각 병렬로 업데이트된다고 밝히고 있습니다. 이렇게 하면 시간 당 많은 후보 경로를 살펴볼 수 있어, 단순 단일 경로를 반복적으로 시도하는 것보다 월등히 빠르게 우수한 경로를 찾을 수 있습니다.</p></li>
<li><p><strong>스레드 단위 세분화</strong>: 더욱 흥미로운 점은, <strong>한 개의 시드의 최적화 과정 내부</strong>에서도 병렬화를 수행했다는 것입니다. 예를 들어, 한 궤적의 충돌 비용이나 그래디언트를 계산할 때, 시간 단계별로 혹은 관절별로 계산을 쪼개 여러 스레드가 동시에 분담하도록 구현했습니다. 논문에 따르면, “workload가 큰 커널들을 시드별로도 다시 여러 스레드로 쪼개어 실행(split kernels across many threads per seed)”하여, 전통적으로 <strong>반복적이고 순차적인 수치최적화 작업</strong>에서도 큰 폭의 가속을 얻었다고 합니다. 대표적인 사례로 <strong>로봇 정방향 기구학 (Forward Kinematics)</strong> 계산을 들 수 있습니다. 보통 n-자유도 로봇의 정기구학은 각 관절 변환을 앞에서부터 차례로 곱적용하는 <strong>완전히 직렬적인 계산</strong>입니다. 그러나 cuRobo는 <strong>동차변환 행렬(4x4)</strong>을 사용해 4개의 요소를 한 번에 처리하고, 여러 관절 변환도 <strong>매트릭스 곱셈을 4개 스레드가 병렬 수행</strong>하는 식으로 병렬화를 부분 도입했습니다. 또한 한 관절씩 진행하던 기존 GPU 구현(STORM 등)이 많은 커널 호출 오버헤드를 발생시킨 것과 달리, cuRobo는 <strong>단일 CUDA 커널</strong>에서 모든 링크 좌표를 계산하도록 구현하여 메모리 병목을 줄였습니다. 그 결과 적정 배치(batch) 크기 이상에서는 CPU의 최고속 라이브러리(Pinocchio 등)보다 수백 - 수천 배까지도 빠른 기구학 계산이 가능해졌습니다. 이러한 세밀한 최적화 덕분에, cuRobo의 정기구학은 100k개의 자세에 대해서도 CPU 대비 <strong>최대 891배</strong> 빠른 성능을 보이며, 거리 계산 (충돌 검사)도 대규모 배치 시 PyBullet 대비 <strong>최대 16000배</strong>까지 빨라지는 <strong>획기적인 속도</strong>를 달성했습니다 (물론 이렇게 큰 배치는 실시간 적용보다는 병렬 시뮬레이션 분석 등에 가깝지만, 100 - 1000개 수준의 병렬 계산에서도 이미 유의미한 가속이 일어납니다).</p></li>
<li><p><strong>CUDA 그래프(CUDA Graphs) 활용</strong>: cuRobo는 Python으로 구현된 상위 로직에서 여러 CUDA 커널을 호출하는 구조인데, 이 경우 <strong>호스트(CPU)-디바이스(GPU) 간 커널 호출의 오버헤드</strong>가 누적될 수 있습니다. 이를 줄이기 위해 최적화 반복과 일부 데이터 준비 과정을 <strong>CUDA Graph</strong> 기능으로 묶어 <strong>일괄 실행</strong>하는 기법을 사용했습니다. CUDA Graph는 미리 정의된 일련의 GPU 연산을 한꺼번에 실행하도록 스케줄링할 수 있는 기술로, cuRobo는 이를 통해 파이썬 루프에서 커널을 매 iteration 호출하던 것을 <strong>녹화(record) 후 재실행</strong>하는 형태로 바꾸어 <strong>약 10배의 속도 향상</strong>을 얻었다고 합니다. 이렇게 Python 레벨의 부담을 줄인 결과, cuRobo의 전체 계획 시간 중 Python 상에서 소모되는 시간이 평균 8ms 정도에 불과하며, 추후 해당 부분을 C++로 옮기고 커널들을 더욱 통합한다면 현재 60배인 속도 향상이 <strong>최대 93배</strong>까지도 늘어날 수 있음을 보였습니다.</p></li>
<li><p><strong>메모리 최적화와 기타 기법</strong>: GPU 메모리 상에서 다루는 데이터 구조도 성능에 영향을 주는데, cuRobo는 로봇 및 환경 정보를 GPU에 상주시켜 반복 사용하고, 충돌 검사에 필요한 <strong>구 구성</strong>이나 <strong>서명 거리장</strong> 등의 데이터도 한 번 만들어 놓으면 효율적으로 읽도록 신경 썼습니다. 또한 로봇의 메시 -&gt; 구 근사 변환 등을 도와주는 도구를 제공하여, 새로운 로봇이나 환경에 적용할 때 겪는 어려움을 줄였습니다 (NVIDIA Isaac Sim과 연동된 sphere generation 유틸리티 등을 제공). 이러한 실무적인 최적화 포인트까지 챙겨, cuRobo 라이브러리는 <strong>일반 PC에서뿐 아니라 Jetson과 같은 임베디드 GPU 플랫폼에서도 좋은 성능</strong>을 내도록 만들어졌습니다.</p></li>
</ul>
<p>요컨대 cuRobo는 <strong>“가능한 모든 것을 병렬로”</strong>라는 철학으로 설계되었고, GPU의 장점을 최대한 살린 맞춤 구현을 통해 기존 CPU 위주의 접근으로는 상상하기 어려운 속도를 실현했습니다. 다음으로, 실제 성능 숫자와 실험 결과들을 자세히 살펴보겠습니다.</p>
</section>
<section id="성능-평가-속도-성공률-그리고-동작-안정성" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="성능-평가-속도-성공률-그리고-동작-안정성"><span class="header-section-number">2.4</span> 성능 평가: 속도, 성공률 그리고 동작 안정성</h2>
<p>cuRobo의 성능은 다양한 기준에서 기존 기술들을 크게 앞서나갑니다. <strong>속도</strong> 측면에서는, 복잡한 7자유도 로봇 팔이 장애물 사이를 이동하는 문제를 평균 <strong>50ms</strong>만에 풀어내어, 기존 최적화 기반 방법 대비 <strong>약 60배 빨라졌습니다</strong>. 심지어 어려운 상위 10% 난이도 문제들에 대해서는 수십 배 이상의 격차가 벌어져, 예를 들어 <strong>98번째 퍼센타일 난이도 문제</strong>의 경우 cuRobo는 약 0.26초, 기존 방식(Tesseract)은 22초가 걸려 <strong>83배</strong> 속도 차이를 보였습니다. 이러한 비교는 Omniverse Isaac Sim의 <strong>Franka Emika Panda</strong> 로봇팔과 다양한 장애물 환경에 대해 총 2600개의 시나리오를 테스트한 결과입니다.</p>
<p>특히 cuRobo의 속도 향상은 <strong>데스크탑 고성능 PC뿐 아니라 임베디드 플랫폼에서도 유효</strong>했습니다. 엔비디아 <strong>Jetson AGX Orin</strong> 모듈(지능형 로봇에 자주 쓰이는 60W 내외 GPU 컴퓨팅 모듈)에서 테스트한 결과, cuRobo는 Jetson에서 15W 저전력 모드로 동작해도 데스크탑 <strong>i7 CPU에서 구동한 Tesseract보다 빠른</strong> 성능을 보였습니다. Jetson 15W 환경에서 조차 cuRobo가 Tesseract보다 <strong>21배</strong> 빨랐고, Jetson을 최대 성능(MAXN)으로 구동하면 <strong>28배</strong>까지도 빨라졌습니다. 이는 cuRobo의 GPU 최적화가 얼마나 뛰어난지를 잘 보여주는 예로, <strong>저전력 엣지 디바이스에서도 실시간 모션 계획</strong>을 가능케 함을 의미합니다.</p>
<p><strong>성공률(성공 확률)</strong>과 <strong>경로 품질</strong> 측면에서도 cuRobo는 우수한 결과를 냈습니다. 앞서 언급한 2600개의 다양한 문제 세트에서, cuRobo의 모션 생성은 <strong>99.8%</strong>의 매우 높은 성공률을 기록했습니다. 이는 동일 조건에서 전통적인 조합(OMPL RRTConnect + TrajOpt 최적화)을 사용한 Tesseract의 약 98.5%와 비교해도 높은 수치입니다. Tesseract는 38개의 실패 사례가 있었던 반면, cuRobo는 오직 5개 문제만 실패했는데, 그마저도 알고리즘상의 한계라기보다 <strong>테스트 데이터의 문제</strong> (목표 자세 자체가 처음부터 장애물과 겹쳐있어 물리적으로 불가능한 경우 등)였다고 합니다. 즉, 유효한 문제에 대해서는 사실상 <strong>모두 해결</strong>했다고 볼 수 있습니다. 또한 cuRobo는 경로 최적화를 통해 <strong>불필요한 우회나 멀리 돌아가는 경로를 크게 단축</strong>시켰습니다. 측정 결과 cuRobo가 만들어낸 경로의 <strong>관절 이동거리 총합</strong>(C-space path length)은 순수 RRT 기반 경로보다 평균 53% 짧았고, 동일한 TrajOpt 적용 대비로도 약 10% 가량 더 짧았습니다. 이는 cuRobo가 <strong>최소한의 움직임으로 목표에 도달하는</strong> 효율적인 경로를 찾아낸다는 의미입니다.</p>
<p>하지만 뭐니뭐니해도 현장에서 중요한 것은 <strong>실제 로봇 동작의 안정성</strong>일 것입니다. cuRobo의 <strong>최소-저크</strong> 최적화는 이 부분에서 큰 강점을 보였는데, 이를 보여주기 위해 연구진은 <strong>실제 로봇</strong>으로 실험을 진행했습니다. 유니버설로봇(UR5e, UR10 모델) 두 대를 준비하여, 각각의 작업공간에 장애물을 놓고 <strong>7개의 임의 목표 자세</strong>를 순서대로 연달아 도달하는 경로를 생성, 로봇에게 실행시키는 테스트를 했습니다. 비교군으로 <strong>최소-저크 옵션을 끈(min-acc)</strong> 경우(즉 가속도만 최소화하고 저크는 고려 안 한 경우)와 <strong>켠(min-jerk)</strong> 경우를 모두 시험하여, 로봇의 <strong>궤적 추종 오차</strong>를 측정했습니다.</p>
<p>그 결과, <strong>저크 최소화가 켜진 경우</strong> 로봇의 추종 성능이 눈에 띄게 향상됨을 확인했습니다. 두 로봇 모두에서, <strong>관절 위치 오차</strong>와 <strong>속도 추종 오차</strong>가 최소-저크 궤적에서 더 낮았고, 특히 UR10 같은 비교적 크고 무거운 로봇에서는 차이가 크게 나타났습니다. UR10의 경우 최소-저크 적용 시 평균 위치 오차가 약 <strong>0.0013 rad</strong>였지만, 미적용 시에는 <strong>0.0025 rad</strong>로 두 배 가까이 늘어나, 로봇 엔코더의 공인 정밀도(약 0.0017 rad)를 넘어서는 오차가 발생했습니다. 무엇보다, 가속도 최소화만 한 경우 궤적 시작부에 <strong>큰 속도 오차/위치 오차 스파이크</strong>가 관찰되었는데, 이는 로봇이 순간적으로 최대 가속도에 도달하도록 명령받았을 때 물리적으로 <strong>즉각 반응하지 못해</strong> 생기는 오차였습니다. 반면 저크를 같이 최소화한 궤적은 <strong>초반에 가속도를 서서히 높이도록</strong> 계획되었기 때문에 이러한 스파이크가 사라졌고, 전반적으로 <strong>매끄럽게 가속/감속</strong>하여 로봇이 보다 정확히 따라갈 수 있었습니다. 이 실험은, 최소-저크 기준의 궤적이 <strong>고속 동작에서의 진동이나 추종 오차를 줄여 로봇 움직임의 안정성</strong>을 높여준다는 것을 실제로 입증했습니다. 이러한 효과 덕분에, cuRobo가 생성한 궤적을 로봇에 보낼 때 <strong>추가적인 속도 보간</strong> 없이도 (32시점 궤적을 10ms 간격으로 선형 보간만 하여) 문제없이 구동할 수 있었고, 약 35회 연속 동작 수행에서도 안전하고 정확한 움직임을 보여주었습니다.</p>
<p>마지막으로, <strong>실시간성</strong> 측면을 언급하면, cuRobo는 실제 로봇상에서도 <strong>계획 시간은 평균 100ms 이내</strong>로 측정되어 플래닝 지연이 거의 무시할 수준임이 확인되었습니다. 즉, 목표 자세만 주어지면 <strong>0.1초 내에 경로가 나오고</strong>, 바로 로봇이 움직이기 시작하여 계획 수립부터 실행 완료까지 매우 짧은 사이클로 동작 가능함을 의미합니다. 이는 산업용 로봇의 빈번한 경로 재계획이나, 인간-로봇 상호작용에서 실시간 반응이 필요한 상황에도 충분히 대응할 수 있는 수준입니다.</p>
</section>
<section id="구현-난이도와-오픈소스-활용" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="구현-난이도와-오픈소스-활용"><span class="header-section-number">2.5</span> 구현 난이도와 오픈소스 활용</h2>
<p>cuRobo는 NVIDIA 연구진에 의해 개발되었으며, <strong>오픈소스로 공개</strong>되어 누구나 활용할 수 있게 되어 있습니다. 공식 깃허브 저장소(NVlabs/curobo)에는 설치 방법과 예제가 제공되어 있고, 2025년 4월 기준으로 1.1k 이상의 Star를 받을 정도로 많은 관심을 모으고 있습니다. <strong>C++/CUDA로 작성된 핵심 연산 커널</strong>들과 <strong>Python 인터페이스</strong>로 구성되어 있어, Python 환경 (예: ROS의 Python 노드 등)에서 손쉽게 불러쓸 수 있으면서도 시간Critical한 부분은 GPU로 동작하도록 최적화되어 있습니다. 라이브러리의 구조도 모듈화되어, 필요한 부분만 떼어쓰는 것도 가능합니다. 예를 들어 <strong>정방향/역방향 기구학</strong>, <strong>충돌 검사</strong>, <strong>MPPI 최적화 모듈</strong> 등을 각각 독립적으로 호출하여 쓸 수 있고, 이를 조합하여 자체적인 모션플래너를 구성할 수도 있습니다.</p>
<p>실제로 cuRobo는 <strong>MoveIt</strong>과 같은 기존 로봇 모션 계획 프레임워크와 연동도 고려되었는데, <strong>Isaac ROS cuMotion</strong>이라는 MoveIt 플러그인 형태로도 제공되어 ROS 환경에서 cuRobo의 계획기를 사용할 수 있습니다. 다만 이 상용 패키지는 GPU가 없는 시스템에서는 동작이 어려울 수 있으므로 (cuRobo 자체가 GPU 가속을 전제로 설계), ROS를 쓰는 경우에도 엔비디아 GPU 플랫폼에서 활용하는 것이 권장됩니다.</p>
<p><strong>구현 난이도</strong> 측면에서, cuRobo가 자체 개발한 GPU 커널들은 매우 전문적인 최적화 기법들이 동원되었으나, 다행히 최종 사용자 입장에서는 <strong>API를 통해 사용</strong>하면 내부 구현을 몰라도 될 정도로 추상화되어 있습니다. 하지만 새로운 로봇 모델이나 새로운 형태의 장애물 환경을 적용하려면, 해당 모델의 <strong>구(sphere) 근사 모델</strong>을 생성해야 하는 등의 추가 작업이 필요합니다. 논문에서 언급된 바에 따르면, NVIDIA Isaac Sim 등의 툴을 이용해 로봇의 메시를 빠르게 다중 구로 치환해주는 유틸리티가 개발되었고, 이를 통해 많은 로봇에 구 모델을 작성해두었다고 합니다. 즉, 현실적으로 연구자들이 자주 쓰는 로봇(Franka Panda, UR 시리즈, Kinova Jaco 등)은 이미 sphere 모델이 준비되어 있어 곧바로 활용 가능할 것입니다. 만약 사용자가 직접 모델을 추가해야 한다면 이 과정이 조금 번거로울 수 있지만, 일회성 작업이며 이후에는 <strong>충돌 검사가 워낙 빨라지는 이점</strong>이 크므로 감수할 만합니다.</p>
<p>정리하면, cuRobo는 <strong>최신 GPU 프로그래밍 기법</strong>으로 무장한 전문적인 라이브러리이지만, 이를 접하는 연구자들은 이미 구현된 함수를 불러써서 효과를 누릴 수 있습니다. 더 나아가 관심 있는 개발자라면 오픈소스 커뮤니티에 기여하여 기능을 개선하거나, cuRobo를 <strong>자신의 연구에 맞게 확장</strong>해볼 수도 있을 것입니다. 이미 cuRobo의 오픈소스화로 인해 컴퓨터 아키텍처 연구자들이 저정밀 연산으로 메모리 병목을 줄이는 실험을 했다거나, 로보틱스 외 분야 전문가들이 이 프레임워크를 기반으로 새로운 알고리즘을 시험해볼 수 있게 되는 등 긍정적인 파급효과가 보고되고 있습니다.</p>
</section>
<section id="기존-모션-생성-기법과의-비교" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="기존-모션-생성-기법과의-비교"><span class="header-section-number">2.6</span> 기존 모션 생성 기법과의 비교</h2>
<p>cuRobo의 성능과 접근법을 이해하기 위해, 기존의 대표적인 로봇 모션 계획/생성 기법들과 비교해보겠습니다. 일반적으로 로봇 모션 계획 분야에서는 <strong>샘플링 기반 기법</strong>(예: RRT, PRM)과 <strong>최적화 기반 기법</strong>(예: CHOMP, TrajOpt, STOMP 등), 그리고 <strong>실시간 프로파일 생성기</strong>(예: Ruckig) 등이 혼재하여 사용되어 왔습니다. 각각의 특성과 한계를 짚어보면 다음과 같습니다.</p>
<ul>
<li><p><strong>샘플링 기반 기법 (예: RRT, BiRRT, OMPL 등)</strong>: 경로를 찾기 위해 로봇의 구성공간(C-space)을 무작위로 샘플링하며 탐색하는 알고리즘입니다. 대표적으로 <strong>RRT (Rapidly-exploring Random Tree)</strong> 알고리즘은 전역적인 경로 탐색에 강점이 있어 좁은 공간에서도 탈출 경로를 잘 찾아냅니다. 그러나 <strong>경로 품질</strong>이 들쭉날쭉하고, 최단경로를 보장하지 않으며, 한번 찾은 경로를 <strong>부드럽게 다듬는 별도 과정</strong>이 필요합니다. Tesseract 등의 프레임워크에서 <strong>RRT-Connect</strong> 같은 방법을 기하학적 플래너(geometric planner)로 쓰고, 결과를 TrajOpt 최적화로 다듬는 식으로 사용했는데, cuRobo 또한 <strong>cuRobo-GP</strong>라는 이름으로 자체 RRT 유사 플래너를 가지고 있습니다. 다만 cuRobo-GP는 GPU 병렬화를 통해 <strong>한 번에 많은 노드 확장을 동시에</strong> 수행하므로 일반 RRT보다 <strong>100배 이상 빠르게</strong> 경로를 찾아냅니다. 실제로 OMPL의 RRTConnect와 비교 시 평균 <strong>101배</strong> 속도 향상을 보였고, 특히 어려운 문제 구간에선 <strong>580배</strong>까지도 속도 차가 벌어졌습니다. 이는 CPU 기반 샘플링 기법이 가질 수밖에 없는 선형 증가(하나의 경로 점씩 검사) 과정을, cuRobo는 <strong>병렬 그래프 확장</strong>으로 획기적으로 바꾼 덕분입니다. 그러나 여전히 샘플링 경로는 최적화된 경로에 비해 길고 비효율적일 수 있어, cuRobo에서는 이 결과를 최종 솔루션으로 바로 쓰기보다는 최적화 알고리즘의 <strong>초기 시드</strong>로 활용하거나, 최적화가 실패할 경우 <strong>대비책</strong>으로 사용합니다.</p></li>
<li><p><strong>최적화 기반 기법 (예: CHOMP, TrajOpt 등)</strong>: 초기 경로가 주어지면 그 경로를 점진적으로 개선하여 충돌 없고 매끄러운 경로로 만드는 방법들입니다. <strong>CHOMP</strong>(Covariant Hamiltonian Optimization for Motion Planning) 같은 알고리즘은 경로를 수리적으로 미분가능한 함수로 보고 <strong>경사하강(gradient descent)</strong>을 통해 비용을 줄이는 방식을 최초로 보여준 기법입니다. 하지만 CHOMP는 CPU 기반으로 동작하며, 복잡한 환경에서는 <strong>수 초 이상의 계산시간</strong>이 걸릴 수 있고, 지역 최적해에 빠지면 실패율이 높다는 단점이 있습니다. 이후 나온 <strong>TrajOpt</strong>(Trajectory Optimization)은 CHOMP와 비슷한 목적을 갖되, 제약조건을 다루기 위해 <strong>이차 프로그래밍</strong>(QP) 풀이를 매 반복마다 수행하는 <strong>Sequential Convex Optimization</strong> 접근을 사용합니다. TrajOpt는 CHOMP보다 수렴이 빠르고 제약 다루기가 쉬워 여러 프레임워크에 통합되었지만, 여전히 <strong>충돌 체크</strong>나 <strong>복잡한 환경에서의 초기값 의존성</strong> 문제가 있습니다. cuRobo는 TrajOpt가 Tesseract에 통합된 버전과 직접 비교 실험을 했는데, <strong>평균 87배 빠르고, 최악의 경우 145배까지 빠르게</strong> 경로 최적화를 완료했습니다. 예를 들어 TrajOpt가 1.79초 걸리던 문제를 cuRobo는 <strong>단 0.01초(10ms)</strong> 만에 풀어낸 사례도 있었습니다. 게다가 TrajOpt는 각 문제를 <strong>단일 시드</strong>로 풀기에 실패하면 다른 시드로 재시작해야 하지만, cuRobo는 애초에 다중 시드를 병렬로 시도하여 <strong>한 번에 성공 확률을 높이므로 반복 재시도 횟수도 적습니다】. 이러한 이유로 </strong>전체 모션 플래닝 파이프라인**으로 보면 cuRobo가 TrajOpt 기반 플래너보다 훨씬 견고하고 빠릅니다 (실험에서 TrajOpt+RRT 방식을 60초까지 반복 재시도하게 했음에도 cuRobo보다 성공률과 품질이 낮았습니다).</p></li>
<li><p><strong>실시간 속도 프로파일러 (예: Ruckig)</strong>: 한편, <strong>Ruckig</strong> 라이브러리는 산업 현장에서 각광받는 <strong>실시간 모션 프로파일 생성기</strong>입니다. 이것은 경로 자체를 찾기보다는, 이미 정해진 경로(또는 단순히 시작-목표 두 점 사이)를 얼마나 빠르게/부드럽게 이동할지 <strong>속도-가속도-저크 한계 내 최적 시간</strong>을 계산해주는 알고리즘입니다. Ruckig는 입력으로 시작 상태(위치,속도,가속도)와 목표 상태(위치,속도,가속도)를 주면, <strong>이동 시간 최소화</strong>를 목표로 하면서도 지정된 <strong>최대 가속/저크 제약을 만족</strong>하는 속도 프로파일을 출력해줍니다. cuRobo와 Ruckig를 직접 비교하는 것은 애플-오렌지 격이지만, <strong>“jerk 제한”</strong>을 다룬다는 공통점이 있어 언급할 가치가 있습니다. Ruckig의 장점은 <strong>마이크로초 단위의 빠른 계산</strong>으로 로봇 제어 루프에 바로 넣을 수 있다는 점이지만, <strong>경로 상의 장애물은 전혀 고려하지 않기 때문에</strong> 주어진 경로 자체가 충돌 없는 것이어야 합니다. cuRobo는 훨씬 복잡한 문제(경로 탐색+속도 프로파일 동시 결정)를 다루므로 시간은 약간 더 들지만, 그 대신 <strong>장애물 회피를 포함한 전역 계획</strong>을 합니다. 논문에서는 Ruckig가 다룰 수 없는 <strong>중간 경유점이 있는 경우</strong>(waypoints 시나리오)에 대해 평가하려 했으나, Ruckig 라이브러리의 해당 기능은 공개 라이선스로 접근하기 어려워 비교하지 못했다고도 언급합니다. 이는 Ruckig가 주로 <strong>1회 구간(point-to-point) 모션</strong>에 최적화되어 있고, 여러 구간을 잇는 것은 제한이 있다는 의미로 해석됩니다. 요약하면, <strong>Ruckig = 동적 제약을 만족하는 세부 프로파일러</strong>, <strong>cuRobo = 전역 경로+프로파일 통합 솔루션</strong>으로 볼 수 있습니다. 실제 적용에서는, cuRobo로 큰 그림 경로를 찾은 뒤 Ruckig로 마지막 미세조정을 하는 조합도 생각해볼 수 있으나, cuRobo 자체도 <strong>jerk 최적화</strong>를 포함하므로 별도 조정 없이 바로 실행 가능한 수준의 결과를 줍니다.</p></li>
<li><p><strong>충돌 검사 라이브러리 (예: FCL 등)</strong>: 로봇 경로 계획의 한 축을 담당하는 것이 충돌 검사 알고리즘입니다. 앞서 설명한 FCL은 널리 쓰이는 충돌 라이브러리로, 로봇의 링크와 장애물의 메시 형상 간 <strong>최근접 거리</strong>나 <strong>충돌 여부</strong>를 빠르게 계산해주는 도구입니다. 그러나 복잡한 장면에서는 수천 - 수만 쌍의 삼각형 간 충돌을 계산해야 하므로 GPU 없이 CPU 단일 스레드로는 시간이 꽤 소요됩니다. cuRobo는 FCL 대신 자체 GPU 충돌 검사를 사용하며, <strong>로봇-환경 상호작용을 수학적 함수(거리 함수) 형태의 비용</strong>으로 통합했습니다. 구로 근사한 로봇 모델 덕분에 연속 충돌 비용의 <strong>그래디언트까지 계산 가능</strong>한 점은 기존 충돌 라이브러리들이 이진 충돌 여부만 체크하는 것과 대조적입니다. 덕분에 cuRobo의 최적화 알고리즘은 <strong>충돌 회피 그래디언트</strong>를 따라 경로를 밀어낼 수 있고, 이는 CHOMP 등의 철학과 유사하나 훨씬 병렬화되어 빨라진 형태라고 볼 수 있습니다. 결과적으로 cuRobo의 충돌 검사는 <strong>동일한 상황에서 기존 PyBullet 충돌 체크보다 최대 16000배 빠르며</strong>, 수만 개의 후보 자세를 동시에 평가할 수도 있어 향후 학습기반 모션 생성이나 몬테카를로 트리 탐색 등에서 <strong>충돌 체크 병목을 제거</strong>하는 데 기여할 수 있습니다.</p></li>
</ul>
<p>종합하면, <strong>cuRobo는 기존 방법들의 장점을 흡수하되 단점은 과감히 극복한 차세대 접근</strong>이라고 할 수 있습니다. 샘플링 기법의 전역 탐색 능력을 도입하되 병렬화로 속도 문제를 해결했고, 최적화 기법의 부드러운 경로 생성 능력을 발전시켜 저크까지 최소화했으며, 실시간 프로파일러 수준의 속도 제약 만족 능력을 통합했습니다. 그리고 이 모두를 가능케 한 것이 <strong>대규모 병렬 컴퓨팅 활용</strong>이라는 점에서, cuRobo는 로봇 모션 계획에 <strong>병렬화 패러다임</strong>을 성공적으로 이식한 사례로 평가됩니다.</p>
</section>
<section id="주요-실험-결과-및-활용-시나리오" class="level2" data-number="2.7">
<h2 data-number="2.7" class="anchored" data-anchor-id="주요-실험-결과-및-활용-시나리오"><span class="header-section-number">2.7</span> 주요 실험 결과 및 활용 시나리오</h2>
<p>cuRobo 논문에서는 다양한 환경에서의 실험 결과를 통해 그 유용한 활용 시나리오들을 제시합니다. <strong>MotionBenchMaker</strong>라는 벤치마크 데이터셋을 활용한 실험에서, 여러 가지 복잡한 장면(scene)들이 시험되었습니다. 예를 들어 <strong>협소한 cage 안에서 팔 뻗기</strong>, <strong>선반(shelf) 사이로 물체 집기</strong>, <strong>테이블 주위로 물체 옮기기</strong> 등, 산업 및 서비스 로봇에서 흔히 마주치는 상황들이 포함되었죠. 이러한 12가지 유형의 환경에 대해 Franka Panda 로봇이 충돌 없이 목표 위치로 팔을 움직이는 문제들이 생성되었고, cuRobo는 모든 환경에서 고르게 높은 성공률과 빠른 계획 시간을 보였습니다.</p>
<p>특히 <strong>복잡한 장애물 밀집 환경</strong>에서 cuRobo의 강점이 두드러졌는데, 이는 병렬 다중 시드 접근 덕분입니다. 예를 들어 <strong>“공” 모양 장애물이 가득한 3차원 공간</strong>이나 <strong>미로 형태의 장벽</strong>이 있는 경우, 전통적 최적화 방법은 초기 경로에 따라 쉽게 충돌 지역에서 못 빠져나오고 실패할 수 있지만, cuRobo는 수십 개의 경로를 동시에 시도하면서 하나라도 뚫리면 곧바로 찾아냅니다. 그리고 찾은 경로는 다시 최적화 과정을 거치며 더욱 다듬어지기 때문에, <strong>처음에는 구불구불하던 샘플링 경로가 결과적으로 매우 매끄럽고 짧은 경로</strong>로 개선됩니다.</p>
<p>또 하나의 시나리오는 <strong>다중 목표 순차 달성(Task Sequencing)</strong> 문제입니다. 산업현장에서 로봇은 종종 <strong>여러 지점을 순서 없이 주어지고 최적 경로로 순회</strong>해야 하는데, cuRobo는 그런 문제의 <strong>부분 경로(point-to-point)</strong>들을 빠르게 해결해줄 수 있습니다. 예컨대 10개의 픽업 포인트를 최적 순서로 방문하는 문제를 풀 때, 기존에는 각 구간 경로를 느린 모션 플래너로 풀어야 했지만, cuRobo를 쓰면 <strong>모든 구간 경로 비용을 신속히 계산</strong>해볼 수 있으므로, 상위 레벨에서 최적 순서 문제를 풀기 수월해집니다. 논문에서도 이러한 <strong>작업 스케줄링</strong>이나 <strong>경로 최적화(예: Traveling Salesman Problem 변형)</strong>에 cuRobo가 기여할 수 있음을 제시하고 있습니다.</p>
<p>현 실시간 제어 쪽 활용으로는, <strong>센서 피드백을 통한 동적 재계획</strong>에의 응용이 있습니다. 비록 현재 cuRobo 자체는 <strong>부분 관찰</strong> 문제(실시간으로 바뀌는 환경 인식)에 대응하는 로직은 없지만, 그 <strong>고속성</strong> 덕분에 센서로 새로운 장애물을 감지할 때마다 빠르게 재계획을 수행하는 방식으로 <strong>반응형 회피</strong>를 구현할 수 있습니다. 예를 들어 로봇 팔 작업 중 사람이 손을 넣는 등 돌발 상황이 생기면, cuRobo로 50ms 내 새 안전 경로를 찾아 즉각 로봇 움직임을 수정하는 형태로 사용할 수 있을 것입니다. 완전한 <strong>Reactive Planning</strong>에 대해서는 여전히 학술적으로 도전이 남아있지만 (cuRobo도 98% 난이도 케이스가 0.26초 걸렸듯 최악 경우 수백 ms - 1초 수준까지 걸릴 수 있기 때문에, 엄격한 실시간 고정주기에는 추가 연구 필요), 점진적으로 개선하여 향후 <strong>수 밀리초 내 경로 업데이트</strong>도 꿈꿔볼 수 있습니다.</p>
<p>그밖에 cuRobo의 <strong>병렬 IK</strong>는 <strong>로봇 가시성 영역 분석</strong> 등에 바로 활용 가능합니다. 논문에서는 3D 공간 격자상의 임의 자세 500개에 대해 cuRobo IK를 병렬 실행하여, 해당 자세에 도달 가능한지 여부(초록색/빨간색 구체로 표시)를 15Hz로 시각화하는 예시를 보였습니다. 이는 로봇의 작업범위나 특정 위치 접근 가능 여부를 실시간으로 계산해주는 유용한 도구로 쓰일 수 있습니다. 또한 cuRobo의 빠른 충돌 IK는 기존에 <strong>수 초 걸리던</strong> 샘플 기반 충돌회피 IK를 <strong>밀리초 단위</strong>로 가속하였기에, 앞으로 <strong>다관절 로봇의 자세 제약 문제</strong>(예: 동시에 여러 로봇 배치 최적화) 등에도 적용 가능성이 큽니다.</p>
<p>마지막으로, cuRobo가 <strong>여러 로봇 플랫폼에 이식</strong>된 사례도 소개됩니다. 연구진은 cuRobo를 Franka, UR 등 외에도 Nvidia Isaac 시뮬레이터 상의 <strong>Kinova Jaco</strong> 로봇팔, <strong>Allegro 손</strong> 등에도 적용해보았고, 기본 알고리즘이 로봇 기구학만 맞춰주면 공통으로 동작함을 확인했습니다. 따라서 특정 로봇에 하드코딩된 솔루션이 아니며, 범용 로봇 모션 계획 라이브러리로서 활용할 수 있음을 보여줍니다.</p>
</section>
<section id="결론-curobo의-장점과-한계-향후-발전-방향" class="level2" data-number="2.8">
<h2 data-number="2.8" class="anchored" data-anchor-id="결론-curobo의-장점과-한계-향후-발전-방향"><span class="header-section-number">2.8</span> 결론: cuRobo의 장점과 한계, 향후 발전 방향</h2>
<p><strong>cuRobo</strong>는 로봇 모션 생성 문제에 <strong>병렬화와 GPU 가속</strong>이라는 강력한 무기를 도입함으로써, <strong>속도, 성공률, 경로 품질</strong> 모든 면에서 새로운 표준을 제시한 솔루션입니다. 요약하면, cuRobo의 주요 <strong>장점</strong>은 다음과 같습니다:</p>
<ul>
<li><strong>획기적인 속도</strong>: 복잡한 충돌회피 경로도 <strong>밀리초 단위</strong>에 찾아내며, 기존 SOTA 방법 대비 수십 배 - 수백 배 빠릅니다. 이는 실시간 애플리케이션 및 고빈도 재계획에 필수적인 이점을 제공합니다.</li>
<li><strong>높은 신뢰도</strong>: 다중 시드 병렬 최적화 덕분에 <strong>사실상 100%에 근접하는 성공률</strong>로 경로를 찾아냅니다. 지역해 문제를 크게 완화하여, 까다로운 환경에서도 인간 수준으로 유연하게 경로를 견주어 찾습니다.</li>
<li><strong>부드럽고 안전한 경로</strong>: <strong>가속도-저크 최소화</strong>를 통해 로봇이 실행하기에 <strong>매우 매끄러운 움직임</strong>을 제공합니다. 이는 로봇 관절의 기계적 스트레스를 줄이고, 고속동작 시에도 <strong>진동이나 오차를 최소화</strong>하여 결국 작업 품질과 로봇 수명 향상으로 이어집니다.</li>
<li><strong>모듈화와 확장성</strong>: IK, 기하학 플래너, 최적화 모듈 등 <strong>구성요소별 모듈화</strong>로 필요에 따라 부분적으로 사용할 수 있고, 오픈소스로 공개되어 <strong>연구 커뮤니티의 참여와 개선</strong>이 가능합니다. 다양한 로봇에 쉽게 이식 가능하며, MoveIt 플러그인 등 <strong>기존 시스템과 연계</strong>도 지원됩니다.</li>
<li><strong>임베디드 친화성</strong>: GPU가 필요하긴 하지만, Jetson과 같은 임베디드 플랫폼에서도 구동될 만큼 경량 최적화가 되어 있어, <strong>현장 로봇에 직접 탑재</strong>하여 사용할 수 있습니다.</li>
</ul>
<p>반면, <strong>한계 및 향후 과제</strong>로 지적되는 부분도 몇 가지 있습니다:</p>
<ul>
<li><strong>동적/반응형 계획의 한계</strong>: 현재 cuRobo는 <strong>정지된 상태의 로봇</strong>이 <strong>정적인 환경</strong>에서 목표까지 가는 <strong>완전한 모션</strong>을 계획합니다. 만약 로봇이 움직이는 중간에 새로운 장애물이 나타나거나 목표가 변한다면, 이를 <strong>지속적으로 재계획하는 기능(reactive planning)</strong>은 아직 구현되어 있지 않습니다. 최악 경우 수백 ms 걸릴 수 있는 점을 고려하면, <strong>하드 실시간 제어 주기(예: 1kHz)</strong>에는 추가 연구가 필요합니다.</li>
<li><strong>복잡한 작업 제약</strong>: cuRobo는 기본적으로 <strong>말단-포즈 도달</strong> 문제에 초점을 맞추고 있습니다. 중간에 도구의 <strong>자세를 유지한다거나</strong> 특정 <strong>경로 제약(예: 컵을 기울이지 않게 운반)</strong> 등의 <strong>과업 제약이 있는 경로 계획</strong>에 대해서는 아직 일반적인 해법을 통합하지 않았습니다. 일부 Orientation constraint 등을 큰 가중치로 넣는 실험은 해보았으나, 이를 엄밀하게 다루는 전용 알고리즘(예: 제약된 탐색공간에서의 RRT 등)은 향후 과제로 남겨두었습니다.</li>
<li><strong>동역학 및 접촉 고려 부족</strong>: 현재 비용 함수는 <strong>로봇의 기구학적 움직임(관절 위치/속도/가속도)</strong>에 관한 항들로 이루어져 있습니다. 따라서 물체를 밀거나 잡는 등 <strong>접촉이 있는 계획</strong>, 혹은 <strong>토크 최적화</strong>나 <strong>에너지 최적화</strong> 같은 <strong>동적 요소</strong>는 포함되어 있지 않습니다. 이러한 부분을 다루려면 로봇의 동역학 모델까지 포함한 최적화(예: 토크 최소화, 임피던스 최적화 등)나 contact-implicit trajectory optimization 기법을 접목해야 하는데, 이는 연구적으로 난이도가 높지만 향후 확장 가능성으로 제시되었습니다.</li>
<li><strong>부분적인 환경 인식</strong>: cuRobo는 환경 모델이 <strong>완전히 주어져 있다는 전제</strong>하에 작동합니다. 센서 데이터로부터 실시간으로 환경 지도를 작성하거나, 보이지 않는 영역의 장애물을 추정하는 등의 <strong>퍼셉션 불확실성</strong> 하에서는 별도의 대책이 필요합니다. 논문에서는 학습 기반으로 <strong>미지 환경에 대한 충돌 비용추정</strong>을 통합하는 등 아이디어를 제시하지만, 아직 구현된 것은 아닙니다.</li>
<li><strong>전문 지식 요구</strong>: 비록 오픈소스로 제공되지만, cuRobo의 최적 성능을 끌어내거나 내부를 수정하려면 GPU 병렬 프로그래밍, 수치 최적화 등 <strong>상당한 전문성</strong>이 필요합니다. 다행히도 구조를 모듈화하여 외부 연구자들이 각 컴포넌트를 개선할 수 있게 해두었고, 실제로 학계 다른 연구자들이 cuRobo 코드를 참고해 <strong>로봇 알고리즘 전용 솔버</strong>를 개선하거나, <strong>하드 제약을 직접 풀어내는 기법</strong>을 접목하는 등의 시도를 하고 있습니다. 이런 협업을 통해 점차 진입장벽을 낮추고 활용성을 높여가는 것이 기대됩니다.</li>
</ul>
<p><strong>결론적으로</strong>, cuRobo는 로봇 모션 계획 분야에 <strong>새로운 속도와 품질의 지평</strong>을 연 매우 인상적인 연구成果입니다. GPU 병렬화의 이점을 극대화하여, 이전까지 수 초 걸리던 문제를 실시간으로 해결하고, 결과 궤적의 <strong>실용적 안정성</strong>까지 확보했다는 점에서, 앞으로 다양한 로봇 시스템에 응용될 것으로 보입니다. 향후 실시간 대응성 강화, 보다 복잡한 제약 조건 지원, 동역학 통합 등 남은 과제들을 해결한다면, cuRobo 혹은 그 파생 기술은 <strong>범용 로봇 모션 플래닝의 표준 툴</strong>로 자리매김할 가능성이 큽니다. 로봇공학 연구자들은 이 도구를 통해 더욱 빠르고 똑똑한 로봇을 구현할 수 있을 것이며, 동시에 남은 도전과제를 함께 풀어나감으로써 로봇의 움직임에 대한 이해와 제어 능력을 한층 발전시킬 수 있을 것입니다.</p>
<p><strong>참고 문헌</strong> (논문 및 관련 자료)</p>
<ul>
<li>Sundaralingam, B., et al.&nbsp;<em>“cuRobo: Parallelized Collision-Free Minimum-Jerk Robot Motion Generation.”</em> arXiv preprint arXiv:2310.17274 (2023) 등.</li>
<li>Github Repository: <strong>NVlabs/curobo</strong> (<a href="https://github.com/NVlabs/curobo">https://github.com/NVlabs/curobo</a>) .</li>
<li>NVIDIA Developer Blog: <em>“CUDA-Accelerated Robot Motion Generation in Milliseconds with cuRobo”</em> (2023).</li>
<li>MoveIt Plugin: <strong>Isaac ROS cuMotion</strong>.</li>
<li>기타 비교 기법: OMPL, TrajOpt, Ruckig, TracIK, PyBullet 등 관련 공식 문서 및 논문.</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>