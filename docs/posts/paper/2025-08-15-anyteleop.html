<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-08-15">
<meta name="description" content="A General Vision-Based Dexterous Robot Arm-Hand Teleoperation System">

<title>📃AnyTeleop 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ef56b68f8fa1e9d2ba328e99e439f80.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-b009f778f5cec7f34f624408a2b5b543.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review"><span class="header-section-number">1</span> Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review"><span class="header-section-number">2</span> Detail Review</a>
  <ul class="collapse">
  <li><a href="#기술적-기여-및-주요-아이디어-분석" id="toc-기술적-기여-및-주요-아이디어-분석" class="nav-link" data-scroll-target="#기술적-기여-및-주요-아이디어-분석"><span class="header-section-number">2.1</span> 기술적 기여 및 주요 아이디어 분석</a></li>
  <li><a href="#기존-연구와의-차별점" id="toc-기존-연구와의-차별점" class="nav-link" data-scroll-target="#기존-연구와의-차별점"><span class="header-section-number">2.2</span> 기존 연구와의 차별점</a></li>
  <li><a href="#실험-설정-및-결과-평가" id="toc-실험-설정-및-결과-평가" class="nav-link" data-scroll-target="#실험-설정-및-결과-평가"><span class="header-section-number">2.3</span> 실험 설정 및 결과 평가</a></li>
  <li><a href="#한계점-및-향후-연구-방향" id="toc-한계점-및-향후-연구-방향" class="nav-link" data-scroll-target="#한계점-및-향후-연구-방향"><span class="header-section-number">2.4</span> 한계점 및 향후 연구 방향</a></li>
  <li><a href="#종합-정리" id="toc-종합-정리" class="nav-link" data-scroll-target="#종합-정리"><span class="header-section-number">2.5</span> 종합 정리</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃AnyTeleop 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">teleoperation</div>
    <div class="quarto-category">vision</div>
  </div>
  </div>

<div>
  <div class="description">
    A General Vision-Based Dexterous Robot Arm-Hand Teleoperation System
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 15, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://arxiv.org/abs/2307.04577">Paper Link</a></li>
<li><a href="http://anyteleop.com/">Project Link</a></li>
</ul>
<ol type="1">
<li>✨ AnyTeleop은 다양한 로봇 팔과 손, 현실 환경, 카메라 설정에 사용 가능한 일반적인 비전 기반 로봇 원격 조작 시스템입니다.</li>
<li>🌐 이 시스템은 여러 시뮬레이터와 실제 환경을 지원하며, 원격 및 협업 원격 조작 기능까지 제공하여 데이터 수집의 확장성을 높입니다.</li>
<li>🚀 AnyTeleop은 범용적인 설계에도 불구하고 실제 및 시뮬레이션 실험에서 기존 시스템보다 뛰어난 성능을 달성하여, 모방 학습을 위한 고품질 데이터 수집을 용이하게 합니다.</li>
</ol>
<hr>
<section id="brief-review" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Brief Review</h1>
<p>AnyTeleop는 다양한 로봇 팔, 로봇 손, 현실(시뮬레이터 또는 실제 세계), 카메라 설정 및 다중 운영자 협업을 지원하는 범용적인 비전 기반 로봇 팔-손 원격 조작 시스템입니다. 기존의 비전 기반 원격 조작 시스템은 특정 로봇 모델이나 배포 환경에 맞춰 설계되어 로봇 모델의 다양성이나 운영 환경이 증가함에 따라 확장성이 떨어진다는 문제를 해결합니다. AnyTeleop는 단일 시스템 내에서 이러한 다양한 시나리오를 지원하면서도 우수한 성능을 달성합니다. 실제 환경 실험에서 AnyTeleop는 동일한 로봇을 사용하여 특정 하드웨어에 맞게 설계된 이전 시스템보다 더 높은 성공률을 보였고, 시뮬레이션 원격 조작에서는 해당 시뮬레이터를 위해 특별히 설계된 이전 시스템보다 더 나은 Imitation Learning 성능을 이끌어냈습니다.</p>
<p>시스템은 모듈성, 통신 중심 설계, Containerization이라는 세 가지 핵심 원칙으로 설계되었습니다. 카메라는 Camera Driver를 통해 RGB 또는 RGB-D 스트림을 Teleoperation Server로 전송합니다. Teleoperation Server는 입력 데이터를 처리하여 로봇 제어 명령을 생성하며, 이 명령은 Teleoperation Client를 통해 시뮬레이터나 실제 로봇으로 전달됩니다. Web Visualizer는 로컬 또는 원격에서 원격 조작 과정을 시각적으로 피드백합니다.</p>
<p>Teleoperation Server는 다음 네 가지 주요 모듈로 구성됩니다.</p>
<ol type="1">
<li>Hand Pose Detection: 카메라 스트림에서 사람 손의 손목(wrist) 및 손가락(finger) 자세를 예측합니다. RGB 또는 RGB-D 카메라, 단일 또는 다중 카메라 등 다양한 카메라 구성을 지원합니다. 손가락 키포인트(keypoint)는 MediaPipe를 사용하여 RGB 데이터로부터 검출하며, 손목 6D 자세는 RGB-D 데이터의 경우 키포인트의 Depth 값을 이용한 PnP 알고리즘으로, RGB 데이터만 있는 경우 FrankMocap에서 영감을 받은 추가 신경망을 사용하여 약한 투영(weak perspective) 변환 스케일을 예측하는 방식으로 추정합니다.</li>
<li>Detection Fusion: 다중 카메라 감지 결과를 통합합니다. 외적 캘리브레이션 없이 사람 손을 자연 마커(marker)로 사용하는 자동 캘리브레이션 과정을 통해 카메라 간의 상대적인 회전(SO(3))을 계산합니다. 각 감지 결과의 신뢰도는 SMPL-X 손 형상 매개변수 예측값의 일관성(초기 참조 값과의 오차)을 기준으로 평가하며, 신뢰도가 가장 높은 카메라의 상대 동작을 선택하여 다음 모듈로 전달합니다.</li>
<li>Hand Pose Retargeting: 사람 손 자세 데이터를 로봇 손 관절 위치로 매핑합니다. 이는 최적화 문제로 공식화됩니다. 사람 손과 로봇 손의 키포인트 벡터 간 차이를 최소화하고 시간적 부드러움을 개선하는 목적 함수를 최소화합니다. <span class="math display">
\min_{q_t} \sum_{i=0}^N ||\alpha v_i^t - f_i(q_t)||^2 + \beta ||q_t - q_{t-1}||^2 \\
\text{s.t.} \quad q_l \leq q_t \leq q_u
</span> 여기서 <span class="math inline">q_t</span>는 시간 <span class="math inline">t</span>에서의 로봇 손 관절 위치, <span class="math inline">v_i^t</span>는 감지된 사람 손 키포인트에서 계산된 <span class="math inline">i</span>번째 키포인트 벡터, <span class="math inline">f_i(q_t)</span>는 로봇 손 관절 위치 <span class="math inline">q_t</span>를 입력받아 <span class="math inline">i</span>번째 로봇 손 키포인트 벡터를 계산하는 순방향 기구학 함수, <span class="math inline">q_l</span>과 <span class="math inline">q_u</span>는 관절 위치의 하한 및 상한, <span class="math inline">\alpha</span>는 손 크기 차이를 고려한 스케일링 계수, <span class="math inline">\beta</span>는 시간적 부드러움에 대한 가중치입니다. 다른 로봇 손 형태에 대해서는 사람과 로봇 손가락 사이의 키포인트 매핑을 수동으로 지정해야 합니다. 이 모듈은 로봇 손만 고려합니다.</li>
<li>Motion Generation: 감지된 손목 및 손 자세(최종 End-effector의 Cartesian 자세)를 기반으로 로봇 팔의 부드럽고 충돌 없는 움직임을 생성합니다. 실시간 모션 생성을 위해 GPU 가속 병렬화 충돌 회피 로봇 모션 생성 라이브러리인 CuRobo를 사용합니다. Motion Generation 모듈은 낮은 주파수(25 Hz)로 End-effector의 Cartesian 자세를 받아 높은 주파수(120 Hz)로 충돌 없는 관절 공간 궤적을 생성합니다. 충돌 회피는 CUDA 기반 기하학적 질의를 사용하여 학습 기반 모델 없이 수행됩니다.</li>
</ol>
<p>Web-based Teleoperation Viewer는 meshcat 및 Three.js를 기반으로 개발되었으며, 브라우저 기반의 접근성과 원격 및 협업 원격 조작을 위한 동기화된 시각화를 지원합니다. 다중 브라우저 창을 열어 다중 시점(multi-view)을 제공할 수 있습니다.</p>
<p>시스템 평가 결과, Profiling 분석에서 Hand Pose Detection이 가장 시간이 많이 소요되는 모듈이지만 요구 주파수(25Hz)를 충족합니다. 실제 로봇 원격 조작 실험에서는 XArm6 및 Allegro Hand를 사용하여 Robotic Telekinesis [54]의 10가지 조작 작업을 재현하여 비교했습니다. AnyTeleop는 10개 작업 중 8개에서 더 높은 성공률을 보였으며, 특히 컵 쌓기 등 얇은 구조의 객체 조작에서 더 안정적인 성능을 보여, 특정 하드웨어에 맞게 설계된 시스템보다 우수함을 입증했습니다. Imitation Learning 응용에서는 AnyTeleop로 수집된 데이터가 SAPIEN 환경에서 [43]의 데이터보다 더 부드럽고 자체 충돌 없는 궤적을 제공하여 더 나은 Imitation Learning 성능을 이끌어냈습니다. 또한, AnyTeleop는 다중 운영자가 서로 다른 로봇을 제어하여 협업 조작 작업을 수행하는 설정을 지원할 수 있음을 Human-to-robot Handover 작업 시연을 통해 보여주었습니다.</p>
<p>실패 모드로는 빠른 손 움직임 중 추적 손실 및 자체 가림(self-occlusion) 시 불안정한 손 자세가 있습니다. 전자는 운영자가 손 움직임을 늦추도록 지시하고, 후자는 다중 카메라를 사용하여 완화할 수 있습니다.</p>
<p>결론적으로 AnyTeleop는 다양한 로봇, 현실, 카메라 설정 및 운영자 수에 적용 가능한 다목적 원격 조작 시스템입니다. 뛰어난 일반성 및 유연성을 제공하며, 시뮬레이션 및 실제 환경 모두에서 이전 시스템보다 우수한 성능을 보여줍니다. 오픈 소스화를 통해 원격 조작 분야의 추가 연구에 기여할 것입니다.</p>
<hr>
</section>
<section id="detail-review" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Detail Review</h1>
<section id="기술적-기여-및-주요-아이디어-분석" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="기술적-기여-및-주요-아이디어-분석"><span class="header-section-number">2.1</span> 기술적 기여 및 주요 아이디어 분석</h2>
<p>사람의 섬세한 손동작을 로봇 팔-손 시스템으로 원격 조작(teleoperation)하는 것은 로봇에게 인간 수준의 지능적인 물체 조작 능력을 부여하는 유망한 접근법입니다. 특히 <strong>비전 기반</strong> 원격 조작은 값비싼 장비 없이 카메라만으로 이러한 목표를 달성할 수 있어 큰 주목을 받고 있습니다. 그러나 기존의 비전 기반 원격 조작 시스템들은 대개 <strong>특정 로봇 모델</strong>이나 <strong>정해진 환경</strong>만을 염두에 두고 설계되어 왔습니다. 이에 따라 새로운 로봇이나 다양한 작업 환경이 추가되면 시스템을 확장하기 어려운 한계가 있었습니다. 또한 대부분 <strong>한 가지 현실(시뮬레이션 또는 실제)</strong>에만 국한되거나, <strong>단일 조종자-로봇 상호작용</strong>만 지원하여 다중 로봇 협업에는 대응하지 못했습니다. 이러한 한계를 극복하기 위해 이 논문에서는 <strong>AnyTeleop</strong>이라는 범용 비전 기반 원격 조작 시스템을 제안합니다. AnyTeleop의 핵심 아이디어와 기술적 기여는 다음과 같습니다:</p>
<ul>
<li><strong>범용성과 통합성:</strong> AnyTeleop은 하나의 시스템으로 <strong>다양한 로봇 팔 및 다지(多指) 로봇 손</strong> 조합을 지원하고, <strong>여러 종류의 현실</strong>(여러 시뮬레이터 플랫폼 또는 실제 환경)에서 동작할 수 있으며, <strong>원격지</strong>에서도 웹 브라우저를 통한 <strong>실시간 시각 피드백</strong>으로 조작이 가능하고, <strong>RGB 또는 RGB-D 카메라</strong> 여러 대를 활용한 <strong>유연한 카메라 구성</strong>을 허용하며, 나아가 <strong>다수의 운영자가 각기 다른 로봇을 동시에 조작</strong>하여 협업할 수 있습니다. 즉 <strong>하나의 통합 시스템</strong>으로 “모든(Any) 테레오퍼레이션” 상황을 아우르는 유연성을 달성했습니다.</li>
</ul>
<center>
<img src="../../images/2025-08-15-anyteleop/image-20250817172035265.png" width="100%">
</center>
<blockquote class="blockquote">
<p><em>AnyTeleop 시스템이 다양한 시나리오에서 조작 작업을 수행하는 예시.</em> 상단 행은 IsaacGym 등 가상 시뮬레이터 상에서의 로봇 조작, 중단 행은 또 다른 시뮬레이터(SAPIEN) 상의 조작, 하단 행은 실제 로봇(XArm6+Allegro)이 컵 쌓기 등 일상 물체를 다루는 모습입니다. 이러한 다양한 환경과 작업에서 <strong>일관된 원격 조작 프레임워크</strong>를 제공하는 것이 AnyTeleop의 목표입니다.</p>
</blockquote>
<ul>
<li><p><strong>모듈화된 아키텍처:</strong> AnyTeleop은 <strong>카메라로부터 사람 손의 동작을 추적</strong>하고 이를 로봇 동작으로 변환하는 일련의 파이프라인을 모듈화하여 설계했습니다. 구체적으로, <strong>① 손 자세 인식 모듈</strong>(Hand Pose Detection)은 단일 혹은 복수의 RGB/RGB-D 카메라 입력으로부터 사람 손의 3차원 관절 위치(keypoint)를 추정합니다. 여러 카메라를 사용할 경우 <strong>② 다중 카메라 융합 모듈</strong>(Detection Fusion)이 각 카메라에서 얻은 손 추적 결과를 통합하여, 한 카메라에서 손이 가려져도 다른 시점 정보를 활용해 <strong>자기 가림(self-occlusion)</strong> 문제를 완화합니다. 그리고 <strong>③ 손 자세 리타게팅 모듈</strong>(Hand Pose Retargeting)이 사람 손의 관절각을 로봇 손의 관절각으로 변환하는데, 로봇의 URDF(기구학 모델) 정보만 있다면 <strong>학습된 모델 없이</strong>도 임의의 로봇 손 구조에 대응할 수 있도록 <strong>최적화 기반 알고리즘</strong>을 사용했습니다. 마지막으로 <strong>④ 모션 생성 모듈</strong>(Motion Generation)은 목표로 한 손목(End-effector)의 위치와 자세를 로봇 팔이 부드럽고 <strong>충돌 없이</strong> 따라가도록 <strong>실시간 경로 생성</strong>을 수행합니다. 본 논문에서는 NVIDIA의 GPU 가속 모션 계획 라이브러리인 <strong>CuRobo</strong>를 활용하여 120Hz 이상의 고주파수로 자연스러운 로봇 팔 움직임을 생성하며, 로봇의 자기 충돌이나 관절 한계 위반이 없도록 제어합니다.</p></li>
<li><p><strong>웹 기반 원격 조작:</strong> AnyTeleop은 <strong>웹 시각화 인터페이스</strong>를 제공하여, 원격지에 있는 운영자도 손쉽게 브라우저를 통해 로봇의 3D 환경을 실시간으로 모니터링하고 조작할 수 있게 했습니다. MeshCat/Three.js 기반으로 구현된 뷰어는 시뮬레이터나 실제 로봇으로부터 주기적으로 장면 정보를 받아와 동기화된 영상을 제공합니다. 이로써 공간적으로 떨어진 다수의 사용자들도 동일한 가상 환경을 보며 <strong>협동 작업</strong>을 수행할 수 있습니다. 또한 이러한 웹 기반 접근은 특정 시뮬레이터에 종속되지 않는 <strong>시뮬레이터 불가지론적</strong> 시각화를 가능케 하여, IsaacGym이든 SAPIEN이든 동일한 방식으로 원격 조작을 지원합니다.</p></li>
</ul>
<p>요약하면, AnyTeleop은 <strong>모든 구성요소를 표준 인터페이스로 분리</strong>하여 필요에 따라 손쉽게 교체하거나 확장할 수 있고, 소프트웨어적으로 도커(container)로 배포되어 복잡한 의존성 설정 없이 <strong>손쉽게 설치 및 실행</strong>할 수 있도록 구현되었습니다. 이러한 <strong>범용적이면서도 성능을 놓치지 않은</strong> 설계 철학 덕분에, AnyTeleop은 다양한 조건에서 안정적으로 동작하면서도 인간 조종자의 섬세한 동작을 로봇에 충실히 재현해냅니다.</p>
</section>
<section id="기존-연구와의-차별점" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="기존-연구와의-차별점"><span class="header-section-number">2.2</span> 기존 연구와의 차별점</h2>
<p>과거의 로봇 원격 조작 연구들은 주로 <strong>특수 장비</strong>에 의존하거나 <strong>한정된 기능</strong>만을 제공했습니다. 예를 들어 초기의 섬세한 손 조작 원격 제어는 데이터 장갑, 모션 캡처 수트, VR 컨트롤러, 햅틱 장치 등의 고가 하드웨어를 착용한 상태에서 수행되는 경우가 많았습니다. 반면 AnyTeleop은 <strong>카메라 하나만으로</strong> 사람 손의 움직임을 인식함으로써 장비 비용과 사용자 부담을 크게 낮추었습니다. 최근 등장한 비전 기반 원격 조작 시스템들도 있었지만, 이들 역시 각자 특정 로봇에 맞게 튜닝되어 범용성이 떨어지는 단점이 있었습니다. 예컨대 <strong>DexPilot (2020)</strong>은 KUKA LBR 팔 + Allegro Hand 조합을 비전으로 조작했지만 특정 하드웨어에 맞춘 보정(calibration)과 심도 카메라 등을 필요로 했고, <strong>Robotic Telekinesis (2023)</strong>와 같은 시스템은 XArm6 + Allegro에 특화된 <strong>학습된 리타게팅 모델</strong>과 <strong>충돌회피 모델</strong>을 사용하여 다른 로봇에는 적용이 어려웠습니다. 또한 <strong>Holo-Dex (2022)</strong>나 <strong>DIME (2022)</strong> 등의 연구는 AR/VR 장치를 통해 몰입감 있게 조작하거나, 학습 기반으로 효율적인 모방을 꾀했지만, <strong>로봇 손만 제어</strong>하고 <strong>로봇 팔은 고려하지 않는</strong> 등 시스템 범위가 제한적이었습니다. 이처럼 기존 연구들은 각각 일부 기능에 초점을 맞추었을 뿐, <strong>여러 로봇과 환경을 통합적으로 지원</strong>하거나 <strong>협업 시나리오</strong>까지 포괄하지는 못했습니다.</p>
<p>이에 비해 AnyTeleop의 가장 큰 차별점은 <strong>범용적 모듈성</strong>과 <strong>확장성</strong>입니다. 사람 손 추적부터 로봇 제어까지의 전 과정을 모듈화하고 표준화함으로써, <strong>새로운 로봇 팔-손 시스템이나 새로운 환경에도 즉각 대응</strong>할 수 있습니다. 예를 들어, 다른 형태의 로봇 손을 사용하려면 해당 URDF 기구학 모델만 제공하면 되고, 별도의 신경망 재학습 없이 곧바로 리타게팅과 제어가 가능합니다. 충돌 회피 역시 특정 로봇에 특화된 모델 대신 <strong>CUDA 기반 기하 계산</strong>으로 처리하여, 로봇 모양만 주어지면 즉석에서 충돌을 검사하고 회피경로를 산출합니다. 이러한 학습 비의존적 접근 덕분에 <strong>새로운 로봇 추가나 환경 변경 시 발생하는 데이터 수집 및 모델 재교육 비용이 거의 들지 않으며</strong>, 시스템이 자동적으로 일반화될 수 있습니다. 반면 기존 시스템들은 새로운 로봇마다 모션 변환기를 다시 학습시키거나 환경별로 손동작 데이터셋을 다시 수집해야 했기에 확장성이 낮았습니다.</p>
<p>또 다른 차별화 지점은 <strong>협업 및 멀티-로봇 지원</strong>입니다. 이전의 비전 기반 원격 조작 연구들은 대부분 한 명의 인간 조작자가 한 대의 로봇만 다루는 시나리오에 머물렀습니다. AnyTeleop은 처음으로 <strong>두 명 이상의 사람이 각자의 로봇을 동시에 조작</strong>하여 <strong>공동의 작업</strong>을 수행하는 비전 기반 시스템을 선보였습니다. 예컨대 한 운영자가 물체를 집어 다른 로봇에게 건네주고, 다른 운영자가 그 로봇을 통해 이를 받아 최종 목표 지점에 두는 식의 <strong>다중 로봇 협동</strong>도 구현됩니다 (뒤의 실험 결과 참조). 이러한 기능은 이전 연구에서는 보고된 바 없어 AnyTeleop의 <strong>독보적인 기능적 차별성</strong>이라 할 수 있습니다.</p>
<p>종합하면, AnyTeleop은 기존의 원격 조작 연구들이 개별적으로 추구하던 목표들(예: 저비용 비전 기반 추적, 범용 로봇 지원, 시뮬레이션 활용, 협업 등)을 <strong>단일 시스템에 통합</strong>함으로써 실현했다는 점에서 의미가 큽니다. 이를 통해 성능 저하 없이도 <strong>더 넓은 적용 범위</strong>를 커버하며, 실제로 실험을 통해 이전 특수목적 시스템들보다 <strong>더 나은 성능</strong>을 입증하였습니다. 즉 AnyTeleop은 <strong>범용성 vs.&nbsp;성능</strong>의 트레이드오프를 극복한 사례로 평가됩니다.</p>
</section>
<section id="실험-설정-및-결과-평가" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="실험-설정-및-결과-평가"><span class="header-section-number">2.3</span> 실험 설정 및 결과 평가</h2>
<p>논문 저자들은 AnyTeleop의 성능을 <strong>정량적 실험</strong>을 통해 검증하기 위해, <strong>실제 로봇 실험</strong>과 <strong>가상 시뮬레이션 실험</strong>을 모두 수행했습니다.</p>
<ul>
<li><strong>실제 로봇 실험:</strong></li>
</ul>
<p>기존 <strong>Robotic Telekinesis</strong> 시스템과의 성능 비교를 위해, 동일한 로봇 하드웨어인 <em>HxArm6</em> 로봇 팔과 <em>Allegro</em> 로봇 손을 사용했습니다. 실험에 사용된 <strong>작업(task)</strong>들은 Telekinesis 논문에서 제시된 10가지 조작 작업으로, 작은 상자를 집어 옮기기, 천으로 만든 장난감 집기, 상자 회전시키기, 가위 잡기, 컵 포개 쌓기, 이중 컵 쌓기, 상자에 든 큐브를 접시로 붓기, 컵을 접시에 옮겨 담기, 서랍 열기, 서랍 열고 물건 집어내기 등이 포함됩니다. 각 작업에 대해 숙련된 조작자가 AnyTeleop을 통해 10번씩 시도를 하였고, 단일 <strong>Intel RealSense RGB-D 카메라</strong>로 손동작을 추적했습니다. Telekinesis (기존 시스템)의 경우 해당 논문에 보고된 성공률을 그대로 비교 대상으로 사용했습니다. <strong>성공률 측정</strong>은 10회 시도 중 작업 목표를 완수한 비율로 정의되었습니다.</p>
<p><strong>결과:</strong></p>
<p>비교 결과 AnyTeleop은 <strong>10개 중 8개 작업에서 더 높은 성공률</strong>을 보였고, <strong>나머지 2개 작업에서는 대등한 성능(동일 성공률)</strong>을 나타냈습니다. 구체적으로, 예를 들어 <em>두 개의 컵 쌓기</em> 작업의 경우 기존 시스템 성공률이 30%에 그쳤던 반면 AnyTeleop은 <strong>70%의 성공률</strong>을 달성했고, <em>컵을 접시에 옮기기</em> 작업도 기존 80%에서 AnyTeleop은 <strong>100% 성공</strong>으로 향상되었습니다. 대부분의 작업에서 AnyTeleop이 향상된 성과를 보였으며, <em>상자 회전</em>이나 <em>큐브 붓기</em> 같은 작업에서는 두 시스템 모두 유사한 성공률을 보였습니다. 흥미롭게도 저자들은 AnyTeleop의 <strong>우수한 성능 요인</strong>으로, <strong>얇은 벽 구조의 물체(컵 등)를 다루는 작업에서의 강점</strong>을 꼽았습니다. AnyTeleop의 <strong>최적화 기반 손 리타게팅 모듈</strong>은 사람 손가락 사이 거리를 로봇 손가락도 최대한 좁혀서 섬세하게 재현하기 때문에, 얇은 컵을 단단히 쥐는 동작을 성공적으로 모사했습니다. 반면 Telekinesis의 <strong>신경망 기반 리타게팅</strong>은 이러한 미세한 그립(grip) 동작을 정확히 전달하지 못해 컵을 놓치는 경우가 있었다고 분석합니다. 요컨대 AnyTeleop은 <strong>더 범용적인 시스템임에도 불구하고 특정 하드웨어에 맞춰진 기존 시스템보다 오히려 높은 조작 성공률</strong>을 보여주었고, 특히 <strong>정밀한 손가락 제어가 필요한 작업에서 두드러진 강점</strong>을 입증했습니다.</p>
<p><strong>시뮬레이션 및 모방학습 실험:</strong></p>
<p>AnyTeleop의 범용성은 가상 환경에서도 시험되었습니다. 저자들은 로봇 학습에서 중요한 <strong>인간 시연 데이터 수집</strong> 용도를 평가하기 위해, 시뮬레이터 상에서 원격 조작으로 모방 학습용 데이터를 모으고 그 품질을 비교했습니다. 비교 대상으로는 최근 발표된 비전 기반 원격 조작 시스템인 Qin 등 (2022)을 선정했는데, 이 시스템은 <strong>단일 RGB-D 카메라</strong>로 <strong>부유하는 손(floating hand)</strong>만 조작할 수 있는 제한이 있었습니다. 실험에 사용된 <strong>조작 작업</strong>들은 해당 기존 연구와 동일하게 3가지로 설정되었으며, (i) 탁자 위 물체를 집어 다른 위치로 옮기는 <em>위치 이동(Relocate)</em>, (ii) 뒤집혀 놓인 머그잔을 90도 회전시켜 올려놓는 <em>머그 뒤집기(Flip Mug)</em>, (iii) 문 손잡이를 돌려 잠금을 풀고 문을 당겨 여는 <em>문 열기(Open Door)</em> 입니다. 각 작업은 <strong>부유 손(floating hand)</strong> 버전과 <strong>팔이 달린 손(arm-hand)</strong> 버전 두 가지 변형으로 수행되었습니다. 부유 손은 로봇 팔이 없는 자유롭게 움직이는 손만으로 조작하는 경우이고, 팔-손 버전은 로봇 팔 끝에 손이 달려있어 고정된 기반(base)을 갖는 현실적인 경우입니다.</p>
<p><strong>데이터 수집 및 학습:</strong></p>
<p>우선, 기존 시스템과 AnyTeleop을 이용하여 각 작업당 <strong>50개 시연(trajactory)</strong> 데이터를 수집했습니다. 기존 시스템은 부유 손 형태만 직접 조작 가능했기에, 팔-손 버전 시연을 얻기 위해 저자들이 별도의 <strong>시연 변환 과정</strong>을 적용했습니다. 반면 AnyTeleop은 처음부터 팔-손 조작을 지원하므로, 팔-손 형태로 50개 시연을 수집한 뒤 이를 부유 손 형태로 변환하여 두 방식 모두에 활용했습니다. 이렇게 얻은 시연 데이터로 <strong>Demo Augmented Policy Gradient (DAPG)</strong> 알고리즘을 이용해 모방 학습 정책을 훈련하였고, 비교를 위해 <strong>순수 강화학습(RL)</strong>으로만 훈련한 정책도 함께 평가했습니다. 각 방법에 대해 서로 동일한 신경망 구조와 보상 설계를 사용하여 공정성을 유지했습니다. 최종 정책들은 3개의 시드로 학습되어, <strong>각각 100회 에피소드 평가</strong>를 통해 성공률을 산출했습니다.</p>
<p><strong>결과:</strong></p>
<p><strong>Table VI</strong>에 보고된 결과에 따르면, AnyTeleop을 통해 수집한 시연으로 학습한 정책이 <strong>6개의 평가 시나리오 중 5개에서</strong> 기존 시스템 시연으로 학습한 정책보다 높은 성공률을 기록했습니다. 또한 이 정책들은 사람 시연 없이 강화학습만으로 훈련한 정책보다도 월등히 높은 성능을 보였습니다. 특히 <strong>팔-손 조작이 포함된 과제들</strong>에서 AnyTeleop 기반 정책의 성능 향상이 두드러졌는데, 그 이유는 다음과 같습니다. (i) AnyTeleop으로 얻은 시연 궤적은 <strong>매우 부드럽고 자연스러운 연결 동작</strong>으로 이루어져 있어, 상태-행동 쌍이 일관되고 학습하기 용이했습니다. 반면 기존 시스템의 시연 데이터는 손동작이 불연속적으로 추정되거나 팔 움직임 생성 시 다소 튐(jitter)이 있어 학습 난이도가 높았습니다. (ii) AnyTeleop은 <strong>팔-손 시스템을 직접 조작</strong>하면서 <strong>자기 충돌이 발생하지 않도록 제약</strong>을 거는 등 물리적으로 <strong>유효한 시연만을 수집</strong>합니다. 하지만 기존 시스템은 팔이 없는 손 시연을 사후에 로봇 팔에 재현(retargeting)하는 방식을 쓰다 보니, 그 과정에서 로봇 팔이 자기 자신을 때리는 등의 <strong>충돌이 포함된 시연</strong>이 여럿 발생했습니다. 이러한 차이로 인해 팔-손 조작 과제들에서 AnyTeleop 시연으로 학습한 정책이 훨씬 높은 성공률을 얻은 것입니다. 한 가지 예외적으로, <em>팔을 이용한 머그 뒤집기</em> 과제에서는 두 시스템의 학습 정책 성능이 비슷했는데, 저자들은 <strong>팔이 있는 상태로 머그를 뒤집는 시연 자체가 매우 어렵고</strong> AnyTeleop으로도 해당 데모의 품질이 떨어졌기 때문이라고 분석했습니다.</p>
<p>종합하면, <strong>AnyTeleop을 통한 원격 조작 데모가 기존 시스템보다 질적으로 우수</strong>하며, 이는 <strong>다운스트림 로봇 학습 성능 향상</strong>으로 직접 이어짐을 보였습니다. 이로써 AnyTeleop의 범용성이 <strong>단순히 여러 로봇을 조작할 수 있다는 것뿐만 아니라</strong>, <strong>실제 활용 가치</strong> 측면에서도 더 나은 데이터를 제공한다는 점이 입증되었습니다.</p>
<ul>
<li><strong>협동 조작 시연:</strong> 앞서 언급한 <strong>다중 운영자 협업</strong> 시나리오의 가능성도 실험적으로 보여주었습니다. 저자들은 예시로 한 명의 사람 조종자가 로봇 팔 A를 이용해 물체를 집어 다른 로봇 팔 B에게 건네주고, 두 번째 조종자가 그 로봇 B를 제어해 물체를 받는 <strong>“사람→로봇 핸드오버”</strong> 과제를 수행했습니다. 구체적으로, <strong>운영자 1</strong>은 <em>UR10 팔 + Schunk 5지 로봇 손</em>을 AnyTeleop으로 조작하여 테이블 위 물체를 집어 들고, <strong>운영자 2</strong>는 <em>KUKA 팔 + Shadow 로봇 손</em>을 조작하여 그 물체를 건네받았습니다. 이 협업 시나리오는 두 운영자가 <strong>같은 가상 환경</strong>을 실시간으로 바라보면서 동작을 조율해야 했는데, AnyTeleop의 <strong>웹 기반 동기화 뷰어</strong>를 통해 두 사용자 화면에 항상 동일한 장면이 표시되고, 각자의 손동작이 중앙 <strong>시뮬레이션 서버</strong>에서 통합되어 두 로봇의 움직임으로 반영됨으로써 가능했습니다. <strong>그림 4</strong>는 이 핸드오버 작업의 한 장면을 보여주는데, 왼쪽의 흰색 UR10-슁크 로봇이 물체를 건네고 오른쪽 주황색 KUKA-섀도우 로봇이 그것을 받는 모습입니다.</li>
</ul>
<center>
<img src="../../images/2025-08-15-anyteleop/image-20250817172921843.png" width="70%">
</center>
<center>
<img src="../../images/2025-08-15-anyteleop/image-20250817172900752.png" width="70%">
</center>
<blockquote class="blockquote">
<p><em>두 운영자가 원격으로 각기 다른 로봇 팔-손을 조작하여 물체를 주고받는 협동 조작 예시.</em> AnyTeleop의 중앙 서버-다중 유닛 구조를 활용하면 물리적으로 떨어진 장소에 있는 사용자들도 마치 한 공간에서 두 로봇을 함께 조작하는 것처럼 <strong>협응(coordinate)</strong>할 수 있습니다. 해당 데모는 <strong>정량적 수치</strong>로 평가되지는 않았지만, AnyTeleop이 <strong>협업 데이터 수집</strong>에도 유용하게 쓰일 수 있음을 보여줍니다. 저자들은 사람이 둘 이상 필요한 로봇 작업(예: 무거운 물체 공동 운반, 조립 작업 등)의 시연 데이터를 얻는 것이 얼마나 어려운지 언급하며, AnyTeleop이 이러한 <strong>복잡한 시나리오의 데이터 수집을 손쉽게 해주는 도구</strong>가 될 수 있다고 강조합니다.</p>
</blockquote>
</section>
<section id="한계점-및-향후-연구-방향" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="한계점-및-향후-연구-방향"><span class="header-section-number">2.4</span> 한계점 및 향후 연구 방향</h2>
<p>AnyTeleop은 현재까지의 원격 조작 시스템 중 가장 범용적이고 성능도 뛰어났지만, 여전히 몇 가지 <strong>한계점</strong>과 <strong>도전 과제</strong>가 존재합니다.</p>
<ul>
<li><p><strong>비전 기반 손 추적의 한계:</strong> AnyTeleop은 상업용 카메라와 딥러닝 기반 손 인식에 의존하기 때문에, <strong>사람 손이 너무 빠르게 움직일 경우 추적이 따라가지 못해 손실</strong>되는 문제가 있습니다. 실제 실험 중에도 조종자가 손을 급격히 휘두르면 시스템이 일시 정지한 뒤 손 위치를 재인식(re-detection)해야 하는 상황이 발생했습니다. 또한 단일 카메라로 손을 볼 때 <strong>손의 일부가 자기 몸으로 가려지면</strong> 인식된 손 자세의 정확도가 떨어지는 현상이 있습니다. 이러한 문제를 완화하기 위해 현재는 <strong>“천천히 움직이라”</strong>고 조종자에게 안내하거나, <strong>여러 대의 카메라</strong>를 배치하여 다양한 각도에서 손을 관찰하는 방식을 사용합니다. 그러나 이는 근본적인 해결책이 아니므로, <strong>향후 연구</strong>로 더 향상된 손 추적 비전 알고리즘을 도입하거나 딥러닝 모델을 개선하여 <strong>속도와 정확도를 높이는 방향</strong>이 필요합니다. 예컨대, 빠른 동작 예측을 위한 <strong>추론 프레임 보간</strong>이나, <strong>자기 가림 상황을 극복할 수 있는 3D 모델 기반 추적</strong> 기법 등을 적용해볼 수 있을 것입니다.</p></li>
<li><p><strong>실시간 시스템 성능:</strong> AnyTeleop이 원활한 조작을 위해 요구하는 일부 기술적 사양도 한계로 지적됩니다. 논문에 따르면 손 추적 모듈은 GPU 상에서 25Hz 정도로 동작하고, 로봇 팔 모션 생성은 100Hz 이상으로 구동되어야 가장 자연스러운데, <strong>모든 모듈을 단일 PC에서 동시에 실행하면 성능이 저하</strong>될 수 있다고 합니다. 이를 해결하기 위해 손 추적/제어 모듈과 시뮬레이터를 <strong>별도의 컴퓨터로 분리</strong>하여 운용하면 성능을 유지할 수 있었지만, 일반 사용자 입장에서는 여러 대의 고성능 장비를 요구하는 셈이어서 부담일 수 있습니다. 따라서 향후에는 <strong>더 경량화된 추적 모델</strong>이나 <strong>최적화된 병렬 처리</strong>를 통해 <strong>단일 시스템에서도 충분한 주파수로 동작</strong>할 수 있도록 개선하는 연구가 기대됩니다.</p></li>
<li><p><strong>감각 피드백의 부재:</strong> 현재 AnyTeleop 조종자는 <strong>시각 정보</strong>에만 의존하여 원격 환경을 느낄 수 있습니다. 반면 기존의 장갑 기반 시스템들은 일부 <strong>촉각/힘 피드백</strong>을 제공하여 사용자가 물체를 쥐는 힘이나 질감을 느낄 수 있게 했습니다. AnyTeleop은 이러한 햅틱 장비를 배제함으로써 간편성과 범용성을 얻었지만, 동시에 조종자가 <strong>촉각적 단서 없이</strong> 화면만 보고 조작해야 한다는 제약이 있습니다. 이는 매우 섬세한 힘 조절이 필요한 작업(예: 계란을 잡기 등)에서 어려움을 초래할 수 있습니다. 향후 연구로 <strong>증강현실(AR)이나 햅틱 피드백 장치</strong>를 선택적으로 결합하여, 필요한 경우 조종자에게 <strong>추가적인 감각 피드백</strong>을 제공하는 방향을 모색해볼 수 있습니다. 예를 들어 AR 헤드셋을 사용해 원격 장면을 1인칭으로 보여주거나, 로봇 손끝에 힘 센서를 달아 조종자 손에 진동 피드백을 주는 방안 등이考해볼 수 있습니다 (물론 이는 시스템 복잡도를 높여 AnyTeleop의 장점인 저비용성을 희석시킬 수 있으므로 균형이 필요합니다).</p></li>
<li><p><strong>복잡한 작업 및 다중 로봇 시나리오:</strong> AnyTeleop으로 시연된 과제들은 주로 단일 로봇 팔-손이 하나의 물체를 다루는 작업 또는 두 로봇 간의 간단한 물체 전달 작업이었습니다. 향후에는 <strong>보다 복잡한 협업 시나리오</strong> (예: 두 로봇이 동시에 서로 다른 도구를 사용해 조립 작업을 한다거나, 다수의 로봇과 인간이 섞인 팀 협업)으로 확장하는 도전이 있습니다. 이를 위해서는 여러 조종자의 동작 타이밍을 자동으로 조율해주는 <strong>공동 제어 알고리즘</strong>, 물체를 주고받는 이상의 <strong>정교한 상호작용 프로토콜</strong> 등이 필요할 것입니다. 또한 현 단계에서는 한 명의 조종자가 하나의 로봇만 제어하지만, 장차 <strong>한 사람이 다수의 로봇을 제어</strong>하거나 <strong>한 로봇을 여러 명이 제어</strong>하는 특별한 경우(예: 거대한 로봇을 두 사람이 각각 다른 부분을 조작)도 고려해볼 수 있습니다. 이러한 확장은 AnyTeleop의 모듈식 구조를 한층 발전시켜, <strong>고차원의 공동 제어</strong> 문제를 다루는 연구로 이어질 수 있습니다.</p></li>
</ul>
<p>요약하면, AnyTeleop은 훌륭한 성능과 범용성을 달성했지만 <strong>비전 센싱의 한계</strong>, <strong>시스템 성능 요구사항</strong>, <strong>피드백 부족</strong>, <strong>복잡한 확장 시나리오</strong> 등의 면에서 향후 개선의 여지가 있습니다. 다행히 저자들은 이 시스템을 <strong>오픈 소스</strong>로 공개하여 연구자들이 자유롭게 개선·활용하도록 할 계획이며, 이를 통해 다양한 후속 연구가 활발히 전개될 것으로 기대됩니다.</p>
</section>
<section id="종합-정리" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="종합-정리"><span class="header-section-number">2.5</span> 종합 정리</h2>
<p>“<strong>AnyTeleop: A General Vision-Based Dexterous Robot Arm-Hand Teleoperation System</strong>” 논문은 로봇 원격 조작 분야에서 <strong>중요한 이정표</strong>를 세운 연구로 평가할 수 있습니다. 이 연구는 하나의 통합된 시스템으로 다양한 로봇과 환경을 지원하면서도, 개별 특화 시스템에 비견하거나 뛰어넘는 성능을 입증하였습니다. <strong>범용성</strong>과 <strong>성능</strong>을 동시에 잡았다는 점에서 학술적 <strong>독창성</strong>이 돋보이며, 특히 다중 로봇 협업까지 아우르는 비전 기반 테레오퍼레이션은 처음 시도되었다는 점에서 <strong>신규성</strong>이 있습니다.</p>
<p>AnyTeleop이 미칠 <strong>실용적 영향</strong>도 상당합니다. 우선 로봇 학습을 위한 <strong>데몬스트레이션 수집</strong>을 규모 확장하는 데에 큰 기여를 할 것으로 보입니다. 과거에는 많은 로봇 시연 데이터를 모으기 위해 복잡한 장비와 인력이 필요했지만, AnyTeleop을 활용하면 저비용 카메라와 인터넷만으로도 어디서든 사람이 로봇에게 시연을 가르칠 수 있습니다. 이는 곧 대규모 <strong>모방 학습 데이터셋 구축</strong>이나, 원격 <strong>크라우드소싱</strong>을 통한 로봇 학습으로 이어질 수 있습니다. 또한 시뮬레이터와 실제를 한 시스템에서 모두 지원하므로, <strong>시뮬레이션-현실 격차(sim-to-real gap)</strong>를 줄이고 보다 빠르게 현실 로봇에 학습 결과를 적용하는 사이클을 구축할 수 있습니다.</p>
<p>산업 및 사회적으로도 응용 가능성이 무궁무진합니다. 예를 들어, <strong>위험한 환경</strong>에서 인간을 대신해 작업해야 하는 로봇을 AnyTeleop으로 조종한다면, 작업자는 안전한 장소에서 카메라 원격장비로 로봇을 제어할 수 있습니다. 이는 원자력 발전소 점검, 화학 물질 취급, 화재 진압, 재난 현장 수색 등의 분야에서 <strong>원격 존재(telepresence)</strong> 로봇의 활용을 용이하게 할 것입니다. 또한 <strong>의료/복지 분야</strong>에서도 숙련된 전문가가 멀리 떨어진 곳의 로봇 팔을 원격 조종해 수술을 보조하거나, 장애인이 집에 있는 로봇 손을 원격 조작해 일상 작업을 수행하는 등 <strong>원격 협력</strong> 시나리오가 실현될 수 있습니다. 두 명 이상의 사람이 협동하여 거리를 초월해 로봇들을 움직이는 기술은 향후 <strong>원격 제조</strong>나 <strong>원격 협업 연구실</strong> 등에도 적용되어, 공간의 제약 없이 인력이 협업하는 새로운 형태의 작업 환경을 만들어낼 수 있습니다.</p>
<p>마지막으로, AnyTeleop은 <strong>오픈 소스로 공개</strong>됨으로써 연구 커뮤니티와 산업계 모두에 <strong>플랫폼</strong>을 제공할 것입니다. 이제 개별 로봇 회사나 연구실이 각자 원격 제어 시스템을 처음부터 만들 필요 없이, AnyTeleop을 기반으로 자신들의 로봇에 맞춰 확장하고 개선하는 식으로 발전이 가속화될 것입니다. 이러한 <strong>공유 인프라</strong>의 등장은 로봇공학 분야에서 표준을 정립하고 중복 노력을 줄이는 효과도 기대됩니다.</p>
<p>결론적으로, AnyTeleop은 <strong>비전 인식, 최적화 제어, 웹기술</strong>을 융합하여 로봇 원격 조작의 새로운 지평을 연 시스템입니다. 사람의 능숙한 손동작을 전례 없이 다양한 로봇에 이식함으로써, 인간과 로봇의 거리를 한층 좁혔습니다. 향후 이 연구를 바탕으로 보다 향상된 추적 기술, 사용자 피드백 통합, 그리고 인간-로봇 협업의 복잡한 문제들에 대한 추가 연구가 이어진다면, <strong>언제 어디서나 누구나 로봇을 조종할 수 있는 시대</strong>가 성큼 다가올 것으로 기대됩니다. AnyTeleop이 구축한 탄탄한 토대 위에서, 로봇 원격 조작의 <strong>스케일 업(scale-up)</strong>과 실용화가 한층 가속화될 것입니다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>