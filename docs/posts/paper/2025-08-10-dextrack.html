<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-08-10">
<meta name="description" content="Towards Generalizable Neural Tracking Control for Dexterous Manipulation from Human References">

<title>📃DexTrack 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ef56b68f8fa1e9d2ba328e99e439f80.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-b009f778f5cec7f34f624408a2b5b543.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review">Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review">Detail Review</a>
  <ul class="collapse">
  <li><a href="#기술적-기여-및-핵심-아이디어-분석" id="toc-기술적-기여-및-핵심-아이디어-분석" class="nav-link" data-scroll-target="#기술적-기여-및-핵심-아이디어-분석">1. 기술적 기여 및 핵심 아이디어 분석</a></li>
  <li><a href="#기존-연구와의-차별점-및-관련-연구-비교" id="toc-기존-연구와의-차별점-및-관련-연구-비교" class="nav-link" data-scroll-target="#기존-연구와의-차별점-및-관련-연구-비교">2. 기존 연구와의 차별점 및 관련 연구 비교</a></li>
  <li><a href="#실제-응용-가능성과-한계점" id="toc-실제-응용-가능성과-한계점" class="nav-link" data-scroll-target="#실제-응용-가능성과-한계점">3. 실제 응용 가능성과 한계점</a></li>
  <li><a href="#구조화된-요약-및-주요-실험-결과-분석" id="toc-구조화된-요약-및-주요-실험-결과-분석" class="nav-link" data-scroll-target="#구조화된-요약-및-주요-실험-결과-분석">4. 구조화된 요약 및 주요 실험 결과 분석</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃DexTrack 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">il</div>
    <div class="quarto-category">rl</div>
    <div class="quarto-category">isaacgym</div>
  </div>
  </div>

<div>
  <div class="description">
    Towards Generalizable Neural Tracking Control for Dexterous Manipulation from Human References
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 10, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://arxiv.org/abs/2502.09614">Paper Link</a></li>
<li><a href="https://meowuu7.github.io/DexTrack/">Project Link</a></li>
<li><a href="https://github.com/Meowuu7/DexTrack">Code Link</a></li>
</ul>
<ol type="1">
<li>🤖 이 연구는 복잡한 접촉 역학과 높은 일반화 능력이 요구되는 인간 레퍼런스로부터 로봇의 능숙한 조작을 위한 일반화 가능한 신경 추적 컨트롤러를 개발하는 문제를 다룹니다.</li>
<li>🛠️ DexTrack은 인간의 조작 레퍼런스를 통해 신경 추적 컨트롤러를 학습하며, 강화 학습과 모방 학습을 통합하고 Homotopy 최적화를 활용하여 고품질의 로봇 추적 데모를 반복적으로 생성 및 활용합니다.</li>
<li>✨ 제안된 컨트롤러는 시뮬레이션 및 실제 환경에서 기존 최고 성능 베이스라인 대비 10% 이상 높은 성공률을 달성했으며, 복잡하고 새로운 조작과 큰 노이즈에도 강건한 일반화 능력을 보였습니다.</li>
</ol>
<center>
<img src="../../images/2025-08-10-dextrack/01.png" width="60%">
</center>
<center>
<img src="../../images/2025-08-10-dextrack/02.png" width="100%">
</center>
<hr>
<section id="brief-review" class="level1">
<h1>Brief Review</h1>
<p>DexTrack은 human references를 활용하여 정교한 조작(dexterous manipulation)을 위한 일반화 가능한 신경망 추적 컨트롤러(neural tracking controller)를 개발하는 도전 과제를 다룹니다. 이 컨트롤러는 다양한 객체를 조작하도록 정교한 로봇 핸드를 제어하여, 인간-객체 상호작용의 운동학적 궤적(kinematic human-object interaction trajectories)에 의해 정의된 다양한 목적을 달성하는 것을 목표로 합니다. 정교한 조작의 복잡한 접촉 역학(intricate contact dynamics)과 적응성(adaptivity), 일반화 가능성(generalizability), 강건성(robustness)의 필요성 때문에 이러한 컨트롤러를 개발하는 것은 어렵습니다.</p>
<p>기존의 강화 학습(reinforcement learning, RL) 및 궤적 최적화(trajectory optimization, TO) 방법은 태스크별 보상(task-specific rewards)이나 정밀한 시스템 모델에 의존하기 때문에 한계가 있습니다. DexTrack은 인간 참조와 로봇 액션 쌍으로 구성된 대규모의 성공적인 로봇 추적 데몬스트레이션(robot tracking demonstrations)을 큐레이션하여 신경망 컨트롤러를 훈련시키는 새로운 접근 방식을 제안합니다. 이 방법은 데이터 플라이휠(data flywheel)을 활용하여 컨트롤러의 성능과 성공적인 추적 데몬스트레이션의 수 및 품질을 반복적으로 향상시킵니다.</p>
<p><strong>핵심 방법론:</strong></p>
<p>DexTrack은 로봇 추적 데몬스트레이션으로부터 신경망 추적 컨트롤러를 학습하는 과정과 고품질 데몬스트레이션을 채굴하는 과정을 번갈아 수행합니다.</p>
<ol type="1">
<li><strong>신경망 추적 컨트롤러 학습:</strong>
<ul>
<li><strong>데이터 전처리:</strong> 인간의 손-객체 조작 궤적을 로봇의 운동학적 핸드 시퀀스로 리타게팅(retargeting)하여 참조 모션 세트를 생성합니다.</li>
<li><strong>강화 학습(RL)과 모방 학습(imitation learning, IL)의 결합:</strong> 일반화 가능하고 강건한 컨트롤러를 개발하기 위해 두 학습 방식을 통합합니다.</li>
<li><strong>신경망 추적 컨트롤러(<span class="math inline">\pi</span>):</strong> 각 타임스텝 <span class="math inline">n</span>에서 정책은 현재 상태 <span class="math inline">s_n</span>과 다음 목표 상태 <span class="math inline">\hat{s}_{n+1}</span>을 관측하고, 액션의 분포를 계산합니다: <span class="math display">a_n \sim \pi(\cdot|o_n, \hat{s}_{n+1})</span>. 효과적인 컨트롤러는 결과 핸드 및 객체 상태가 해당 다음 목표 상태와 밀접하게 일치하도록 보장해야 합니다.</li>
<li><strong>강화 학습:</strong>
<ul>
<li>목표는 할인된 누적 보상(discounted cumulative reward) <span class="math display">J = E_{p(\tau|\pi)}\left[\sum_{n=0}^{N-1}\gamma^n r_n\right]</span>을 최대화하는 것입니다. 여기서 <span class="math inline">r_n = r(s_n, a_n, \hat{s}_{n+1}, s_{n+1})</span>은 보상입니다.</li>
<li>로봇 핸드는 비례 미분(proportional derivative, PD) 컨트롤러를 사용하여 제어되며, 액션 <span class="math inline">a_n</span>은 모든 핸드 관절에 대한 목표 위치 명령을 포함합니다.</li>
<li>샘플 효율성 향상을 위해 잔차 액션 공간(residual action space)을 도입합니다. <span class="math inline">a_n = s_n^b + \sum_{k=0}^n \Delta a_k</span>로 목표 위치를 계산하며, <span class="math inline">s_n^b</span>는 베이스라인 핸드 궤적입니다.</li>
<li>관측(<span class="math inline">o_n</span>)은 현재 핸드 및 객체 상태, 베이스라인 궤적, 액션, 속도, 객체 형상(<code>feat_{obj}</code>) 및 보조 특징(<code>aux_n</code>)을 포함합니다: <span class="math display">o_n = \{s_n, \dot{s}_n, s_n^b, a_n, \text{feat}_{obj}, \text{aux}_n\}</span>. <code>feat_{obj}</code>는 사전 훈련된 PointNet 기반 객체 포인트 클라우드 인코더에서 생성됩니다.</li>
<li>조작 추적을 위한 보상(<span class="math inline">r</span>)은 전환된 핸드 및 객체 상태가 참조 상태와 일치하도록 장려하며 핸드-객체 친화도(hand-object affinity)를 촉진합니다: <span class="math display">r = w_{o,p}r_{o,p} + w_{o,q}r_{o,q} + w_{wrist}r_{wrist} + w_{finger}r_{finger} + w_{affinity}r_{affinity}</span> 여기서 <span class="math inline">r_{o,p}</span>, <span class="math inline">r_{o,q}</span>, <span class="math inline">r_{wrist}</span>, <span class="math inline">r_{finger}</span>, <span class="math inline">r_{affinity}</span>는 각각 객체 위치, 객체 방향, 핸드 손목, 핸드 손가락, 핸드-객체 친화도에 대한 보상입니다.</li>
</ul></li>
<li><strong>모방 학습:</strong> RL의 샘플 비효율성 문제를 극복하기 위해, 성공적이고 풍부하며 다양한 “추적 지식”을 컨트롤러에 증류합니다. 컨트롤러는 고품질 로봇 추적 데몬스트레이션을 모방하도록 훈련됩니다. 액터 손실(actor loss) 외에 액션 지도 손실(action supervision loss)을 통합하여 정책 예측이 전문가 액션(<span class="math inline">a_n^L</span>)으로 편향되도록 합니다: <span class="math display">L_a = E_{a_n \sim \pi(\cdot|o_n, \hat{s}_{n+1})}\Vert a_n - a_n^L \Vert</span> 이는 탐색을 안내하고 수렴 속도를 높이며 복잡한 문제의 성능을 향상시킵니다.</li>
</ul></li>
<li><strong>신경망 컨트롤러를 활용한 고품질 로봇 추적 데몬스트레이션 채굴:</strong>
<ul>
<li><strong>Single Trajectory Tracking:</strong> 기본적으로 RL을 사용하여 개별 궤적 추적 문제를 해결하지만, 이는 다양하고 고품질의 데이터셋을 제공하기 어렵습니다.</li>
<li><strong>“tracking prior” 전이:</strong> 이미 많은 궤적을 추적할 수 있는 지식을 인코딩한 메인 추적 컨트롤러를 활용하여 단일 궤적 추적 정책을 개선합니다. 즉, 참조 궤적을 추적하는 데 추적 컨트롤러를 먼저 사용하고, 그 결과로 얻은 액션 시퀀스를 베이스라인 궤적으로 설정하여 잔차 정책을 다시 최적화합니다.</li>
<li><strong>Homotopy Optimization Scheme:</strong> 자체 채굴된 데이터에서 발생할 수 있는 편향과 다양성 감소 문제를 해결하기 위해 Homotopy 최적화 스킴을 제안합니다. 태스크 <span class="math inline">T_0</span>를 직접 해결하는 대신, 최적화 경로 <span class="math inline">(T_K, T_{K-1}, ..., T_0)</span>의 각 태스크를 반복적으로 해결합니다. 이는 “사고의 사슬(chain-of-thought)”과 유사하며, <span class="math inline">T_{m+1}</span>의 추적 결과를 <span class="math inline">T_m</span>의 베이스라인 궤적으로 설정하여 전이합니다.</li>
<li><strong>효과적인 Homotopy 경로 생성기 학습:</strong> 추론 중 효과적인 Homotopy 경로를 효율적으로 생성하기 위해 작은 데이터셋에서 Homotopy 경로 생성기 <span class="math inline">M</span>을 학습합니다. 이 문제는 추적 태스크 변환 문제로 재구성되며, 각 추적 태스크 <span class="math inline">T_0</span>에 대해 효과적인 “parent task”의 분포 <span class="math inline">M(\cdot|T_0)</span>를 제공하는 생성기를 목표로 합니다. 조건부 확산 모델(conditional diffusion model)을 사용하여 <span class="math inline">T_p \sim M(\cdot|T_c)</span>와 같이 학습합니다.</li>
</ul></li>
<li><strong>반복적 최적화를 통한 추적 컨트롤러 개선:</strong>
<ul>
<li><strong>1단계:</strong> 소규모의 추적 태스크 샘플을 통해 초기 데몬스트레이션 세트를 생성하고, 이를 사용하여 첫 번째 추적 컨트롤러를 학습합니다.</li>
<li><strong>2단계:</strong> 컨트롤러의 추적 오류에 비례하여 가중치를 부여하여 더 많은 궤적을 샘플링합니다. RL과 추적 사전 지식을 통합하여 데몬스트레이션을 채굴하고, Homotopy 경로를 검색하여 Homotopy 경로 생성기를 훈련합니다. 가장 잘 추적된 궤적들의 결과를 새로운 데몬스트레이션 세트로 큐레이션하여 컨트롤러를 재훈련합니다.</li>
<li><strong>3단계:</strong> 남아있는 궤적들로부터 추가로 샘플링하고, RL, 추적 컨트롤러, Homotopy 생성기를 활용하여 데몬스트레이션을 큐레이션합니다. 이 최종 세트를 사용하여 추적 컨트롤러를 최종 최적화합니다.</li>
</ul></li>
</ol>
<p><strong>실험 결과:</strong> DexTrack은 Isaac Gym 시뮬레이션 환경과 실제 세계 모두에서 광범위한 실험을 통해 그 우수성을 입증했습니다. GRAB 및 TACO 데이터셋의 복잡한 조작 추적 태스크에서 기존의 최첨단 베이스라인 대비 10% 이상 높은 성공률을 달성했습니다. 본 방법은 얇은 객체, 복잡한 움직임, 미묘한 핸드 내 재정렬(in-hand re-orientations)을 포함한 새로운 조작에 성공적으로 일반화되며, 상당한 운동학적 노이즈(kinematic noise)에 대한 강건성을 보입니다. Ablation Study를 통해 데몬스트레이션의 품질과 양이 컨트롤러 훈련에 중요함이 입증되었습니다.</p>
<p><strong>한계:</strong> 고품질 데몬스트레이션 확보 과정이 시간이 많이 소요된다는 점이 주요 한계로 언급됩니다. 향후 연구에서는 훈련 속도를 높이기 위한 더 빠르고 근사적인 Homotopy 최적화 방법을 탐색할 수 있습니다.</p>
<hr>
</section>
<section id="detail-review" class="level1">
<h1>Detail Review</h1>
<blockquote class="blockquote">
<p>DexTrack: 인간 시범 동작으로 학습한 범용 로봇 손 추적 제어</p>
</blockquote>
<section id="기술적-기여-및-핵심-아이디어-분석" class="level2">
<h2 class="anchored" data-anchor-id="기술적-기여-및-핵심-아이디어-분석">1. 기술적 기여 및 핵심 아이디어 분석</h2>
<p><strong>DexTrack</strong>은 인간의 손동작 시범(kinematic reference)을 바탕으로 <strong>범용적인 신경망 기반 로봇 손 추적 제어기</strong>를 제안한 연구이다. 이 제어기는 주어진 <strong>인간-물체 상호작용 궤적(시퀀스)</strong>을 로봇 손으로 최대한 정확히 따라하게 함으로써 다양한 물체 조작 작업을 수행한다. DexTrack의 핵심 아이디어는 <strong>고품질 로봇 추적 데모 데이터</strong>를 반복적으로 수집·확장하고 이를 통해 <strong>신경망 정책</strong>을 학습시키는 <strong>데이터 플라이휠(data flywheel)</strong> 방식을 도입한 것이다. 즉, 초기에는 인간 시범을 로봇의 <strong>운동 참조</strong>로 리타게팅(retargeting)하여 얻은 <strong>성공적인 추적 데모</strong>들로부터 모방 학습을 시작하고, 학습된 제어기를 다시 사용해 더 어려운 새로운 시범들을 추적함으로써 <strong>더 많은 데모를 채굴</strong>하고 성능을 높이는 과정을 반복한다.</p>
<p>구체적으로 DexTrack의 <strong>구조</strong>는 다음과 같다: 우선 다수의 인간 손동작-물체 상호작용 궤적을 로봇 손의 관절공간으로 <strong>리타게팅</strong>하여 <strong>로봇 기준의 운동 참조 시퀀스</strong>를 만든다. 그런 다음, <strong>신경망 추적 제어기</strong>는 매 시각각 현재 로봇 손 상태와 향후 목표 상태(참조 궤적의 다음 단계들)를 입력으로 받아 <strong>로봇 손의 액션 명령(관절 위치 또는 힘 등)</strong>을 출력한다. 이때 <strong>잔여(residual) 액션 학습</strong> 기법을 사용하여, <strong>참조 궤적</strong> 자체를 기본 베이스라인으로 두고 신경망이 <strong>필요한 보정 동작만 출력</strong>하도록 함으로써 학습 효율을 높였다. 이렇게 하면 사람 손과 로봇 손의 형태 차이로 인한 오차나 물리적 제약을 신경망이 보정하여 <strong>참조 경로를 가깝게 추적</strong>할 수 있다.</p>
<p><strong>학습 방식</strong> 측면에서, DexTrack은 <strong>강화학습(RL)</strong>과 <strong>모방학습(IL)</strong>을 정교하게 결합하여 제어기를 훈련시킨다. - 먼저 인간 시범으로부터 얻은 <strong>로봇 추적 데몬스트레이션</strong>(참조 궤적 + 이를 성공적으로 따라간 로봇 액션 시퀀스)의 <strong>다양한 데이터셋</strong>을 모은 뒤, 이를 <strong>모방 학습</strong>하여 초기 정책을 얻는다. - 동시에 정책의 <strong>견고성</strong>을 높이기 위해, 환경 상에서 <strong>추가적인 RL 파인튜닝</strong>을 수행하는데, 이때 보상은 <strong>참조 궤적과 로봇 상태의 일치도</strong>를 측정하는 <strong>트래킹 보상</strong>으로 설계된다.</p>
<p>이러한 <strong>IL로 학습된 초기 정책 + RL로 강화된 정책</strong>의 결합은, 복잡한 접촉 동작이 많은 dexterous manipulation 문제에서도 <strong>학습 신속성과 강인성</strong>을 모두 확보하게 한다. 특히 RL 없이 모방학습만으로는 예기치 못한 상황에 취약할 수 있는데, DexTrack은 RL을 통해 <strong>잡음이나 예외 상황에서도 복구 행동</strong>을 할 수 있는 능력을 갖춘 점이 특징이다.</p>
<p>DexTrack의 또 다른 핵심 기법은 <strong>Homotopy 최적화(homotopy optimization)</strong>를 활용한 <strong>개별 궤적 추적 향상</strong>이다. 이는 어려운 특정 시범 궤적을 한 번에 학습하기 어려울 경우, <strong>현재 학습된 추적 제어기</strong>를 이용해 해당 궤적을 <strong>점진적으로 난이도를 낮추는 일련의 중간 참조 경로</strong>로 분해하여 따라가 보는 접근법이다. 예를 들어 <strong>체인-오브-쏘트(chain-of-thought)</strong>와 유사하게, 복잡한 목표 동작을 <strong>단계별 단순화</strong>한 여러 참조 단계들을 만들어 <strong>쉬운 것부터 어려운 것 순서로</strong> 추적 수행한다. 각 단계에서는 RL 기반의 <strong>단일 궤적 추적 최적화</strong>를 수행하여 성공적인 로봇 액션 시퀀스를 찾아내고, 단계가 진행될수록 원래의 어려운 참조에 가까워지도록 한다. 이렇게 하면 처음에는 실패하던 복잡한 시범도 <strong>점진적인 성공 사례</strong>들을 통해 최종적으로 성공적인 추적 데모를 얻어낼 수 있다. 이 <strong>Homotopy 경로 생성</strong> 방법은 데이터 플라이휠 과정에서 <strong>데모 다양성</strong>을 높이고 품질을 향상시켜, 결과적으로 <strong>일반화 성능이 우수한 제어기</strong>를 얻는 데 크게 기여한다.</p>
<p>요약하면, DexTrack의 주요 기술적 기여는 다음과 같다:</p>
<ul>
<li><strong>범용 신경 추적 제어기</strong>를 제시하고 데이터 플라이휠을 통해 <strong>시행착오적 성능 향상</strong>을 실현함 (더 많은 데모를 모을수록 성능이 향상).</li>
<li><strong>강화학습 + 모방학습 통합 학습법</strong>으로 다량의 고품질 데모의 힘을 빌리면서도 <strong>새 환경에서도 견고한</strong> 정책을 학습함.</li>
<li><strong>Homotopy 기반 개별 궤적 최적화</strong> 스킴을 개발하여 어려운 추적 문제를 단계별로 풀어내고 <strong>데모 품질과 다양성</strong>을 높이는 <strong>데이터 기반 솔루션</strong>을 제안함.</li>
</ul>
<p>이와 같이 DexTrack은 복잡한 접촉 역학을 가지는 다지 로봇 손 조작 문제에 대해, <strong>인간 시범으로부터 보편적인 추종 능력을 학습</strong>시키는 새로운 패러다임을 제시하였다.</p>
</section>
<section id="기존-연구와의-차별점-및-관련-연구-비교" class="level2">
<h2 class="anchored" data-anchor-id="기존-연구와의-차별점-및-관련-연구-비교">2. 기존 연구와의 차별점 및 관련 연구 비교</h2>
<p>DexTrack은 <strong>기존의 강화학습(RL) 또는 모델 기반 최적화 접근법</strong>과 구별되는 새로운 방향을 제시한다. 과거 OpenAI 등의 연구에서는 <strong>특정 과제별 보상 설계</strong>를 통해 RL로 로봇 손 동작을 학습시키거나, 혹은 <strong>정확한 물리 모델과 접촉 타이밍</strong>에 의존하는 <strong>모델 기반 경로 최적화</strong>를 사용해 왔다. 그러나 전자는 매 과제마다 보상을 손수 설계해야 하므로 <strong>일반화된 하나의 정책으로 여러 작업을 수행하기 어려웠고</strong>, 후자는 접촉이 많은 환경에서 <strong>정확한 모델링이 어려워</strong> 새로운 물체나 기술에 <strong>적응성이 떨어지는</strong> 문제가 있었다. <strong>인간 시연 기반 모방 학습</strong> 접근도 일부 시도되었지만, 기존 방법들은 <strong>잡음 없는 이상적인 궤적</strong>만을 대상으로 하거나 <strong>간단한 파지(grasp)나 경로 추종</strong> 등에 국한되어, <strong>섬세한 잔동작이 필요한 인핸드 조작</strong>까지 다루지 못했다. 예를 들어 OmniGrasp (2024)라는 선행 연구에서는 범용 정책을 학습하긴 했지만, <strong>물체 집기와 단순 이동</strong> 정도의 <strong>제한적인 모션</strong>만 고려하여 여전히 복잡한 손놀림이 요구되는 작업은 다루지 않았다. 이에 반해 <strong>DexTrack은 훨씬 복잡한 동작</strong> (얇은 도구 다루기, 연속적인 손 안에서의 재배치 등)까지 포함하여 <strong>보다 풍부한 기술 습득</strong>을 목표로 한다.</p>
<p>또한 DexTrack은 <strong>인간 동작 모방</strong>을 활용한다는 점에서 관련 연구들과 맥락을 같이하지만, <strong>데이터 수집과 활용 면에서 독창성</strong>을 보인다. 일부 연구들은 모방 학습에 RL을 추가로 활용하여 샘플 효율을 높이는 <strong>데모 강화 RL</strong> 기법들을 제안한 바 있다. 하지만 이들 연구에서는 <strong>데몬스트레이션 데이터가 이미 주어져 있다</strong>는 가정을 하며, 인간이나 텔레옵으로 얻은 데모를 그대로 활용하는 경우가 많다. 반면 <strong>DexTrack은 고품질 데모를 직접 만들어내는 루프</strong>를 통해 문제를 해결했다는 점에서 차별화된다. 즉, <strong>추적 제어기 자체가 데모 생성을 도우면서 성능을 높이는 부트스트래핑</strong>을 구현하여, 시범 데이터 부족 문제를 창의적으로 풀었다. 이러한 <strong>데이터 플라이휠 기법</strong>은 최근 거대 모델 학습에서 데이터 규모가 성능을 좌우한다는 통찰에 착안한 것으로서, 로봇 제어 분야에 이를 적용해 <strong>학습용 데이터와 정책을 함께 향상</strong>시킨 사례라 할 수 있다.</p>
<p><strong>Human demonstration 기반 로봇 조작</strong> 분야의 다른 작업들과 비교하면, DexTrack은 <strong>고차원 모션 추종</strong>에 초점을 맞춘 점이 돋보인다. 예를 들어, <strong>DGrasp</strong> (Christen et al., 2022) 등의 기법은 비교적 단순한 연속 파지 동작을 여러 단계로 나눠 푸는 방식을 사용하지만, <strong>하나의 긴 복잡 동작을 끝까지 추적</strong>하는 범용 정책은 아니었다. DexTrack은 하나의 신경망이 <strong>여러 작업 종류에 대응</strong>하면서도 <strong>세밀한 손가락 움직임까지 정확히 모사</strong>하도록 훈련되었고, 이를 통해 이전 기법들이 실패하거나 시도하지 않은 <strong>섬세한 조작 시나리오</strong>들을 성공적으로 수행했다. 특히, <strong>얇은 물체를 다루거나</strong> 물체를 손 안에서 자유롭게 돌리는 동작, 도구를 활용한 복합 움직임 등에 있어서 DexTrack은 기존 강화학습 기반 방법(PPO 등)이 일반화에 실패하는 경우에도 안정적으로 동작함을 보였다. 결과적으로 DexTrack은 <strong>기존 방식 대비 약 10% 이상의 성공률 향상</strong>을 달성하며, <strong>범용성</strong>과 <strong>적응성</strong> 측면에서 현 상태-of-the-art를 한 단계 진보시킨 것으로 평가된다.</p>
<p>요약하면, DexTrack은 <strong>(a)</strong> 과제별 설계나 정확한 모델 없이도 다양한 작업에 통하는 <strong>범용 제어기</strong>를 제시했고, <strong>(b)</strong> 인간 시범 활용 연구들 가운데서도 <strong>더 어려운 작업과 노이즈에 강한</strong> 새로운 접근법을 선보였다는 점에서 독창적이다. 이를 통해 로봇이 <strong>사람의 복잡한 손동작까지 학습하여 모방</strong>하는 길을 크게 확장한 것으로 볼 수 있다.</p>
</section>
<section id="실제-응용-가능성과-한계점" class="level2">
<h2 class="anchored" data-anchor-id="실제-응용-가능성과-한계점">3. 실제 응용 가능성과 한계점</h2>
<p>DexTrack에서 제안한 제어기는 <strong>시뮬레이션</strong>뿐만 아니라 <strong>실제 로봇 손</strong>에도 검증되어 그 <strong>응용 가능성</strong>을 보여주었다. 연구진은 시뮬레이터(Isaac Gym) 상에서 학습한 정책을 <strong>실제 4지 로봇 손(LEAP Hand)</strong>에 이식하여 여러 가지 <strong>일상 물체 조작 실험</strong>을 진행하였다. 예를 들어, 사람 손 시범으로 기록한 물체 사용 동작(망치질, 칼로 자르기, 비누 잡기 등)을 로봇 손이 실제로 따라하도록 한 결과, <strong>사전에 보지 못한 새 물체</strong>나 <strong>센서 잡음</strong>이 존재해도 상당히 <strong>안정적인 조작</strong>이 가능함을 확인했다. <strong>사과 들어올리기</strong>와 같이 <strong>둥근 물체를 쥐기 어려운 상황</strong>에서도 DexTrack 제어기는 끝까지 물체를 파지하고 들어올리는 데 성공한 반면, 기존 PPO 기반 제어기는 시작 단계부터 물체를 놓치는 등 실패하였다. 이러한 실제 실험을 통해 DexTrack의 정책이 <strong>시뮬레이션-실세계 간 격차(sim-to-real gap)</strong>를 어느 정도 극복하고 <strong>현실 환경의 마찰·동역학에서도 동작함</strong>을 보여주었다. 나아가 <strong>특수한 튜닝이나 추가 학습 없이도</strong> 인간 시범 기반으로 학습된 정책을 현실에 바로 투입해 다양한 작업을 수행할 수 있다는 점에서, 향후 범용 로봇 조작기로서의 잠재력을 시사한다.</p>
<p>그럼에도 불구하고, DexTrack에는 <strong>극복해야 할 한계점</strong>이나 <strong>추가로 고려해야 할 부분</strong>도 존재한다.</p>
<ul>
<li>첫째로, <strong>고품질 데모 수집 과정의 비용</strong> 문제가 있다. 논문에서도 한계로 지적했듯이, DexTrack의 성능을 끌어올리려면 다양한 작업에 대한 <strong>성공 사례 데이터</strong>가 많이 필요한데, 이를 얻기 위해 <strong>Homotopy 최적화</strong>를 포함한 복잡한 절차를 거쳐야 하므로 <strong>학습에 많은 시간과 계산 자원</strong>이 소요된다. 수천 개 이상의 시퀀스를 병렬 환경(8192개 시뮬레이터)에서 돌려가며 정책을 학습하고 또 데모를 추가 수집하는 식이어서, <strong>훈련 파이프라인이 무겁고 비실용적일 수 있다</strong>.</li>
<li>둘째로, <strong>일부 한계 상황에서의 성능 저하</strong>가 관찰되었다. DexTrack 제어기가 훈련 시 경험해보지 못한 <strong>완전히 새로운 범주의 물체</strong> 중 특히 <strong>형상이 매우 얇거나 특이한 경우</strong>, 해당 물체에 대한 파지가 제대로 이루어지지 않아 <strong>추적에 실패</strong>할 수 있다. 예컨대 훈련 데이터에 없던 극단적으로 얇은 도구를 다뤄야 하는 경우, 제어기가 올바른 힘 조절과 접촉 위치를 찾지 못해 사람 시범 동작을 끝까지 재현하지 못한다. 이는 <strong>모델의 일반화 한계</strong>를 드러내는 부분으로, 새로운 물체 물성이나 마찰계수를 만났을 때의 대응은 추가 연구가 필요한 영역이다.</li>
</ul>
<p>또 다른 현실적 고려사항으로는, DexTrack이 <strong>고정된 참조 궤적을 추종</strong>하는 방식이라는 점이다. 실제 응용에서 로봇이 작업 도중 <strong>참조 동작의 변경이나 예기치 않은 사건</strong>에 직면하면, 현재의 DexTrack 정책은 그 상황을 극복하도록 설계되지 않았다. 물론 <strong>참조 자체에 큰 잡음이나 비현실적인 동작</strong>이 있어도 정책이 알아서 보정해주는 <strong>견고성</strong>은 가지고 있지만, <strong>임무 목표 자체를 재설정</strong>하는 능동적인 지능과는 거리가 있다. 따라서 장기적으로는 이러한 <strong>고수준 의사결정</strong>과 결합되어야 가정된 참조 없이도 동작할 수 있을 것이다. 마지막으로, 실세계 적용을 위해서는 <strong>정확한 상태추정</strong>이 필수인데, 논문에서도 물체 포즈 추정을 위해 <strong>특정 비전 모듈(FoundationPose)</strong>을 사용하고 있다. 만일 객체 인식이나 추적에 오류가 생기면 제어 성능이 떨어질 수 있으므로, <strong>센서 신뢰도에 대한 의존성</strong>도 고려해야 한다.</p>
<p>정리하면, DexTrack은 <strong>현실적인 로봇 손 활용</strong>에 한 걸음 다가선 유망한 방식이지만, <strong>대량 학습 데이터 확보 비용</strong>, <strong>훈련 범위를 벗어난 물체에 대한 일반화 한계</strong>, <strong>실시간 적응성 부족</strong>, <strong>센서 의존성</strong> 등의 측면에서 앞으로 개선 여지가 있다. 저자들도 향후 <strong>Homotopy 최적화 과정을 가속화</strong>하거나 더 효율적인 데모 확보 방식을 연구하여 <strong>훈련 속도를 높이는 것</strong>이 과제로 남아 있다고 밝히고 있다.</p>
</section>
<section id="구조화된-요약-및-주요-실험-결과-분석" class="level2">
<h2 class="anchored" data-anchor-id="구조화된-요약-및-주요-실험-결과-분석">4. 구조화된 요약 및 주요 실험 결과 분석</h2>
<p><strong>연구 개요:</strong> DexTrack은 복잡한 <strong>다지 로봇 손 조작</strong> 문제에 대해, <strong>인간 시범 경로를 추적</strong>하는 <strong>범용 정책</strong>을 학습시키는 접근법이다. 이를 통해 각 작업마다 따로 훈련하지 않고도 <strong>다양한 물체 조작 기술</strong>을 하나의 신경망 제어기로 수행하는 것을 목표로 한다. 핵심 아이디어는 대량의 <strong>로봇 추적 데모</strong>(인간 참조 + 성공 액션 시퀀스)를 <strong>반복적</strong>으로 확보하여, <strong>강화학습과 모방학습을 결합</strong>해 제어기를 향상시키는 것이다. 또한 어려운 개별 시범은 <strong>Homotopy 경로</strong>로 단계적 해결하여 <strong>데모의 다양성</strong>을 높였다.</p>
<p><strong>기술 구성:</strong> DexTrack 알고리즘은 다음과 같은 단계로 이뤄진다:</p>
<ul>
<li><strong>데이터 준비:</strong> <em>인간 시범 모션 리타게팅</em> – GRAB, TACO 등 인간-물체 상호작용 데이터셋의 손동작을 로봇 손모델(시뮬레이터 상 Allegro Hand)에 맞게 변환하여 <strong>로봇 참조 궤적</strong> 집합을 생성. 예컨대 컵을 잡고 따르는 사람 손 움직임 → 로봇 손 관절각도 참조 시퀀스.</li>
<li><strong>초기 데모 수집:</strong> 참조 궤적 일부를 <strong>개별 강화학습</strong>으로 최적 추종해봄으로써 <strong>성공 사례</strong>(tracking demonstration)를 모은다. 이때 <strong>잔여 정책(residual policy)</strong> 기법으로 참조 대비 보정 동작만 학습하여 효율을 높인다.</li>
<li><strong>정책 학습(RL+IL):</strong> 모인 데모를 <strong>모방학습(Behavior Cloning)</strong>하여 <strong>추적 정책</strong>을 학습하고, 추가로 <strong>추적 보상 기반 RL(PPO)</strong>로 미세 조정하여 <strong>노이즈나 새로운 상황에도 견딜 수 있게</strong> 만든다. 관측 상태에는 현재 로봇 손/물체 상태, 참조 궤적(앞으로의 목표 자세), 이전 액션 등이 포함된다.</li>
<li><strong>Homotopy 최적화:</strong> 현 정책으로 <strong>추적에 실패하는 어려운 참조</strong>에 대해, 해당 궤적을 <strong>단계별 더 쉬운 참조들로 분해</strong>하여 각 단계를 <strong>RL로 해결</strong>함으로써 최종 성공 데모를 얻는다. 이렇게 <strong>새 데모를 데이터셋에 추가</strong>하여 다시 정책을 학습시키는 <strong>루프를 반복</strong>한다.</li>
</ul>
<p><strong>실험 설정:</strong> 저자들은 <strong>두 가지 공개 데이터셋</strong>(GRAB: 일상 동작 1269개 시퀀스, TACO: 도구 사용 동작 2316개 시퀀스)을 활용하여 DexTrack을 훈련하고 평가했다. <strong>훈련</strong>은 Isaac Gym 시뮬레이터 상에서 8192병렬 환경으로 진행되었고, <strong>Allegro 로봇 손</strong>(4손가락, 16자유도)을 사용했다. <strong>평가</strong>는 각 데이터셋의 <strong>미보seen 궤적</strong>에 대한 추적 성공률로 측정되며, 추가로 <strong>실제 로봇 손(LEAP Hand)</strong>으로 <strong>현실 실험</strong>도 수행되었다. <strong>벤치마크</strong>로는 세 가지 비교 방법이 설정되었다: (1) <strong>DGrasp</strong> – 기존 모방+최적화 기법을 추적 문제로 변형, (2) <strong>PPO (OmniGrasp reward)</strong> – OmniGrasp 논문의 보상함수로 PPO 학습, (3) <strong>PPO (tracking reward)</strong> – DexTrack이 제안한 동일 환경에서 보상만 가지고 PPO 학습한 순수 RL. <strong>성능 지표</strong>로는 물체의 <strong>회전/이동 오차</strong>, 손목 자세 오차, 손가락 관절 오차의 <strong>평균</strong>과, 최종적으로 <strong>성공률</strong>(오차가 임계값 이하일 때 성공) 등이 사용되었다. 성공 기준은 오차 임계값을 엄격하게(strict) 혹은 완화하여(lenient) 두 종류로 산정되었다.</p>
<p><strong>주요 실험 결과:</strong> DexTrack은 <strong>모든 기준에서 기존 방법들을 앞서는 성능</strong>을 보였다. <strong>추적 정확도</strong> 지표(물체 자세 오차 등)에서 DexTrack이 가장 낮은 오차를 기록했고, 무엇보다 <strong>작업 성공률</strong>에서 큰 격차를 나타냈다. 아래 표는 <strong>DexTrack과 가장 성능이 좋았던 기존 기법</strong>(PPO 기반 RL)의 <strong>성공률 비교</strong>를 보여준다:</p>
<div data-align="center">
성공률 비교 (Strict / Lenient 기준)
</div>
<table class="caption-top table">
<thead>
<tr class="header">
<th><strong>데이터셋</strong></th>
<th><strong>기존 PPO 기법</strong></th>
<th><strong>DexTrack (제안)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>GRAB</strong> (일상 동작)</td>
<td>38.58% / 54.82%</td>
<td><strong>46.70% / 65.48%</strong></td>
</tr>
<tr class="even">
<td><strong>TACO</strong> (도구 사용)</td>
<td>34.98% / 57.64%</td>
<td><strong>48.77% / 74.38%</strong></td>
</tr>
</tbody>
</table>
<blockquote class="blockquote">
<p>참고: Strict은 더 엄격한 성공 기준, Lenient는 다소 완화된 기준이며, DexTrack은 두 경우 모두에서 최고 성능을 달성했다.</p>
</blockquote>
<p>DexTrack은 <strong>평균적으로 10%p 이상 높은 성공률</strong>을 보이며, 특히 <strong>복잡한 동작일수록 격차가 더욱 커졌다</strong>. 예를 들어, <strong>손바닥에서 물체를 재배치</strong>하는 세밀한 동작이나 <strong>얇은 물체 잡아 흔들기</strong> 등의 과제에서 DexTrack은 참조 경로를 거의 완벽하게 따라간 반면, <strong>기존 PPO 기반 정책은 초반 파지부터 실패</strong>하는 모습을 보였다. 이는 DexTrack의 <strong>일반화 능력</strong>과 <strong>접촉 다루는 섬세함</strong>이 기존 대비 크게 향상되었음을 시사한다. 더욱이 <strong>잡음이 큰 비현실적 참조</strong>에 대한 실험에서도, DexTrack 정책은 손가락이 물체를 통과하는 등 모순된 입력이 주어져도 <strong>상황에 맞게 자세를 조정하며 끝까지 동작을 수행</strong>하여 <strong>강인함</strong>을 보여주었다.</p>
<p><strong>실제 로봇 실험 결과:</strong> 시뮬레이션에서 높은 성능을 보인 DexTrack 정책은 <strong>현실 환경에도 직접 적용</strong>되었다. 연구진은 학습된 제어기를 <strong>별도 도메인 적응 없이</strong> 물체 인식 시스템(카메라 기반 포즈 추적)과 연동하여 <strong>실제 로봇 손+팔</strong>로 실행했다. 그 결과 사과 들어올리기, 망치질, 물체 건네주기 등 <strong>10여 가지 실제 시나리오</strong>에서 <strong>대부분 성공적인 조작</strong>을 시현해 보였다. 정량적으로 봤을 때도 <strong>현실 성공률</strong>은 DexTrack이 기존 대비 월등히 높았는데, 예를 들어 <strong>사과 집어들기</strong>의 경우 엄격한 기준에서 <strong>기존 방법 성공률 0% vs DexTrack 25%</strong>, <strong>망치 쥐고 사용하기</strong> 0% vs 50% 등 <strong>모든 객체에 대해 우위</strong>를 보였다. 이러한 실험은 DexTrack의 접근법이 <strong>시뮬레이션에 국한되지 않고 실제 로봇에서도 통한다</strong>는 것을 증명하며, <strong>범용 로봇 손 기술의 실용화 가능성</strong>을 높여준다. 다만 현실 실험에서는 <strong>상태 추정 오차, 마찰 계수 차이</strong> 등으로 인해 성공률이 시뮬레이션만큼 높게 나오지 않은 사례도 있었다. 그럼에도 DexTrack은 <strong>최고 성능 기준으로 실세계에서도 기존 대비 뚜렷한 성능 향상</strong>을 보여줬으며, 이는 곧 본 기법의 <strong>우수한 일반화 능력과 구현 가능성</strong>을 입증하는 결과이다.</p>
<p><strong>요약 및 평가:</strong> DexTrack 논문은 <strong>인간 시범 학습을 통한 범용 로봇 조작</strong>의 실현에 있어 중요한 진전을 이루었다. 기술적으로 <strong>데이터 주도</strong> 접근과 <strong>학습 기법의 조합</strong>으로 난제를 풀었고, 실험적으로도 다양한 복잡 작업에서 <strong>주목할 만한 성공률 개선</strong>을 입증했다. 특히 <strong>데이터 플라이휠을 통한 점진적 학습 향상</strong>, <strong>Homotopy 최적화로 난이도 완화</strong>, <strong>RL+IL 병행으로 강인성 확보</strong> 등의 아이디어는 관련 연구 대비 뚜렷한 <strong>혁신 포인트</strong>로 평가된다. 실제 로봇 적용 결과는 이 방법의 <strong>실용적 잠재력</strong>을 보여주지만, 동시에 <strong>데이터 확보 비용</strong> 등의 현실적인 한계도 드러냈다. 전반적으로 DexTrack은 <strong>한계가 분명한 기존 방법들을 넘어</strong>, 범용적인 로봇 손 제어기의 가능성을 제시한 의미 있는 연구로 볼 수 있다. 향후 데모 확보 효율화, 새로운 물체 카테고리에 대한 일반화 추가 개선 등이 이루어진다면, 인간의 능숙한 손동작을 로봇이 학습하여 다양한 작업을 수행하는 비전이 한층 가까워질 것으로 기대된다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>