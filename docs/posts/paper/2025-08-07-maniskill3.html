<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-08-06">
<meta name="description" content="Demonstrating GPU Parallelized Robot Simulation and Rendering for Generalizable Embodied AI with ManiSkill3">

<title>📃ManiSkill3 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-bc185b5c5bdbcb35c2eb49d8a876ef70.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-5a614c35f1f90bfd0a5b2992298a8538.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review"><span class="header-section-number">1</span> Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review"><span class="header-section-number">2</span> Detail Review</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃ManiSkill3 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">sapien</div>
    <div class="quarto-category">simulation</div>
  </div>
  </div>

<div>
  <div class="description">
    Demonstrating GPU Parallelized Robot Simulation and Rendering for Generalizable Embodied AI with ManiSkill3
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 6, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://arxiv.org/abs/2410.00425">Paper Link</a></li>
<li><a href="https://www.maniskill.ai/">Project Link</a></li>
<li><a href="https://github.com/haosulab/ManiSkill">Github Link</a></li>
</ul>
<ol type="1">
<li>🚀 ManiSkill3는 기존 시뮬레이터의 제약(속도, 메모리, 이질성)을 해결한 GPU 병렬화 로봇 시뮬레이터로, 최대 30,000+ FPS와 낮은 GPU 메모리 사용량을 자랑합니다.</li>
<li>💡 이 플랫폼은 모바일 조작, 드로잉, 휴머노이드 등 12가지의 다양한 작업 도메인과 20개 이상의 로봇을 지원하며, 사용자 친화적인 API 및 이질적 시뮬레이션 기능을 통해 일반화 가능한 로봇 학습을 가속화합니다.</li>
<li>✅ ManiSkill3는 로봇 강화 학습 시간을 크게 단축하고, 시뮬레이션에서 실제 환경으로의 안정적인 zero-shot 정책 배포를 입증하여 Sim2Real 및 Real2Sim 연구에 강력한 기반을 제공합니다.</li>
</ol>
<center>
<img src="../../images/2025-08-07-maniskill3/teaser.jpg" width="80%">
</center>
<hr>
<section id="brief-review" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Brief Review</h1>
<p>GPU 병렬 로봇 시뮬레이션 및 렌더링을 통한 일반화 가능한 체화형 AI 구현: ManiSkill3</p>
<p>ManiSkill3는 일반화 가능한 로봇 조작을 목표로 하는 가장 빠른 상태-시각 GPU 병렬 로봇 시뮬레이터로, 접촉이 많은 물리 시뮬레이션을 지원합니다. 이 프레임워크는 시뮬레이션+렌더링, 이종 시뮬레이션, 포인트 클라우드/복셀 시각 입력 등 다양한 측면에서 GPU 병렬화를 지원합니다. ManiSkill3의 GPU 시뮬레이션 및 렌더링은 다른 플랫폼보다 2~3배 적은 GPU 메모리를 사용하며, 최소한의 Python/PyTorch 오버헤드, GPU에서의 시뮬레이션, 그리고 SAPIEN 병렬 렌더링 시스템 덕분에 벤치마크 환경에서 최대 30,000+ FPS를 달성합니다. 이를 통해 수 시간 걸리던 훈련 시간이 몇 분으로 단축됩니다. 또한, 모바일 조작, 드로잉, 휴머노이드, 숙련된 조작 등 12가지 독특한 도메인에 걸쳐 가장 포괄적인 GPU 병렬화 환경/작업을 제공하며, 모션 플래닝, RL, 텔레오퍼레이션으로부터 수백만 프레임의 시연 데이터도 제공합니다. ManiSkill3는 인기 있는 RL 및 시연 기반 학습 알고리즘을 아우르는 포괄적인 기준선도 제공합니다.</p>
<p>기존 로봇 학습 연구는 비전 및 언어 연구와 달리 로봇 조작을 위한 적절한 데이터셋이 부족했습니다. 실세계 모방 학습은 방대한 데이터가 필요하고, 강화 학습(RL)은 광범위한 실제 환경 설정이 요구됩니다. Isaac Lab과 Mujoco의 MJX와 같은 GPU 병렬 시뮬레이션은 로봇 이동과 같은 문제 해결에 큰 진전을 가져왔지만, 조작 태스크에서는 이종 시뮬레이션(각 병렬 환경이 다른 장면을 포함하는 것) 및 빠른 병렬 렌더링 기능이 부족하여 시각 입력을 사용하는 RL 알고리즘의 훈련 속도가 느린 한계가 있었습니다. ManiSkill3는 이러한 한계를 해결하고 Apache-2.0 라이선스 하에 오픈 소스로 공개됩니다.</p>
<p>ManiSkill3의 핵심 기여는 다음과 같습니다.</p>
<ol type="1">
<li><strong>최첨단 GPU 병렬 시뮬레이션 및 렌더링:</strong> ManiSkill3는 빠른 병렬 렌더링과 낮은 시스템 오버헤드를 통해 GPU를 효율적으로 사용하여, 시각 태스크를 다른 시뮬레이터보다 빠르게 해결합니다. 시뮬레이션+렌더링 FPS는 최대 30,000+에 달하며, 시각 데이터 수집을 대규모로 가속화합니다. 또한, GPU 메모리 사용량이 2~3배 낮아 장치 내 시각 RL 및 대규모 신경망 훈련을 가능하게 합니다. 벤치마크에서 128개 병렬 환경의 경우 ManiSkill3는 3.5GB의 GPU 메모리를 사용하는 반면, Isaac Lab은 14.1GB를 사용합니다. ManiSkill3는 SAPIEN의 래스터화 렌더러를 사용하는 반면 Isaac Lab은 레이 트레이싱을 사용합니다.</li>
<li><strong>가장 포괄적인 환경:</strong> 테이블탑, 모바일 조작, 룸 스케일 장면, 사족보행/휴머노이드 이동, 휴머노이드/양손 조작, 다중 에이전트 로봇, 드로잉/클리닝, 숙련된 조작, 시각-촉각 조작, 고전 제어, 디지털 트윈, 소프트 바디 조작 등 12가지 독특한 카테고리의 환경과 20개 이상의 로봇을 기본 제공합니다. ReplicaCAD 및 AI2-THOR 장면을 지원하며, PhysX 기반의 시뮬레이션을 사용합니다.</li>
<li><strong>이종(Heterogeneous) GPU 시뮬레이션:</strong> ManiSkill3는 각 병렬 환경에서 완전히 다른 객체 형상, 객체 수, 그리고 서로 다른 자유도(DoF)를 가진 관절(articulation)을 시뮬레이션하고 렌더링할 수 있는 유일한 시뮬레이션 프레임워크입니다. 이를 통해 PPO와 같은 알고리즘이 YCB 데이터셋의 모든 객체나 PartNetMobility 데이터셋의 캐비닛에 대해 동시에 훈련하여 더 일반화 가능한 학습을 가능하게 합니다.</li>
<li><strong>간소화된 통합 API:</strong> 관절(articulation), 링크, 조인트 및 액터에 대한 완전한 객체 지향 API를 제공하여 복잡한 텐서 인덱싱 없이 로봇 환경을 쉽게 구축하고 관리할 수 있습니다. 포즈 정보는 배치(batched) <code>Pose</code> 객체로 저장되어, 예를 들어 두 포즈 <span class="math inline">P_1, P_2</span>에 대해 <span class="math inline">(P_1 P_2)^{-1} P_1^{-1}</span>와 같은 연산을 메서드 체이닝 패턴으로 간결하게 수행할 수 있습니다. <code>ManiSkill3.poses.Pose.inv_then_mul(p1, p2, p1_inv=True)</code> URDF 및 MJCF 정의 형식을 기본적으로 지원하며, GPU 병렬화된 관절 위치 제어 및 역운동학(IK) 제어를 위한 사전 구축된 제어기 옵션을 제공합니다.</li>
<li><strong>확장 가능한 데이터셋 생성 파이프라인:</strong> 모션 플래닝, RL 정책, 텔레오퍼레이션 등 다양한 방법을 통해 시연 데이터를 수집하며, 특히 복잡한 태스크의 경우 RLPD [2] 및 RFCL [47]과 같은 온라인 모방 학습 알고리즘을 사용하여 소수의 시연으로부터 일반화된 정책을 학습시킨 후 대규모 데이터셋을 생성합니다. 트랙토리 리플레이 도구는 CPU/GPU 시뮬레이션에서 수집된 데이터를 다른 설정(관측, 보상, 병렬 환경 수, RNG 시딩)으로 리플레이할 수 있도록 지원합니다.</li>
<li><strong>VR 텔레오퍼레이션:</strong> OpenVR 클라이언트 프로토콜을 구현하여 주류 VR 장치를 지원하며, 작업자의 손목 및 손 포즈를 실시간으로 로봇 동작으로 변환합니다. 4K 해상도의 스테레오 비디오 스트림을 60Hz로 VR 장치에 전송하여 몰입형 시야각을 제공합니다.
<ul>
<li><strong>로봇 제어 모듈:</strong>
<ul>
<li><strong>팔 제어 모듈:</strong> 인간의 손목 포즈를 로봇 팔 관절 위치로 변환합니다. Pinocchio 라이브러리 기반의 Closed-loop Inverse Kinematics (CLIK) 알고리즘의 수정된 버전을 사용하여 관절 각도를 계산하며, 이종 엔드 이펙터(end-effector)에 대한 IK 문제를 동시에 처리합니다. 특정 관절의 움직임을 조절하기 위해 소프트 마스크(soft mask)를 사용하고, 부드러운 팔 동작을 위해 SE(3) 그룹 필터를 적용합니다.</li>
<li><strong>손 제어 모듈:</strong> 인간 손가락 포즈를 로봇 손 관절 위치로 변환합니다. 이는 다음 목적 함수를 최소화하는 최적화 문제로 정식화됩니다. <span class="math display">\min_{\mathbf{q}_t} \sum_{i=0}^N \|\alpha_i \mathbf{v}_i^t - f_i(\mathbf{q}_t)\|^2 + \beta\|\mathbf{q}_t - \mathbf{q}_{t-1}\|</span> 여기서 <span class="math inline">\mathbf{q}_t</span>는 시간 <span class="math inline">t</span>에서의 로봇 손 관절 위치, <span class="math inline">\mathbf{v}_i^t</span>는 인간 손의 <span class="math inline">i</span>번째 키포인트 벡터, <span class="math inline">f_i(\mathbf{q}_t)</span>는 순방향 운동학을 사용한 로봇 손의 해당 키포인트 벡터입니다. <span class="math inline">\alpha_i</span>는 손 크기 차이를 보상하고, <span class="math inline">\beta</span>는 시간적 일관성을 위한 정규화 항의 가중치입니다. 이 최적화는 NLopt 솔버로 구현됩니다.</li>
</ul></li>
<li><strong>Sim-to-Real 인터페이스:</strong> 깊이 카메라로 캡처된 포인트 클라우드를 VR 헤드셋에 투영하고 EasyHec으로 카메라 포즈를 보정하여 시뮬레이션 환경과 실제 환경을 “디지털 트윈” 방식으로 정렬합니다.</li>
</ul></li>
</ol>
<p><strong>벤치마크 및 결과:</strong></p>
<ul>
<li><strong>강화 학습 (RL) 훈련 속도:</strong> ManiSkill3의 GPU 시뮬레이션은 <code>PickCube</code> 태스크에서 PPO를 사용할 때 ManiSkill2의 CPU 시뮬레이션 대비 상태 기반 관측에서 약 15배, RGB 기반 관측에서 약 8배의 훈련 속도 향상을 보여줍니다. 상태 기반의 경우 1분, RGB 기반의 경우 10분 만에 거의 100% 성공률에 도달합니다.</li>
<li><strong>시연 기반 학습 (LfD) / 모방 학습:</strong> 행동 복제(BC), Diffusion Policy (DP), Action Chunking Transformer (ACT)와 같은 오프라인 모방 학습 기준선과 RLPD, RFCL과 같은 온라인 모방 학습 기준선을 제공합니다. 특히 Diffusion Policy는 적은 수의 시연에서도 가장 좋은 성능을 보였습니다. PerAct와 같은 복셀 기반 VLA 모델도 지원하며, Multi-View 및 SE(3) 증강이 성능 향상에 기여함을 보여줍니다.</li>
<li><strong>시각 기반 Sim2Real 조작:</strong> ManiSkill3는 Koch v1.1 로봇 팔과 휴대폰 카메라를 사용하여 시각 기반 조작 정책을 종단 간(end-to-end) 훈련하고 제로샷(zero-shot)으로 실제 세계에 배포하는 재현 가능한 설정을 제공합니다. 시뮬레이션 훈련 시 배경 녹색 스크리닝 및 광범위한 도메인 무작위화(카메라 포즈, 조명 방향, 로봇 포즈, 큐브 크기, 색상, 마찰)를 적용합니다. 약 1시간 훈련 후 최종 정책은 실제 세계에서 91.6%의 성공률을 달성했으며, 시뮬레이션과 실제 세계 성공률 간의 높은 상관관계(0.9284)를 입증했습니다.</li>
</ul>
<p><strong>한계점:</strong> 복잡한 환경(예: 룸 스케일 장면)에서는 단일 GPU에서 병렬 환경의 수가 제한될 수 있습니다. Sim2Real의 완전한 해결은 아니며, 특정 보상 설계가 필요할 수 있습니다. 현재 Sim2Real 데모는 정적 카메라로 제한되어 있고, 소프트 바디 환경과 같은 일부 태스크는 GPU 병렬화가 되지 않습니다.</p>
<p><strong>결론:</strong> ManiSkill3는 일반화 가능한 로봇 시뮬레이션 및 렌더링을 위한 최첨단 프레임워크를 제공합니다. 이 플랫폼은 낮은 GPU 메모리 사용량, 높은 FPS, 독특한 이종 GPU 시뮬레이션, 그리고 가장 다양한 로봇 태스크를 특징으로 합니다. Sim2Real 및 Real2Sim 환경을 신뢰성 있게 지원하고, 몰입형 VR 텔레오퍼레이션 시스템을 제공하며, 사용자 친화적인 객체 지향 API를 통해 확장 가능한 로봇 학습의 접근성을 높입니다.</p>
<hr>
</section>
<section id="detail-review" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Detail Review</h1>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>