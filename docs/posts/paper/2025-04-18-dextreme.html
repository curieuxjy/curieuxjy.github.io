<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-04-18">
<meta name="description" content="Transfer of Agile In-hand Manipulation from Simulation to Reality">

<title>📃Dextreme 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-1e438c382a17f6d88d3993662a872df6.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-a37c72dd2dbac68997fcdc15a3622e78.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-b009f778f5cec7f34f624408a2b5b543.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    window.setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      window.setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    window.hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(darkModeDefault) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const darkModeDefault = false;
    document.querySelector('link.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !window.hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
    };
    // Switch to dark mode if need be
    if (window.hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review"><span class="header-section-number">1</span> Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review"><span class="header-section-number">2</span> Detail Review</a>
  <ul class="collapse">
  <li><a href="#배경-손-안-조작과-sim-to-real의-도전과제" id="toc-배경-손-안-조작과-sim-to-real의-도전과제" class="nav-link" data-scroll-target="#배경-손-안-조작과-sim-to-real의-도전과제"><span class="header-section-number">2.1</span> 배경: 손 안 조작과 Sim-to-Real의 도전과제</a></li>
  <li><a href="#dextreme의-접근법-privileged-rl-teacher-student-구조-adr-등" id="toc-dextreme의-접근법-privileged-rl-teacher-student-구조-adr-등" class="nav-link" data-scroll-target="#dextreme의-접근법-privileged-rl-teacher-student-구조-adr-등"><span class="header-section-number">2.2</span> DeXtreme의 접근법: Privileged RL, Teacher-Student 구조, ADR 등</a></li>
  <li><a href="#domain-randomisation-이하-dr-디테일-파헤치기" id="toc-domain-randomisation-이하-dr-디테일-파헤치기" class="nav-link" data-scroll-target="#domain-randomisation-이하-dr-디테일-파헤치기"><span class="header-section-number">2.3</span> Domain Randomisation (이하 <strong>DR</strong>) 디테일 파헤치기 🔍</a>
  <ul class="collapse">
  <li><a href="#왜-domain-randomisation인가" id="toc-왜-domain-randomisation인가" class="nav-link" data-scroll-target="#왜-domain-randomisation인가"><span class="header-section-number">2.3.1</span> 1. 왜 Domain Randomisation인가?</a></li>
  <li><a href="#무작위화-파라미터-전체-목록" id="toc-무작위화-파라미터-전체-목록" class="nav-link" data-scroll-target="#무작위화-파라미터-전체-목록"><span class="header-section-number">2.3.2</span> 2. 무작위화 파라미터 전체 목록</a></li>
  <li><a href="#automatic-domain-randomisation-adr-메커니즘" id="toc-automatic-domain-randomisation-adr-메커니즘" class="nav-link" data-scroll-target="#automatic-domain-randomisation-adr-메커니즘"><span class="header-section-number">2.3.3</span> 3. Automatic Domain Randomisation (<strong>ADR</strong>) 메커니즘</a></li>
  <li><a href="#훈련-스케줄-실제-효과" id="toc-훈련-스케줄-실제-효과" class="nav-link" data-scroll-target="#훈련-스케줄-실제-효과"><span class="header-section-number">2.3.4</span> 4. 훈련 스케줄 &amp; 실제 효과</a></li>
  <li><a href="#재현-팁-주의사항" id="toc-재현-팁-주의사항" class="nav-link" data-scroll-target="#재현-팁-주의사항"><span class="header-section-number">2.3.5</span> 5. 재현 팁 &amp; 주의사항</a></li>
  <li><a href="#요약" id="toc-요약" class="nav-link" data-scroll-target="#요약"><span class="header-section-number">2.3.6</span> 6. 요약</a></li>
  </ul></li>
  <li><a href="#vision-기반-상태-추정과-teacher-student-적용" id="toc-vision-기반-상태-추정과-teacher-student-적용" class="nav-link" data-scroll-target="#vision-기반-상태-추정과-teacher-student-적용"><span class="header-section-number">2.4</span> Vision 기반 상태 추정과 Teacher-Student 적용</a></li>
  <li><a href="#결과-현실에서의-민첩한-손-안-조작" id="toc-결과-현실에서의-민첩한-손-안-조작" class="nav-link" data-scroll-target="#결과-현실에서의-민첩한-손-안-조작"><span class="header-section-number">2.5</span> 결과: 현실에서의 민첩한 손 안 조작</a></li>
  <li><a href="#마무리-및-의의" id="toc-마무리-및-의의" class="nav-link" data-scroll-target="#마무리-및-의의"><span class="header-section-number">2.6</span> 마무리 및 의의</a></li>
  </ul></li>
  <li><a href="#reference" id="toc-reference" class="nav-link" data-scroll-target="#reference"><span class="header-section-number">3</span> Reference</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃Dextreme 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">paper</div>
    <div class="quarto-category">in-hand</div>
    <div class="quarto-category">vision</div>
  </div>
  </div>

<div>
  <div class="description">
    Transfer of Agile In-hand Manipulation from Simulation to Reality
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 18, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p>CoRL 2021</p>
</blockquote>
<ul>
<li><a href="https://dextreme.org/">프로젝트 홈페이지</a></li>
<li><a href="https://github.com/isaac-sim/IsaacGymEnvs/tree/main/isaacgymenvs/tasks/dextreme">Code</a></li>
<li><a href="https://arxiv.org/pdf/2210.13702">Paper</a></li>
</ul>
<hr>
<ol type="1">
<li>🤖 DeXtreme은 심층 강화 학습을 통해 인간형 로봇 손의 정교한 조작 정책을 훈련하고, 물체의 상태에 대한 신뢰성 있는 실시간 정보를 제공하는 강력한 자세 추정기를 개발했습니다.</li>
<li>💪 시뮬레이션에서 다양한 조건에 적응하도록 훈련된 정책은 비전 기반 정책에서 기존 최고 성능을 능가하며 모션 캡처 시스템을 통해 특권적인 상태 정보를 제공받은 정책과 경쟁력을 갖습니다.</li>
<li>💰 Allegro Hand 및 Isaac Gym GPU 기반 시뮬레이션을 통해 접근 가능한 로봇 손과 카메라로 유사한 결과를 얻을 수 있는 가능성을 제시하여 민첩한 조작 개발 및 배포 과정을 단순화했습니다.</li>
</ol>
<section id="brief-review" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Brief Review</h1>
<p>이 논문은 다지 로봇 손으로 민첩한 조작을 학습하고 시뮬레이션에서 현실로 이전하는 기술인 DeXtreme을 제시합니다. 핵심은 심층 강화 학습(RL)을 사용하여 로봇 손의 견고한 조작 정책을 훈련하고, 조작 대상 객체의 상태에 대한 신뢰할 수 있는 실시간 정보를 제공하는 강력한 자세 추정기를 개발하는 것입니다.</p>
<p><strong>핵심 방법론:</strong></p>
<ol type="1">
<li><p><strong>과제 설정:</strong> 인간형 로봇 손으로 물체 방향을 바꾸는 과제를 설정합니다. 손바닥 위에 놓인 물체를 원하는 목표 방향으로 회전시키는 것이 목표입니다. 목표 방향에 도달하면 새로운 목표 방향이 주어지고, 물체를 떨어뜨리거나 정지하지 않고 연속적으로 목표를 달성하는 횟수를 측정합니다.</p></li>
<li><p><strong>하드웨어 구성:</strong> Allegro Hand (손목 고정)와 3대의 Intel D415 RGB 카메라를 사용합니다. 카메라는 손바닥을 기준으로 외부 캘리브레이션됩니다. 마커 기반 시스템 대신 비전 기반 시스템을 사용하여 물체 자세를 추정합니다.</p></li>
<li><p><strong>정책 학습:</strong></p>
<ul>
<li><strong>RL 공식화:</strong> 물체 조작 과제를 부분적으로 관찰 가능한 마르코프 결정 프로세스(POMDP)로 모델링합니다. Proximal Policy Optimization (PPO) 알고리즘을 사용하여 관측값에서 행동으로의 매핑을 학습하는 확률적 정책 <span class="math inline">\pi_\theta</span> (actor)를 학습합니다. 또한 가치 함수 <span class="math inline">V^{\pi}_\phi (s, o)</span> (critic)를 학습하여 정책 가치를 추정합니다.</li>
<li><strong>Actor와 Critic:</strong> Critic은 Actor와 다른 관측값을 사용하며, 상태 <span class="math inline">s \in S</span>에 대한 추가 정보를 받습니다. Actor의 입력은 물체 위치, 방향, 목표 위치, 방향, 상대적 목표 방향, 이전 행동, 손 관절 각도, 확률적 지연 등으로 구성됩니다 (총 50차원). Critic은 Actor의 입력 외에도 핑거팁 위치/회전/속도/힘, 손 관절 속도/힘, 물체 속성, 중력 벡터 등 추가 상태 정보를 활용합니다 (총 265차원).</li>
<li><strong>신경망 구조:</strong> 정책은 LSTM(Long Short-Term Memory) 네트워크를 사용하며, 이전 hidden state <span class="math inline">h \in H</span>와 환경 관측값 <span class="math inline">o</span>를 입력으로 받습니다. LSTM은 1024개의 hidden unit과 layer normalization을 사용하고, 그 뒤에 512 크기의 MLP(Multilayer Perceptron) 레이어 2개가 ELU 활성화 함수와 함께 연결됩니다. 액션 공간 <span class="math inline">A</span>는 로봇 손의 16개 관절에 대한 PD 컨트롤러 목표입니다. 가치 함수 LSTM 레이어는 2048개의 hidden unit을 갖고 layer normalization을 사용하며, 1024 및 512 유닛의 MLP 레이어 2개와 ELU 활성화 함수가 뒤따릅니다. 정책의 출력은 지수 이동 평균(EMA) 평활화 필터를 통과합니다.</li>
</ul></li>
<li><p><strong>보상 함수:</strong> Isaac Gym의 Shadow Hand 환경에서 영감을 받아 설계된 보상 함수를 사용합니다. 목표에 가까운 회전, 고정 목표 위치에 가까운 위치, 액션 페널티, 액션 변화 페널티, 관절 속도 페널티 등을 고려합니다.</p></li>
<li><p><strong>시뮬레이션 환경:</strong> GPU 기반 Isaac Gym 시뮬레이터를 사용하여 수천 개의 로봇을 병렬로 시뮬레이션합니다.</p></li>
<li><p><strong>도메인 랜덤화:</strong> 시뮬레이션과 실제 사이의 간극을 줄이기 위해 다양한 도메인 랜덤화 기법을 적용합니다.</p>
<ul>
<li><strong>Vectorized Automatic Domain Randomization (VADR):</strong> 도메인 랜덤화 파라미터를 자동으로 조정하여 정책 성능을 유지하면서 랜덤화 범위를 최대화합니다. 각 파라미터에 대해 별도의 스텝 크기 <span class="math inline">\Delta_n</span>을 설정하고, 환경의 40%를 평가에 사용합니다. 평가 환경에서는 ADR 랜덤화 차원 중 하나를 현재 상한 또는 하한 경계로 고정합니다. 에피소드 종료 시 연속 성공 횟수를 기록하고, 평균 연속 성공 횟수가 임계값을 초과하면 범위를 넓히고, 낮으면 범위를 좁힙니다. 여러 GPU에서 훈련할 때 각 GPU에서 VADR을 독립적으로 실행합니다.</li>
<li><strong>물리 랜덤화:</strong> 질량, 마찰, 반발 계수 등 기본 속성을 랜덤화합니다. 손과 물체의 크기를 랜덤하게 조정하고, 관절 강성, 감쇠, 한계를 랜덤화합니다. 또한 물체에 임의의 힘을 가합니다.</li>
<li><strong>비물리 랜덤화:</strong> 액션 및 관측에 확률적 지연, 액션 지연 시간, 상관/비상관 가우시안 노이즈를 추가합니다. 또한 RNA(Random Network Adversary)를 사용하여 구조화된 노이즈 패턴을 도입합니다.</li>
<li><strong>Random Network Adversary (RNA):</strong> 각 에피소드마다 무작위로 생성된 신경망을 사용하여 환경에 더 구조화된 상태 가변 노이즈 패턴을 도입합니다. RNA 네트워크의 액션은 <span class="math inline">a = \alpha \cdot a_{RNA} + (1-\alpha) \cdot a_{policy}</span>의 공식으로 정책으로부터의 액션과 혼합됩니다. <span class="math inline">\alpha</span>는 ADR에 의해 제어됩니다.</li>
</ul></li>
<li><p><strong>자세 추정:</strong> NVIDIA Omniverse Isaac Sim과 Replicator를 사용하여 5백만 장의 이미지를 생성합니다. torchvision Mask-RCNN에서 영감을 얻은 네트워크를 사용하여 bounding box, segmentation, 큐브 모서리의 keypoint를 예측합니다. 세 대의 카메라에서 20Hz의 추론 속도로 네트워크를 실행하고, 각 카메라에서 PnP 알고리즘을 적용하여 자세를 추정한 다음, 필터링된 카메라에서 키포인트를 삼각 측량하여 최종 자세를 얻습니다.</p></li>
</ol>
<p><strong>주요 결과:</strong></p>
<ul>
<li><p>ADR을 사용하여 훈련된 정책이 수동으로 조정된 정책보다 성능이 우수합니다.</p></li>
<li><p>비전 기반 자세 추정을 사용한 정책이 이전 연구의 비전 기반 정책보다 성능이 향상되었고, 모션 캡처 시스템을 사용한 정책과도 경쟁력이 있습니다.</p></li>
<li><p>저렴한 하드웨어 (Allegro Hand)와 간단한 비전 시스템으로도 민첩한 조작이 가능하다는 것을 입증합니다.</p></li>
</ul>
<p><strong>핵심 기여:</strong></p>
<ul>
<li><p>저렴한 하드웨어를 사용하고 순수하게 비전 기반 파이프라인을 사용하는 학습 기반 민첩한 조작 시스템을 시연합니다.</p></li>
<li><p>다양한 로봇 설정에서 작동하는 강력한 자세 추정기를 개발합니다.</p></li>
<li><p>순수 비전 기반 상태 추정 결과가 기존 비전 기반 결과보다 성능이 우수하며 마커 기반 결과와 비슷합니다.</p></li>
</ul>
<p>이 연구는 로봇 연구 커뮤니티가 최첨단 핸드 내 조작 시스템에 접근할 수 있도록 지원하고 추가 연구 및 발전을 촉진하는 것을 목표로 합니다.</p>
</section>
<section id="detail-review" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Detail Review</h1>
<blockquote class="blockquote">
<p>DeXtreme: 시뮬레이션에서 현실로의 민첩한 손 안 조작 전이 – 논문 리뷰</p>
</blockquote>
<section id="배경-손-안-조작과-sim-to-real의-도전과제" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="배경-손-안-조작과-sim-to-real의-도전과제"><span class="header-section-number">2.1</span> 배경: 손 안 조작과 Sim-to-Real의 도전과제</h2>
<p>일반적인 로봇 그리퍼(집게)는 두 개의 손가락으로 물체를 잡는 방식이어서 한 번 쥔 물체의 <strong>자세</strong>(orientation)를 크게 바꾸기 어렵습니다. 반면 <strong>다지(多指) 로봇 손</strong>은 인간 손처럼 복잡한 움직임으로 물체를 <strong>손 안에서 조작(in-hand manipulation)</strong>할 수 있어, 예를 들어 손바닥 위에서 큐브의 자세를 자유롭게 바꾸는 등 <strong>고난도 조작</strong>을 가능하게 합니다. 그러나 이러한 <strong>고자유도</strong> 로봇 손의 제어는 난이도가 높고, 특히 시뮬레이션으로 학습한 제어 정책을 현실 로봇에 옮길 때 <strong>시뮬레이션-현실 간 격차(sim-to-real gap)</strong>로 인해 많은 문제가 발생합니다. 손가락과 물체 사이의 미세한 마찰, 접촉(dynamic contact) 등 물리 상호작용을 정확히 모사하기 어렵기 때문입니다.</p>
<p>2018년 OpenAI 연구진은 <strong>심층 강화학습</strong>만으로 다지 로봇 손의 복잡한 손 안 조작을 처음 성공적으로 시현하여 큰 주목을 받았습니다. 이들은 Shadow Hand라는 고가의 로봇 손과 모션 캡처 기반의 정밀 추적 시스템을 사용하고, 수백 대의 CPU 서버와 수십 대의 GPU를 동원한 복잡한 학습 구조를 도입했습니다. 그 결과 Rubik’s Cube와 같은 난제 해결이 가능해졌지만, <strong>특수한 하드웨어와 막대한 연산 자원</strong>에 의존했기에 <strong>재현성과 확장성</strong> 측면에서 한계가 있었습니다. 이후 연구들에서도 강화학습을 통한 손 안 조작 성공 사례가 보고되었지만 대부분 <strong>시뮬레이션 내의 성과</strong>에 그쳤습니다.</p>
<p><strong>DeXtreme</strong>은 이러한 맥락에서 등장한 연구로, <strong>비용을 획기적으로 낮춘 장비</strong>와 <strong>효율적인 학습 기법</strong>을 통해 <strong>현실 세계에서 민첩한 손 안 조작</strong>을 구현한 사례입니다. 이 연구에서는 약 10배 저렴한 Allegro Hand(4 finger, 관절 수 16)를 사용하고 손목을 고정했으며, 물체 추적을 위해 <strong>전용 마커나 모캡 없이 3대의 범용 RGB 카메라</strong>만 활용했습니다. 또한 시뮬레이터로 <strong>NVIDIA Isaac Gym</strong>(GPU 가속 물리 시뮬레이션)을 사용하여 학습 인프라를 크게 간소화했습니다. 그 결과 단 8개의 GPU로 학습을 완료할 수 있었으며 (OpenAI의 이전 작업은 400여 대의 CPU 서버와 32개의 GPU를 사용, 최종 정책은 <strong>모션 캡처 없이도</strong> OpenAI의 모캡 기반 성능에 필적하는 수준을 달성했습니다. 요약하면, <strong>DeXtreme</strong>은 <em>“저렴한 로봇 손+비전 기반 상태 추정+대규모 병렬 시뮬레이션”</em> 조합으로 <strong>손 안 조작의 sim-to-real</strong> 가능성을 재확인하고, 관련 연구의 <strong>진입장벽을 낮춘</strong> 의미 있는 성과입니다.</p>
</section>
<section id="dextreme의-접근법-privileged-rl-teacher-student-구조-adr-등" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="dextreme의-접근법-privileged-rl-teacher-student-구조-adr-등"><span class="header-section-number">2.2</span> DeXtreme의 접근법: Privileged RL, Teacher-Student 구조, ADR 등</h2>
<p><strong>DeXtreme</strong>에서는 현실 로봇(hand + 카메라)으로 옮겨도 동작하는 <strong>강화학습 정책</strong>을 만들기 위해, 시뮬레이션 상에서 다음과 같은 기법들을 조합해 학습을 진행했습니다:</p>
<ul>
<li><p><strong>Privileged Learning과 비대칭 정책 학습</strong>: 현실에서는 물체의 정확한 상태(예: 큐브의 3차원 자세)를 직접 알 수 없지만 시뮬레이션에선 쉽게 얻을 수 있습니다. 이를 활용해 학습 시 <strong>정책(policy)</strong>과 <strong>가치함수(critic)</strong>에 서로 다른 정보를 제공했습니다. 정책 네트워크(실제 로봇에 배치될 <strong>학생(student)</strong> 역할)는 <strong>실제로 관측 가능한 정보</strong>만을 입력으로 받도록 했습니다. 구체적으로 <strong>손 관절 각도</strong>, 목표 자세와 현재 추정된 큐브 자세(약간의 노이즈 추가) 등 <strong>부분 관측 상태</strong>만으로 행동을 결정하게 합니다. 반면 <strong>가치함수 신경망(</strong>교사** 역할)<strong>에는 시뮬레이터가 제공하는 </strong>privileged 정보<strong>까지 추가로 입력했습니다. 예를 들어 물체의 실제 위치/자세, 물리 파라미터(마찰계수 등)와 임의로 가해진 외력 등의 정보를 </strong>평가자<strong>만 알고 있도록 함으로써, 학습 과정에서 </strong>정책 평가<strong>의 정확성을 높이고 안정적인 학습이 가능하게 했습니다. 이러한 </strong>비대칭(actor-critic) 학습** 구조는 Pinto 등 선행연구의 방식을 따른 것으로, 현실에서 관측 불가능한 정보를 활용해 <strong>교사가 학생 정책을 효과적으로 지도</strong>하는 형태로 볼 수 있습니다. 또한 정책 네트워크는 <strong>LSTM 기반의 순환신경망(recurrent policy)</strong>으로 구성하여, 과거의 관측 정보를 내재화하고 <strong>부분 관측</strong> 문제를 완화했습니다. LSTM (은닉 차원 1024)을 사용함으로써 손 움직임의 <strong>연속성</strong>과 <strong>시간 지연</strong>에 대한 대응 능력을 갖춘 정책을 학습했습니다.</p></li>
<li><p><strong>Domain Randomization (도메인 랜덤화)</strong>과 <strong>커리큘럼 학습</strong>: 시뮬레이션-현실 격차를 극복하는 대표 기법으로 <strong>환경 무작위화</strong>가 사용되었습니다. <strong>물리 파라미터 무작위화</strong>로는 물체와 손의 마찰계수, 질량, 관성, 탄성계수 등을 임의로 변화시켰고, 손가락 관절 마다 마찰/마찰감쇠 계수나 구동 힘 한계 등을 랜덤하게 스케일 조정했습니다. 또한 매 timestep 임의의 작은 외력을 물체에 가해 <strong>예기치 않은 충격</strong>에도 견디도록 학습시켰습니다. 심지어 중력 가속도 값도 에피소드마다 바꾸어 가며 다양한 중력 환경을 경험시켰습니다. <strong>비(非)물리적 랜덤화</strong>로는 센서 지연이나 잡음 같은 현실적 요소를 추가했습니다. 예를 들어, <strong>관측 지연</strong>으로서 가상의 카메라 <strong>프레임레이트 지연</strong>을 도입하여, 정책이 매 시간 물체 상태를 업데이트 받지 못하고 낮은 주기의 정보에도 견인하도록 만들었습니다. 실제 시스템에서 제어 명령이 로봇에 전달될 때 통신 지연이 있으므로, <strong>액션 지연</strong> 또한 무작위로 발생시키고, 오래된 명령이 실행되는 상황을 섞었습니다. 이와 함께 각 관측값과 행동에 <strong>가우시안 잡음</strong>을 상관된 형태로 추가하여 (일부 환경은 노이즈 0으로 두기도 함) 센서/액츄에이터 노이즈에 대한 <strong>내성</strong>을 키웠습니다.</p></li>
<li><p><strong>Random Network Adversary</strong>: 일반적인 가우시안 노이즈로는 한계가 있는 <strong>구조적 교란</strong>에 대응하기 위해, 무작위로 생성된 신경망을 <strong>적대적 동작 신호</strong>로 사용했습니다. 매 에피소드마다 임의의 파라미터로 초기화된 작은 신경망이 <strong>가짜 행동</strong> <span class="math inline">a_{RNA}</span>을 생성하고, 이를 현재 정책의 행동 <span class="math inline">a_{\pi}</span>와 일정 비율로 섞어서 최종 시뮬레이터에 적용할 행동 <span class="math inline">a_{sim}</span>으로 삼았습니다. 이 비율 <span class="math inline">\alpha</span> 역시 학습 진행에 따라 조절되는데, 학습 초기에 <span class="math inline">\alpha</span>를 높여 정책에 <strong>예측 불가능한 교란</strong>을 많이 섞어주고, 정책이 향상되면 <span class="math inline">\alpha</span>를 낮추는 식입니다. 이렇게 하면 단순 랜덤 노이즈보다 <strong>상황 의존적</strong>인 교란을 정책이 견디도록 만들 수 있습니다 (OpenAI의 Rubik’s Cube 학습에도 사용된 기법). 아래 그림은 이러한 <strong>랜덤 신경망 적대기법</strong>의 개념도입니다.</p></li>
</ul>
<p><strong>Figure 1:</strong> 무작위 신경망 적대기법(Random Network Adversary)의 동작. 에피소드마다 랜덤 가중치로 생성된 신경망이 상태 <span class="math inline">s_t</span>를 입력으로 <strong>적대적 행동</strong> <span class="math inline">a_{RNA}</span>를 생성하고(왼쪽), 이를 현재 정책의 행동 <span class="math inline">a_{\pi}</span>와 합쳐 최종 행동 <span class="math inline">a_{sim}</span>로 적용한다(오른쪽). <span class="math inline">\alpha</span>는 적대 행동의 반영 비율로, 학습 중 ADR 알고리즘에 의해 점진 조정된다.</p>
<ul>
<li><strong>Automatic Domain Randomization (ADR)</strong>: 초기 학습 단계부터 너무 과도한 무작위화를 주면 정책이 <strong>기본기 습득</strong>도 못한 채 학습이 실패할 수 있습니다. DeXtreme은 이를 피하기 위해, OpenAI에서 제안된 <strong>자동 도메인 랜덤화(ADR)</strong>를 활용했습니다. <strong>ADR 알고리즘</strong>은 정책의 성능을 모니터링하며 <strong>랜덤화 난이도를 자동 조절</strong>합니다. 구체적으로, 각 랜덤화 변인의 범위(분포 폭)를 정책이 <strong>어느 정도 견딜 수 있는지</strong>를 평가하여, 성능이 좋으면 범위를 넓히고 성능이 떨어지면 범위를 줄이는 <strong>적응형 커리큘럼</strong>입니다. 이 작업을 가속하기 위해 전체 병렬 시뮬레이션 중 일부(40%) 환경을 <strong>평가 모드</strong>로 설정하고, 특정 랜덤화 변인을 극단값(최대/최소)으로 고정한 상태에서 에피소드를 실행합니다. 에피소드 종료 시 <strong>연속 성공 횟수</strong>(아래에서 설명)를 측정하여 임계값 이상이면 해당 변인의 무작위화 범위를 넓히고, 기준 이하이면 범위를 좁히는 식입니다. 이렇게 하면 학습이 진행될수록 정책이 더 <strong>넓은 환경 변화</strong>에 견디게끔 훈련 난이도가 상승합니다. <strong>Vectorized ADR</strong>은 Isaac Gym의 대량 병렬 환경을 활용해 이러한 범위 조정을 <strong>동시에 여러 변인에 대해</strong> 수행하는 최적화된 구현입니다. 요약하면, ADR을 통해 처음에는 <strong>쉬운 환경</strong>에서 시작해 점차 <strong>어려운 환경</strong>으로 난이도가 올라가는 <strong>자동 커리큘럼 학습</strong>이 달성됩니다.</li>
</ul>
<p><strong>Figure 2:</strong> 시뮬레이션에서의 정책 학습 파이프라인. 여러 개의 병렬 환경에서 Allegro Hand가 큐브를 돌리는 장면이 보인다 (왼쪽 그림). 각 환경은 무작위화된 물리 파라미터를 가지며, 학습 알고리즘(PPO 기반)이 <strong>순환 신경망 정책</strong>을 개선한다. 동시에 <strong>Vectorized ADR</strong> 알고리즘이 정책 성능을 평가하여 무작위화 범위(오른쪽 아래 그래프 아이콘의 Δ 기호로 표시)를 조정한다. 이러한 과정으로 정책은 다양한 조건에서 <strong>강인한 제어</strong> 능력을 익히게 된다.</p>
</section>
<section id="domain-randomisation-이하-dr-디테일-파헤치기" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="domain-randomisation-이하-dr-디테일-파헤치기"><span class="header-section-number">2.3</span> Domain Randomisation (이하 <strong>DR</strong>) 디테일 파헤치기 🔍</h2>
<p>DeXtreme가 <strong>저비용 Allegro Hand + RGB Vision</strong> 만으로 실세계에서 민첩한 in‑hand manipulation을 달성할 수 있었던 결정적 비결은 <strong>DR + Automatic Domain Randomisation(ADR)</strong> 입니다. 이 절에서는 논문이 사용한 DR 구성, 매개변수 범위, ADR 알고리즘, 그리고 실제 성능 영향까지 깊이 들어가 보겠습니다.</p>
<hr>
<section id="왜-domain-randomisation인가" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="왜-domain-randomisation인가"><span class="header-section-number">2.3.1</span> 1. 왜 Domain Randomisation인가?</h3>
<ul>
<li><strong>시뮬레이터 모델 오차</strong>: 마찰·접촉·센서 지연 같은 요소를 완벽히 모델링하기 어렵다.<br>
</li>
<li><strong>하드웨어 가변성</strong>: 온도·마모·배터리 전압 등의 요인으로 로봇 파라미터가 매일 변한다.<br>
</li>
<li><strong>예기치 못한 외란</strong>: 손가락에 부딪히는 충격, 비전 tracking 오류 등.</li>
</ul>
<blockquote class="blockquote">
<p>따라서 “시뮬레이터가 틀린 것을 전제로 하고”, 가능한 많은 조건을 <strong>무작위화</strong>하여 <strong>강인한(policy)</strong> 를 학습한다. 이때 DR은 크게 <strong>물리·관측·제어·환경</strong> 4 영역으로 나뉜다. citeturn6view0</p>
</blockquote>
<hr>
</section>
<section id="무작위화-파라미터-전체-목록" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="무작위화-파라미터-전체-목록"><span class="header-section-number">2.3.2</span> 2. 무작위화 파라미터 전체 목록</h3>
<p>아래 표는 논문의 <strong>Table 3</strong>을 발췌·정리한 것으로, <strong>초기 범위</strong>와 ADR이 발견한 <strong>최종 범위</strong>(↔︎ 더 넓어진 부분은 굵게 표기)를 보여준다.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 19%">
<col style="width: 29%">
<col style="width: 14%">
<col style="width: 11%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>카테고리</th>
<th>파라미터</th>
<th>타입</th>
<th>초기 범위</th>
<th>ADR 후 범위</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Hand</strong></td>
<td>Mass Scaling</td>
<td>uniform</td>
<td>0.4–1.5</td>
<td>0.4–1.5</td>
</tr>
<tr class="even">
<td></td>
<td>Friction Scaling</td>
<td>uniform</td>
<td>0.8–1.2</td>
<td><strong>0.54–1.58</strong></td>
</tr>
<tr class="odd">
<td></td>
<td>Joint Stiffness Scaling</td>
<td>log‑uniform</td>
<td>0.3–3.0</td>
<td><strong>0.3–3.52</strong></td>
</tr>
<tr class="even">
<td></td>
<td>Effort Scaling</td>
<td>uniform</td>
<td>0.9–1.1</td>
<td><strong>0.9–2.49</strong></td>
</tr>
<tr class="odd">
<td><strong>Object</strong></td>
<td>Mass Scaling</td>
<td>uniform</td>
<td>0.4–1.6</td>
<td>0.4–1.6</td>
</tr>
<tr class="even">
<td></td>
<td>Friction Scaling</td>
<td>uniform</td>
<td>0.3–0.9</td>
<td><strong>0.01–1.60</strong></td>
</tr>
<tr class="odd">
<td></td>
<td>External Forces</td>
<td>additive</td>
<td>‑</td>
<td>OpenAI 방식 참조</td>
</tr>
<tr class="even">
<td><strong>Observation</strong></td>
<td>Pose Delay Prob.</td>
<td>set</td>
<td>0–0.05</td>
<td><strong>0–0.47</strong></td>
</tr>
<tr class="odd">
<td></td>
<td>Pose Frequency</td>
<td>set</td>
<td>1 (=매스텝)</td>
<td><strong>1–6 스텝</strong></td>
</tr>
<tr class="even">
<td></td>
<td>Correlated/Uncorr. Noise</td>
<td>gaussian</td>
<td>0–0.04</td>
<td><strong>0–0.14 (uncorr.)</strong></td>
</tr>
<tr class="odd">
<td><strong>Action</strong></td>
<td>Action Delay Prob.</td>
<td>set</td>
<td>0–0.05</td>
<td><strong>0–0.31</strong></td>
</tr>
<tr class="even">
<td></td>
<td>Action Latency (스텝)</td>
<td>set</td>
<td>0</td>
<td><strong>0–1.5</strong></td>
</tr>
<tr class="odd">
<td></td>
<td>RNA (적대 신경망) 스케일 α</td>
<td>set</td>
<td>0</td>
<td><strong>0–0.16</strong></td>
</tr>
<tr class="even">
<td><strong>Environment</strong></td>
<td>Gravity Δg (m/s²)</td>
<td>normal</td>
<td>0±0.5</td>
<td>동일</td>
</tr>
</tbody>
</table>
<p><em>타입</em>: <strong>Scaling</strong>은 모수에 계수 곱셈, <strong>Additive</strong>는 값 더하기, <strong>Set value</strong>는 에피소드마다 상수를 샘플링한다. citeturn6view0</p>
<hr>
</section>
<section id="automatic-domain-randomisation-adr-메커니즘" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3" class="anchored" data-anchor-id="automatic-domain-randomisation-adr-메커니즘"><span class="header-section-number">2.3.3</span> 3. Automatic Domain Randomisation (<strong>ADR</strong>) 메커니즘</h3>
<ol type="1">
<li><strong>초기화</strong>: 각 파라미터 <span class="math inline">p_i</span> 는 <span class="math inline">[l_i, u_i]</span> 범위를 갖고 시작. 초기 값은 현실 계측치 ± 여유치.<br>
</li>
<li><strong>병렬 환경 샘플링</strong>: Isaac Gym의 8 GPU에서 <strong>16 k envs</strong>를 실행. 이 중 <strong>40 %</strong> 는 <em>evaluation env</em> 로 지정해 DR 범위의 <strong>경계값</strong>( <span class="math inline">l_i</span> 또는 <span class="math inline">u_i</span> )만 고정한다.<br>
</li>
<li><strong>성공률 측정</strong>: 에피소드 종료 시 <strong>consecutive success</strong>(큐브 연속 회전 성공 수)를 경계별로 기록.<br>
</li>
<li><strong>경계 업데이트</strong> (VADR 알고리즘) citeturn6view0
<ul>
<li>평균 성공 &gt; 상한 <span class="math inline">\gamma_\text{high}</span> → <strong>범위를 확장</strong><br>
</li>
<li>평균 성공 &lt; 하한 <span class="math inline">\gamma_\text{low}</span> → <strong>범위를 축소</strong><br>
</li>
<li>파라미터마다 <strong>개별 step size</strong> 를 사용해 훈련 안정성 보장.<br>
</li>
<li>업데이트가 발생하면 해당 경계의 과거 통계 큐를 리셋.</li>
</ul></li>
<li><strong>반복</strong>: 훈련 진행에 따라 대부분 파라미터가 <strong>2–5 배</strong> 이상 넓어짐(위 표 굵은 부분 참고). 이는 정책이 점진적으로 <strong>더 험난한 난이도</strong>를 경험하도록 하는 <strong>자동 커리큘럼</strong> 역할을 수행한다.</li>
</ol>
<p><strong>RNA(Random Network Adversary)</strong> 역시 ADR이 조정하는 파라미터 중 하나다. 무작위 MLP가 생성한 가짜 액션 <span class="math inline">a_\text{RNA}</span> 를 정책 액션 <span class="math inline">a_\pi</span> 와 혼합하여 <strong>구조화된 교란</strong>을 주입함으로써, 단순 가우시안 노이즈보다 강력한 일반화 효과를 얻는다.</p>
<hr>
</section>
<section id="훈련-스케줄-실제-효과" class="level3" data-number="2.3.4">
<h3 data-number="2.3.4" class="anchored" data-anchor-id="훈련-스케줄-실제-효과"><span class="header-section-number">2.3.4</span> 4. 훈련 스케줄 &amp; 실제 효과</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>모델</th>
<th>DR 방식</th>
<th>평균 연속 성공(실로봇)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Non‑ADR</td>
<td>수동 튜닝 DR</td>
<td><strong>14.8</strong></td>
</tr>
<tr class="even">
<td>ADR</td>
<td>VADR + RNA</td>
<td><strong>27.8</strong></td>
</tr>
<tr class="odd">
<td>ADR (최고 롤아웃)</td>
<td>〃</td>
<td><strong>112</strong> (peak)</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>수동 DR</strong>은 파라미터가 고정되어 일부 상황에서 cube가 ’stuck’되는 실패 모드를 보였다.<br>
</li>
<li><strong>ADR</strong> 정책은 같은 하드웨어·연산 자원으로 <strong>2 배 이상</strong> 성공 횟수를 늘리고, stuck 현상도 제거했다. citeturn6view0<br>
</li>
<li>훈련 커브(논문 Figure 6)는 ADR 활성화 후 <strong>npd(무작위화 엔트로피)</strong>가 지속적으로 상승하면서 성능도 동반 향상되는 양상을 보여준다.</li>
</ul>
<hr>
</section>
<section id="재현-팁-주의사항" class="level3" data-number="2.3.5">
<h3 data-number="2.3.5" class="anchored" data-anchor-id="재현-팁-주의사항"><span class="header-section-number">2.3.5</span> 5. 재현 팁 &amp; 주의사항</h3>
<ol type="1">
<li><strong>현실 계측 → 초기 범위 설정</strong>: 실제 Allegro Hand의 관절 스프링·댐핑, 큐브 질량/마찰 값 등을 먼저 측정하고 ± 40–60 % 정도로 초기 범위를 넓히면 안정적인 초기 탐색이 가능하다.<br>
</li>
<li><strong>Pose Frequency 랜덤화</strong>: Vision tracking 주기가 제어 loop(30 Hz)보다 느리므로, <code>Obj.Pose Freq.</code> 를 1–6 스텝으로 랜덤화해 <strong>센서 지연 내성</strong>을 키워야 한다.<br>
</li>
<li><strong>단계적 ADR 활성화</strong>: 학습 초반엔 ADR off + 좁은 수동 DR로 <strong>베이스 움직임</strong>을 먼저 익히고, 5 M step 이상 성과가 안정화되면 ADR을 켜면 수렴 속도가 빠르다.<br>
</li>
<li><strong>파라미터별 step size</strong>: 마찰처럼 민감한 변수는 작은 step(예: ±0.02), 관절 effort scale 같이 비교적 완만한 변수는 큰 step(예: ±0.1)을 주면 학습 폭주를 막을 수 있다.</li>
</ol>
<hr>
</section>
<section id="요약" class="level3" data-number="2.3.6">
<h3 data-number="2.3.6" class="anchored" data-anchor-id="요약"><span class="header-section-number">2.3.6</span> 6. 요약</h3>
<ul>
<li><strong>DR</strong>은 물리·관측·제어·환경 전 채널에 걸쳐 <strong>70 개+</strong> 파라미터를 무작위화.<br>
</li>
<li><strong>Vectorised ADR</strong>이 <strong>파라미터별 경계</strong>를 자동 확장/축소 → <strong>자동 커리큘럼</strong>.<br>
</li>
<li><strong>RNA</strong>가 구조화된 행동 교란을 가미해 정책 일반화 강화.<br>
</li>
<li>그 결과, <strong>모캡·고가 장비 없이도</strong> Shadow Hand 수준의 연속 성공률을 Allegro Hand에서 달성.</li>
</ul>
<p>DeXtreme의 DR/ADR 설계는 “<strong>얼마나 많이가 아니라, 어떻게 똑똑하게</strong> 무작위화할 것인가?”에 대한 훌륭한 레퍼런스로, sim‑to‑real 로드맵을 그리는 연구자라면 꼭 참고해 볼 만하다.</p>
</section>
</section>
<section id="vision-기반-상태-추정과-teacher-student-적용" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="vision-기반-상태-추정과-teacher-student-적용"><span class="header-section-number">2.4</span> Vision 기반 상태 추정과 Teacher-Student 적용</h2>
<p>현실 로봇에서 <strong>큐브의 자세</strong>를 알아내기 위해, 저자는 <strong>별도의 비전 신경망</strong>을 설계했습니다. 이 <strong>물체 자세 추정 네트워크</strong>는 <strong>Mask R-CNN</strong> 구조를 응용하여, 카메라 이미지에서 <strong>큐브의 8개 모서리 점(keypoints)</strong>를 검출하도록 학습되었습니다. 먼저 RGB 영상에서 큐브의 <strong>바운딩 박스와 마스크(segmentation)</strong>를 예측하고, 그 내부에서 모서리 점들의 위치를 회귀합니다. 이렇게 하면 복잡한 배경이나 큐브 미검출 문제를 줄이고, 검출된 키포인트들을 이용해 <strong>PnP 알고리즘</strong>으로 3D 자세를 산출할 수 있습니다. 카메라는 Allegro Hand를 중심으로 배치된 Intel RealSense D415 RGB 카메라 3대를 사용했으며, 각 카메라의 출력으로 추정된 큐브 자세들을 <strong>필터링 및 평균 결합</strong>하여 최종 물체 자세를 계산합니다. 이 방법은 전용 마커 없이도 비교적 정확한 (평균 5.3° 오차) 자세 추정이 가능했고, OpenAI의 end-to-end 비전 정책과 달리 <strong>카메라 배치에 유연</strong>하다는 장점이 있습니다.</p>
<p>비전 네트워크의 학습은 <strong>전적으로 시뮬레이션 데이터</strong>로 이루어졌습니다. Isaac Sim을 사용해 손과 큐브가 다양한 자세로 있는 <strong>합성 이미지 500만 장</strong>을 렌더링하여 대량의 학습 데이터를 확보했습니다. 이 때 <strong>조명, 카메라 각도, 배경</strong> 등을 무작위화하여 다양한 상황을 망라했고, 추가로 <strong>CutMix</strong>, <strong>모션 블러</strong> 등의 <strong>데이터 증강</strong>을 적용하여 실제 카메라 영상과의 도메인 격차를 줄였습니다. 아래 그림의 윗줄은 시뮬레이터로 생성한 다양한 카메라 시점의 이미지들이고, 아랫줄은 여기에 임의 배경 합성, 블러 등을 추가한 증강 결과들입니다. 이렇게 학습된 네트워크는 실제 로봇에서 약 15Hz로 동작하며, 추정된 큐브 자세를 <strong>강화학습 정책</strong>에 실시간 제공해줍니다.</p>
<p><strong>Figure 3:</strong> 비전 데이터 생성과 학습 파이프라인. (왼쪽) Omniverse Isaac Sim으로 무작위 환경에서 합성된 손+큐브 이미지들. 이렇게 500만 장의 <strong>합성 데이터셋</strong>을 확보한 뒤, (오른쪽) <strong>데이터 증강</strong>을 거쳐 Mask R-CNN 기반 <strong>물체 추적 네트워크</strong>를 학습한다. 이 네트워크는 큐브의 bounding box, segmentation, 8개 모서리 <strong>키포인트</strong>를 예측하며, 최종적으로 여러 카메라의 결과를 <strong>PnP</strong>로 통합해 3D 자세를 산출한다.</p>
<p>강화학습 <strong>정책 네트워크</strong>는 초기에 시뮬레이션에서 학습될 때 <strong>정확한 큐브 자세(특권 정보)</strong> 대신 위와 같은 <strong>추정 정보</strong>에 노이즈를 섞은 값을 관측으로 받도록 설계되었습니다. 이를 통해 실제 비전 시스템의 오차와 지연에 정책이 미리 단련되었고, sim-to-real 시 겪는 <strong>관측 불확실성</strong>을 견딜 수 있었습니다. 요약하면, 시뮬레이터 상의 <strong>교사(teacher) 정책</strong>은 완전 상태 정보를 활용해 높은 성능으로 학습되고, 이후 <strong>학생(student) 정책</strong>은 제한된 관측으로도 유사한 행동을 모방하도록 유도되었습니다. 이러한 <strong>teacher-student 네트워크 구조</strong> 덕분에 최종 정책은 모캡 없이도 동작하면서, 마치 모캡이 있는 것처럼 높은 성공률을 보이는 결과를 얻었습니다.</p>
</section>
<section id="결과-현실에서의-민첩한-손-안-조작" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="결과-현실에서의-민첩한-손-안-조작"><span class="header-section-number">2.5</span> 결과: 현실에서의 민첩한 손 안 조작</h2>
<p><strong>DeXtreme</strong>의 최종 정책을 실제 Allegro Hand 로봇에 이식한 결과, 손바닥 위의 큐브를 <strong>연속해서 여러 목표 자세로 빠르게 회전</strong>시키는 데 성공했습니다. 평가 지표는 <strong>연속 성공 횟수</strong>(consecutive successes)로, 큐브를 떨어뜨리지 않고 몇 번 연속으로 목표 자세에 도달시키는지를 측정합니다. 학습된 정책은 평균 수십 회 이상의 연속 성공을 달성했으며, 최대 수백 회에 달하는 연속 회전도 시현되었습니다. 특히 <strong>비전 기반</strong>임에도 불구하고 성능이 매우 높아, 이전 최고 성능의 <strong>모캡 기반 정책</strong>에 버금가는 수준이고, OpenAI의 <strong>최고 비전 정책</strong>보다 <strong>약 1.5배 많은 평균 연속 성공 횟수</strong>를 기록했습니다. 예를 들어, OpenAI의 카메라 기반 정책보다 <strong>평균 연속 성공 횟수가 1.5배 향상</strong>되었고, <strong>모커(MoCap) 사용 정책과 유사한 범위</strong>(약 100회 내외)의 성공을 보였습니다.</p>
<p>또한 다양한 실험에서 <strong>정책의 강인함</strong>이 확인되었습니다. 하루 간격으로 로봇을 동작시켜 <strong>환경 변화(온도, 마모 등)</strong>에 따른 성능 변화를 관찰한 결과, 약간의 변동은 있었지만 전반적으로 높은 성공률을 유지했습니다. 한편, <strong>ADR 기반 정책</strong>과 그렇지 않은 정책을 비교한 실험에서는 ADR이 없는 경우 특정 조건에서 <strong>명확한 실패 모드</strong>가 나타난 반면, ADR을 거친 정책은 훨씬 <strong>안정적 동작</strong>을 보였습니다. 요컨대, 시뮬레이션에서 도입한 다양한 기법들이 현실에서도 효과를 발휘하여, <strong>손 안 조작 작업의 성공률과 안정성</strong>을 크게 높인 것을 검증했습니다.</p>
</section>
<section id="마무리-및-의의" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="마무리-및-의의"><span class="header-section-number">2.6</span> 마무리 및 의의</h2>
<p>DeXtreme 연구는 <strong>저렴한 로봇 손과 카메라, 그리고 효율적인 학습 기법</strong>만으로도 <strong>난이도 높은 손 안 조작</strong>을 현실에서 구현할 수 있다는 것을 보여주었습니다. 특히 <strong>Privileged RL</strong>과 <strong>teacher-student 지식전이</strong>, <strong>대규모 도메인 랜덤화+ADR 커리큘럼</strong>의 조합이 sim-to-real 문제를 극복하는 데 매우 효과적임을 입증했습니다. 이로써 복잡한 모캡 장비나 거대한 연산 자원 없이도 <strong>최신 수준의 손 재주</strong>를 로봇에게 학습시킬 수 있는 길을 제시했다는 점에서 의미가 큽니다. 저자들은 코드와 학습 파이프라인을 공개하여(<strong>재현 가능성</strong>) 추후 연구자들이 이를 기반으로 다양한 물체, 다양한 손으로 실험을 확장할 수 있도록 했습니다. DeXtreme은 향후 <strong>일상적인 로봇 손 기술</strong> 개발에 중요한 참고 사례가 될 것이며, <strong>강화학습 기반 로봇 제어</strong>의 실용화를 한 걸음 앞당긴 연구로 평가됩니다.</p>
</section>
</section>
<section id="reference" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Reference</h1>
<ul>
<li><a href="https://research.nvidia.com/publication/2023-06_dextreme-transfer-agile-hand-manipulation-simulation-reality#:~:text=Recent%20work%20has%20demonstrated%20the,the%20literature%20on%20the%20same">DeXtreme: Transfer of Agile In-Hand Manipulation from Simulation to Reality | Research</a></li>
<li><a href="https://ar5iv.labs.arxiv.org/html/2210.13702#:~:text=This%20paper%20builds%20on%20top,us%20to%20reduce%20the%20amount">[2210.13702] DeXtreme: Transfer of Agile In-hand Manipulation from Simulation to Reality</a></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    window.setColorSchemeToggle(window.hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>