<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-05-05">
<meta name="description" content="교체가능한 촉각센서">

<title>📃Reskin-Anyskin 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-1e438c382a17f6d88d3993662a872df6.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-a37c72dd2dbac68997fcdc15a3622e78.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-b009f778f5cec7f34f624408a2b5b543.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    window.setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      window.setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    window.hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(darkModeDefault) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const darkModeDefault = false;
    document.querySelector('link.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !window.hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
    };
    // Switch to dark mode if need be
    if (window.hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#reskin" id="toc-reskin" class="nav-link active" data-scroll-target="#reskin"><span class="header-section-number">1</span> ReSkin</a>
  <ul class="collapse">
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link" data-scroll-target="#brief-review"><span class="header-section-number">1.1</span> Brief Review</a></li>
  </ul></li>
  <li><a href="#anyskin" id="toc-anyskin" class="nav-link" data-scroll-target="#anyskin"><span class="header-section-number">2</span> AnySkin</a>
  <ul class="collapse">
  <li><a href="#brief-review-1" id="toc-brief-review-1" class="nav-link" data-scroll-target="#brief-review-1"><span class="header-section-number">2.1</span> Brief Review</a></li>
  </ul></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review"><span class="header-section-number">3</span> Detail Review</a>
  <ul class="collapse">
  <li><a href="#배경-촉각-센서의-어려움과-요구사항" id="toc-배경-촉각-센서의-어려움과-요구사항" class="nav-link" data-scroll-target="#배경-촉각-센서의-어려움과-요구사항"><span class="header-section-number">3.1</span> 배경: 촉각 센서의 어려움과 요구사항</a></li>
  <li><a href="#reskin-자기장-기반-저비용-교체형-촉각-센서" id="toc-reskin-자기장-기반-저비용-교체형-촉각-센서" class="nav-link" data-scroll-target="#reskin-자기장-기반-저비용-교체형-촉각-센서"><span class="header-section-number">3.2</span> ReSkin: 자기장 기반 저비용 교체형 촉각 센서</a></li>
  <li><a href="#새로운-센서로의-적응-reskin의-self-supervised-학습-기법" id="toc-새로운-센서로의-적응-reskin의-self-supervised-학습-기법" class="nav-link" data-scroll-target="#새로운-센서로의-적응-reskin의-self-supervised-학습-기법"><span class="header-section-number">3.3</span> 🔥 새로운 센서로의 적응: ReSkin의 Self-supervised 학습 기법</a></li>
  <li><a href="#anyskin-플러그앤플레이plug-and-play-촉각-피부의-실현" id="toc-anyskin-플러그앤플레이plug-and-play-촉각-피부의-실현" class="nav-link" data-scroll-target="#anyskin-플러그앤플레이plug-and-play-촉각-피부의-실현"><span class="header-section-number">3.4</span> AnySkin: 플러그앤플레이(plug-and-play) 촉각 피부의 실현</a></li>
  <li><a href="#결론-및-향후-전망" id="toc-결론-및-향후-전망" class="nav-link" data-scroll-target="#결론-및-향후-전망"><span class="header-section-number">3.5</span> 결론 및 향후 전망</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃Reskin-Anyskin 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">paper</div>
    <div class="quarto-category">tactile</div>
  </div>
  </div>

<div>
  <div class="description">
    교체가능한 촉각센서
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 5, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="reskin" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> ReSkin</h1>
<blockquote class="blockquote">
<p><a href="https://reskin.dev/">https://reskin.dev/</a></p>
</blockquote>
<ol type="1">
<li>💡 ReSkin은 머신러닝과 자기 감지를 활용하여 저렴하고 다재다능하며 오래 사용할 수 있는 촉각 소프트 센서를 제공합니다.</li>
<li>🧲 ReSkin은 자기 센싱을 통해 전자 회로를 수동 인터페이스와 분리하여 다양한 형태로 제작이 용이하며, 머신러닝은 제작 및 시간 변화에 강인한 센서 응답 모델을 학습합니다.</li>
<li>⚙️ 자가 지도 학습 알고리즘을 통해 작은 데이터 수집 절차로 성능을 향상시켜 기존의 촉각 감지 모듈보다 더 다양하고 확장 가능하며 저렴한 촉각 감지 모듈을 만들 수 있습니다.</li>
</ol>
<section id="brief-review" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="brief-review"><span class="header-section-number">1.1</span> Brief Review</h2>
<p>ReSkin은 저렴하고 교체 가능하며, 오래 지속되는 다용도 소프트 촉각 스킨입니다.</p>
<p><strong>핵심 아이디어:</strong></p>
<ul>
<li><p><strong>자기장 센싱:</strong> ReSkin은 소프트 자성 스킨과 magnetometer 기반 센싱 메커니즘을 사용합니다. 외력에 의해 스킨이 변형되면 자기장 왜곡이 발생하고, 이를 통해 접촉 위치와 힘을 추정합니다. 전자 회로는 수동 인터페이스와 분리되어 있어 인터페이스 교체가 용이하며 다양한 형태로 제작할 수 있습니다.</p></li>
<li><p><strong>머신러닝:</strong> 머신러닝 모델을 사용하여 센서 응답 특성을 학습합니다. 이를 통해 제작 과정이나 시간 경과에 따른 변동에 강인한 모델을 구축하고, self-supervised learning 알고리즘을 통해 적은 비용으로 성능을 향상시킵니다.</p></li>
</ul>
<p><strong>구체적인 내용:</strong></p>
<ul>
<li><p><strong>센서 설계:</strong> 스킨은 elastomer 매트릭스 내에 삽입된 자성 미세 입자로 구성됩니다. 힘이 가해져 스킨이 변형되면 magnetometer가 자기장의 변화를 측정합니다. 5개의 magnetometer(중앙 1개, 주변 4개)를 사용하여 자기장 변화를 측정합니다.</p></li>
<li><p><strong>데이터 수집:</strong> Dobot Magician 로봇과 ATI Nano 17 force/torque 센서를 사용하여 데이터를 수집합니다. 로봇은 스킨의 다른 위치에 힘을 가하고, 센서 보드는 자기장 측정값을 스트리밍합니다.</p></li>
<li><p><strong>모델 아키텍처:</strong> 자기장 변화 <span class="math inline">\mathbf{B}</span>에서 접촉력의 위치 <span class="math inline">\mathbf{x} = (x, y)</span>와 크기 <span class="math inline">F</span>를 예측하기 위해 5개의 layer를 가진 multilayer perceptron (MLP)를 사용합니다. 아키텍처는 다음과 같습니다: <span class="math inline">\mathbf{B}(15) \rightarrow \text{MLP+ReLU}(200) \rightarrow \text{MLP}(200) \rightarrow \text{MLP}(40) \rightarrow \text{MLP+ReLU}(200) \rightarrow \text{MLP+ReLU}(200) \rightarrow xyF(3)</span>. 세 번째 activation layer는 bottleneck feature layer이며, <span class="math inline">\text{feat}(\cdot)</span>는 이 3-layer feature extraction network를 나타냅니다. 손실 함수는 <span class="math inline">\text{L2-loss}</span>를 <span class="math inline">\mathbf{(x, y, F)}</span>에 적용합니다.</p></li>
<li><p><strong>Self-Supervised Learning (SSL):</strong> Ground truth 라벨 없이 새로운 센서에 적응하기 위해 triplet loss를 사용합니다. <span class="math inline">\mathcal{L}_{\text{triplet}} = \max(0, ||\text{feat}(\mathbf{B}_a) - \text{feat}(\mathbf{B}_p)||^2 - ||\text{feat}(\mathbf{B}_a) - \text{feat}(\mathbf{B}_n)||^2)</span>. 여기서 <span class="math inline">\mathbf{B}_a</span>, <span class="math inline">\mathbf{B}_p</span>, <span class="math inline">\mathbf{B}_n</span>은 각각 anchor, positive, negative 샘플이며, <span class="math inline">||\mathbf{x}_a - \mathbf{x}_p|| &lt; ||\mathbf{x}_a - \mathbf{x}_n||</span>를 만족합니다.</p></li>
<li><p><strong>실험 결과:</strong></p>
<ul>
<li>단일 센서 모델은 시간이 지남에 따라 성능이 저하됩니다.</li>
<li>Multi-sensor 모델은 단일 센서 모델보다 성능이 우수합니다.</li>
<li>Self-supervised adaptation은 multi-sensor 모델의 성능을 더욱 향상시킵니다. 특히, 적은 양의 adaptation 데이터로도 상당한 성능 향상을 얻을 수 있습니다.</li>
</ul></li>
<li><p><strong>다양한 응용:</strong> ReSkin은 로봇 그리퍼, 개 신발, 장갑, arm sleeve 등 다양한 형태로 적용될 수 있습니다. 물이 채워진 shot glass의 무게를 감지하고, 블루베리를 쥐는 등의 섬세한 조작에도 활용될 수 있습니다.</p></li>
</ul>
<p><strong>결론:</strong></p>
<p>ReSkin은 높은 localization 정확도와 힘 감도를 제공하는 저렴하고 컴팩트한 촉각 센서입니다. 머신러닝과 자기장 센싱을 결합하여 시간 경과 및 개별 스킨의 변동에 강인한 모델을 개발하고, SSL adaptation 절차를 통해 새로운 스킨에 대한 모델을 개선합니다.</p>
</section>
</section>
<section id="anyskin" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> AnySkin</h1>
<blockquote class="blockquote">
<p><a href="https://any-skin.github.io/">https://any-skin.github.io/</a></p>
</blockquote>
<ol type="1">
<li>🤖 AnySkin은 로봇 터치를 위해 제작된 새로운 스킨 센서로, 조립이 쉽고 다양한 로봇 말단 장치와 호환되며 새로운 스킨 인스턴스에 일반화될 수 있습니다.</li>
<li>🧲 AnySkin은 감지 표면의 자화된 철 입자에 의해 생성된 자기장의 왜곡을 통해 접촉을 감지하며, 유연한 표면이 전자 장치와 물리적으로 분리되어 손상 시 쉽게 교체할 수 있습니다.</li>
<li>🔬 AnySkin은 간소화된 제작 과정, 내구성이 뛰어나고 쉽게 교체할 수 있는 접착제 없는 자기 촉각 센서 디자인, 슬립 감지 및 정책 학습 기능, 그리고 훈련된 모델의 새로운 인스턴스로의 제로샷 일반화 기능을 제공합니다.</li>
</ol>
<section id="brief-review-1" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="brief-review-1"><span class="header-section-number">2.1</span> Brief Review</h2>
<p>이 문서는 로봇 터치를 위한 새로운 촉각 센서인 AnySkin을 소개합니다. AnySkin은 조립이 용이하고, 다양한 로봇 End-effector와 호환되며, 새로운 Skin instance에 대한 일반화가 가능한 것이 특징입니다.</p>
<p><strong>핵심 아이디어:</strong></p>
<p>기존 촉각 센서의 단점(비용, 불편함, 일관성 부족)을 극복하고, 생물학적 움직임 제어에서 중요한 역할을 하는 촉각을 로봇 공학에 더 쉽게 통합하는 것을 목표로 합니다.</p>
<p><strong>주요 특징 및 기여:</strong></p>
<ol type="1">
<li><strong>향상된 제작 과정 및 디자인 도구:</strong> 접착제가 필요 없고 내구성이 뛰어나며 쉽게 교체할 수 있는 자기 촉각 센서를 위한 간소화된 제작 과정과 디자인 도구를 제시합니다.</li>
<li><strong>Slip 감지 및 정책 학습:</strong> AnySkin 센서를 사용한 Slip 감지 및 Visuo-tactile 정책 학습의 효율성을 입증합니다. USB 삽입과 같은 정밀 작업에 적용 가능합니다.</li>
<li><strong>교체 용이성:</strong> AnySkin은 평균 12초 만에 교체할 수 있으며, 교체 후에도 재사용이 가능합니다.</li>
<li><strong>Zero-shot 일반화:</strong> 한 AnySkin instance에서 학습된 모델이 다른 AnySkin instance에 Zero-shot으로 일반화됩니다. ReSkin과 같은 기존 촉각 솔루션과 비교하여 성능 저하가 훨씬 적습니다.</li>
</ol>
<p><strong>기술적 상세:</strong></p>
<ul>
<li><strong>센서 작동 원리:</strong> AnySkin은 자기장 왜곡을 감지하여 접촉을 감지합니다. 센서 표면에는 자화된 철 입자가 포함되어 있으며, 외부 힘에 의한 표면 변형은 자기장 변화를 일으킵니다.</li>
<li><strong>Fabrication 과정:</strong> Smooth-On DragonSkin 10 Slow와 MQFP-15-7(25μm) magnetic particles를 1:1:2 비율로 혼합하여 2-part mold에서 경화시킵니다 (<span class="math inline">\text{Fig. 2a}</span>). 경화된 Skin은 Pulse Magnetizer를 사용하여 자화됩니다.</li>
<li><strong>자기장 강화:</strong> Pulse Magnetizer를 사용하여 경화 후 Skin을 자화함으로써, 기존 ReSkin에 비해 더 강력한 자기장을 생성합니다.</li>
<li><strong>입자 분포 균일성:</strong> 더 미세한 Magnetic Particles(MQFP-15-7(25μm))를 사용하여 입자가 경화 전에 가라앉는 현상을 방지하고, Skin 전체에 걸쳐 더 균일한 분포를 얻습니다 (<span class="math inline">\text{Fig. 2b}</span>).</li>
<li><strong>Self-aligning 디자인:</strong> Self-aligning 디자인을 통해 Elastomer와 회로의 상대적 위치 변동성을 줄이고, 신호 일관성을 향상시킵니다.</li>
</ul>
<p><strong>실험 결과:</strong></p>
<ul>
<li><strong>신호 특성 비교:</strong> Pulse Magnetizer, finer particles, self-aligning 디자인이 신호 강도, 일관성, Misalignment에 대한 민감도에 미치는 영향을 정량적으로 분석합니다. (Table I)</li>
<li><strong>Slip 감지:</strong> Jaco Robot에 장착된 AnySkin 센서를 사용하여 수집된 데이터를 기반으로 LSTM 모델을 훈련하여, unseen object에 대한 Slip 감지 정확도가 92%임을 입증합니다 (<span class="math inline">\text{Fig. 3}</span>).</li>
<li><strong>교체 용이성 비교:</strong> ReSkin, DIGIT과 비교하여 AnySkin의 교체 시간과 재사용성을 User Study를 통해 평가합니다 (Table II).</li>
<li><strong>정책 학습에서의 교체 가능성:</strong> Plug insertion, Card swiping, USB insertion의 세 가지 정밀 조작 작업에서 AnySkin의 Cross-instance 일반화 성능을 평가합니다 (<span class="math inline">\text{Fig. 5}</span>). ReSkin과 DIGIT에 대한 비교 결과도 제시됩니다 (Table III).</li>
</ul>
<p><strong>주요 공식:</strong></p>
<ul>
<li>본 논문에서는 특정 공식을 명시적으로 제시하지는 않습니다. 하지만 실험 결과 분석에서 평균, 표준 편차 등의 기본적인 통계적 개념이 사용됩니다.</li>
<li>LSTM(Long Short-Term Memory) 모델이 Slip 감지 모델로 사용됩니다.</li>
<li>BAKU (Bidirectional Action-conditioned Keyframe Transformer) 아키텍쳐가 정책 학습에 사용됩니다.</li>
</ul>
<p><strong>결론:</strong></p>
<p>AnySkin은 촉각 데이터를 활용하여 더욱 능숙하고 성능이 뛰어난 모델을 개발하는 데 기여할 수 있는 잠재력을 가진 새로운 촉각 센서입니다. Visuo-tactile 정책을 새로운 Instance에 Zero-shot으로 일반화하는 최초의 센서입니다.</p>
</section>
</section>
<section id="detail-review" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Detail Review</h1>
<blockquote class="blockquote">
<p>ReSkin과 AnySkin: 교체 가능한 촉각 센서와 센서 간 일반화</p>
</blockquote>
<section id="배경-촉각-센서의-어려움과-요구사항" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="배경-촉각-센서의-어려움과-요구사항"><span class="header-section-number">3.1</span> 배경: 촉각 센서의 어려움과 요구사항</h2>
<p>로봇에게 <strong>촉각(tactile)</strong>은 인간과 마찬가지로 섬세한 상호작용에 필수적이지만, 현실 로봇 시스템에서 촉각은 시각이나 관성 센서 대비 활용이 저조했습니다. 기존 촉각 센서는 <strong>비용이 높고</strong>, <strong>플랫폼에 특화된 형태</strong>로 제작되며, <strong>일관성(consistency)</strong> 문제로 인해 센서를 교체하면 센서 출력 특성이 달라지는 문제가 있습니다. 이러한 변동성 때문에 한 센서에서 학습한 모델을 다른 센서에 그대로 적용하기 어렵고, 부드러운 촉각 센서는 사용 중 마모로 잦은 교체가 필요하기에 더 큰 문제를 야기합니다. 예를 들어 카메라와 마이크는 저렴하고 범용적이며 교체 후에도 동일한 성능을 기대할 수 있지만, 촉각 센서는 <strong>제작 공정상의 편차</strong>로 샘플마다 반응이 달라 많은 경우 <strong>새 센서마다 재학습</strong>이 필요했습니다. 이러한 이유로 <strong>실용적인 촉각 피부(sensor skin)</strong>를 만드는 것이 로봇 조작 분야의 오랜 과제로 남아 있었습니다.</p>
</section>
<section id="reskin-자기장-기반-저비용-교체형-촉각-센서" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="reskin-자기장-기반-저비용-교체형-촉각-센서"><span class="header-section-number">3.2</span> ReSkin: 자기장 기반 저비용 교체형 촉각 센서</h2>
<p><strong>ReSkin</strong>은 이러한 문제를 해결하고자 2021년에 제안된 <strong>저비용(&lt; $30)</strong>, <strong>교체 가능</strong>하고 <strong>다용도</strong>인 촉각 센서입니다. ReSkin의 핵심 아이디어는 <strong>자기장 기반 감지(magnetic sensing)</strong>입니다. 부드러운 폴리머 피부에 미세한 <strong>자성 입자</strong>를 섞어 제조한 얇은 패치(두께 2~3mm)를 사용하고, 이 패치를 조금 떨어진 곳에 배치한 <strong>자기 센서들(자력계)</strong>로 변형을 측정합니다. 물체가 피부를 누르거나 미는 등 변형이 일어나면 자성 입자의 배열이 바뀌어 주변 자기장 <strong>B</strong>가 변하고, 이를 다수의 자력계가 읽어들여 힘의 크기와 위치를 추정하는 것입니다. <strong>전자 회로부와 센싱 표면을 분리</strong>한 이러한 구조 덕분에, 피부 패치가 마모되면 간단히 교체할 수 있고 회로는 재사용 가능합니다. 또한 폴리머 소재이므로 로봇 손가락, 팔 등 <strong>곡면에도 부착</strong>하기 쉬워 활용 범위가 넓습니다. ReSkin은 <strong>400 Hz 이상의 높은 샘플링속도</strong>와 약 <strong>1 mm의 위치 해상도</strong>(90% 정확도 기준)를 보이며, 50,000회 이상의 접촉 사이클에도 성능이 크게 저하되지 않을 만큼 내구성을 갖추었습니다.</p>
<p>ReSkin의 또 다른 특징은 <strong>데이터 기반 모델링</strong>입니다. 물리 공식을 일일이 사용하지 않고, 자력계들이 출력하는 다차원 신호 <strong>ΔB</strong>로부터 <strong>접촉 지점 (x, y)</strong>과 <strong>접촉 힘 F</strong>를 바로 예측하는 <strong>머신러닝 모델</strong>을 학습합니다. 이렇게 하면 센서마다 미세한 특성 차이가 있더라도, 학습을 통해 <strong>보정된 모델</strong>이 복잡한 관계를 학습하게 됩니다. 다만 초기 ReSkin 연구 당시에도 <strong>“새로운 센서에도 일반화되는 모델”</strong>을 만드는 것이 중요한 목표로 제시되었습니다. 동일한 제작 공정으로 만든 ReSkin이라도 개체별로 <em>raw</em> 자기장 신호 분포에 차이가 있으며 (논문의 Figure 4b에서 센서마다 동일한 힘 입력에 대한 자기장 변화가 다름을 보여줍니다), 장기간 사용하면 시간이 지남에 따른 드리프트도 발생합니다. 따라서 한 센서에서 학습한 모델을 <strong>다른 센서에 바로 적용하면 성능 저하</strong>가 발생할 수밖에 없습니다. 실제로 ReSkin 논문에서도 <strong>단일 센서로 학습한 모델을 새 센서에 적용</strong>했을 때 접촉 위치 예측 정확도가 약 25%에 불과해 크게 떨어지는 것을 확인했습니다. 이 문제를 해결하지 못하면 “교체 가능한 촉각 센서”라는 목표를 이룰 수 없기 때문에, ReSkin에서는 별도의 章을 할애하여 <strong>“새로운 센서로의 적응(Adapting to New Sensors)”</strong> 방법을 제시했습니다.</p>
</section>
<section id="새로운-센서로의-적응-reskin의-self-supervised-학습-기법" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="새로운-센서로의-적응-reskin의-self-supervised-학습-기법"><span class="header-section-number">3.3</span> 🔥 새로운 센서로의 적응: ReSkin의 Self-supervised 학습 기법</h2>
<p>ReSkin이 제안한 <strong>센서 교체 시 재학습 부담을 줄이는 기법</strong>은 크게 두 가지입니다.</p>
<p>첫째, <strong>다중 센서 학습</strong>입니다. 서로 다른 여러 센서(실험에서는 6개의 회로 보드와 18장의 피부 조합)로부터 데이터를 모아 하나의 통합 모델로 학습시킴으로써, 모델이 <strong>다양한 분포의 데이터</strong>를 학습하고 일반화 능력을 갖추도록 했습니다.</p>
<p>둘째, <strong>특징 공간 정규화(feature regularization)</strong>를 통해 새로운 센서에서도 특징이 일관되게 맵핑되도록 유도했습니다. 이를 위해 저자들은 <strong>Self-supervised triplet loss</strong> 함수를 도입했는데, 아이디어는 다음과 같습니다. 센서 출력 <strong>B</strong> (자기장 변화 신호)를 내부 <strong>특징 표현 <span class="math inline">\text{feat}(B)</span></strong> 공간으로 맵핑할 때, <strong>피부 위에서 가까운 위치</strong>의 두 접촉은 특징 공간에서도 가깝게, 멀리 떨어진 접촉은 특징이 멀어지도록 제약합니다. 구체적으로 한 접촉점을 앵커(anchor)로 잡고, 이와 실제 위치가 가까운 접촉을 positive, 먼 접촉을 negative로 삼아 <strong>앵커-포지티브 쌍의 특징거리</strong>가 <strong>앵커-네거티브 쌍의 특징거리</strong>보다 작도록 학습합니다. 이러한 triplet loss <span class="math inline">L_{\text{triplet}}</span>은 접촉 <strong>위치 레이블 없이도</strong> 구성할 수 있는 자가 지도 신호로서, 서로 다른 센서 간에 특징 공간의 <strong>위치 민감도</strong>를 맞춰주는 역할을 합니다.</p>
<p>triplet loss을 활용하면 새로운 센서에 대한 <strong>fine-tuning</strong>도 수월해집니다. ReSkin을 처음 사용할 때 사용자는 간단한 <strong>보정 데이터</strong>를 수집하여 모델을 해당 센서에 맞게 미세조정할 수 있습니다. 예를 들어, 펜 끝이나 탐침을 이용해 <strong>센서 표면을 직선 경로로 따라 누르면서</strong> 이동시키고, 움직인 순서에 따라 데이터를 index 하면 위치 레이블 없이도 순서 정보가 부여됩니다. 이렇게 얻은 <strong>연속 눌림 데이터</strong>에서 임의의 세 점을 뽑아 삼중항(Anchor, Positive, Negative)으로 구성하면, Positive와 Negative의 기준은 index 순서로 결정할 수 있습니다 (예: 앵커에 더 가까운 index를 positive로). 즉, 사람의 손으로 센서 위를 쓸어내린 기록만 있으면 충분하며 별도의 정밀한 라벨링은 필요 없습니다. 이렇게 수집한 <strong>unlabeled</strong> 데이터로 triplet loss을 적용하여, 앞서 언급한 다중 센서로 미리 학습된 모델을 <strong>해당 새로운 센서의 특징 공간에 맞도록</strong> 미세조정합니다. 논문에서는 매 스텝 원래 학습 데이터 배치와 삼중항 배치를 함께 사용하여, 기존 예측 손실(L2 손실)과 triplet loss을 동시에 최소화하도록 모델을 훈련하는 절차를 제시했습니다.</p>
<p>이 <strong>Self-supervised 적응</strong> 방법의 효과는 실험으로 입증되었습니다. 다중 센서 데이터로 학습한 모델을 새로운 센서에 적용할 때, <strong>아무 추가 적응 없이</strong> 바로 쓰면 접촉 위치 정확도가 80% 초반 수준이었으나, <strong>소량의 적응 데이터</strong>만으로도 크게 향상되었습니다. 예를 들어 새로운 센서에서 <strong>780개 점</strong>을 눌러 얻은 비라벨 데이터로 파인튜닝하면 적응 전보다 성능이 눈에 띄게 좋아졌고, 데이터를 더 늘릴수록 점진적 향상이 있지만 1000개 남짓에서 <strong>포화 현상</strong>을 보였습니다. 이는 <strong>수백 개 수준의 값싼 데이터만으로도</strong> 모델이 빠르게 해당 센서에 적응함을 보여줍니다. 또한 <strong>훈련에 사용한 센서 개수가 적을수록</strong> (즉 처음부터 다양한 데이터를 못 봤을수록) 이 자가 지도 적응이 주는 이득이 더 컸는데, 반대로 충분히 많은 센서 데이터로 학습한 경우에는 기본 성능이 높아 적응의 개선 폭이 약간 줄어드는 양상도 보였습니다. 한편, 매우 <strong>간이한 환경</strong>에서도 효과가 있음을 보여주기 위해 별도의 실험을 했는데, 사람 손으로 임의 위치 325번 눌러 수집한 데이터로 적응시킨 결과 <strong>접촉 위치 정확도가 약 79.9%에서 84.8%로 상승</strong>하고 힘 예측 오차도 줄어들어, 통제되지 않은 환경에서도 방법의 효용이 확인되었습니다. 심지어 <strong>센서 하드웨어 형태가 다른 경우</strong>에도 적용해보았는데, rigid 보드로 학습한 모델을 <strong>유연한(flexible) 회로 보드</strong> 형태의 ReSkin에 적응시킨 결과 약 <strong>75%의 정확도</strong>를 달성했습니다. 유연 보드는 구조상 자력계와 피부 간 거리가 훨씬 가까워 신호 세기가 달라지는 어려운 상황이었지만, 제안한 적응 기법으로 일정 수준 성능을 확보한 것입니다.</p>
<p>정리하면, <strong>ReSkin은 다중 센서 학습과 Self-supervised 적응을 통해</strong> 새로운 피부를 교체하더라도 간단한 보정만 거치면 일관된 촉각 인식 성능을 유지할 수 있음을 보여주었습니다. (논문 Table 2에서 자가 적응까지 거친 모델의 접촉 위치 정확도는 <strong>87%</strong> 수준까지 향상되었습니다.) 이러한 접근은 <strong>작업 중간에 센서를 교체해야 하는 현실 시나리오</strong>에서 특히 유용하며, 논문 저자들은 이를 통해 ReSkin이 <em>“새로운 피부에도 간단한 적응만으로 학습된 모델을 재사용할 수 있는”</em> 교체형 촉각 센서 솔루션의 가능성을 입증했다고 강조합니다.</p>
</section>
<section id="anyskin-플러그앤플레이plug-and-play-촉각-피부의-실현" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="anyskin-플러그앤플레이plug-and-play-촉각-피부의-실현"><span class="header-section-number">3.4</span> AnySkin: 플러그앤플레이(plug-and-play) 촉각 피부의 실현</h2>
<p>ReSkin 이후, 2024년에 발표된 <strong>AnySkin</strong>은 한걸음 더 나아가 <strong>교정(calibration)이나 재학습 없이</strong> 센서를 교체해 사용할 수 있는 <strong>진정한 플러그앤플레이 촉각 센서</strong>를 지향합니다. AnySkin은 기본적인 감지 원리나 전자 하드웨어는 ReSkin의 <strong>자기장 기반 설계</strong>를 계승하지만, <strong>일관성(consistency)</strong> 향상을 위해 센서의 <strong>구조적 개선</strong>과 <strong>제조 공정 표준화</strong>에 집중했습니다.</p>
<ul>
<li>첫째로, <strong>센싱 표면과 전자부의 완전 분리</strong>를 구현하면서 <strong>자체 접착(self-adhering)</strong>이 되고 <strong>정렬(self-aligning)</strong>이 쉬운 부착 메커니즘을 도입했습니다. 이를 통해 사용자가 AnySkin 패치를 로봇 손가락이나 팔에 <strong>마치 휴대폰 케이스를 끼우듯</strong> 손쉽게 장착할 수 있고, 매번 같은 위치와 orientation으로 정렬되어 센서 간 편차를 줄입니다.</li>
<li>둘째로, <strong>자기 신호 세기 강화</strong>를 위해 새로운 자성물질과 자화 방법을 적용했습니다. 예컨대 이전보다 <strong>강한 자계</strong>를 만들어내는 자성 입자와 펄스자화 방식을 활용하여 센서 출력을 증폭함으로써, 환경 노이즈나 개체 간 미세한 차이에 덜 민감하게 했습니다.</li>
<li>셋째로, <strong>접착제 없는 내구성 높은 제조 공정</strong>을 개발하고 이를 누구나 따라할 수 있도록 <strong>디자인 툴과 CAD 파일</strong>을 공개했습니다. AnySkin 패치는 3D 프린터로 출력한 몰드에 실리콘 재료(예: Smooth-On Dragon Skin 10)와 자성 입자를 부어 만들고, 쉽게 떼어낼 수 있도록 설계되어 반복 사용에 용이합니다. 전체 조립 과정은 <strong>약 12초 정도</strong>밖에 걸리지 않을 만큼 단순하며, 센서를 새 것으로 바꿔 끼운 뒤에도 이전 센서로 수집한 데이터나 모델을 그대로 활용할 수 있습니다.</li>
</ul>
<p>이러한 개선 덕분에 AnySkin은 <strong>저비용·편의성</strong>뿐 아니라 <strong>데이터 재사용성(data reusability)</strong> 면에서 최초의 성과를 보여주었습니다. 연구진은 AnySkin의 효과를 다양한 <strong>로봇 플랫폼과 작업</strong>에서 실험으로 검증했는데, 몇 가지 예를 들어보면 다음과 같습니다:</p>
<ul>
<li><p><strong>범용성</strong>: AnySkin 패치는 평평한 그리퍼부터 사람 손가락 모양의 로봇 손까지 다양한 형태에 적용되었습니다. 실제 Franka эм 로봇팔의 그리퍼, 사족보행 로봇의 지팡이형 끝부분(Dobb-E stick), 그리고 4손가락 로봇핸드(LEAP Hand)의 손가락에 부착하여 모두 정상적으로 작동함을 보였습니다. 이는 센서의 물리적 폼팩터 제약이 거의 없고, 간단히 <strong>붙였다 떼었다</strong> 할 수 있음을 의미합니다.</p></li>
<li><p><strong>학습된 정책의 유지</strong>: AnySkin을 장착한 로봇으로 <strong>정교한 조작 과제</strong>를 학습시킨 후, <strong>센서만 새 것으로 교체</strong>해도 성능이 크게 떨어지지 않았습니다. 예를 들어, 카메라 영상 + 촉각센서로 USB 케이블을 꽂는 동작을 배우게 한 뒤 센서를 바꿔끼워 수행해보면, <strong>성공률 감소가 약 13% 정도</strong>에 불과했습니다. 반면 동일한 실험에서 이전 세대인 ReSkin 센서는 <strong>43% 가량 성능 감소</strong>가 나타났고, 다른 대표적인 촉각 센서인 <strong>DIGIT</strong>(카메라 기반 젤사이트 센서)의 경우는 원래도 성능 기여가 작았을 뿐 아니라 교체 시 오히려 악화되는 경향을 보였습니다. <strong>즉, AnySkin은 한 센서에서 학습된 모델을 새로운 센서에 거의 그대로</strong> 쓸 수 있음을 입증한 것입니다. 아래 그림은 <strong>플러그 삽입(Plug Insertion)</strong> 작업에서 카메라만 쓴 경우, 카메라+ReSkin, 카메라+AnySkin, 카메라+DIGIT의 조합별 성공률을 비교한 결과입니다. AnySkin을 사용하면 원래 학습에 사용된 센서를 새 것으로 바꿔도 성능 저하가 미미하지만, ReSkin은 교체 후 성능이 크게 떨어지고(사실상 카메라만 쓴 것과 비슷해짐), DIGIT 역시 편차가 심한 모습을 볼 수 있습니다. 이러한 특성 덕분에 AnySkin은 <em>“학습된 정책을 보존한 채 센서를 교체(swap)할 수 있는”</em> 최초의 촉각 센서로 평가됩니다.</p></li>
<li><p><strong>미끄러짐 감지</strong>: AnySkin은 <strong>물체 미끄럼 감지</strong>와 같은 섬세한 접촉 변화도 포착할 수 있습니다. 예를 들어 물체를 잡은 그립이 헐거워져 물체가 미끄러지기 시작하는 <strong>초기 징후</strong>를 LSTM 기반 모델로 학습시킨 결과, 약 <strong>92%의 정확도</strong>로 미끄러짐 발생을 탐지했습니다. 이는 로봇 손이 사전에 그립을 조정하거나 힘을 높여 떨어뜨리는 것을 방지하는 데 활용될 수 있습니다. 이 실험에서도 여러 AnySkin 센서를 교체하며 수행했지만 일관된 성능을 보였다고 보고됩니다.</p></li>
</ul>
<p>AnySkin의 개발 과정에서 무엇보다 강조된 것은 <strong>일관된 센서 응답</strong>입니다. 연구 결과에 따르면 AnySkin은 ReSkin에 비해 <strong>신호의 센서 간 분산이 획기적으로 감소</strong>하였고, 개체별 <strong>보정 없이도</strong> 큰 추가 오차 없이 동작합니다. 사실상 <strong>공장 출하시 보정된 카메라를 교체하는 것과 비슷한 수준의 사용자 경험</strong>을 제공하는 것이죠. 이러한 특장점으로 인해 AnySkin 연구는 “로봇 촉각 센싱을 카메라처럼 쉽고 흔하게 만들겠다”는 비전을 향한 중요한 진전으로 평가받고 있습니다.</p>
</section>
<section id="결론-및-향후-전망" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="결론-및-향후-전망"><span class="header-section-number">3.5</span> 결론 및 향후 전망</h2>
<p>ReSkin과 AnySkin으로 이어지는 연구는 로봇을 위한 <strong>실용적 촉각 피부</strong> 구현에 있어 큰 진전을 보여주었습니다. ReSkin이 <strong>소형·저가·교체가능</strong> 촉각 센서의 틀을 제시하고 머신러닝을 통해 <strong>마모와 개체차를 보정</strong>하는 개념을 도입했다면, AnySkin은 한발 더 나아가 <strong>센서 인스턴스 간 zero-shot 일반화</strong>를 실현함으로써 사실상 <strong>보정 없이 바로 교체</strong>해 쓸 수 있는 수준에 도달했습니다. 특히 AnySkin의 경우 기존 상용 촉각센서들과 비교해도 범용성, 유지보수 편의성 측면에서 우위를 보여 대규모 적용의 가능성을 높였습니다. 물론 여전히 풀어야 할 과제도 있습니다. 예를 들어 현재 단일 접촉 지점의 힘과 위치를 예측하는 수준에서, <strong>다중 접촉 지점의 동시 인식</strong>이나 보다 복잡한 촉각 정보(예: 촉감 질감 분별) 등은 향후 연구로 남아 있습니다. 또한 센서 교체 주기가 늘어날수록 누적되는 미세한 차이나 시간에 따른 재료 특성 변화 등도 추가로 살펴볼 부분입니다. 그럼에도 불구하고, ReSkin/AnySkin 연구는 데이터 취득부터 학습, 교체에 이르는 <strong>촉각 센서 활용 전 주기</strong>를 크게 개선한 사례입니다. 이를 통해 로봇 연구자들은 마치 카메라를 다루듯 손쉽게 촉각 센서를 다룰 수 있고, 한 번 모은 촉각 데이터를 반복 활용하여 학습 효율을 높일 수 있게 되었습니다. 궁극적으로 이러한 노력들은 로봇에게 인간 수준의 풍부한 촉각능력을 부여하고, <strong>섬세하고 안전한 물체 조작</strong>을 가능케 하는 방향으로 나아가고 있습니다. 앞으로 AnySkin처럼 <strong>쉽게 교체하고 확장할 수 있는 촉각 피부</strong>가 더 발전하고 상용화된다면, 로봇의 <strong>촉각이 시각 만큼이나 당연한 시대</strong>가 올 것으로 기대됩니다.</p>
<p>촉각 센서마다 일관성 없이 반응 특성이 제각각이면, 한 센서로 학습한 모델을 다른 동일한 센서에 적용하기 어렵다. 특히 부드러운 촉각 센서는 마모로 교체가 잦아 이 문제가 더욱 중요하다. ReSkin은 자기장 기반의 소프트 촉각 센서로, 자성 입자를 섞은 얇은 피부와 분리된 자기 센서 회로로 구성된다. 이를 통해 센서 인터페이스를 저비용으로 쉽게 교체 가능하게 설계했다. ReSkin에서 학습한 모델이 새로운 센서에서도 일반화되도록 하는 것은 핵심 과제다. 그러나 동일한 힘을 가해도 센서마다 측정되는 자기장 변화 분포(원시 신호)가 달라, 보정 없이 기존 모델을 쓰면 성능 저하가 발생한다. 이를 완화하기 위해 다중 센서의 데이터를 합쳐 학습하고, 삼중항(self-supervised triplet) 손실로 특징 공간을 정규화한다. triplet loss은 접촉 위치가 가까운 샘플들의 특징을 가깝게 유지하도록 유도하여, 센서 간 일관된 표현을 학습시킨다. 새로운 센서를 쓸 때는 간단한 unlabeled 데이터(예: 센서 표면을 펜으로 따라 그으며 눌러본 기록)를 수집해 triplet loss로 모델을 미세조정할 수 있다. 이렇게 Self-supervised 방식으로 추가 학습하면 레이블이 없어도 해당 센서의 특징 분포에 모델을 맞출 수 있다. ReSkin의 Self-supervised 적응 기법은 통제되지 않은 수동 조작 데이터나 센서 하드웨어 종류가 다른 경우에도 성능 향상을 보였다. 예를 들어 사람 손으로 눌러 얻은 데이터로 적응하면 접촉 위치 예측 정확도가 약 79.9%에서 84.8%로 향상되었고, 경직 보드에서 학습한 모델을 유연 보드에 적용할 때도 75% 수준의 정확도를 달성했다. AnySkin은 ReSkin의 디자인을 발전시켜, 센싱 표면과 전자부를 완전히 분리하고 자기장 세기를 강화하는 등으로 센서 간 응답의 일관성을 크게 높였다. 또한 부착 방식도 셀프 정렬되도록 고안되어 교체 시 정확히 같은 위치와 자세로 장착된다. AnySkin 패치는 교체에 12초 정도밖에 걸리지 않으며, 한 센서로 학습한 모델을 새로운 패치에 그대로 적용해도 플러그 삽입 과제 성공률 저하가 13% 이내로 매우 작았다. 반면 이전 세대인 ReSkin은 같은 조건에서 성능이 40% 이상 떨어져, AnySkin의 센서 간 일관성이 월등함을 보여준다.</p>
<p># Reference</p>
<ul>
<li>Reskin <a href="https://openreview.net/pdf?id=87_OJU4sw3V">논문</a></li>
<li>AnySkin <a href="https://arxiv.org/pdf/2409.08276">논문</a></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    window.setColorSchemeToggle(window.hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>