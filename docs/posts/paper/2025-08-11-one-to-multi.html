<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-08-11">
<meta name="description" content="Imitation Learning for Dexterous Manipulation from Single-Camera Teleoperation">

<title>📃From One Hand to Multiple Hands 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-bc185b5c5bdbcb35c2eb49d8a876ef70.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-5a614c35f1f90bfd0a5b2992298a8538.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review">Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review">Detail Review</a>
  <ul class="collapse">
  <li><a href="#방법론-methodology" id="toc-방법론-methodology" class="nav-link" data-scroll-target="#방법론-methodology">1. 방법론 (Methodology)</a>
  <ul class="collapse">
  <li><a href="#단일-카메라-텔레오퍼레이션을-통한-데모-수집" id="toc-단일-카메라-텔레오퍼레이션을-통한-데모-수집" class="nav-link" data-scroll-target="#단일-카메라-텔레오퍼레이션을-통한-데모-수집">1.1 단일 카메라 텔레오퍼레이션을 통한 데모 수집</a></li>
  <li><a href="#다중-로봇-손으로의-시연-데이터-변환-multi-hand-demonstration-translation" id="toc-다중-로봇-손으로의-시연-데이터-변환-multi-hand-demonstration-translation" class="nav-link" data-scroll-target="#다중-로봇-손으로의-시연-데이터-변환-multi-hand-demonstration-translation">1.2 다중 로봇 손으로의 시연 데이터 변환 (Multi-Hand Demonstration Translation)</a></li>
  <li><a href="#모방-학습-알고리즘-및-정책-학습" id="toc-모방-학습-알고리즘-및-정책-학습" class="nav-link" data-scroll-target="#모방-학습-알고리즘-및-정책-학습">1.3 모방 학습 알고리즘 및 정책 학습</a></li>
  </ul></li>
  <li><a href="#실험-설정과-결과-평가-experiments-and-results" id="toc-실험-설정과-결과-평가-experiments-and-results" class="nav-link" data-scroll-target="#실험-설정과-결과-평가-experiments-and-results">2. 실험 설정과 결과 평가 (Experiments and Results)</a>
  <ul class="collapse">
  <li><a href="#실험-환경과-과제-구성" id="toc-실험-환경과-과제-구성" class="nav-link" data-scroll-target="#실험-환경과-과제-구성">2.1 실험 환경과 과제 구성</a></li>
  <li><a href="#사용자-원격조작-실험-커스텀-손-vs.-기존-로봇-손" id="toc-사용자-원격조작-실험-커스텀-손-vs.-기존-로봇-손" class="nav-link" data-scroll-target="#사용자-원격조작-실험-커스텀-손-vs.-기존-로봇-손">2.2 사용자 원격조작 실험: 커스텀 손 vs.&nbsp;기존 로봇 손</a></li>
  <li><a href="#정책-학습-성능-비교-rl-vs.-모방-학습" id="toc-정책-학습-성능-비교-rl-vs.-모방-학습" class="nav-link" data-scroll-target="#정책-학습-성능-비교-rl-vs.-모방-학습">2.3 정책 학습 성능 비교: RL vs.&nbsp;모방 학습</a></li>
  <li><a href="#추가-실험-ablation-및-영향-요소-분석" id="toc-추가-실험-ablation-및-영향-요소-분석" class="nav-link" data-scroll-target="#추가-실험-ablation-및-영향-요소-분석">2.4 추가 실험: Ablation 및 영향 요소 분석</a></li>
  <li><a href="#실세계-로봇에의-적용-및-성능" id="toc-실세계-로봇에의-적용-및-성능" class="nav-link" data-scroll-target="#실세계-로봇에의-적용-및-성능">2.5 실세계 로봇에의 적용 및 성능</a></li>
  </ul></li>
  <li><a href="#기존-연구와의-비교-comparison-with-prior-work" id="toc-기존-연구와의-비교-comparison-with-prior-work" class="nav-link" data-scroll-target="#기존-연구와의-비교-comparison-with-prior-work">3. 기존 연구와의 비교 (Comparison with Prior Work)</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃From One Hand to Multiple Hands 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">il</div>
    <div class="quarto-category">rl</div>
    <div class="quarto-category">vision</div>
  </div>
  </div>

<div>
  <div class="description">
    Imitation Learning for Dexterous Manipulation from Single-Camera Teleoperation
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 11, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://arxiv.org/abs/2204.12490">Paper Link</a></li>
<li><a href="https://yzqin.github.io/dex-teleop-imitation/">Project Link</a></li>
<li><a href="https://github.com/yzqin/dex-hand-teleop">Code Link</a></li>
</ul>
<ol type="1">
<li>💡 이 연구는 단일 카메라 원격 조작 시스템을 통해 다중 손가락 로봇의 능숙한 조작을 위한 인간 시연 데이터를 효율적으로 수집하는 새로운 방법을 제안합니다.</li>
<li>🤖 본 시스템은 iPad로 인간의 손을 촬영하여 시뮬레이터에 맞춤형 로봇 손을 생성한 후, 이 데이터를 Allegro, Schunk 등 여러 종류의 실제 로봇 손에 맞게 오프라인으로 리타겟팅하여 모방 학습에 활용합니다.</li>
<li>🏆 제안된 방식으로 수집된 시연 데이터는 모방 학습 정책의 시뮬레이션 성능을 크게 향상시키고, Sim2Real 전환 시 더 견고하고 인간과 유사한 동작을 가능하게 함을 보여줍니다.</li>
</ol>
<hr>
<section id="brief-review" class="level1">
<h1>Brief Review</h1>
<p>본 논문은 단일 카메라 기반 텔레오퍼레이션(teleoperation)을 통해 숙련된 조작(dexterous manipulation)을 위한 인간 시범 데이터(human demonstration data)를 수집하고, 이를 이용하여 다지(multi-finger) 로봇 핸드에 대한 Imitation Learning 정책을 학습하는 새로운 프레임워크를 제안합니다. 궁극적으로 학습된 정책을 실제 로봇에 성공적으로 전이(transfer)시키는 것을 목표로 합니다.</p>
<p><strong>I. 소개</strong></p>
<p>다지 로봇 핸드를 이용한 Dexterous Manipulation은 로봇공학에서 가장 도전적이고 중요한 문제 중 하나입니다. 로봇 핸드와 조작 대상 간의 복잡한 접촉 패턴은 모델링하기 어렵고, 구조화되지 않은 환경에서 접촉이 많은 작업을 해결하는 제어기를 수동으로 설계하는 것은 매우 어렵습니다. 최근 Reinforcement Learning (RL)이 유망한 결과를 보여주지만, 높은 Degree-of-Freedom (DoF)과 불연속적인 접촉은 RL 정책 훈련의 샘플 복잡성(sample complexity)을 증가시킵니다. 또한, RL 보상을 통한 블랙박스 최적화는 예상치 못하거나 안전하지 않은 행동으로 이어질 수 있습니다. 텔레오퍼레이션을 통해 수집된 인간 시범으로부터 학습하는 것은 Dexterous Manipulation을 위한 자연스러운 해결책입니다. 그러나 대부분의 기존 텔레오퍼레이션 시스템은 Virtual Reality (VR) 장치나 유선 글러브(wired gloves)를 필요로 하여 유연성과 확장성(scalability)이 제한됩니다. Vision-based 텔레오퍼레이션은 특수 장비 착용의 필요성을 없애 비용을 절감하고 확장성을 높이지만, 인간 손 움직임을 로봇 손 움직임으로 변환하는 모션 리타겟팅(Motion Retargeting)이라는 새로운 과제를 제시합니다. 이 과정이 직관적이지 않으면 인간 작업자가 로봇을 제어하기 어렵고, 특정 로봇 손으로 수집된 시범은 동일한 로봇에서만 Imitation Learning에 사용될 수 있다는 한계가 있습니다.</p>
<p>본 논문은 이러한 도전 과제를 해결하기 위해 단일 카메라 텔레오퍼레이션 시스템을 도입합니다. 이 시스템은 iPad와 컴퓨터만으로 효율적으로 3D 시범을 수집할 수 있습니다. 핵심 기여 중 하나는 물리 시뮬레이터(physical simulator) 내에서 각 사용자에 대해 사용자 맞춤형 로봇 핸드(customized robot hand)를 생성한다는 점입니다. 이 핸드는 작업자 손과 동일한 구조를 모방하여 직관적인 인터페이스를 제공하고 데이터 수집 시 불안정한 인간-로봇 핸드 리타겟팅을 피하여 대규모의 고품질 데이터를 얻을 수 있게 합니다. 데이터 수집 후, 맞춤형 로봇 핸드의 궤적(trajectory)은 다양한 실제 로봇 핸드(예: Schunk Robot Hand, Adroit Robot Hand, Allegro Robot Hand)로 변환되어 훈련 시범으로 사용될 수 있습니다. 본 논문의 데이터와 Imitation Learning을 통해 여러 복잡한 조작 작업에서 기존 baseline 대비 큰 개선을 보였습니다. 특히, 학습된 정책이 실제 로봇으로 전이될 때 훨씬 더 강건함(robust)을 보여주었습니다.</p>
<p><strong>II. 제안하는 시스템 개요</strong></p>
<p>제안하는 프레임워크는 다음 세 단계로 구성됩니다 (그림 2 참조):</p>
<ol type="1">
<li><strong>Customized Hand Teleoperation</strong>: iPad에서 RGB-D 비디오 스트리밍을 통해 작업자의 손 모양을 추정하고, 이를 기반으로 물리 시뮬레이터에 사용자 맞춤형 로봇 핸드를 실시간으로 구성합니다. 인간 작업자는 이 맞춤형 로봇 핸드를 제어하여 Dexterous Manipulation 작업을 수행합니다. 이 시스템을 통해 시간당 약 60개의 성공적인 시범을 효율적으로 수집할 수 있습니다.</li>
<li><strong>Multi-Robots Demonstration Translation</strong>: 맞춤형 핸드로 수집된 시범 궤적을 오프라인에서 Motion Retargeting 최적화를 통해 실제 로봇 핸드(Schunk, Allegro, Adroit Robot Hand 등)의 상태-액션 궤적(joint position 및 motor command)으로 변환합니다. 이 변환은 손의 기하학적 구조, DoF, 심지어 손가락 개수가 다른 로봇에도 적용 가능합니다.</li>
<li><strong>Demonstration-Augmented Policy Learning</strong>: 변환된 시범 데이터를 사용하여 Dexterous Manipulation 정책을 훈련합니다. 이는 RL 목적 함수에 시범을 사용하여 Behavior Cloning을 결합하는 방식입니다 (Demo Augmented Policy Gradient, DAPG). 이 프레임워크는 RL 단독으로는 잘 해결되지 않는 복잡한 작업에서 효율적으로 인간과 유사한 기술을 학습할 수 있게 합니다.</li>
</ol>
<p>학습된 정책은 XArm-6 로봇에 부착된 실제 Allegro Hand로 Sim2Real 전이 실험을 수행하였으며, 본 논문의 시범 데이터를 학습에 통합함으로써 Sim2Real 갭(gap)에 대한 정책의 강건함을 크게 향상시키는 것을 보여주었습니다.</p>
<p><strong>III. Customized Hand Teleoperation</strong></p>
<p>텔레오퍼레이션 시스템은 iPad와 노트북으로 구성됩니다 (그림 3 참조). iPad의 전면 카메라를 사용하여 25fps로 인간 작업자의 RGB-D 비디오를 스트리밍합니다. 시스템은 물리 시뮬레이터, 인간 동작을 포착하는 Hand Detector, 시뮬레이션 환경을 시각화하는 GUI로 이루어져 있습니다.</p>
<p><strong>A. Task Description</strong></p>
<p>시뮬레이션 환경은 SAPIEN [47]에서 구축되었으며, 세 가지 Dexterous Manipulation 작업이 설계되었습니다:</p>
<ul>
<li><strong>Relocate</strong>: 로봇이 물체(예: YCB dataset의 Tomato Soup Can, Potted Meat Can, Mustard Bottle)를 들어 목표 위치로 옮깁니다. 초기 및 목표 포즈가 무작위로 설정되는 목표-조건부(goal-conditioned) 작업입니다 (그림 1, 첫째 줄).</li>
<li><strong>Flip</strong>: 로봇이 테이블 위의 머그컵을 뒤집습니다. 머그컵의 위치와 중력 방향을 따라 수평 회전이 무작위로 설정됩니다 (그림 1, 둘째 줄).</li>
<li><strong>Open Door</strong>: 로봇이 문 손잡이를 돌려 문을 잠금 해제한 다음 당겨서 문을 엽니다. 문의 위치가 무작위로 설정됩니다 (그림 1, 셋째 줄).</li>
</ul>
<p><strong>B. Hand Detector</strong></p>
<p>Hand Detector는 RGB-D 프레임을 입력받아 손목 포즈, 손 포즈 파라미터, 손 모양 파라미터를 출력합니다. MediaPipe [49]와 FrankMocap [50]을 기반으로 구현되었습니다. MediaPipe hand tracker로 손 영역의 바운딩 박스를 감지하고, 이를 FrankMocap 모델에 입력하여 SMPL-X [51] 모델 기반의 포즈 및 모양 파라미터를 추정합니다. SMPL-X 모델은 손의 기하학적 구조에 대한 모양 파라미터와 변형에 대한 포즈 파라미터로 손을 나타냅니다. 추정된 파라미터와 PnP (Perspective-n-Point) 알고리즘을 통해 손목의 카메라 변환을 계산합니다.</p>
<p><strong>C. Customized Robot Hand</strong></p>
<p>본 시스템은 각 사용자의 손 기하학적 구조를 기반으로 맞춤형 로봇 핸드를 구축합니다. 초기화 시 추정된 손 모양 파라미터로부터 인간 손의 관절 골격(joint skeleton)을 추출하고, 이를 기반으로 물리 시뮬레이터에 동일한 운동학적 구조(kinematics structure)를 가진 로봇 모델을 만듭니다 (그림 4 참조). 효율적인 충돌 감지 및 안정적인 시뮬레이션을 위해 손바닥은 상자, 손가락은 캡슐과 같은 기본 도형을 사용합니다. 맞춤형 핸드는 SMPL-X 모델과 일치하는 45 DoF (15 * 3)를 가지며, Motion Retargeting 없이 감지된 포즈 파라미터를 사용하여 직접 제어됩니다 (표 I 참조).</p>
<p>Customized Robot Hand의 관절 각도는 PD controller로 제어됩니다. 추정된 포즈는 저역 통과 필터(low-pass filter)를 거쳐 위치 목표(position target)로 설정됩니다. 시각 텔레오퍼레이션의 지각 오류(perception error) 문제를 해결하기 위해, 손 모양 추정 결과를 신뢰도 점수(confidence score)로 활용합니다. 초기화 시 최적의 시야에서 추정된 모양 파라미터를 ground-truth로 사용하고, 현재 프레임의 모양 파라미터와의 오차를 통해 포즈 정확도의 신뢰도를 계산합니다. 신뢰도 기반 PD 제어는 다음 수식으로 표현됩니다:</p>
<p><span class="math display">u(t) = p(t)K_pe(t) + k_d\frac{de(t)}{dt}</span></p>
<p>여기서 <span class="math inline">u(t)</span>는 관절 토크(joint torque), <span class="math inline">K_p</span>와 <span class="math inline">K_d</span>는 PD 파라미터이며, <span class="math inline">p(t)</span>는 정규화된 확률 밀도(normalized probability density)로 계산된 신뢰도 점수입니다. 지각 오류가 클 경우, 제어기의 강성(stiffness)을 줄여 원치 않는 갑작스러운 움직임을 제거합니다.</p>
<p><strong>IV. Multi-Robots Demonstration Translation</strong></p>
<p><strong>A. Hand Pose Retargeting</strong></p>
<p>맞춤형 핸드에서 수집된 시범을 특정 로봇 핸드로 변환하기 위해 Hand Pose Retargeting을 수행합니다. 본 시스템은 이를 오프라인 최적화 문제로 정의합니다.</p>
<p><span class="math display">
\begin{gathered}
\min _{q_t^R} \sum_{i=0}^N\left\|f_i^C\left(q_t^C\right)-f_i^R\left(q_t^R\right)\right\|^2+\alpha\left\|q_t^R-q_{t-1}^R\right\|^2 \\
\quad \text { s.t. } \quad q_{\text {lower }}^R \leq q_t^R \leq q_{\text {upper }}^R,
\end{gathered}
</span></p>
<p>여기서 <span class="math inline">q_t^C</span>는 맞춤형 로봇의 시간 <span class="math inline">t</span>에서의 관절 위치, <span class="math inline">q_t^R</span>는 특정 로봇(예: Schunk Robot Hand)의 해당 관절 위치입니다. <span class="math inline">f_C^i</span>와 <span class="math inline">f_R^i</span>는 두 로봇의 <span class="math inline">i</span>-번째 키포인트(예: 손가락 끝 위치)에 대한 전방 운동학(forward kinematics) 함수를 나타냅니다. 시간적 일관성(temporal consistency)을 개선하기 위해 관절 위치 변화를 패널티하는 정규화 항을 추가하고, <span class="math inline">q_t^R</span>를 <span class="math inline">q_{t-1}^R</span>의 값으로 초기화합니다. 이 최적화 문제를 해결하면 어떤 특정 로봇에 대해서도 관절 위치 궤적 <span class="math inline">q_t^R</span>를 계산할 수 있습니다 (그림 5 참조).</p>
<p><strong>B. Action Computation</strong></p>
<p>Joint Pose Trajectory 외에도 Demo-augmented Policy Learning을 위해 각 손가락 관절에 대한 액션(action), 즉 joint torque 또는 motor control command가 필요합니다. DexMV [54]의 절차를 따라, 먼저 joint pose trajectory를 1차 저역 통과 필터에 통과시킨 후, 로봇 역동학(inverse dynamics)의 조작기 방정식(manipulator equation) <span class="math inline">\tau = f_{inv}(q, q', q'')</span>를 통해 joint torque를 계산합니다.</p>
<p><strong>V. Demonstration-Augmented Policy Learning</strong></p>
<p>무작위로 초기화되거나 목표 포즈가 주어지는 작업에서는 단순한 Behavior Cloning만으로는 성공하기 어렵습니다. 따라서 본 논문은 시범을 RL에 통합하는 Imitation Learning 알고리즘인 Demo Augmented Policy Gradient (DAPG) [3]를 사용합니다. DAPG의 목적 함수는 다음과 같습니다:</p>
<p><span class="math display">g_{aug} = \sum_{(s,a)\in\rho^\pi}\nabla \ln \pi(a|s)A^\pi (s, a)+\sum_{(s,a)\in\rho^{\pi_{demo}}}\nabla \ln \pi_\theta (a|s)\lambda_0\frac{\lambda_1}{k} \max_{(s',a')\in\rho^\pi}A^\pi (s', a')</span></p>
<p>여기서 첫 번째 항은 RL의 일반적인 정책 기울기(policy gradient) 목적 함수이고, 두 번째 항은 시범을 이용한 Imitation 목적 함수입니다. 이는 Behavior Cloning과 온라인 RL의 조합으로 볼 수 있습니다. <span class="math inline">\rho^\pi</span>는 정책 <span class="math inline">\pi</span> 하에서의 점유 측정(occupancy measure), <span class="math inline">\lambda_0</span>와 <span class="math inline">\lambda_1</span>은 하이퍼파라미터, <span class="math inline">k</span>는 훈련 반복 횟수입니다. <span class="math inline">A^\pi (s', a')</span>는 이점 함수(advantage function)입니다.</p>
<p><strong>VI. 실험</strong></p>
<p><strong>A. Teleoperation User Study</strong></p>
<p>제안된 Customized Robot Hand의 이점을 입증하기 위해 17명의 인간 작업자를 대상으로 텔레오퍼레이션 사용자 연구를 수행했습니다. 작업자들은 Customized Robot Hand, Schunk SVH Hand, Adroit Hand, Allegro Hand의 네 가지 로봇 핸드 모델을 사용하여 Relocate 및 Open Door 작업을 수행했습니다. Customised Robot Hand의 경우 인간 포즈 파라미터를 각 관절의 PD 목표로 직접 사용했지만, 나머지 세 로봇의 경우 온라인 Motion Retargeting이 필요했습니다.</p>
<p>결과는 표 II(Relocate)와 표 III(Open Door)에 나타나 있습니다. Customized Robot Hand는 다른 세 로봇 핸드의 온라인 Retargeting 방식에 비해 모든 작업에서 월등히 높은 성공률을 달성했습니다. 예를 들어, Relocate 작업의 경우 Customized Hand는 시간당 약 60개의 성공적인 데모를 수집할 수 있었지만, Allegro Hand를 직접 조작할 때는 10개에 불과했습니다. 사용자들은 Customized Hand가 다른 로봇 핸드보다 제어하기 쉽다고 보고했습니다. 이는 온라인 Motion Retargeting 단계에서 발생하는 제어 불가능한 시간 소모(평균 76 ± 65ms, 큰 편차) 때문인 것으로 분석되었습니다. 온라인 Retargeting을 제거함으로써 시스템은 더 부드럽고 즉각적인 피드백을 제공합니다.</p>
<p><strong>B. Task Learning Comparison</strong></p>
<p>Relocate (세 가지 다른 물체), Flip, Open Door 작업에서 처리된 시범 데이터를 사용하여 정책을 훈련하고 RL baseline과 비교했습니다. RL baseline으로는 Trust Region Policy Optimization (TRPO) [56]을 사용했습니다. 정책 및 가치 함수(value function)는 32 × 32의 2-layer Multi-Layer Perceptrons (MLPs)로 구성되었고, TRPO는 각 스텝마다 200개의 궤적을 사용했습니다. Imitation Learning 알고리즘은 DAPG를 사용했으며, 각 작업에 대해 50개의 시범 궤적을 수집하고 이를 특정 로봇으로 Retargeting했습니다.</p>
<p>훈련 곡선은 그림 6에, 세 가지 특정 로봇 핸드의 성공률은 표 IV에 요약되어 있습니다. Imitation Learning 방식인 DAPG는 대부분의 작업과 로봇에서 RL baseline을 능가했습니다. 이는 Motion Retargeting을 통해 생성된 시범이 정책 훈련을 크게 개선할 수 있음을 보여줍니다. 유일한 예외는 Allegro Hand를 사용한 Open Door 작업이었는데, DAPG는 자연스러운 행동으로 손잡이를 잡고 문을 열려고 시도하는 반면, RL 정책은 큰 힘으로 손잡이를 누르며 마찰에 의존하여 문을 여는 경향을 보였습니다 (그림 8). 이는 시범이 정책의 행동을 예상된(인간과 같은) 안전한 방향으로 조절하는 데 중요한 가치를 제공함을 강조합니다.</p>
<p><strong>C. Ablation Study</strong></p>
<p>다양한 동적 조건과 시범 데이터 수의 영향을 조사하기 위해, 물체 마찰, 제어기 파라미터, 물체 밀도, 시범 데이터 수를 대상으로 Relocate (tomato soup can, Schunk Robot) 작업에서 Ablation Study를 수행했습니다 (그림 7). 학습 곡선은 마찰 변화에 강건함을 보였는데, 이는 다지 핸드가 여러 접촉점을 통해 힘 폐쇄(force closure)를 형성하여 마찰에 덜 민감하기 때문입니다. 물체 밀도에 대해서도 유사한 결과가 나타났습니다. 제어기 파라미터의 경우, 강성이 클수록 더 빨리 목표에 도달했지만, 작은 PD 값으로도 작업을 해결할 수 있었습니다. 더 많은 시범 데이터를 사용할수록 더 나은 성능을 달성했으며, 20-30개의 데모에서는 분산(variance)이 더 크게 나타났습니다.</p>
<p><strong>D. Real-World Robot Experiments</strong></p>
<p>실제 로봇 실험에서는 XArm-6 로봇 암 [58]에 Allegro Hand를 부착했습니다 (그림 9 참조). Relocate 및 Flip 작업을 평가했으며, Sim2Real 전이를 용이하게 하기 위해 훈련 중 물체 포즈에 가산 가우시안 노이즈(additive Gaussian noise)를 적용하고 마찰, 밀도, PD 제어 파라미터와 같은 동적 파라미터를 무작위화했습니다. 관측 공간은 로봇 고유 상태(proprioceptive state), 물체 포즈(초기 포즈는 RealSense D435 카메라로 캡처된 포인트 클라우드를 ICP 알고리즘으로 추정), 그리고 Relocate의 경우 목표 위치를 포함했습니다.</p>
<p>Relocate 작업에서는 훈련에 사용된 물체(known object)와 훈련 중 보지 못한 새로운 물체(novel object) 그룹으로 나누어 정책을 평가했습니다 (그림 10). 정량적 결과(표 V)는 Imitation Learning (DAPG)이 순수 RL보다 실제 로봇 전이 시 훨씬 더 큰 성능 차이를 보임을 보여줍니다. 이는 인간과 유사한 조작 정책이 Sim2Real 갭에 더 강건하기 때문으로 추정됩니다. 더욱 흥미롭게도, 학습된 정책은 훈련 중 보지 못한 새로운 물체에도 일반화되었습니다. 이는 다지 핸드가 인간처럼 작동할 때 형상 변화에 대한 일정 수준의 강건함을 제공함을 시사합니다.</p>
<p>정책 시각화(그림 11)는 Sim2Real 갭에 대한 Imitation Learning 정책의 강건함을 설명합니다. Relocate 작업에서 RL 정책은 불안정한 접촉(두 손가락만 사용)으로 물체를 잡는 경향이 있었지만, 시범으로 훈련된 정책은 네 손가락 모두를 사용하여 안정적으로 잡았습니다. 이로 인해 실제 로봇에서는 RL 정책의 물체가 손에서 미끄러지는 반면, Imitation Learning 정책은 안정적으로 물체를 잡았습니다. Flip 작업에서도 순수 RL 정책은 시뮬레이터에서 컵을 빠르게 밀어 해결했지만, Imitation Learning 정책은 한 손가락을 컵 안에 넣고 손목을 회전시키는 인간과 유사한 행동을 보였습니다. 이러한 RL 정책의 행동은 실제 로봇 핸드에서는 거의 성공하지 못했습니다. 두 가지 예시 모두에서 순수 RL은 시뮬레이터의 물리적 특성을 ’해킹’하여 부자연스러운 행동을 학습하는 경향이 있으며, 이는 실제 세계로 전이되기 어렵습니다. 반면, 본 논문의 시범을 사용하여 인간과 유사한 행동을 학습하는 Imitation Learning은 실제 세계 응용에 훨씬 더 강건하고 안정적인 정책을 가능하게 합니다.</p>
<p><strong>VII. 결론</strong></p>
<p>본 논문은 Imitation Learning을 위한 인간 손 조작 데이터를 수집하기 위해 새로운 단일 카메라 텔레오퍼레이션 시스템을 제안합니다. 특히, 다양한 인간 작업자가 데이터를 보다 직관적으로 수집할 수 있도록 맞춤형 로봇 핸드(customized robot hand) 개념을 도입했습니다. 수집된 시범 데이터가 여러 로봇에서의 Dexterous Manipulation 학습을 개선하고, 데이터 수집이 단 한 번만 필요함에도 불구하고 실제 세계에 배치될 때 강건성을 높임을 보여주었습니다.</p>
<hr>
</section>
<section id="detail-review" class="level1">
<h1>Detail Review</h1>
<blockquote class="blockquote">
<p>논문 리뷰: From One Hand to Multiple Hands – Single-Camera Teleoperation을 활용한 다지 로봇 손 모방학습</p>
</blockquote>
<section id="방법론-methodology" class="level2">
<h2 class="anchored" data-anchor-id="방법론-methodology">1. 방법론 (Methodology)</h2>
<section id="단일-카메라-텔레오퍼레이션을-통한-데모-수집" class="level3">
<h3 class="anchored" data-anchor-id="단일-카메라-텔레오퍼레이션을-통한-데모-수집">1.1 단일 카메라 텔레오퍼레이션을 통한 데모 수집</h3>
<p>이 논문의 핵심은 <strong>단일 RGB-D 카메라</strong>(아이패드)에 기반한 텔레오퍼레이션 시스템을 통해 인간 손 시연(demonstration)을 효율적으로 수집하는 새로운 프레임워크다. 사용자는 특수 장비 없이 아이패드 한 대만으로 자신의 손 동작을 촬영하여 <strong>3차원 손 자세와 형상</strong>을 실시간으로 추정한다. 저자들은 MediaPipe와 FrankMocap 기반의 손 추적기를 사용하여, 입력 RGB-D 영상에서 <strong>손목 위치, 손가락 관절 각도(포즈) 및 손 형태(shape) 파라미터</strong>를 추정한다. 여기서 <strong>SMPL-X 모델</strong>을 활용하여 손의 형상과 포즈를 파라미터화하며, 초기 프레임에서 추정된 손 형태 파라미터를 통해 사용자의 손 크기와 모양을 파악한다. 이후 이 정보를 이용해 <strong>물리 시뮬레이터(SAPIEN)</strong> 상에 <strong>사용자 손과 동일한 형태・크기의 맞춤형 로봇 손 모델</strong>을 즉석에서 생성한다. 이 <strong>커스텀 로봇 손</strong>(customized robot hand)은 사용자의 손 골격과 운동학 구조를 그대로 반영하며, 예를 들어 사용자의 엄지손가락이 짧다면 생성된 로봇 손에서도 엄지가 짧게 구현된다. 이렇게 만들어진 로봇 손 모델은 약 <strong>45자유도(DoF)</strong>를 가져 인간 손의 섬세한 움직임을 모사한다.</p>
<p>사용자는 자신의 손을 움직이면, <strong>PD 제어기</strong>를 통해 해당 관절 목표각이 시뮬레이터의 커스텀 로봇 손에 전달되어 로봇 손이 따라 움직인다. 이때 영상 기반 추적의 오차로 인한 <strong>잡음이나 튀는 동작</strong>을 줄이기 위해, 저자들은 손 형태 추정값의 신뢰도를 <strong>가중치로 활용한 PD 제어 기법</strong>을 고안하였다. 구체적으로, 초기 캘리브레이션 시 얻은 <strong>손 shape 파라미터</strong>를 기준값으로 삼고, 매 프레임의 shape 추정치와의 차이를 계산하여 추적 정확도의 신뢰도로 활용한다. 신뢰도가 낮은 경우(손 추적 오차가 큰 경우) PD 제어의 강성을 낮추어 갑작스런 잘못된 동작 전송을 억제함으로써, <strong>부드럽고 안정적인 원격조작</strong>을 가능하게 하였다.</p>
<p>이 시스템은 <strong>온라인 모션 리타기팅(motion retargeting)</strong>을 필요로 하지 않는다는 점에서 기존 방식과 차별화된다. 일반적인 비전 기반 텔레오퍼레이션에서는 사람 손의 관절 움직임을 로봇 손의 관절로 <strong>실시간 변환</strong>해야 하는데, 사람 손과 로봇 손 구조 차이로 인해 제어가 어렵고 지연이 발생하곤 했다. 반면 본 논문에서는 <strong>사용자별로 동일한 구조의 로봇 손을 사용</strong>하므로 이러한 매핑 과정이 불필요하다. 그 결과 사용자는 마치 <strong>자신의 손을 그대로 가상 공간에 옮겨놓은 듯한 자연스러운 방식</strong>으로 물체 조작 시연을 할 수 있다. 저자들의 사용자 연구에 따르면, 제안 시스템으로는 <strong>1시간에 약 60개의 성공 시연</strong>을 모을 수 있는데, 이는 예컨대 사용자가 직접 Allegro 로봇 손(4손가락 로봇)을 조작해 시연을 모을 때의 약 10개에 비해 6배에 달하는 수치다. 실험에 참여한 사람들 역시 <strong>커스텀 손이 기존 로봇 손보다 조작하기 훨씬 쉽다</strong>고 평가하였다. 이러한 높은 데모 수집 효율은 <strong>대규모의 양질의 시연 데이터</strong>를 확보하게 해주며, 결과적으로 모방 학습 성능 향상으로 이어진다.</p>
</section>
<section id="다중-로봇-손으로의-시연-데이터-변환-multi-hand-demonstration-translation" class="level3">
<h3 class="anchored" data-anchor-id="다중-로봇-손으로의-시연-데이터-변환-multi-hand-demonstration-translation">1.2 다중 로봇 손으로의 시연 데이터 변환 (Multi-Hand Demonstration Translation)</h3>
<p>시뮬레이터에서 수집된 <strong>맞춤형 로봇 손의 시연 trajectories</strong>는, 오프라인 단계에서 임의의 타깃 로봇 손 모델로 변환(retargeting)된다. 이는 <strong>한 번의 인간 시연 데이터 수집으로 여러 종류의 로봇 손 학습 데이터를 생성</strong>할 수 있음을 의미한다. 논문에서는 <strong>Schunk SVH 5손가락 로봇 손, Adroit 손(샌디에이고 대학 Adroit) 및 Allegro Hand(4손가락)</strong>의 세 가지 서로 다른 상용 로봇 손을 대상으로 실험하였다. 이들 로봇 손들은 <strong>형태(geometry)</strong>와 <strong>운동 범위(DOF)</strong>뿐 아니라 손가락 개수까지 사람 손과 상이하지만, 커스텀 손 시연을 각 로봇 손의 데이터로 변환함으로써 <strong>동일 과제에 대한 다종 로봇 시연 데이터셋</strong>을 구축할 수 있다.</p>
<p>모션 리타기팅은 <strong>각 로봇 손의 관절 움직임 궤적</strong>을 찾는 <strong>최적화 문제</strong>로 공식화된다. 구체적으로, 커스텀 손과 타깃 로봇 손의 <strong>중요 키포인트</strong> (손가락 끝 위치 등)가 최대한 일치하도록 두 손의 관절각을 조정하는 방식을 취한다. 각 시점에서 <strong>양 손 모델의 정방향 운동학 결과(손가락 키포인트 좌표)</strong> 간 오차를 최소화하는 관절 구성을 찾아내며, 시간적 연속성을 위해 <strong>이전 프레임의 해</strong>로 초기화하고 관절 변화량에 대한 정규화 항을 추가하여 <strong>부드러운 궤적</strong>을 얻는다. 이렇게 계산된 <strong>관절 위치 trajectory</strong>는 해당 로봇 손에서의 시연으로 간주되며, 이후 학습 알고리즘에 투입될 수 있다. 특히 Allegro Hand의 경우 인간 손가락보다 하나 적은 <strong>4개 손가락</strong>만 있기 때문에, 최적화 과정에서 인간의 약지/소지 움직임을 나머지 손가락에 분산시키는 등 형태 차이를 보정한다. 저자들은 이러한 <strong>오프라인 리타기팅</strong>은 실시간으로 할 때보다 계산 비용이 크지만, <strong>한 번만 수행하면 되므로 충분히 감내할 수 있는 수준</strong>이라고 설명한다. 실제로 논문에 따르면 오프라인 리타기팅에 수 밀리초 단위의 계산 시간이 들지만, 온라인 리타기팅 시에는 반복 최적화로 인해 프레임 간 지연이 들쑥날쑥 커져 사람이 다음 동작을 예측하며 조작하기 어렵게 된다고 지적한다. 커스텀 손 접근법은 이러한 <strong>온라인 retargeting에 따른 지연과 불안정성 문제</strong>를 근본적으로 해소하였다.</p>
<p>리타기팅된 시연 데이터에는 각 로봇 손의 <strong>상태(관절각 등)</strong> 뿐 아니라 <strong>행동(action) 데이터</strong>도 필요하다. 모방 학습을 위해서는 시연 시퀀스의 상태-액션 쌍이 필요한데, 관절 위치 궤적으로부터 해당 로봇 손의 구동 명령(토크 또는 모터 입력)을 계산하는 절차가 추가된다. 이 부분에서 저자들은 이전 연구인 <strong>DexMV</strong> 방법론을 참고하여, 우선 관절각 시퀀스에 1차 저역통과 필터를 적용하고, 로봇 <strong>역동역학(manipulator equation) 기반</strong>으로 각 시점의 관절 토크를 추정하는 방식을 사용하였다. 이를 통해 <strong>시연 궤적을 따라가는 데 필요한 근사 제어 신호</strong>까지 계산함으로써, 최종적으로 <em>“(상태, 액션) 궤적”</em> 형태의 <strong>학습용 시연 데이터</strong>를 완성한다.</p>
</section>
<section id="모방-학습-알고리즘-및-정책-학습" class="level3">
<h3 class="anchored" data-anchor-id="모방-학습-알고리즘-및-정책-학습">1.3 모방 학습 알고리즘 및 정책 학습</h3>
<p>이렇게 준비된 다수 로봇 손의 인간 시연들을 활용하여, 최종적으로 <strong>다이렉트 정책 학습</strong>(policy learning)을 수행한다. 가장 단순한 접근인 <strong>행동 클로닝(Behavior Cloning)</strong>의 경우 시연 데이터를 바로 모방하도록 학습하면 되지만, 초기 상태나 목표 조건이 변하는 복잡한 작업에서는 순수 행동 클로닝만으로는 성공적인 정책을 얻기 어렵다. 따라서 논문에서는 <strong>강화학습(RL)</strong>에 시연 데이터를 활용하는 형태의 <strong>모방 강화학습 알고리즘</strong>을 채택하였다. 구체적으로, Rajeswaran 등이 제안한 <strong>DAPG (Demo Augmented Policy Gradient)</strong> 알고리즘을 사용하여 <strong>강화학습 목표에 시연 모방 항(term)을 추가</strong>하였다. DAPG는 전문가 시연으로 사전학습(behavior cloning)을 실시한 후, 이후 학습 과정에서도 <strong>정책 그래디언트 계산 시 시연 데이터로부터 유도된 보상(or 정규화 항)</strong>을 추가함으로써, <strong>표준 RL과 BC의 조합</strong>으로 볼 수 있는 방법이다. 본 연구에서는 TRPO(Trust Region Policy Optimization) 알고리즘을 기반 RL 기법으로 사용하고, 여기에 동일한 하이퍼파라미터 세팅으로 DAPG를 적용하여 학습을 진행하였다.</p>
<p>정책 학습은 시뮬레이션 환경에서 이루어지며, 관측 상태에는 <strong>로봇 손 관절 상태</strong>, <strong>손바닥(팜)의 속도</strong>, <strong>물체의 3D 위치와 자세</strong> 등이 포함된다. 과제에 따라 목표물의 위치나 문의 힌지 각도 등의 목표 조건도 관측에 주어지며, 에이전트의 행동은 <strong>손바닥 이동</strong>(자유 공간에서의 6-자유도 움직임은 6차원 속도 제어)과 <strong>손가락 관절 제어</strong>(PD 위치 제어 입력)로 구성된다. 이렇게 학습된 정책은 해당 로봇 손 모델의 시뮬레이션에서 동작을 익히게 되며, 이후 <strong>실제 로봇 손</strong>으로의 이식을 목표로 한다. 특히 실세계로의 일반화를 돕기 위해, 학습 중에 <strong>도메인 랜덤화</strong> 기법을 도입하였다. 예를 들어 물체의 초기 위치나 물리 속성(마찰 계수, 무게 등)을 다양하게 랜덤화하고, 관측되는 물체 상태에 <strong>가우시안 잡음</strong>을 추가하여 센서 노이즈와 환경 차이를 견디도록 훈련했다. 이러한 전략과 <strong>인간 시演의 도입으로 정책이 사람과 유사한 동작 전략</strong>을 학습하게 되어, <strong>시뮬레이션-실세계 간 격차(sim2real gap)</strong>를 극복하는 데 큰 도움이 되었다고 저자들은 밝히고 있다.</p>
</section>
</section>
<section id="실험-설정과-결과-평가-experiments-and-results" class="level2">
<h2 class="anchored" data-anchor-id="실험-설정과-결과-평가-experiments-and-results">2. 실험 설정과 결과 평가 (Experiments and Results)</h2>
<section id="실험-환경과-과제-구성" class="level3">
<h3 class="anchored" data-anchor-id="실험-환경과-과제-구성">2.1 실험 환경과 과제 구성</h3>
<p>저자들은 앞서 구축한 SAPIEN 시뮬레이터 환경에서 <strong>세 가지 복잡한 다지 조작 과제</strong>를 실험했다. 각 과제는 실제 인간 시연을 통해 데이터가 수집되고, 이후 정책 학습 및 평가에 활용되었다:</p>
<ul>
<li><strong>Relocate (물체 옮기기)</strong>: 로봇 손이 탁자 위의 <strong>물체를 집어서 임의의 목표 위치로 옮기는 작업</strong>이다. 초기 물체의 자세와 목표 위치는 에피소드마다 무작위로 설정되며, 로봇은 물체를 들어올려 정해진 위치에 놓는 것을 목표로 한다. 이 과제에는 YCB 객체셋의 <strong>토마토 수프 캔, 통조림(Potted Meat Can), 머스타드 병</strong>의 세 가지 물체가 사용되어, <strong>목표지향 다중 물체 조작</strong> 능력을 평가한다.</li>
<li><strong>Flip (머그컵 뒤집기)</strong>: 평평한 테이블 위에 놓인 머그잔을 <strong>90도 회전시켜 옆으로 눕히는 작업</strong>이다. 로봇 손은 잔을 움켜쥐고 천천히 기울여 눕혀야 하며, 지나친 힘을 주면 물체가 미끄러지거나 튕겨나갈 수 있다. 이 과제는 <strong>특정 방향으로 힘을 미세하게 가하여 물체를 조작하는 능력</strong>을 평가하며, 매 에피소드마다 머그잔의 초기 위치와 회전 각도가 무작위로 변경된다.</li>
<li><strong>Open Door (문 열기)</strong>: 문에 달린 레버 형태의 손잡이를 <strong>돌려서 문을 여는 이단계 작업</strong>이다. 먼저 손잡이를 쥐고 회전시켜 <strong>잠금을 해제</strong>한 뒤, 계속 잡은 상태로 문을 <strong>당겨서 연다</strong>. 로봇 손은 손잡이를 단단히 파지하면서도 회전과 당기기 두 동작을 모두 수행할 수 있는 <strong>적절한 손가락 구성</strong>을 찾아야 한다. 매 시도마다 문의 위치(거리 등)가 약간씩 바뀌어, <strong>일반화된 문 열기 동작</strong>을 익혀야 한다.</li>
</ul>
<p>각 과제의 <strong>성공 기준</strong>은 명확하게 정의되었다. 예를 들어 Relocate의 경우 에피소드 종료 시 <strong>물체와 목표 지점 사이 거리가 일정 임계값 이하</strong>이면 성공으로 판정하고, Flip은 <strong>머그잔의 기울기 각도가 목표 범위</strong>에 들어오면 성공으로 본다. Open Door는 <strong>문 경첩의 회전각이 일정 각도 이상</strong> 벌어져 실제로 문이 열렸을 때 성공 처리한다. 이러한 성능 지표를 통해 <strong>성공률(success rate)</strong>이나 <strong>에피소드 리턴(return)</strong> 등을 측정하였다.</p>
</section>
<section id="사용자-원격조작-실험-커스텀-손-vs.-기존-로봇-손" class="level3">
<h3 class="anchored" data-anchor-id="사용자-원격조작-실험-커스텀-손-vs.-기존-로봇-손">2.2 사용자 원격조작 실험: 커스텀 손 vs.&nbsp;기존 로봇 손</h3>
<p>먼저 <strong>데모 수집 단계의 효용성</strong>을 확인하기 위해 수행된 <strong>텔레오퍼레이션 사용자 연구(user study)</strong> 결과를 살펴본다. 17명의 피험자들이 앞서 정의한 Relocate 과제와 Open Door 과제를 각기 수행하되, 네 가지 다른 로봇 손 모델을 사용하도록 했다. 비교 대상은 (1) 제안한 <strong>맞춤형 로봇 손</strong>, (2) <strong>Schunk SVH</strong> 5손가락 로봇 손, (3) <strong>Adroit</strong> 로봇 손, (4) <strong>Allegro</strong> 로봇 손이었다. 커스텀 손 이외의 세 경우에는 모두 <strong>온라인 모션 리타기팅</strong>을 통해 사용자의 손 동작이 해당 로봇 손으로 매핑되었고, 커스텀 손의 경우 앞서 설명한 대로 <strong>1:1 직접 제어</strong>가 이루어졌다.</p>
<p>평가 방법으로, 각 조합(작업 + 로봇 손)에 대해 <strong>5회씩 연속 시도</strong>하게 하고 그 <strong>평균 성공률과 작업 완료 시간</strong>을 측정하였다. Relocate와 Open Door 모두 <strong>두 단계(stage)</strong>로 나누어 세분화 평가하였는데, 예를 들어 Open Door의 경우 <strong>손잡이 회전 성공 여부</strong>를 1단계, <strong>문 열기 완료 여부</strong>를 2단계로 구분해 각각의 성공률과 소요 시간을 기록했다. 이는 작업 내 세부 단계별로 어느 부분에서 실패하거나 시간이 지연되는지 파악하기 위함이다.</p>
<p><strong>결과적으로, 커스텀 로봇 손을 이용한 경우 압도적으로 높은 성공률과 더 빠른 수행 시간</strong>을 보였다. 예를 들어 Relocate 과제에서 1단계(물체 들어올리기) 성공률은 <strong>커스텀 손 78.9%</strong>로, Schunk(61.2%), Adroit(58.8%), Allegro(44.7%)에 비해 월등히 높았다. 2단계(물체 이동 완료) 역시 커스텀 손이 <strong>55.3%</strong>로 나머지(30.6%, 28.2%, 16.9%)보다 훨씬 높았다. Open Door 과제에서도 커스텀 손의 1단계(손잡이 돌리기) 성공률이 <strong>95.3%</strong>로 다른 손들(71~83%)보다 높았고, 2단계(문 열기)도 <strong>82.4%</strong>로 타 로봇 손들(41~61%) 대비 크게 앞섰다. 작업 완료 시간도 일관되게 커스텀 손이 짧아서, <strong>더 빠르게 과제를 달성</strong>했다. 이러한 사용자 실험을 통해, <strong>맞춤형 손을 이용한 비전 기반 원격조작이 전통적인 로봇 손 직접 제어보다 훨씬 효율적</strong>임이 검증되었다. 저자들은 특히 <strong>Allegro 손의 성능이 가장 저조</strong>했던 점을 지적했는데, 그 이유로 “Allegro는 손가락이 4개라 인간 손 동작을 충실히 맵핑하기 어렵고, 손 크기도 사람 손보다 훨씬 커 제어가 어색하다”고 분석했다. 반면 커스텀 손은 사용자 손과 크기/구조가 같고 추가 매핑 계산이 없기에 <strong>즉각적이고 직관적인 피드백</strong>을 주어 조작을 수월하게 만든 것이다.</p>
<p>결과적으로, 맞춤형 손 시스템은 <strong>데모 수집 단계부터 질적으로 우수한 데이터</strong>(높은 성공률의 시연)를 <strong>다량 확보</strong>하게 해주며, 이는 이후 학습 성능 향상의 기반이 된다.</p>
</section>
<section id="정책-학습-성능-비교-rl-vs.-모방-학습" class="level3">
<h3 class="anchored" data-anchor-id="정책-학습-성능-비교-rl-vs.-모방-학습">2.3 정책 학습 성능 비교: RL vs.&nbsp;모방 학습</h3>
<p>다음으로, 이렇게 수집된 시연 데이터를 활용한 <strong>정책 학습 결과</strong>를 순수 강화학습과 비교 평가하였다. 각 과제(Relocate - 3가지 객체, Flip, Open Door)에 대해 <strong>TRPO 기반 강화학습(RL)</strong>으로 훈련한 정책과, <strong>DAPG 기반 모방 학습(IL)</strong>으로 훈련한 정책을 비교하였다. 여기서 <strong>시연 데이터의 양은 과제당 50개 에피소드</strong>로 동일하게 제한하였고, 정책 학습은 3개의 시드로 반복하여 <strong>수렴 속도와 최종 성능의 평균</strong>을 비교했다. Figure 4의 학습曲선 및 Table VI의 최종 성공률이 두 방법을 종합적으로 보여준다.</p>
<p><strong>학습曲선</strong>을 보면, <strong>모방 학습(DAPG)이 순수 RL보다 훨씬 빠르게 초기 성능을 끌어올리고 더 높은 수준에서 수렴</strong>하는 경향이 명확하다. 특히 난이도가 높은 과제일수록 그 격차가 크게 벌어졌다. 최종 <strong>성공률</strong> 지표로 보아도, <strong>대부분의 과제-로봇 조합에서 DAPG 정책이 RL 정책을 능가</strong>했다. 예를 들어 Relocate-토마토캔, 머그 뒤집기 등에서 모든 로봇 손에 대해 모방 학습이 더 높은 성공률을 기록하였다. 이는 <strong>사람 시연으로부터 생성한 데이터가 학습에 유의미한 신호</strong>를 제공하여, 고차원 탐색 공간에서 RL 혼자 학습할 때 발생하는 시행착오를 크게 줄여주기 때문이다.</p>
<p>흥미로운 점은 <strong>Open Door 과제에서 Allegro 손을 사용한 경우</strong>였다. 이 한 가지 사례에서는 DAPG 정책의 최종 성공률이 RL과 큰 차이가 없었는데, 이는 Allegro 손의 구조적 한계와 과제의 난이도가 맞물려 나타난 결과로 보인다. 비록 정량적 성능 향상은 작았지만, 두 접근법의 <strong>동작 양상은 크게 달랐다</strong>. 저자들이 시각적으로 정책 행동을 관찰한 바로는, <strong>DAPG로 학습된 정책은 사람처럼 손잡이를 쥐고 돌린 후 당기는 자연스러운 전략</strong>을 구사한 반면, <strong>순수 RL 정책은 손잡이를 제대로 쥐지 못하고 손바닥으로 강압적으로 누르면서 마찰력으로 문을 여는</strong> 비교적 <strong>비정상적인 방법</strong>을 사용했다고 한다. 후자는 시뮬레이터 상에서는 우연히 성공할지 모르나 실제 세계에선 통하지 않을 가능성이 크다. 이 사례는, <strong>모방 학습을 통해 얻은 정책이 보다 인간스러운 동작으로 안전하고 예상 가능한 범위 내에서 과제를 수행</strong>함을 보여준다. 결국 <strong>대부분의 상황에서 인간 데모 활용이 학습 성능과 행동 품질을 향상</strong>시킴이 입증되었다.</p>
</section>
<section id="추가-실험-ablation-및-영향-요소-분석" class="level3">
<h3 class="anchored" data-anchor-id="추가-실험-ablation-및-영향-요소-분석">2.4 추가 실험: Ablation 및 영향 요소 분석</h3>
<p>저자들은 모방 강화학습의 성공에 기여하는 요소들을 분석하기 위해 몇 가지 <strong>요인 별 Ablation 실험</strong>도 수행하였다. 예를 들어, Relocate(토마토 수프 캔) + Schunk Hand 조합에 대해, <strong>(a) 물체 마찰계수</strong>, <strong>(b) 물체 밀도(무게)</strong>, <strong>(c) PD 제어기의 강성/감쇠 계수</strong>, <strong>(d) 학습에 사용한 데모 개수</strong> 등을 변화시켜 가며 DAPG 학습의 민감도를 관찰했다. Figure 5에 제시된 학습曲선을 통해 각 조건 변화가 학습 속도와 최종 성능에 미치는 영향을 비교하였는데, 전반적으로 <strong>환경 물리 파라미터의 변화에도 시연 데이터가 포함된 학습은 안정적으로 동작</strong>함을 보였다. 예컨대 물체 마찰이나 무게가 달라져도 데모를 포함한 정책은 비교적 <strong>강인한 성능 유지</strong>를 보였으며, 이는 시연을 통해 학습한 <strong>인간 특유의 적응적 조작 전략</strong>이 작용한 결과로 해석된다. 또한 데모 개수에 따른 실험에서는, <strong>시연 데이터가 많을수록 학습 성능이 개선되다가 어느 정도 수렴</strong>하는 양상이 나타났는데, 이는 추가 데모가 초기 학습에 도움은 되지만 과도한 경우 수확 체감이 있음을 시사한다. PD 제어 파라미터의 경우 너무 낮은 강성은 정확도 저하로, 너무 높은 강성은 진동 증가로 이어져, <strong>적절한 튜닝이 필요함</strong>을 실험으로 확인하였다.</p>
</section>
<section id="실세계-로봇에의-적용-및-성능" class="level3">
<h3 class="anchored" data-anchor-id="실세계-로봇에의-적용-및-성능">2.5 실세계 로봇에의 적용 및 성능</h3>
<p>최종적으로, 시뮬레이션에서 학습된 정책을 <strong>현실의 로봇 손</strong>에 이식하여 검증하였다. 하드웨어 플랫폼은 <strong>Allegro Hand + XArm-6 로봇 팔</strong> 조합으로, 시뮬레이션의 Allegro Hand 모델과 동일한 로봇 손을 6자유도 로봇 팔 끝에 장착한 구성이다. 저자들은 학습된 정책으로 실세계에서 위 과제들을 수행해보고 <strong>성공률과 동작의 안정성</strong>을 평가했다. 그 결과, <strong>인간 시연을 포함하여 학습된 정책은 시뮬레이터에서뿐만 아니라 실제 환경에서도 높은 성공률과 강인한 성능</strong>을 보였다. 더욱이 시뮬레이션에서는 보지 못했던 <strong>새로운 객체나 변형된 상황에도 정책이 비교적 잘 적응</strong>하는 모습을 보였는데, 이는 <strong>학습 과정에서 인간 시연을 통해 얻은 일반적인 조작 원리와 자연스러운 힘 가하기 전략</strong> 덕분으로 풀이된다. 반면, <strong>동일 환경에서 순수 RL로 학습된 정책은 현실에서 거의 실패</strong>하였는데, 시뮬레이터 상의 비현실적인 전략(예: 마찰로 문 밀기 등)이 현실에선 통하지 않고, 미세한 동작 오차에 대한 보정 능력도 부족했기 때문이다. 정량적으로 실험 횟수가 제한되어 구체적인 성공률 수치로 비교하진 않았지만, <strong>데모 기반 정책이 월등히 안정적인 성과</strong>를 보인 것은 분명하다. 요약하면, 본 논문의 접근법은 <strong>시뮬레이션-현실 간 격차를 줄여주는 인간 데모의 힘</strong>을 입증했으며, 복잡한 다관절 손 조작 작업을 실제 로봇으로 수행하는 데 있어 <strong>모방 학습의 유용성</strong>을 보여주었다.</p>
</section>
</section>
<section id="기존-연구와의-비교-comparison-with-prior-work" class="level2">
<h2 class="anchored" data-anchor-id="기존-연구와의-비교-comparison-with-prior-work">3. 기존 연구와의 비교 (Comparison with Prior Work)</h2>
<p>본 연구는 <strong>다지 로봇 손의 정교한 조작</strong>과 <strong>인간 시연 학습</strong> 분야에서 여러 기존 접근들과 구별되는 혁신점을 제시한다. 여기서는 관련 선행 연구들과 비교하여 이 논문의 차별성과 기여도를 분석한다.</p>
<ul>
<li><p><strong>VR 글러브 기반 데모 수집 vs.&nbsp;카메라 기반 데모 수집</strong>: 인간 시연을 로봇 학습에 활용하려는 시도는 이전부터 있어 왔다. 대표적으로 2018년 Rajeswaran 등은 <strong>VR 장비와 데이터글러브</strong>를 활용해 인간이 가상현실에서 로봇 손을 조작하며 데모를 모으고, 이를 활용해 <strong>DAPG 알고리즘</strong>으로 정책을 학습하는 연구를 수행했다. 이 방식은 성공적인 Dexterous 핸드 조작을 보여주었지만, <strong>전용 장비가 필요하고 한정된 인원만 참여</strong>할 수 있어 데이터 수집의 <strong>확장성(scalability)</strong>이 떨어진다는 단점이 있었다. 반면 본 논문은 <strong>특수 장비 없이 카메라만으로 누구나 데모를 제공</strong>할 수 있는 환경을 마련함으로써, 다양한 사용자로부터 <strong>대량의 데모를 손쉽게 확보</strong>할 수 있게 했다. 실제로 “VR을 통한 수집은 많은 인적 노력(human effort)을 요해 확장성이 낮지만, 단일 카메라 텔레오퍼레이션은 프로세스를 <strong>더욱 손쉽고 대규모로 확장 가능</strong>하게 만든다”고 저자들도 강조한다. 이러한 접근은 향후 <strong>클라우드 로보틱스나 크라우드소싱</strong>을 통해 방대한 인간 시연 데이터를 모을 수 있는 길을 열었다는 점에서 의의가 크다.</p></li>
<li><p><strong>멀티캠 Vision 텔레오퍼레이션 vs.&nbsp;단일캠 접근</strong>: 비전 기반의 원격조작 자체는 과거에도 연구된 바 있는데, <strong>DexPilot</strong> 연구가 그 선구적 예다. DexPilot에서는 <strong>4대의 깊이 카메라(RealSense)</strong>를 테이블 주변에 배치하고 배경을 검은 천으로 막는 등 상당히 복잡한 세팅을 통해, 인간 손 영상을 인식해 Allegro 로봇 손을 제어하였다. 이와 비교하면 본 논문은 <strong>카메라 한 대(iPad)</strong>로 동일한 목표를 달성하면서, 추가로 <strong>사용자별 커스텀 손 인터페이스</strong>까지 제공하여 조작의 직관성을 높였다. 무엇보다도, DexPilot 등 이전 연구들은 <strong>단일 특정 로봇 손</strong>(예: Allegro)만을 대상으로 하였는데, 본 연구는 <strong>동일한 인간 시연 데이터를 여러 로봇 손으로 변환하여 학습에 활용</strong>하는 <strong>범용성</strong>을 선보였다. 이는 이전에는 볼 수 없었던 새로운 개념으로, 예컨대 한 사람의 시연으로 쉥크 손, 어드로이트 손, 알레그로 손 각각의 정책을 모두 학습시킬 수 있음을 처음으로 실증하였다. 이러한 <strong>Multi-hand demonstration</strong> 아이디어는 로봇 핸드 하드웨어가 다양한 현실에서 <strong>데이터 효율적인 학습</strong>을 가능케 하는 방향성을 제시한다.</p></li>
<li><p><strong>단순 그리퍼(2-jaw) 작업 vs.&nbsp;고차원 다지 조작</strong>: 인간 시연을 비전으로부터 가져와 학습하는 연구 중에는, 비교적 간단한 병렬 그리퍼(집게 형태 로봇 핸드)로 <strong>픽앤플레이스</strong> 같은 작업을 가르치는 사례들이 있었다. 예를 들어 인간 동작 영상을 모방해 2-finger 그리퍼로 물체를 집는 정도의 과제는 3D 정보 없이도 가능하여, 2D 영상 기반 imitation이 시도되었다. 그러나 이러한 선행 연구들은 <strong>저차원 제어(몇 개 관절)</strong>와 <strong>단순 작업</strong>에 국한되어, 복잡한 손가락들을 활용한 3D 상호작용 과제에는 적용하기 어려웠다. 본 논문의 시스템은 <strong>RGB-D를 통해 3D 손-물체 포즈 정보를 추출</strong>하고, 이를 활용해 <strong>복잡한 접촉이 있는 작업</strong>들(예: 손잡이 돌려당기기)을 시연 및 학습하였다는 점에서, <strong>기존 영상 모방학습 연구들을 한 단계 발전</strong>시켰다. 요컨대 <strong>보다 난이도 높은 다지 조작 작업에 비전 기반 모방학습을 확장</strong>한 사례로 평가된다.</p></li>
<li><p><strong>다수 로봇 손 간 정책 전이</strong>: 다관절 로봇 손 연구에서 <strong>로봇 구조가 바뀌면 새로 학습을 해야 하는 문제</strong>는 오래 지속된 숙제였다. 예를 들어 5손가락 로봇에 맞춰 학습된 정책은 4손가락 로봇에는 바로 적용하기 어렵고, 심지어 손가락 길이 비율 차이만 있어도 성능에 큰 영향이 있었다. 이를 해결하려는 시도로 <strong>meta-learning</strong>이나 <strong>이종 로봇 간 domain adaptation</strong> 등의 연구가 일부 있었지만, 여전히 <strong>사전 데이터 준비나 보정이 까다로웠다</strong>. 본 연구는 사람 손이라는 <strong>공통 참조 기준(human hand as common reference)</strong>을 활용하여, 처음에는 사람 손과 같은 구조의 커스텀 손으로 시연을 모으고 나서 이를 각 로봇 손으로 변환함으로써 <strong>자연스럽게 여러 형태의 로봇 시연 데이터</strong>를 확보했다. 이렇게 함으로써 <strong>여러 로봇 플랫폼에 걸쳐 학습 데이터를 공유</strong>할 수 있게 되었고, 결과적으로 각 로봇별 최적 정책을 학습하면서도 <strong>필요한 인간 시연 횟수는 최소화</strong>하는 성과를 거두었다. 이는 기존의 multi-finger manipulation 연구에서 한 종류 로봇에 특화된 데이터를 썼던 관행과 달리, <strong>범용적인 시연 데이터 활용</strong> 가능성을 처음 보여준 것이다.</p></li>
<li><p><strong>정책의 자연스러움과 안전성</strong>: OpenAI의 유명한 <strong>Rubik’s Cube 푸는 로봇 손</strong>과 같은 사례에서 볼 수 있듯, 순수 강화학습을 통해 다관절 손 조작을 습득시키는 것은 가능하지만 종종 <strong>비인간적인 해법</strong>(예: 큐브 던졌다 받기 등)이 나타나거나, <strong>현실 적용 시 예기치 못한 동작</strong>을 보일 수 있다. 이에 비해 본 논문의 접근은 <strong>인간의 데모를 통해 정책이 인간과 유사한 동작 분포를 따르도록 유도</strong>하였고, 그 결과 RL만 사용했을 때 나타나는 위험하거나 이상한 행동을 억제하는 효과가 있었다. 논문에서 묘사된 것처럼, 문 열기 동작에서 순수 RL 정책은 문을 <strong>마찰로 억지로 여는</strong> 방법을 택했지만, 데모를 참고한 정책은 <strong>손잡이를 제대로 잡고 트는</strong> 보다 <strong>안전하고 일반화 가능한 방법</strong>을 구사했다. 이런 차이는 산업적 응용에서 매우 중요하다. 즉, 본 연구는 <strong>기존 대비 안전하고 신뢰할 수 있는 다지 손 조작 정책</strong>을 얻는 데 기여했다고 평가할 수 있다.</p></li>
</ul>
<p>요약하면, <em>“From One Hand to Multiple Hands”</em> 논문은 <strong>비전 기반 텔레오퍼레이션, 맞춤형 로봇 손 개념, 다중 로봇 간 시연 이식, 데모-강화 학습 통합</strong> 등을 한 데 묶어 <strong>다지 로봇 손 학습의 새로운 지평</strong>을 연 연구라 할 수 있다. 이전 연구들에 비해 <strong>데이터 수집의 용이성과 확장성</strong>, <strong>학습 정책의 성능과 현실 적합성</strong> 측면에서 뛰어난 성과를 보였으며, 향후 다양한 형태의 로봇 손이나 복잡한 조작 작업에 <strong>범용적으로 적용될 수 있는 모방학습 프레임워크</strong>로서 큰 영향을 미칠 것으로 기대된다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>