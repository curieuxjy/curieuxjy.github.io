<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-11-10">
<meta name="description" content="Interior-point Policy Optimization under Constraints">

<title>Curieux.JY - 📃IPO</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>
<script type="application/json" class="js-hypothesis-config">
{
  "theme": "clean",
  "openSidebar": false
}
</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a>
  <ul class="collapse">
  <li><a href="#constrained-markov-decision-processcmdp" id="toc-constrained-markov-decision-processcmdp" class="nav-link" data-scroll-target="#constrained-markov-decision-processcmdp"><span class="header-section-number">1.1</span> Constrained Markov Decision Process(CMDP)</a></li>
  <li><a href="#policy-gradient-methods" id="toc-policy-gradient-methods" class="nav-link" data-scroll-target="#policy-gradient-methods"><span class="header-section-number">1.2</span> Policy Gradient Methods</a></li>
  </ul></li>
  <li><a href="#method" id="toc-method" class="nav-link" data-scroll-target="#method"><span class="header-section-number">2</span> Method</a>
  <ul class="collapse">
  <li><a href="#interior-point-policy-optimization" id="toc-interior-point-policy-optimization" class="nav-link" data-scroll-target="#interior-point-policy-optimization"><span class="header-section-number">2.1</span> Interior-point Policy Optimization</a></li>
  <li><a href="#logarithmic-barrier-function" id="toc-logarithmic-barrier-function" class="nav-link" data-scroll-target="#logarithmic-barrier-function"><span class="header-section-number">2.2</span> Logarithmic Barrier Function</a></li>
  <li><a href="#performance-guarantee-bound" id="toc-performance-guarantee-bound" class="nav-link" data-scroll-target="#performance-guarantee-bound"><span class="header-section-number">2.3</span> Performance Guarantee Bound</a></li>
  </ul></li>
  <li><a href="#experiment" id="toc-experiment" class="nav-link" data-scroll-target="#experiment"><span class="header-section-number">3</span> Experiment</a>
  <ul class="collapse">
  <li><a href="#discounted-cumulative-constraints" id="toc-discounted-cumulative-constraints" class="nav-link" data-scroll-target="#discounted-cumulative-constraints"><span class="header-section-number">3.1</span> Discounted Cumulative Constraints</a></li>
  <li><a href="#mean-valued-constraints" id="toc-mean-valued-constraints" class="nav-link" data-scroll-target="#mean-valued-constraints"><span class="header-section-number">3.2</span> Mean Valued Constraints</a></li>
  <li><a href="#constraint-effects" id="toc-constraint-effects" class="nav-link" data-scroll-target="#constraint-effects"><span class="header-section-number">3.3</span> Constraint Effects</a></li>
  <li><a href="#hyperparameter-tuning" id="toc-hyperparameter-tuning" class="nav-link" data-scroll-target="#hyperparameter-tuning"><span class="header-section-number">3.4</span> Hyperparameter Tuning</a></li>
  <li><a href="#multiple-constraints" id="toc-multiple-constraints" class="nav-link" data-scroll-target="#multiple-constraints"><span class="header-section-number">3.5</span> Multiple Constraints</a></li>
  <li><a href="#stochastic-environment-effects" id="toc-stochastic-environment-effects" class="nav-link" data-scroll-target="#stochastic-environment-effects"><span class="header-section-number">3.6</span> Stochastic Environment Effects</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">4</span> Conclusion</a></li>
  <li><a href="#reference" id="toc-reference" class="nav-link" data-scroll-target="#reference"><span class="header-section-number">5</span> Reference</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃IPO</h1>
  <div class="quarto-categories">
    <div class="quarto-category">paper</div>
    <div class="quarto-category">rl</div>
    <div class="quarto-category">cmdp</div>
  </div>
  </div>

<div>
  <div class="description">
    Interior-point Policy Optimization under Constraints
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 10, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>오늘은 “IPO: Interior-point Policy Optimization under Constraints”라는 논문에 대해서 리뷰해보려고 합니다. 흔히 강화학습(Reinforcement Learning)을 처음 개념을 공부하고 나면, 강화학습의 문제를 MDP(Markov Decision Process)로 정의한다는 것을 떠올릴 수 있습니다. 이때 강화학습의 핵심인 Reward, 즉 보상을 잘 설정해주어야 Agent가 원하는 방향대로 학습을 하게 됩니다. 보상은 Agent가 해야하는 행동 양식의 (+)가 되는 방향을 나타내는 지 표이며 우리가 원하는 행동을 Encourage(장려)하는 역할을 하게 됩니다.</p>
<p>이번 논문에서는 기본적인 강화학습의 MDP가 아닌 <strong>Constraint</strong>라는 개념을 넣어서 생각을 해보려고 합니다. Constraint(제약)은 가장 단순하게는 <code>-Reward</code> 라고 생각해볼 수 도 있습니다. 우리가 Agent가 하지 않았으면 하는 행동을 정의함으로써 negative reward를 준다고 볼 수 있는 것이죠. (마치 Gradient Ascent가 Gradient Discent의 반대로 생각해볼 수 있듯이요.) 따라서 Reward와 Constraint는 서로 (+)/(-) 부호적인 성격이 다르지만 Agent에게 학습의 방향을 제시하는 신호라는 측면에서는 공통점을 가지고 있습니다.</p>
<p>조금 더 Constraint에 대해서 자세히 살펴보겠습니다. Constraint는 제약이 발생되는 시점에 따라 2가지로 나누어서 생각해 볼 수 있습니다.</p>
<center>
<img src="../../images/2024-11-10-ipo/1-1731239276308-2.png" alt="22" width="100%">
<figcaption>
Constraints
</figcaption>
</center>
<p>우선, <code>instantaneous constraint</code>는 뜻에서도 알 수 있듯이 일시적으로 constraint를 주는 것을 말합니다. 강화학습에서 Agent가 action을 하게 되는 timestep 마다 제약 상황인지를 판단하여 constraint를 주는 것을 말합니다. 이는 기본적인 강화학습 개념에서 매 timestep마다 reward를 주는 상황과 같습니다. 예를 들어 로봇팔(Manipulator)을 제어하는 상황을 생각해보면, Agent는 적절한 움직임을 위해 로봇팔을 구성하는 모터들을 잘 구동하여 원하는 모션을 만들어야 합니다. 이때 로봇이 움직이는 모든 매 순간마다 각 모터들(joint)이 가동범위에 있어야 하고 과한 토크가 가해지지 않도록 해야 합니다. 이러한 제약 상황들은 매 순간 판단해서 해당 범위들을 넘지 않는 action을 선택하도록 학습해야 하므로 <code>instantaneous constraint</code>의 예로 볼 수 있습니다.</p>
<p>다음으로 <code>cumulative constraint</code>는 Agent가 학습하는 하나의 Episode 내에서 누적해서 나온 값으로 판단하여 제약상황을 판단하는 것을 말합니다. 이때 누적되는 시간은 하나의 Episode가 시작해서 끝날 때까지일 수도 있고 아니면 5 timesteps 동안이라는 특정 timestep 수를 지정하여 계산할 수 있습니다. 로봇팔의 예시로 살펴보자면, 로봇이 펜을 잡는 모션을 할 때까지 100 timestep이 걸렸는데 매 timestep 마다 지연(latency)가 발생하여 이를 제약하고자 합니다. 이러한 상황에서 <strong>100 timestep동안</strong>의 average latency를 구해서 특정 latency를 넘지 못하도록 constraint를 줄 수 있습니다. 이러한 예시처럼 특정 구간 동안의 값을 통해서 constraint를 주는 것을 <code>cumulative constraint</code>라고 합니다. 이번 IPO 논문에서는 두번째로 소개드린 <code>cumulative constraint</code>에 초점을 맞춰 개발된 알고리즘을 소개하고 있습니다.</p>
<section id="constrained-markov-decision-processcmdp" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="constrained-markov-decision-processcmdp"><span class="header-section-number">1.1</span> Constrained Markov Decision Process(CMDP)</h2>
<p>앞서 설명드린 <code>Constraint</code>가 MDP에 추가된 것을 <code>Constrained Markov Decision Process(CMDP)</code>라고 합니다. CMDP에서는 Reward와 같이 현재 State에서 Action을 취하고 다음 State에 도달했을 때 얻게 되므로 아래 사진에서와 같이 Space가 정의되게 됩니다.</p>
<p>Constraint는 <span class="math inline">(s_n, a_n, s_{n+1})</span>과 같은 transition tuple로 계산되게 되며, cumulative constraint는 일정 timestep, 즉 transition이 n(서수:t)개 모여서 계산되게 됩니다. 이때 Constraint도 여러 종류가 있을 수 있으므로 constraint의 가짓 수는 m(서수:i)으로 나타낼 수 있습니다. Constraint는 more than better인 reward와 다르게 제약되는 상황을 정의하게 되는 constraint limit이 있게 되고 이를 <span class="math inline">\epsilon_i</span>로 나타내게 됩니다.</p>
<center>
<img src="../../images/2024-11-10-ipo/4.png" alt="22" width="100%">
<figcaption>
Constraint Space and Constraint Limit
</figcaption>
</center>
<p>Constraint의 Expectation은 다음과 같이 정의가 되며 2가지의 constraint 계산방법이 있습니다. 첫번째로는 <code>discounted cumulative constraint</code>로 할인율 <span class="math inline">\gamma</span>를 고려한 constraint들을 하나의 policy가 동작하는 동안 누적합한 값을 말합니다. 두번째로는 일정 timestep <span class="math inline">T</span>동안 계산한 constraint들의 평균을 말하는 것으로 <code>mean values constraint</code>가 있습니다. 이 2가지 종류의 지표에 대해서 후에 실험에서 다룰 예정이며 CMDP의 목표를 정리해보면, 기존에 <span class="math inline">J_R</span>만을 Maximization했던 강화학습 문제가 <span class="math inline">J_{C_i}</span>를 고려해야 한다는 것이 추가 되었다는 것을 알 수 있습니다.</p>
<center>
<img src="../../images/2024-11-10-ipo/5.png" alt="22" width="100%">
<figcaption>
Constraint Expectation
</figcaption>
</center>
<p>기존의 Constraint가 있는 최적화 문제는 <strong>Lagrangian Relaxation Method</strong>를 통해서 해결했었습니다. 라그랑지안 승수법이라고도 불리는 해당 방법은 기존의 최적화 식 <span class="math inline">f(x)</span>에 constraint <span class="math inline">g_i(x)</span>가 추가된 최적화 문제를 Lagrange Multipilers를 곱하여 기존 최적화 함수 목적식에 더하여서 제약 조건을 푸는 방법입니다.</p>
<center>
<img src="../../images/2024-11-10-ipo/2.png" alt="22" width="100%">
<figcaption>
Lagrangian relaxation method
</figcaption>
</center>
<center>
<img src="../../images/2024-11-10-ipo/3.png" alt="22" width="100%">
</center>
<p>라그랑지안 승수법은 가장 심플하게 제약 조건들을 메인 최적화식에 녹여내어 풀어내는 방식으로, CMDP 문제들도 해당 방법을 통해 해결하는 것이 통상적인 방법이었지만 라그랑지안 승수법은 정책이 수렴할 때 제약 조건이 만족되지만, 이 접근법은 Lagrange multiplier의 초기값과 학습률에 민감하고 학습 과정에서 얻은 정책이 항상 제약 조건을 일관되게 만족시키지는 않는다는 한계점이 있습니다.</p>
</section>
<section id="policy-gradient-methods" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="policy-gradient-methods"><span class="header-section-number">1.2</span> Policy Gradient Methods</h2>
<p>앞 부분에서 살펴본 것과 같이 CMDP Goal은 Reward 값을 최대화하면서 제약식을 만족하는 최적의 policy를 찾는 것이라고 할 수 있습니다.</p>
<center>
<img src="../../images/2024-11-10-ipo/6.png" alt="22" width="100%">
<figcaption>
CMDP Goal
</figcaption>
</center>
<p>먼저 제약조건을 잠시 뒤로 두고, 본래 기본적인 강화학습의 목적식인 Reward Maximization은 어떻게 할까요? Policy Gradient는 강화학습의 한 계열로 최적의 policy, 즉 가장 Reward를 많이 받을 수 있는 policy를 찾기 위해 아래와 같은 목적식의 gradient를 계산하게 됩니다. 이때 최적의 policy를 찾기 위해서 <span class="math inline">\theta</span>는 위에서 구한 gradient 값을 기반으로 아래와 같이 업데이트하게 됩니다.</p>
<center>
<img src="../../images/2024-11-10-ipo/7.png" alt="22" width="100%">
<figcaption>
Policy Gradient Methods
</figcaption>
</center>
<p><strong>Trust Region Policy Optimization(TRPO)</strong>라는 알고리즘이 PG계열에서 대표적으로 사용되는 알고리즘이며, 최적이 policy를 찾기 위해 surrogate function을 이용하고 policy가 업데이트 되는 step size를 제한하기 위해 KL divergence를 사용합니다. TRPO의 최적화 식은 아래와 같이 표현할 수 있습니다.</p>
<center>
<img src="../../images/2024-11-10-ipo/8.png" alt="22" width="100%">
<figcaption>
TRPO VS PPO
</figcaption>
</center>
<p>하지만 TRPO는 <a href="https://en.wikipedia.org/wiki/Conjugate_gradient_method">conjugate gradient optimization</a>으로 풀리는 2차 미분 최적화를 사용하기 때문에 계산 cost가 큽니다. 따라서 TRPO를 실용적으로 사용할 수 있게한 <strong>Proximal Policy Optimization (PPO)</strong> 알고리즘이 제안되었습니다. PPO의 최적화 식은 TRPO에서 문제였던 2차미분을 1차 미분 surrogate function으로 대체할 수 있었으며 계산복잡성을 줄일 수 있었습니다.</p>
<p>IPO는 이러한 흐름대로 발전해온 <strong>PPO 알고리즘의 최적화 식에서 제약식을 추가</strong>하면서 발전하게 됩니다.</p>
</section>
</section>
<section id="method" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Method</h1>
<section id="interior-point-policy-optimization" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="interior-point-policy-optimization"><span class="header-section-number">2.1</span> Interior-point Policy Optimization</h2>
<p>IPO이전에 CPO(Constrained policy optimization)라는 알고리즘이 제안되었었습니다. IPO는 CPO의 단점을 보완하여 제안된 알고리즘으로 볼 수 있으며 아래와 같이 2개 알고리즘을 비교해볼 수 있습니다.</p>
<center>
<img src="../../images/2024-11-10-ipo/9.png" alt="22" width="100%">
<figcaption>
CPO VS IPO
</figcaption>
</center>
<p>우선, CPO는 TRPO에서 제약조건을 추가한 목적식을 사용하여 TRPO의 문제이기도 했던 2차 미분 계산이 필요하다는 특성이 있습니다. 따라서 제약조건들을 추가하거나 mean valued constraint와 같은 누적 제약식을 계산하기 까다롭거나 할 수 없다는 문제점을 가지고 있었습니다. 이에 반해, IPO는 PPO에 제약조건을 추가한 목적식을 기반으로 하여 1차 미분만을 하면 된다는 장점을 가지고 있으며, 다양한 제약조건들을 이후에 설명할 핵심 아이디어인 logarithmic barrier function을 이용하여 쉽게 추가할 수 있습니다.</p>
</section>
<section id="logarithmic-barrier-function" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="logarithmic-barrier-function"><span class="header-section-number">2.2</span> Logarithmic Barrier Function</h2>
<p>우선 IPO의 문제 정의는 아래와 같이 PPO의 목적식에다가 Constraint를 추가한 것으로 정의할 수 있습니다.</p>
<center>
<img src="../../images/2024-11-10-ipo/10.png" alt="22" width="100%">
<figcaption>
IPO Problem Definition
</figcaption>
</center>
<p>Constraint는 Limit을 고려하여 부등호로 나타낼 수 있으며 이는 <strong>Indicatior Function</strong>에 넣었을때, Constraint를 넘었을 경우 <span class="math inline">-\infin</span>로 나타내고 Constraint를 만족했을 경우 0으로 나타낼 수 있습니다. 하지만 Indicator Function은 불연속적이며 미분 불가능하기 때문에 gradient를 구할 수 없어서 <strong>Logarithmic Barrier Function</strong>을 통해 근사하게 됩니다.</p>
<center>
<img src="../../images/2024-11-10-ipo/11.png" alt="22" width="100%">
<figcaption>
Logarithmic Barrier Function
</figcaption>
</center>
<p>Logarithmic Barrier Function(<span class="math inline">\phi</span>)은 그래프에서와 같이 하이퍼 파라미터인 <span class="math inline">t</span>의 값이 클수록 Indicator Function과 유사하다는 것을 알 수 있습니다. 그래프에서 초록색 t=50일 때의 그래프가 점선의 Indicator Function과 유사한 것 처럼요. 또한 <span class="math inline">\phi</span>는 이분이 가능하기 때문에 gradient를 통해 최적화할 수 있습니다.</p>
<center>
<img src="../../images/2024-11-10-ipo/13.png" alt="22" width="100%">
<figcaption>
IPO 결론(목적식과 수도코드)
</figcaption>
</center>
<p>따라서 IPO의 최적화식은 PPO의 목적식 (<span class="math inline">L^{C L I P}(\theta)</span>)에 Logarithmic Barrier Function(<span class="math inline">\phi</span>)을 이용하여 제약조건을 합치게 된(<span class="math inline">\sum_{i=1}^m \phi\left(\widehat{J}_{C_i}^{\pi_i}\right)</span>) 모습이 됩니다.</p>
</section>
<section id="performance-guarantee-bound" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="performance-guarantee-bound"><span class="header-section-number">2.3</span> Performance Guarantee Bound</h2>
<p>그렇다면 IPO의 성능 보장을 이론적으로 검증해보겠습니다.</p>
<center>
<img src="../../images/2024-11-10-ipo/14-1.png" alt="22" width="90%"> <img src="../../images/2024-11-10-ipo/15-1.png" alt="22" width="100%">
</center>
<p>이러한 수식적인 검증 과정을 거쳐 IPO의 목적식은 일정 한계 내에 있다는 것(Bounded) 되어있다는 결론을 내릴 수 있습니다.</p>
<center>
<img src="../../images/2024-11-10-ipo/16.png" alt="22" width="100%">
</center>
<p>수식적으로 Performance Guarantee Bound를 확인하여 <span class="math inline">t</span>(logarithmic barrier function의 하이퍼파라미터)가 클수록 Indicator function에 대한 더 좋은 근사값을 제공하게 되고 더 높은 reward와 cost를 얻을 수 있다는 것을 확인할 수 있습니다. 하지만 <span class="math inline">t</span>가 클수록 최적화 식이 수렴하는 속도는 느려진다는 단점이 있습니다. 또한 수식으로 확인한 단조성(monotonicity)을 이용하여, 수렴 속도와 최적화 성능 사이의 균형을 맞출 수 있는 적절한 <span class="math inline">t</span> 값을 찾기 위해 이진 탐색 알고리즘(binary search)을 사용할 수 있다는 사실도 확인할 수 있습니다.</p>
</section>
</section>
<section id="experiment" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Experiment</h1>
<p>실험을 통해 확인할 수 있는 IPO(Interior Point Optimization)의 주요 장점은 다음과 같습니다:</p>
<ul>
<li><strong>할인 누적 제약(discounted cumulative constraints)</strong>과 <strong>평균 값 제약(mean valued constraints)</strong>을 포함한 보다 일반적인 형태의 누적 제약을 처리할 수 있습니다.</li>
<li><strong>하이퍼파라미터 설정이 간단</strong>하고 조정이 용이합니다.</li>
<li><strong>복수의 제약 조건이 있는 최적화 문제</strong>로 쉽게 확장할 수 있습니다.</li>
<li><strong>확률적인(stochastic) 환경에서도 높은 안정성</strong>과 견고함을 보여줍니다.</li>
</ul>
<center>
<img src="../../images/2024-11-10-ipo/1.gif" alt="22" width="100%">
<figcaption>
실험 비교군과 실험 환경
</figcaption>
</center>
<section id="discounted-cumulative-constraints" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="discounted-cumulative-constraints"><span class="header-section-number">3.1</span> Discounted Cumulative Constraints</h2>
<center>
<img src="../../images/2024-11-10-ipo/17.png" alt="22" width="100%">
<figcaption>
Discounted Cumulative Constraints 실험 결과
</figcaption>
</center>
<ul>
<li>IPO VS. CPO
<ul>
<li>IPO
<ul>
<li><strong>최고 성능</strong>을 보여줍니다.</li>
<li>제약 조건이 충족된 이후에도 <strong>더 나은 정책</strong>을 찾기 위해 탐색을 계속합니다.</li>
<li>이로 인해 <strong>더 높은 보상</strong>과 <strong>더 낮은 비용</strong>으로 수렴합니다.</li>
<li><strong>수렴 속도는 느리지만</strong>, 최종 성능은 CPO보다 우수합니다.</li>
</ul></li>
<li>CPO
<ul>
<li><strong>수렴 속도</strong>가 IPO보다 빠릅니다.</li>
<li>제약 조건이 충족되면 <strong>개선 작업을 중단</strong>합니다.</li>
<li>제약 조건을 빠르게 만족시키지만, 그 이후에는 <strong>성능 개선이 멈춥니다</strong>.</li>
<li>따라서 <strong>보상이나 비용 측면에서 IPO만큼의 최적화</strong>를 이루지 못할 가능성이 있습니다.</li>
</ul></li>
</ul></li>
</ul>
<table class="table">
<colgroup>
<col style="width: 26%">
<col style="width: 36%">
<col style="width: 36%">
</colgroup>
<thead>
<tr class="header">
<th>특징</th>
<th>IPO</th>
<th>CPO</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>수렴 속도</strong></td>
<td>느림</td>
<td>빠름</td>
</tr>
<tr class="even">
<td><strong>제약 충족 후 개선</strong></td>
<td>계속 탐색 (더 나은 정책을 찾음)</td>
<td>개선 중단 (제약 조건 충족 시)</td>
</tr>
<tr class="odd">
<td><strong>최종 성능</strong></td>
<td>더 높은 보상과 낮은 비용</td>
<td>제약 조건 만족 후 개선 없음</td>
</tr>
</tbody>
</table>
<ul>
<li>IPO VS. PDO
<ul>
<li>IPO
<ul>
<li><strong>최고 성능</strong>을 보여줍니다.</li>
<li>제약 조건이 충족된 이후에도 <strong>더 나은 정책</strong>을 찾기 위해 탐색을 계속합니다.</li>
<li><strong>안정적인 학습 과정</strong>을 가지며, 성능의 변동이 적습니다.</li>
<li>초기화나 학습률에 <strong>덜 민감</strong>합니다.</li>
</ul></li>
<li>PDO
<ul>
<li>IPO만큼 좋은 정책으로 <strong>수렴 가능</strong>하지만, <strong>훈련 중 성능의 분산(variance)</strong>이 높습니다.</li>
<li>제약 조건 값을 <strong>한계 이하로 낮추는 정책</strong>을 찾을 수 있으나, 그 결과 <strong>보상(reward)</strong>이 가장 낮아질 수 있습니다.</li>
<li><strong>Lagrange multiplier</strong>의 초기값과 <strong>학습률(learning rate)</strong>에 <strong>민감</strong>하게 반응합니다.</li>
<li>초기 설정이 잘못되면, 학습 과정이 불안정해질 수 있습니다.</li>
</ul></li>
</ul></li>
</ul>
<table class="table">
<colgroup>
<col style="width: 30%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>특징</th>
<th>IPO</th>
<th>PDO</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>수렴 성능</strong></td>
<td>최고 성능에 수렴</td>
<td>IPO 수준으로 수렴 가능</td>
</tr>
<tr class="even">
<td><strong>훈련 중 성능 변동</strong></td>
<td>낮음 (안정적)</td>
<td>높음 (변동이 큼)</td>
</tr>
<tr class="odd">
<td><strong>제약 조건 만족도</strong></td>
<td>제약 조건을 충족하며 탐색 지속</td>
<td>제약 조건 값을 한계 이하로 낮춤</td>
</tr>
<tr class="even">
<td><strong>보상 (Reward)</strong></td>
<td>높은 보상</td>
<td>가장 낮은 보상 가능성</td>
</tr>
<tr class="odd">
<td><strong>초기화/학습률 민감도</strong></td>
<td>낮음</td>
<td>높음</td>
</tr>
</tbody>
</table>
<ul>
<li>(optional)CPO vs.&nbsp;PPO / TRPO</li>
</ul>
<table class="table">
<colgroup>
<col style="width: 23%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>특징</th>
<th>CPO</th>
<th>PPO</th>
<th>TRPO</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>제약 조건 처리 여부</strong></td>
<td>제약 조건을 고려함</td>
<td>제약 조건 없음</td>
<td>제약 조건 없음</td>
</tr>
<tr class="even">
<td><strong>보상 (Reward)</strong></td>
<td>높음 (제약 조건 내에서)</td>
<td>가장 높음 (제약 조건 위반 가능성 있음)</td>
<td>높음 (제약 조건을 간접적으로 완화)</td>
</tr>
<tr class="odd">
<td><strong>제약 조건 위반 가능성</strong></td>
<td>낮음</td>
<td>높음</td>
<td>중간 (신뢰 영역으로 일부 완화)</td>
</tr>
<tr class="even">
<td><strong>학습 안정성</strong></td>
<td>높음</td>
<td>높음</td>
<td>매우 높음</td>
</tr>
<tr class="odd">
<td><strong>계산 복잡도</strong></td>
<td>중간</td>
<td>낮음</td>
<td>높음</td>
</tr>
</tbody>
</table>
</section>
<section id="mean-valued-constraints" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="mean-valued-constraints"><span class="header-section-number">3.2</span> Mean Valued Constraints</h2>
<center>
<img src="../../images/2024-11-10-ipo/18.png" alt="22" width="100%">
<figcaption>
Mean Valued Constraints 실험 결과
</figcaption>
</center>
<ul>
<li>IPO VS. PDO
<ul>
<li>IPO
<ul>
<li><strong>일관된 수렴</strong>: 모든 작업(task)에서 <strong>할인 누적 보상(discounted cumulative reward)</strong>이 높은 정책으로 안정적으로 수렴합니다.</li>
<li><strong>제약 조건 만족</strong>: 모든 작업에서 <strong>평균 값 제약(mean valued constraints)</strong>을 지속적으로 만족시킵니다.</li>
<li><strong>안정적인 학습</strong>: 훈련 중 성능의 변동이 적으며, <strong>낮은 분산(variance)</strong>을 보입니다.</li>
</ul></li>
<li>PDO
<ul>
<li><strong>제약 조건 위반 가능성</strong>: 간혹 제약 조건을 <strong>위반하는 정책</strong>으로 수렴할 수 있습니다. (참조: Figure 3b)</li>
<li><strong>훈련 중 높은 분산</strong>: 훈련 과정에서 성능의 변동이 크며, <strong>높은 분산</strong>을 보입니다. (참조: Figure 3d 및 Figure 3f)</li>
<li><strong>높은 보상 가능성</strong>: 때때로 높은 보상을 달성할 수 있지만, 제약 조건을 지키지 못할 위험이 있습니다.</li>
</ul></li>
</ul></li>
</ul>
<table class="table">
<colgroup>
<col style="width: 31%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>특징</th>
<th>IPO</th>
<th>PDO</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>할인 누적 보상</strong></td>
<td>안정적으로 높은 보상에 수렴</td>
<td>높은 보상 가능성이 있으나 불안정</td>
</tr>
<tr class="even">
<td><strong>제약 조건 만족도</strong></td>
<td>항상 제약 조건을 만족함</td>
<td>간혹 제약 조건을 위반</td>
</tr>
<tr class="odd">
<td><strong>훈련 중 성능 변동 (분산)</strong></td>
<td>낮음 (안정적)</td>
<td>높음 (변동이 큼)</td>
</tr>
<tr class="even">
<td><strong>안정성</strong></td>
<td>매우 안정적</td>
<td>초기화와 학습률에 민감</td>
</tr>
</tbody>
</table>
</section>
<section id="constraint-effects" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="constraint-effects"><span class="header-section-number">3.3</span> Constraint Effects</h2>
<p>Point Gather 환경에서 <strong>제약 조건</strong>을 완화하여 임계값을 <strong>1</strong>로 설정한 경우, 각 에이전트는 평균적으로 <strong>최대 1개의 폭탄(bomb)</strong>을 수집할 수 있습니다. Constraint 값을 내려서 완화하게 되면 제약 조건이 <strong>매우 느슨</strong>해져서, 제약 조건이 있는 최적화 문제의 성능이 제약 조건이 없는 경우와 <strong>동일한 수준</strong>으로 나타납니다.</p>
<ul>
<li>CPO
<ul>
<li>CPO는 여전히 비용을 <strong>증가</strong>시켜 제약 임계값(1)에 도달하려고 합니다.</li>
<li>이는 때때로 <strong>랜덤 초기화된 정책보다도 성능이 떨어질 수 있습니다</strong>.</li>
<li>CPO는 항상 비용을 <strong>제약 임계값(1)</strong>까지 밀어 올리려는 경향을 보입니다.</li>
</ul></li>
<li>IPO
<ul>
<li>IPO는 제약 조건이 충족된 이후에도 <strong>비용을 계속 줄여나갑니다</strong>.</li>
<li>이로 인해 더 낮은 비용을 달성하며, <strong>더 나은 최종 성능</strong>을 보여줍니다.</li>
</ul></li>
</ul>
<table class="table">
<colgroup>
<col style="width: 31%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>특징</th>
<th>CPO</th>
<th>IPO</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>제약 조건 만족도</strong></td>
<td>제약 임계값(1)까지 비용 증가</td>
<td>제약 충족 후에도 비용 감소 지속</td>
</tr>
<tr class="even">
<td><strong>최종 비용 수준</strong></td>
<td>약 <strong>1</strong></td>
<td>약 <strong>0.25</strong></td>
</tr>
<tr class="odd">
<td><strong>성능</strong></td>
<td>제약 충족을 우선시하며 성능 저하 가능</td>
<td>제약을 충족하면서도 더 나은 성능</td>
</tr>
</tbody>
</table>
<center>
<img src="../../images/2024-11-10-ipo/19.png" alt="22" width="100%">
</center>
<p>따라서 실험을 통해 다음과 같은 결론을 내릴 수 있습니다.</p>
<ul>
<li><strong>CPO</strong>는 제약을 맞추기 위해 비용을 적극적으로 증가시키지만, 그 결과 성능이 <strong>떨어질 가능성</strong>이 있습니다.</li>
<li><strong>IPO</strong>는 제약을 만족한 이후에도 비용을 줄이며, <strong>더 높은 성능</strong>을 달성할 수 있습니다.</li>
</ul>
</section>
<section id="hyperparameter-tuning" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="hyperparameter-tuning"><span class="header-section-number">3.4</span> Hyperparameter Tuning</h2>
<ul>
<li>IPO vs.&nbsp;PDO
<ul>
<li>IPO
<ul>
<li><strong>하이퍼파라미터 <span class="math inline">t</span>의 튜닝이 용이</strong>합니다.</li>
<li><strong>보상(reward)</strong>과 <strong>비용(cost)</strong>은 하이퍼파라미터 <span class="math inline">t</span>와 <strong>양의 상관 관계</strong>를 가집니다.</li>
<li><span class="math inline">t</span> 값이 커질수록, 보상과 비용이 동시에 증가합니다.</li>
<li><strong>이진 탐색(binary search)</strong>이 가능:</li>
<li><span class="math inline">t</span> 값을 조정하며 성능을 확인할 수 있으며, 이진 탐색을 통해 빠르게 최적의 값을 찾을 수 있습니다.</li>
</ul></li>
<li>PDO
<ul>
<li><strong>초기 Lagrange multiplier (<span class="math inline">\lambda</span>)</strong>와 <strong>학습률(learning rate)</strong>의 설정이 까다롭습니다.</li>
<li>초기 <span class="math inline">\lambda</span> 값이 <strong>0.01에서 0.1</strong> 사이일 때 매우 민감하게 반응합니다.</li>
<li>잘못된 초기화는 학습 과정의 불안정을 초래할 수 있습니다.</li>
<li><strong>학습률(learning rate)</strong>의 변화에도 민감합니다.</li>
<li>학습률이 <strong>0.01에서 0.001</strong>로 작아지면, 정책의 수렴 속도가 <strong>느려집니다</strong>.</li>
<li>하이퍼파라미터 설정에 <strong>많은 시간과 노력이 필요</strong>합니다.</li>
</ul></li>
</ul></li>
</ul>
<table class="table">
<colgroup>
<col style="width: 31%">
<col style="width: 34%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>특징</th>
<th>IPO</th>
<th>PDO</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>하이퍼파라미터 튜닝 용이성</strong></td>
<td>쉬움</td>
<td>어렵고 복잡함</td>
</tr>
<tr class="even">
<td><strong>보상과 비용의 관계</strong></td>
<td><span class="math inline">t</span>와 양의 상관 관계</td>
<td>초기 <span class="math inline">\lambda</span>와 학습률에 민감</td>
</tr>
<tr class="odd">
<td><strong>초기 설정 민감도</strong></td>
<td>낮음</td>
<td>높음</td>
</tr>
<tr class="even">
<td><strong>튜닝 방법</strong></td>
<td>이진 탐색 가능</td>
<td>초기화와 학습률 설정에 많은 노력 필요</td>
</tr>
</tbody>
</table>
<center>
<img src="../../images/2024-11-10-ipo/20.png" alt="22" width="100%">
</center>
<p>따라서 실험을 통해 다음과 같은 결론을 내릴 수 있습니다.</p>
<ul>
<li><strong>IPO</strong>는 하이퍼파라미터 <span class="math inline">t</span>의 튜닝이 쉽고, 보상과 비용이 <span class="math inline">t</span> 값에 따라 예측 가능하게 변화하기 때문에 <strong>안정적인 최적화</strong>가 가능합니다.</li>
<li><strong>PDO</strong>는 초기화와 학습률에 민감하여 <strong>튜닝이 까다롭고 학습 과정이 불안정</strong>할 수 있습니다. 특히 초기 <span class="math inline">\lambda</span>와 학습률 설정이 중요한 역할을 합니다.</li>
</ul>
</section>
<section id="multiple-constraints" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="multiple-constraints"><span class="header-section-number">3.5</span> Multiple Constraints</h2>
<p>IPO (Interior Point Optimization)는 제약 조건을 다룰 때 <strong>유연하고 확장 가능</strong>한 방식으로 설계되어 있습니다. 특히, <strong>logarithmic barrier function</strong>을 사용하여 제약 조건을 쉽게 추가할 수 있습니다. IPO에서는 새로운 제약 조건이 필요할 때, 기존 최적화 함수에 <strong>로그 배리어 항</strong>을 추가하기만 하면 됩니다. 이 방식은 <strong>CPO보다 간단</strong>하게 제약 조건을 추가할 수 있는 이점이 있습니다. <strong>IPO</strong>는 logarithmic barrier function을 사용하여 제약 조건을 쉽게 추가할 수 있어, <strong>확장성과 유연성</strong> 측면에서 CPO보다 유리합니다.</p>
<ul>
<li>CPO와의 비교
<ul>
<li>CPO (Constrained Policy Optimization)는 제약 조건을 직접적으로 다루지만, 새로운 제약 조건이 추가될 때마다 <strong>문제의 복잡도</strong>가 증가하고, 튜닝이 어려워질 수 있습니다.</li>
<li>반면, IPO는 <strong>logarithmic barrier function</strong>을 사용하기 때문에, 제약 조건을 쉽게 확장할 수 있으며 <strong>구현과 튜닝이 더 간단</strong>합니다.</li>
</ul></li>
<li>Point Gather 실험에서의 제약 조건 확장
<ul>
<li>Point Gather 환경에서는 에이전트가 보상을 얻는 과정에서 다양한 제약 조건을 추가할 수 있습니다.</li>
<li>실험에서 <strong>다양한 제약 조건</strong>을 추가하기 위해, <strong>새로운 타입의 ball (제약 조건에 해당하는 오브젝트)</strong>을 도입할 수 있습니다.</li>
<li>예를 들어, 기존의 bomb 외에 새로운 제약 조건을 나타내는 여러 종류의 ball을 추가하여, 에이전트가 이들을 <strong>피하면서도 최대한 많은 보상을 얻는</strong> 정책을 학습할 수 있습니다.</li>
<li>이를 통해 <strong>다중 제약 조건 환경</strong>에서도 IPO의 성능을 평가할 수 있습니다.</li>
</ul></li>
</ul>
<center>
<img src="../../images/2024-11-10-ipo/21.png" alt="22" width="100%">
</center>
<table class="table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>특징</th>
<th>IPO</th>
<th>CPO</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>제약 조건 추가 용이성</strong></td>
<td>로그 배리어 항 추가만으로 가능</td>
<td>복잡한 추가 작업과 튜닝 필요</td>
</tr>
<tr class="even">
<td><strong>확장성</strong></td>
<td>간단하게 여러 제약 조건 확장 가능</td>
<td>제약 조건 추가 시 복잡도 증가</td>
</tr>
<tr class="odd">
<td><strong>Point Gather 실험 적용</strong></td>
<td>다양한 제약 조건 ball 추가 가능</td>
<td>제약 조건 추가 시 성능 저하 위험</td>
</tr>
</tbody>
</table>
</section>
<section id="stochastic-environment-effects" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="stochastic-environment-effects"><span class="header-section-number">3.6</span> Stochastic Environment Effects</h2>
<p>실세계 환경에서의 불확실성 및 랜덤 노이즈 추가 실험 <strong>실제 환경</strong>에서는 항상 <strong>불확실성(uncertainty)</strong>이 존재합니다. 에이전트의 행동 결과는 종종 <strong>랜덤 노이즈(random noise)</strong>에 의해 영향을 받습니다. 예를 들어, 바람, 센서 오류, 마찰 등의 예기치 못한 요인들이 시스템에 영향을 줄 수 있습니다. 해당 실험에서 행동(action)은 <strong>속도(velocity)</strong>와 <strong>진행 방향(heading)</strong>의 벡터로 정의되며, 값의 범위는 <strong>-1에서 1 사이</strong>입니다. <span class="math inline">(-1, 1)</span> 범위의 벡터는 에이전트가 움직일 방향과 속도를 나타냅니다.</p>
<p>실험에서는 <strong>평균 0</strong>의 랜덤 노이즈를 행동(action)에 추가하여 환경의 불확실성을 모사했습니다.</p>
<ul>
<li>노이즈의 분산(variance)은 세 가지 값으로 설정되었습니다:
<ul>
<li><span class="math inline">\sigma^2 = 0.2</span></li>
<li><span class="math inline">\sigma^2 = 0.5</span></li>
<li><span class="math inline">\sigma^2 = 1.0</span></li>
</ul></li>
</ul>
<center>
<img src="../../images/2024-11-10-ipo/22.png" alt="22" width="100%">
</center>
<ul>
<li><strong><span class="math inline">\sigma^2 = 0.5</span></strong>일 때도 학습이 <strong>성공적으로 수렴</strong>하는 것을 확인할 수 있었습니다.
<ul>
<li>이는 에이전트가 일정 수준의 환경 불확실성에서도 <strong>안정적으로 정책을 학습할 수 있음</strong>을 보여줍니다.</li>
</ul></li>
<li><strong><span class="math inline">\sigma^2 = 1.0</span></strong>의 경우, 노이즈가 커져 학습이 불안정해질 가능성이 있으며, 이는 추가 실험에서 확인할 필요가 있습니다.</li>
<li><strong>실제 환경의 불확실성</strong>을 반영하기 위해 랜덤 노이즈를 추가하는 것은 강화 학습의 <strong>강건성(robustness)</strong> 평가에 중요한 역할을 합니다.</li>
<li>적절한 수준의 노이즈(<span class="math inline">\sigma^2 = 0.5</span>)에서는 학습이 안정적으로 진행되었으며, 에이전트가 다양한 환경 변동에도 잘 적응할 수 있음을 확인했습니다.</li>
</ul>
</section>
</section>
<section id="conclusion" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Conclusion</h1>
<p>이번 포스팅에서는 <strong>제약조건을 포함한 MDP</strong>의 문제는 어떻게 정의할 수 있고 어떤 방식으로 최적화식을 디자인하여 풀 수 있는지 살펴보며 <strong>IPO 알고리즘</strong>에 대해 알아보았습니다. 강화학습에서 학습의 방향성을 Reward로만 디자인 하게될 경우의 문제들을 Constraint로 바꾸어서 디자인하게 된다면 많은 이점이 있을 수 있고, CMDP를 다룬 다른 알고리즘들에 비해 심플하면서도 사용하기 편한 아이디어라는 생각이 들었습니다.</p>
</section>
<section id="reference" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Reference</h1>
<ul>
<li><a href="https://arxiv.org/abs/1910.09615">Original Paper: IPO</a></li>
<li><a href="https://www.researchgate.net/publication/259246799_A_Near-Optimal_Distributed_QoS_Constrained_Routing_Algorithm_for_Multichannel_Wireless_Sensor_Networks">Lagrangian relaxation method Diagram</a></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>