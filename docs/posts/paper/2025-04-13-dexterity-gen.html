<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-04-13">
<meta name="description" content="Foundation Controller for Unprecedented Dexterity">

<title>Curieux.JY - 📃Dexterity-Gen 리뷰</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review"><span class="header-section-number">1</span> Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review"><span class="header-section-number">2</span> Detail Review</a>
  <ul class="collapse">
  <li><a href="#배경-dexterous-manipulation과-foundation-model-접근" id="toc-배경-dexterous-manipulation과-foundation-model-접근" class="nav-link" data-scroll-target="#배경-dexterous-manipulation과-foundation-model-접근"><span class="header-section-number">2.1</span> 배경: Dexterous Manipulation과 Foundation Model 접근</a></li>
  <li><a href="#dexteritygen의-주요-아이디어-rl로-학습한-skill-prior-teleop-프롬프트" id="toc-dexteritygen의-주요-아이디어-rl로-학습한-skill-prior-teleop-프롬프트" class="nav-link" data-scroll-target="#dexteritygen의-주요-아이디어-rl로-학습한-skill-prior-teleop-프롬프트"><span class="header-section-number">2.2</span> DexterityGen의 주요 아이디어: RL로 학습한 Skill Prior + Teleop 프롬프트</a></li>
  <li><a href="#dexgen의-모델-구성-autoregressive-생성-정책과-goalstate-network-구조" id="toc-dexgen의-모델-구성-autoregressive-생성-정책과-goalstate-network-구조" class="nav-link" data-scroll-target="#dexgen의-모델-구성-autoregressive-생성-정책과-goalstate-network-구조"><span class="header-section-number">2.3</span> DexGen의 모델 구성: Autoregressive 생성 정책과 Goal/State Network 구조</a></li>
  <li><a href="#실험-결과-안정성-10100배-향상-인간-로봇-협업을-통한-전례없는-성과" id="toc-실험-결과-안정성-10100배-향상-인간-로봇-협업을-통한-전례없는-성과" class="nav-link" data-scroll-target="#실험-결과-안정성-10100배-향상-인간-로봇-협업을-통한-전례없는-성과"><span class="header-section-number">2.4</span> 실험 결과: 안정성 10~100배 향상, 인간-로봇 협업을 통한 전례없는 성과</a></li>
  <li><a href="#결론-및-전망" id="toc-결론-및-전망" class="nav-link" data-scroll-target="#결론-및-전망"><span class="header-section-number">2.5</span> 결론 및 전망</a></li>
  </ul></li>
  <li><a href="#reference" id="toc-reference" class="nav-link" data-scroll-target="#reference"><span class="header-section-number">3</span> Reference</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃Dexterity-Gen 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">paper</div>
    <div class="quarto-category">rl</div>
    <div class="quarto-category">hand</div>
  </div>
  </div>

<div>
  <div class="description">
    Foundation Controller for Unprecedented Dexterity
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 13, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<center>
<img src="../../images/2025-04-13-dexterity-gen/1.png" width="100%">
</center>
<p>이번 포스팅에서 리뷰할 논문은 <a href="https://arxiv.org/pdf/2502.04307"><strong>DEXTERITYGEN: Foundation Controller for Unprecedented Dexterity</strong></a> 입니다.</p>
<ol type="1">
<li>🤖 다양한 작업에서 로봇 손의 안전하고 정교한 동작 생성.</li>
<li>📊 인간의 텔레오퍼레이션을 통해 로봇의 고수준 정책을 보조.</li>
<li>🛠️ 시뮬레이션 데이터셋을 통해 대규모 운동 기본(primitive) 요소를 학습.</li>
</ol>
<section id="brief-review" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Brief Review</h1>
<p>이 논문은 복잡한 손 조작 기술을 로봇에게 가르치는 데 있어 기존 방식들의 한계를 극복하고자 <strong>DexterityGen (DexGen)</strong>이라는 새로운 프레임워크를 제안합니다. DexGen은 강화 학습(RL)을 통해 대규모의 손 조작 동작 primitive를 사전 학습하고, 이를 바탕으로 튼튼한(robust) foundational controller를 학습합니다. 실제 환경에서는 인간의 텔레오퍼레이션(teleoperation)과 같은 외부 정책을 통해 DexGen을 프롬프트하여 고도의 손재주를 발휘할 수 있도록 합니다.</p>
<p><strong>핵심 방법론:</strong></p>
<p>DexGen의 핵심은 RL을 통해 생성된 다양한 시뮬레이션 데이터셋을 활용하여 행동 생성 모델을 사전 학습하는 것입니다. 이는 coarse한 동작 명령을 안전하고 유용한 로봇 동작으로 변환하는 것을 목표로 합니다.</p>
<ol type="1">
<li><p><strong>데이터셋 생성:</strong> “Anygrasp-to-Anygrasp”라는 태스크를 중심으로 RL을 통해 다양한 물체 조작 궤적을 수집합니다. 이 태스크는 물체를 임의의 자세로 이동시키는 것을 목표로 하며, 다양한 손목 자세, 움직임, 도메인 랜덤화를 통해 데이터셋의 다양성을 확보합니다. RL 학습 과정에서 목표를 근접한 위치로 설정하여 학습의 효율성을 높입니다. 데이터셋은 목표 물체 자세와 손가락 관절 위치를 포함하는 goal-related reward, 스타일 관련 reward, 그리고 regularization term으로 구성된 보상 함수를 사용하여 생성됩니다.</p>
<ul>
<li>수식 표현:
<ul>
<li>전체 보상 함수: <span class="math inline">r = w_{goal}r_{goal} + w_{style}r_{style} + w_{reg}r_{reg}</span></li>
<li>Goal-related reward: <span class="math inline">r_{goal} = exp(-\alpha_{pos}\|p_{obj} - p_{obj}^{target}\|^2 - \alpha_{orn}d(R_{obj}, R_{obj}^{target})) - \alpha_{hand}\|q - q^{target}\|^2 + \alpha_{bonus}\mathbb{1}(goal\ achieved)</span></li>
<li>Regularization term: <span class="math inline">r_{reg} = -\alpha_{work}\|\dot{q}^T\|\|\tau\| - \alpha_{action}\|a\|^2 - \alpha_{\tau}\|\tau\|^2</span></li>
<li>Style reward: <span class="math inline">r_{style} = \sum_{i} \alpha_{i} \|\dot{x}_i^{tip}\|</span></li>
</ul></li>
</ul></li>
<li><p><strong>모델 아키텍처:</strong> DexGen은 두 개의 모듈로 구성됩니다.</p>
<ul>
<li><strong>Diffusion Model:</strong> 로봇의 현재 상태가 주어졌을 때, 로봇 손가락 핵심점(keypoint)의 움직임 분포를 모델링합니다. 이는 UNet 기반의 모델을 사용하며, FiLM-conditioning을 통해 task/mode 정보를 주입합니다.</li>
<li><strong>Inverse Dynamics Model:</strong> 핵심점 움직임을 실행 가능한 로봇 동작(관절 목표 위치)으로 변환합니다. 이는 residual multilayer perceptron (MLP)으로 구현됩니다.</li>
</ul></li>
<li><p><strong>추론 (Inference):</strong> 학습된 분포에서 안전한 동작을 샘플링하는 동시에, 입력된 참조 동작을 최대한 보존하는 방향으로 동작을 생성합니다. 이를 위해 gradient guidance를 diffusion sampling 과정에 적용하여 motion conditioning을 수행합니다. 이는 다음 수식으로 표현됩니다.</p>
<ul>
<li><span class="math inline">\Delta x \sim p_\theta(\Delta x|o) \exp(-Dist(\Delta x, \Delta x^{input}))</span></li>
<li><span class="math inline">Dist(\Delta x, \Delta x^{input}) = \sum_{i=1}^T \|\Delta x_i - \Delta x^{input}\|^2</span></li>
</ul></li>
</ol>
<p><strong>결과:</strong></p>
<p>시뮬레이션 및 실제 환경 실험을 통해 DexGen의 효과를 검증합니다. 시뮬레이션에서는 DexGen이 suboptimal한 정책의 견고성(robustness)과 성공률을 크게 향상시키는 것을 보여줍니다. 실제 환경에서는 인간 텔레오퍼레이터를 통해 DexGen을 활용하여 다양한 물체 재정렬, 주사기 사용, 드라이버 사용과 같은 복잡한 손 조작 기술을 성공적으로 수행하는 것을 입증합니다. 특히, 물체를 떨어뜨리지 않고 유지하는 시간이 10배에서 100배까지 향상되는 결과를 보여줍니다.</p>
<p><strong>전반적으로, DexGen은 coarse한 명령을 섬세한 손 동작으로 변환하여 로봇의 손재주를 크게 향상시키는 foundational controller로서의 가능성을 보여줍니다.</strong></p>
</section>
<section id="detail-review" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Detail Review</h1>
<blockquote class="blockquote">
<p>DEXTERITYGEN: 전례 없는 기교를 위한 <strong>Foundation Controller</strong> 리뷰</p>
</blockquote>
<section id="배경-dexterous-manipulation과-foundation-model-접근" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="배경-dexterous-manipulation과-foundation-model-접근"><span class="header-section-number">2.1</span> 배경: Dexterous Manipulation과 Foundation Model 접근</h2>
<p><strong>Dexterous manipulation (정교한 물체 조작)</strong>는 인간 손과 유사한 다자유도 로봇 손을 이용해 물체를 섬세하고 능숙하게 다루는 문제입니다. 이러한 dexterous manipulation 기술을 로봇에게 가르치는 일은 매우 어렵습니다. 기존 접근법은 크게 두 갈래로 나뉩니다. - 첫째, <strong>인간 원격조작 (teleoperation)</strong>을 통한 <strong>모방학습</strong> 방법입니다. 사람 운영자가 VR 장갑 등으로 로봇 손을 원격 제어하며 시연 데이터를 모아 정책(policy)을 학습시키는 방식이지만, <strong>촉각 피드백 부재</strong>와 <strong>다른 구조의 로봇 손 조작의 난해함</strong> 때문에 <strong>안전하고 정교한 동작</strong>을 인간이 만들어내기가 어렵습니다. - 둘째, <strong>시뮬레이션 강화학습 (sim-to-real RL)</strong> 방법으로, 가상 환경에서 강화학습으로 정책을 훈련한 후 실제 로봇에 이전(sim-to-real)하는 접근입니다. 하지만 이 방법도 <strong>시뮬레이션-현실 간 도메인 차이</strong>로 인한 성능 저하와, 복잡한 작업에 필요한 <strong>특수한 보상함수 설계</strong> 등의 문제가 있습니다.</p>
<p>이러한 한계 때문에, 최근 로봇 제어 분야에서는 <strong>대규모 사전학습 모델 (foundation model)</strong> 개념을 도입한 새로운 접근들이 주목받고 있습니다. <strong>DeepMind의 Gato</strong> 모델이 대표적인 예로, 하나의 거대 <strong>Transformer</strong> 네트워크로 <strong>604가지에 달하는 다양한 과제</strong>를 학습하여 <strong>멀티모달</strong> 정책을 구현했습니다. Gato는 동일한 파라미터로 아타리 게임 플레이, 이미지 자막 생성, 대화, <strong>로봇 팔로 블록 쌓기</strong> 등의 서로 다른 작업을 모두 수행해 <strong>“Generalist Agent”</strong>의 가능성을 보였지만, 주로 비교적 단순한 <strong>平行 그리퍼 로봇 (parallel gripper)</strong>의 조작 등에 한정되어 <strong>정교한 손동작</strong>까지 보여주지는 못했습니다.</p>
<p>한편, <strong>Google의 Robotics Transformer (RT-1)</strong>은 13대의 로봇을 통해 <strong>17개월간 130k 에피소드의 실세계 데이터</strong>를 수집하여 <strong>700가지 이상의 작업</strong>을 학습한 거대 비전-모터 정책입니다 (<a href="https://robotics-transformer1.github.io/#:~:text=To%20test%20RT,contain%20over%20700%20tasks">Robotics Transformer: RT-1</a>). RT-1은 카메라 영상과 작업 지시어를 입력 받아 <strong>End-to-End</strong>로 로봇 제어 명령을 출력하는 Transformer로, 새로운 물체나 환경에서도 일반화된 성능을 보였습니다. 이후 버전인 <strong>RT-2</strong>에서는 거대 비전-언어 모델을 접목하여 시각적 개념과 언어지식을 활용하는 방향으로 확장되었지만, 이들 역시 <strong>집게(gripper)</strong> 형태 로봇 조작에 초점을 맞춰 <strong>다손가락 섬세 조작</strong>에는 직접 적용하기 어렵습니다.</p>
<p>또 다른 흐름으로 <strong>Diffusion Policy</strong> 방법론이 있습니다. 이는 로봇의 정책을 <strong>확률적 생성 모델</strong>로 간주하여 <strong>확산 모델 (diffusion model)</strong>로 구현한 접근입니다. 예를 들어 <strong>Diffusion Policy</strong>는 로봇의 <strong>시각-운동 (visuomotor) 정책</strong>을 조건부 확산 과정으로 표현하여 <strong>단일 정책이 다모달 행동 분포를 학습</strong>하도록 합니다. 확산 모델은 <strong>멀티모달 행동</strong> 분포를 효과적으로 캡처하여, 시뮬레이션 로봇 조작 벤치마크에서 LSTM 기반 정책이나 강화학습 기반 방법들을 능가하는 성능을 보였습니다. 특히, <strong>10Hz의 저빈도 제어 출력</strong>을 생성하고, 이미지 지연 등의 <strong>latency 보정</strong>을 위해 한 번에 여러 스텝의 액션을 예측하는 <strong>receding horizon</strong> 특성을 활용하는 등, <strong>다단계 행동 생성(autoregressive)</strong>과 <strong>멀티모달 의사결정</strong>에 강점을 보였습니다. 하지만 기존 diffusion policy 연구들은 주로 단순한 팔-그리퍼 조작이나 짧은 수평 이동 등의 작업에 집중되어 있어, <strong>고차원 다지 관절</strong>을 가진 <strong>로봇 손의 세밀한 제어</strong>에 직접 적용된 사례는 드물었습니다.</p>
<p>요약하면, 대규모 <strong>Foundation Model</strong> 기반 접근(Gato, RT 계열)과 <strong>Diffusion</strong> 기반 정책 등이 로봇 제어에 도입되어왔지만, <strong>다자유도 로봇 손의 섬세한 조작</strong>이라는 영역에서는 <strong>안전성</strong>과 <strong>정밀 제어</strong> 측면의 난제가 여전히 남아 있습니다. <strong>DexterityGen (DexGen)</strong>은 이러한 격차를 해소하기 위해 고안된 새로운 <strong>foundation 컨트롤러</strong>로, 인간 원격조작과 강화학습의 장점을 결합해 전례없는 수준의 기교있는 로봇 손동작을 달성했습니다.</p>
</section>
<section id="dexteritygen의-주요-아이디어-rl로-학습한-skill-prior-teleop-프롬프트" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="dexteritygen의-주요-아이디어-rl로-학습한-skill-prior-teleop-프롬프트"><span class="header-section-number">2.2</span> DexterityGen의 주요 아이디어: RL로 학습한 Skill Prior + Teleop 프롬프트</h2>
<p>DexterityGen(이하 DexGen)은 “Foundation Controller”, 즉 범용적인 저수준 제어 모듈을 지향합니다. 핵심 아이디어는 강화학습(RL)으로 다양한 low-level 손동작 스킬을 미리 학습해 <strong>스킬 프라이어(prior)</strong>를 만들고, 이를 기반으로 <strong>인간 원격조작 명령</strong>을 <strong>안전하고 세밀한 동작으로 변환</strong>시키는 <strong>생성형 정책</strong>을 구축하는 것입니다. 저자들은 <code>“RL은 저수준 모션 프리미티브를 배우는 데 효과적이고, 인간은 고수준의 거친 동작 명령을 제공하는 데 뛰어나다”</code>는 통찰을 강조하며, 두 접근의 결합이 최적 해법임을 주장합니다. 실제로 DexGen은 시뮬레이션에서 RL로 방대한 다중 작업 데이터셋을 생성하여 정책을 사전 학습하고(Training 단계), 실제 로봇 제어 시에는 인간 teleoperator의 조작 신호를 프롬프트로 받아 세밀한 액션을 생성합니다(Inference 단계). 이렇게 함으로써, <strong>사람이 직접 조작할 때 발생하는 위험하거나 불안정한 동작을 모델이 학습된 안전 동작 분포 내의 행동으로 투영(projection)하여 실행</strong>하게 됩니다.</p>
<ul>
<li>DexGen의 트레이닝/인퍼런스 개요.</li>
</ul>
<p><strong>왼쪽</strong>: 시뮬레이션에서 다중 작업 데이터셋을 모아 DexGen <strong>생성모델</strong>을 학습한다. 모델은 주어진 상태에서 다양한 정교한 동작들을 확률적으로 생성하도록 훈련된다 (분포 예시: 회전, 병진 등).</p>
<p><strong>오른쪽</strong>: 실제 인퍼런스 시, 인간 <strong>Teleop</strong> 또는 상위 정책이 낸 거친 <strong>Motion</strong> 명령이 DexGen의 분포 상에 투영되어 안전한 행동을 산출한다. 이 과정을 통해 고차원 핸드의 복잡한 조작을 안정적으로 수행할 수 있다.*</p>
<p><strong>데이터 수집 및 사전학습:</strong> DexGen의 학습을 위해 <strong>대규모 시뮬레이션 데이터셋</strong>인 <strong>“Anygrasp-to-Anygrasp”</strong>를 구축합니다. 이는 다양한 물체를 임의의 그립(grasp) 상태에서 다른 임의의 그립 상태로 옮기는 <strong>범용 조작 과제</strong>로, <strong>다양한 손-물체 상호작용</strong>의 핵심을 포괄하도록 설계되었습니다. 구체적으로, 각 물체에 대해 가능한 모든 잡기 구성을 탐색한 뒤 이를 <strong>초기 상태</strong>와 <strong>목표 상태</strong>로 설정하고, RL 에이전트가 한 그립에서 다른 그립으로 물체를 옮기도록 학습시킵니다. 학습된 RL 정책을 다수 rollout하여 <strong>손-물체 이동 궤적 데이터</strong>를 대량으로 모읍니다. 저자들은 <strong>100,000개 이상의 고유 그립</strong>을 샘플링하여 데이터 범위를 극대화했고, 추가로 <strong>자유 손가락 운동</strong>이나 <strong>정밀 회전 조작</strong> 등의 과제를 더해 <strong>미세 동작</strong> 데이터도 확보했습니다. 이렇게 모인 <strong>멀티태스크 데이터</strong>는 이후 <strong>생성모델의 학습데이터</strong>로 사용됩니다. 한편, 이러한 접근은 기존 <strong>foundation model</strong>들이 보통 <strong>실세계 시演 데이터</strong>에 의존하는 것과 대조적입니다. DexGen은 <strong>시뮬레이션 데이터로 사전학습</strong>함으로써 방대한 데이터 수집에 필요한 인간 노동을 줄이고, <strong>도메인 랜덤화</strong> 등을 통해 현실 적응력을 확보하고자 했습니다.</p>
</section>
<section id="dexgen의-모델-구성-autoregressive-생성-정책과-goalstate-network-구조" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="dexgen의-모델-구성-autoregressive-생성-정책과-goalstate-network-구조"><span class="header-section-number">2.3</span> DexGen의 모델 구성: Autoregressive 생성 정책과 Goal/State Network 구조</h2>
<p>DexGen의 컨트롤러는 크게 두 모듈로 구성됩니다: <strong>(1) 생성 정책 모듈</strong>과 <strong>(2) 역기구학 모듈</strong>입니다.</p>
<p>첫 번째 <strong>생성 정책</strong>은 <strong>확산 모델 (diffusion model)</strong> 기반으로 구현된 <strong>확률적 정책 생성기</strong>로서, 현재 로봇 <strong>상태(state)</strong>를 입력받아 미래의 손동작 <strong>분포</strong>로부터 <strong>샘플을 생성</strong>합니다.</p>
<p>두 번째 <strong>역기구학(inverse dynamics)</strong> 모듈은, 생성된 <strong>손가락 움직임(motion)</strong>을 실제 로봇의 <strong>구동 명령(action)</strong>으로 변환하는 역할을 합니다. 이때 <strong>기술적인 용어</strong>를 빌리자면, 정책 모듈은 <strong>현재 상태</strong>를 처리하는 부분(이것을 편의상 <strong>StateNet</strong>이라 지칭)과, <strong>외부 목표 동작</strong> 정보를 반영하는 부분(마찬가지로 <strong>GoalNet</strong>이라 지칭)으로 나눠볼 수도 있습니다. DexGen의 구조에서 <strong>StateNet</strong>은 로봇 손의 과거 몇 스텝에 걸친 <strong>프로프리오셉션(proprioception) 상태</strong> 입력을 받아 <strong>내재 상태 표현</strong>으로 인코딩합니다. 한편, <strong>GoalNet</strong>에 해당하는 부분은 명시적인 네트워크 모듈로 존재하는 것은 아니지만, <strong>외부에서 주어지는 목표 동작(Motion Conditioning)</strong>을 생성 과정에 반영하는 <strong>메커니즘</strong>이 도입되어 있습니다. 즉, DexGen은 <strong>인간 조작자가 의도하는 손가락 움직임</strong>을 직접 네트워크 입력으로 취하지 않고, <strong>생성 과정 중에 목표 방향으로 샘플을 유도하는 방식(guidance)</strong>으로 반영합니다. 이러한 <strong>Guided Sampling</strong> 전략을 통해 모델은 학습 시 분포에서 벗어나는 <strong>비안전한 명령</strong>을 걸러내면서도, <strong>사용자 명령의 의도</strong>는 최대한 살린 행동을 생성할 수 있습니다.</p>
<p><strong>Diffusion 기반 Autoregressive Policy:</strong> DexGen의 정책 모듈은 <strong>UNet 기반</strong> 확산 모델로 구현되었으며, 한 번에 <strong>Horizon H</strong>만큼의 <strong>미래 손가락 움직임 오프셋 시퀀스</strong>를 예측합니다. 예컨대 0.1초 간격으로 5스텝 미래 (H=5, 0.5초) 정도의 <strong>손가락 위치 변화</strong>를 예측하도록 학습되고, 제어 주기는 10Hz로 동작합니다. 이는 <strong>autoregressive</strong>하게 정책을 생성하는 것과 유사한데, 매 시간스텝마다 현재 상태를 반영해 <strong>단기 계획</strong>을 출력하고, 실행 후 다시 업데이트된 상태로 다음 계획을 세우는 <strong>receding horizon</strong> 제어 구조를 가집니다. <strong>Mode conditioning</strong> 입력도 함께 제공하여, 특정 작업 모드(예: 드라이버로 나사를 조일 때의 정밀회전 모드)를 모델에 알려줄 수 있습니다. (대부분의 데이터는 “default” 모드로 학습되고, 특별한 경우에만 레이블링된 모드를 사용.) 이 생성 정책은 <strong>확산모델 표준 학습목표</strong>(노이즈 예측 손실)로 학습되며, 학습된 모델은 다양한 <strong>회전, 이동, 재그립</strong> 등의 동작을 <strong>조건부 확률분포</strong> 형태로 내재하게 됩니다. 중요한 점은, <strong>외부 Motion 프롬프트</strong>는 이 확산 정책 네트워크에 <strong>직접 주입되지 않고</strong>, 대신 <strong>샘플링 단계에서의 Gradient Guidance</strong>로 활용된다는 것입니다. 이는 학습 시 <strong>분포 왜곡</strong> 없이 안정적인 모션 분포를 익히게 하고, 추론 시에만 인간 명령을 <strong>살짝 끌어당기는 역할</strong>을 하도록 분리한 설계입니다.</p>
<p><strong>Inverse Dynamics 모듈:</strong> 위 확산 정책이 출력하는 <strong>손가락 키포인트의 움직임</strong>은 로봇 손가락의 <strong>목표 관절각(position)</strong>으로 변환되어야 실제 제어에 사용할 수 있습니다. DexGen에서는 이를 위해 <strong>잔차(residual) 구조의 다층퍼셉트론(MLP)</strong>으로 단순한 <strong>역기구학 모델</strong>을 구현했습니다. 이 MLP는 현재 로봇 상태와 생성된 <strong>Motion</strong>을 입력받아, 각 조인트의 목표 위치를 확률적으로 출력합니다 (평균과 분산을 내는 Gaussian 출력). 학습 시에는 <strong>MSE 손실</strong>로 해당 동작이 실제 데이터의 조인트 변위와 일치하도록 학습되었습니다. 이 모듈은 비교적 단순한 회귀망이지만, 상술한 <strong>생성 정책의 출력 (미래 손끝 움직임)</strong>을 물리적인 <strong>로봇 명령</strong>으로 바꿔주는 필수적인 역할을 합니다.</p>
<p>*DexGen 컨트롤러의 <strong>모듈 구조</strong> (논문 Figure 4 재구성).</p>
<p><strong>Diffusion Model</strong>은 현재 <strong>State</strong> (로봇 상태)와 <strong>Mode</strong>를 입력받아 다다익선한 <strong>Motion</strong>(손가락 키포인트 움직임)을 생성한다. 이 때 <strong>외부 Motion Conditioning</strong> (사용자의 목표 동작)은 네트워크 입력으로 직접 들어가지 않고, <strong>Gradient Guidance</strong> 방식으로 확산 모델의 샘플을 적절히 유도한다. 이렇게 생성된 <strong>Motion</strong>은 <strong>Inverse Dynamics Model</strong>에 의해 로봇 관절 <strong>Action</strong> 명령으로 변환된다.*</p>
<p><strong>Guided Sampling (모션 조건 유도):</strong> DexGen이 <strong>인간 텔레오퍼레이터의 명령</strong>을 반영하는 방식은 확산 모델의 <strong>Guided Sampling</strong> 기법으로 구현되었습니다. 구체적으로, 모델이 예측한 다음 손가락 위치 시퀀스가 <strong>입력된 목표 움직임</strong>과 가까워지도록, 확산 과정의 각 스텝에서 <strong>손가락 오프셋 차이</strong>에 대한 <strong>그래디언트</strong>를 샘플에 가이드로 더해주는 방식입니다. 간단히 말해, <strong>생성 중인 동작</strong>이 <strong>학습된 안전 동작 분포</strong>를 유지하면서도 <strong>사용자 명령 방향</strong>으로 약간 편향되도록 힘을 주는 것입니다. 이때 가이드 세기인 λ 값에 따라 <strong>DexGen의 보수성</strong>이 조절됩니다. λ가 너무 작으면 모델이 안전하게만 굴러가서 사용자가 원하는 목표에 충분히 못 미치게 되고, λ가 너무 크면 오히려 사용자 명령(때로는 서투르거나 위험한 동작)이 모델의 안전장치를 이겨버릴 수 있습니다. 논문 실험에서는 모든 실험에 잘 맞는 <strong>공통의 중간 세기</strong>를 찾아 적용했다고 합니다. 결과적으로, DexGen은 <strong>학습된 저수준 행동 분포</strong>를 기반으로 <strong>미세 조정</strong>만 가해 안전성과 목표추종을 동시에 만족시키는 행동을 생성합니다. 이러한 접근은 인간 조작 신호를 <strong>강화학습 정책의 관측으로 넣는</strong> 기존 <strong>Shared Autonomy</strong> 방식들과 차별화되며, 고차원 손가락 제어에서 <strong>사용자 의도에 따른 연속적 미세 행동 샘플링</strong>을 가능케 한 점에서 의의가 있습니다.</p>
</section>
<section id="실험-결과-안정성-10100배-향상-인간-로봇-협업을-통한-전례없는-성과" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="실험-결과-안정성-10100배-향상-인간-로봇-협업을-통한-전례없는-성과"><span class="header-section-number">2.4</span> 실험 결과: 안정성 10~100배 향상, 인간-로봇 협업을 통한 전례없는 성과</h2>
<p>저자들은 DexGen의 성능을 시뮬레이션과 실제 로봇 실험으로 검증하였습니다.</p>
<p>먼저 시뮬레이터에서, 앞서 생성한 다양한 RL 정책들과 결합하여 DexGen이 얼마나 성능을 향상시키는지 평가했습니다. Figure 8에서, <strong>노이즈가 섞인 suboptimal 전문가 정책</strong>에 DexGen을 적용한 경우와 아닌 경우를 비교하는데, DexGen 없이 원 시연 정책만 사용할 경우 물체를 제대로 잡지 못하고 계속 떨어뜨리는 <strong>catastrophic failure</strong>가 빈번했습니다. 반면 DexGen이 보조해준 경우에는 <strong>객체를 손에서 떨어뜨리지 않고 유지</strong>하는 시간이 월등히 증가했고, 심지어 <strong>대부분이 잡음뿐인 엉망인 정책</strong>조차 DexGen이 일부 교정하여 <strong>목표 동작을 어느 정도 성공</strong>시키는 사례를 보였습니다. 논문에서는 DexGen이 다양한 상위 정책에 대해 <strong>물체 홀딩 지속시간을 10배에서 최대 100배까지</strong> 늘려주었고, <strong>기존에 실패하던 경우에도 성공을 달성</strong>하게 해주었다고 보고합니다. 이는 DexGen이 <strong>외부 정책의 불안정성을 크게 완화</strong>시켜준다는 것을 의미합니다. 특히 <strong>지도 신호 λ</strong>에 따른 영향도 분석했는데, λ=0 (guidance 없음)에서는 안전하지만 목표 달성은 안 되고, λ가 너무 크면 안전성이 떨어지는 현상을 확인하여, 적절한 trade-off 지점을 찾아 사용했습니다. 이 결과는 DexGen의 guided sampling 접근이 성공적으로 작동함을 보여줍니다.</p>
<p><strong>실제 로봇 실험</strong>에서는 <strong>Allegro 4-핑거 로봇 핸드 + Franka 암</strong> 조합으로 다양한 난이도의 덱스터러스 작업을 수행했습니다. 인간 조작자는 원격지에서 master 장치를 통해 <strong>고수준 움직임</strong>을 명령하고, DexGen 컨트롤러가 이를 받아 <strong>손가락 세밀 조작</strong>을 실시간 생성합니다. 평가한 작업으로는 (1) <strong>공중에서 물체 잡고 임의 방향으로 재배향하기</strong> (In-hand Object Reorientation), (2) <strong>툴 핸들 재그립</strong> 후 <strong>파워 그립 유지</strong>하기 (Functional Grasping), (3) <strong>물체를 손가락 사이에서 다른 그립으로 옮겨잡기</strong> (In-hand Regrasping) 등이 있었습니다. 또한 이러한 기본 스킬들을 조합해야 하는 <strong>펜 잡고 쓰기</strong>, <strong>주사기 사용하기</strong>, <strong>드라이버로 나사 조이기</strong> 같은 <strong>장시간(long-horizon) 공구 사용 작업</strong>도 도전하였습니다.</p>
<p>그 결과, DexGen 없이는 대부분의 작업에서 인간 조작만으로는 실패하던 것이, DexGen의 도움으로 높은 성공률을 기록했습니다. 예를 들어, “큰 물체 세로 방향 재배향” 작업에서 <strong>Teleop 단독</strong>으로는 20회 중 0회 성공, 평균 물체 홀딩 시간 5% (거의 바로 드롭)였으나, <strong>Teleop + DexGen</strong>의 경우 20회 중 <strong>12회 성공</strong>, 홀딩 시간 <strong>75%</strong>로 크게 향상되었습니다. 작은 물체 재배향도 0→13회 성공으로 개선되었고, 공구 재그립 작업 또한 Teleop 단독 0%→ DexGen 보조 50~70%대로 성공률이 올랐습니다. 아래 표는 대표적인 평가 과제들에 대한 <strong>성공률(SR)</strong>과 <strong>물체 떨어뜨리기 전까지 유지 시간(TTF)</strong>을 비교한 결과입니다:</p>
<table class="table">
<colgroup>
<col style="width: 19%">
<col style="width: 20%">
<col style="width: 16%">
<col style="width: 28%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th><strong>작업</strong></th>
<th><strong>Teleop (성공/시도)</strong></th>
<th><strong>Teleop TTF</strong></th>
<th><strong>Teleop + DexGen (성공/시도)</strong></th>
<th><strong>DexGen TTF</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>큰 물체 재배향 (세로 방향)</td>
<td>0/20</td>
<td>5%</td>
<td>12/20</td>
<td>75%</td>
</tr>
<tr class="even">
<td>작은 물체 재배향 (세로 방향)</td>
<td>0/20</td>
<td>5%</td>
<td>13/20</td>
<td>79%</td>
</tr>
<tr class="odd">
<td>공구 수직 재그립 (파워그립)</td>
<td>0/10</td>
<td>5%</td>
<td>7/10</td>
<td>87%</td>
</tr>
<tr class="even">
<td>공구 수평 재그립 (파워그립)</td>
<td>1/10</td>
<td>10%</td>
<td>6/10</td>
<td>80%</td>
</tr>
<tr class="odd">
<td>작은 공 공중 재그립</td>
<td>0/10</td>
<td>5%</td>
<td>5/10</td>
<td>78%</td>
</tr>
<tr class="even">
<td>실린더 공중 재그립</td>
<td>0/10</td>
<td>5%</td>
<td>5/10</td>
<td>74%</td>
</tr>
</tbody>
</table>
<p><em>표 1: 주요 실제작업에서 <strong>Teleop 단독</strong> vs <strong>DexGen 보조</strong> 성능 비교 (성공률과 홀딩 시간). DexGen의 도움 없이는 인간이 물체를 거의 바로 떨어뜨려 성공할 수 없던 작업들도, DexGen을 통해 안정적으로 물체를 다루며 절반 이상 성공하는 것으로 나타났다.</em></p>
<p>특히 <strong>펜으로 쓰기, 주사기 사용, 드라이버 사용</strong>과 같은 복잡한 작업은 여러 단계를 차례로 수행해야 하는데, DexGen은 이러한 <strong>장기간 조작에도 처음으로 도전하여 부분적인 성공</strong>을 거두었습니다.</p>
<ul>
<li>예를 들어 <code>드라이버 작업</code>의 경우, “물체 재배향→재그립→나사 홈 정렬→조이기”의 4단계 중, <strong>재배향은 16/20회</strong>, <strong>재그립 11/20회</strong>, <strong>드라이버 끝을 홈에 맞추기 5/20회</strong>, 최종적으로 <strong>나사 조이기 동작 완수 3/20회 성공</strong>하였습니다.</li>
<li><code>주사기 사용</code> 역시, “재배향→재그립→밀어 넣기” 3단계 중 최종 <strong>밀어 넣기 4/20회</strong> 성공으로 완전한 성공률은 아직 낮지만 <strong>단계별로는 꽤 높은 성공 비율</strong>을 보였습니다.</li>
</ul>
<p>이는 해당 작업의 난이도를 고려하면 유의미한 성과로, 저자들은 <code>“세계 최초로 이러한 장기간의 복잡한 기교 조작을 Teleop으로 실현했다”</code>고 강조합니다. 비록 여러 단계를 연달아 성공적으로 수행하는 <strong>연계 성공률</strong>은 낮았지만, 이는 각 서브스킬의 성공률을 향상하고 통합하는 추가 연구로 극복 가능할 것으로 전망하고 있습니다.</p>
<p>한편, DexGen과 자주 비교될 수 있는 기존 방법들과의 차이를 정리하면 다음과 같습니다:</p>
<ul>
<li><strong>대규모 사전학습 데이터:</strong> 기존의 Gato, RT-1 등 <strong>로봇 Foundation 모델</strong>들은 <strong>실세계</strong>의 거대한 시연 데이터로 학습된 반면, <strong>DexGen은 전적으로 시뮬레이션 데이터</strong>로 학습되었습니다. 이는 현실 데이터 수집의 어려움을 우회하면서도, Domain Randomization 등을 통해 현실 적용력을 확보하려 한 것으로, <strong>sim-to-real</strong>의 새로운 가능성을 제시합니다.<br>
</li>
<li><strong>고차원 다지 로봇 손 조작:</strong> 이전의 일반ist 정책들은 주로 2-finger 그리퍼와 같은 <strong>저차원 제어</strong>에 집중되었습니다. DexGen은 <strong>Degrees of Freedom 16</strong>의 <strong>Allegro Hand</strong>를 효과적으로 제어함으로써, <strong>정교한 손동작 분야에서 generative pretraining의 성공적인 사례</strong>를 처음 보여주었습니다. 이는 Rubik’s Cube 풀기(OpenAI Dactyl) 등 단일 과제 RL 성공 이후로, <strong>다양한 물체와 도구 사용</strong>에까지 범용성을 확장한 의의가 있습니다.<br>
</li>
<li><strong>연속적 프롬프트에 의한 저수준 제어:</strong> 대부분의 기존 <strong>로봇 파운데이션 모델</strong>은 <strong>자연어 지시</strong>나 <strong>태스크 ID</strong>처럼 <strong>이산적이고 상위 수준</strong>의 conditioning만을 받습니다. 반면 DexGen은 <strong>연속적인 미세 동작</strong>을 <strong>프롬프트</strong>로 받아들이고, 이를 실시간 행동으로 변환하는 <strong>저수준 컨트롤러</strong>라는 점에서 차별화됩니다. 이는 향후 고레벨 플래너나 언어 모델과 <strong>결합하여 작동하는 기본 제어기</strong>로 활용될 수 있음을 시사합니다.</li>
</ul>
</section>
<section id="결론-및-전망" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="결론-및-전망"><span class="header-section-number">2.5</span> 결론 및 전망</h2>
<p>DexterityGen 프로젝트는 <strong>인간-로봇 협업</strong>과 <strong>생성형 정책</strong>의 결합으로 로봇 손의 잠재력을 크게 끌어올린 사례입니다. 요약하면, DexGen은 <strong>시뮬레이션에서 학습한 거대한 skill prior</strong>를 활용하여, <strong>현실에서 인간의 고수준 조작을 안전한 세부 행동으로 구현</strong>하는 <strong>foundation controller</strong>를 제안했습니다. 이를 통해 기존에 어려웠던 다양한 물체의 공중 조작, 도구 사용 등을 최초로 시연하며, <strong>안정성 측면에서 10~100배 향상</strong>이라는 놀라운 결과를 보였습니다. DexGen의 등장은 향후 로봇 연구에 여러 흥미로운 방향을 열어줍니다. 예를 들어, 이 low-level dexterous controller를 high-level task planning이나 언어지시 정책과 결합하면, 더욱 복잡한 작업을 인간의 간단한 명령으로 수행하는 멀티레벨 로봇 제어 시스템을 구성할 수 있을 것입니다. 또한 DexGen이 가능케 한 <strong>안정적인 공구 사용</strong> 데이터 수집을 바탕으로, 추후에는 <strong>완전 자율적인 섬세 조작</strong> 정책으로도 발전시킬 수 있을 것입니다. 저자들도 DexGen이 <code>“미래 로봇 에이전트의 핵심 빌딩블록”</code>으로서 역할하며, 앞으로 끝없는 새로운 가능성을 열어줄 것으로 기대하고 있습니다.</p>
<p>궁극적으로, <strong>DexterityGen</strong>은 <strong>다자유도 로봇 손 제어</strong> 분야에서 <strong>파운데이션 모델</strong> 개념을 성공적으로 적용한 첫 사례 중 하나로서, <strong>복잡한 인간 수준의 기교</strong>를 로봇에게 학습시키는 방향에 큰 이정표를 세웠습니다. 향후 연구를 통해 남아있는 한계점들 – 예를 들어 장기 연쇄 동작의 완성도 향상, 촉각센서 결합, 실시간 성능 최적화 등 – 이 개선된다면, 진정한 의미의 범용 조작 로봇에 한 걸음 더 다가설 수 있을 것으로 보입니다.</p>
</section>
</section>
<section id="reference" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Reference</h1>
<ul>
<li><a href="https://arxiv.org/abs/2502.04307">Original Paper</a></li>
<li><a href="https://zhaohengyin.github.io/dexteritygen/">Project Homepage</a></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>