<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-05-09">
<meta name="description" content="The Foundational Pose as a Selection Mechanism for the Design of Tool-Wielding Multi-Finger Robotic Hands">

<title>Curieux.JY - 📃Foundational Pose for Hand Robots 리뷰</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review"><span class="header-section-number">1</span> Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review"><span class="header-section-number">2</span> Detail Review</a>
  <ul class="collapse">
  <li><a href="#연구-문제와-동기" id="toc-연구-문제와-동기" class="nav-link" data-scroll-target="#연구-문제와-동기"><span class="header-section-number">2.1</span> 연구 문제와 동기</a></li>
  <li><a href="#foundational-pose-개념-정의" id="toc-foundational-pose-개념-정의" class="nav-link" data-scroll-target="#foundational-pose-개념-정의"><span class="header-section-number">2.2</span> Foundational Pose 개념 정의</a></li>
  <li><a href="#설계-공간-탐색에서-foundational-pose의-역할" id="toc-설계-공간-탐색에서-foundational-pose의-역할" class="nav-link" data-scroll-target="#설계-공간-탐색에서-foundational-pose의-역할"><span class="header-section-number">2.3</span> 설계 공간 탐색에서 Foundational Pose의 역할</a></li>
  <li><a href="#실험-설계-및-결과-요약-다양한-도구-사용-시-손-설계-예시" id="toc-실험-설계-및-결과-요약-다양한-도구-사용-시-손-설계-예시" class="nav-link" data-scroll-target="#실험-설계-및-결과-요약-다양한-도구-사용-시-손-설계-예시"><span class="header-section-number">2.4</span> 실험 설계 및 결과 요약 (다양한 도구 사용 시 손 설계 예시)</a></li>
  <li><a href="#주요-기여와-한계점" id="toc-주요-기여와-한계점" class="nav-link" data-scroll-target="#주요-기여와-한계점"><span class="header-section-number">2.5</span> 주요 기여와 한계점</a></li>
  <li><a href="#기존-접근법과의-비교" id="toc-기존-접근법과의-비교" class="nav-link" data-scroll-target="#기존-접근법과의-비교"><span class="header-section-number">2.6</span> 기존 접근법과의 비교</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃Foundational Pose for Hand Robots 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">paper</div>
    <div class="quarto-category">hand</div>
  </div>
  </div>

<div>
  <div class="description">
    The Foundational Pose as a Selection Mechanism for the Design of Tool-Wielding Multi-Finger Robotic Hands
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 9, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ol type="1">
<li>🤖 이 논문은 로봇 손의 도구 사용 능력을 설계하기 위해 ’Foundational Pose (FP)’라는 특정 자세를 선택 메커니즘으로 사용하는 새로운 가설을 제시했습니다.</li>
<li>⚙️ 연구팀은 FP에 도달할 수 있는 손 디자인을 대량으로 생성하고 평가하는 시뮬레이션을 통해 99% 이상의 디자인이 도구를 성공적으로 사용하는 것을 확인하며 가설을 지지했습니다.</li>
<li>✨ 개발된 프레임워크는 로봇 손 설계 공간에 대한 심층적인 통찰을 제공하며, 실제 프로토타입 제작을 통해 도구 사용 작업의 현실적인 구현 가능성을 입증했습니다.</li>
</ol>
<hr>
<section id="brief-review" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Brief Review</h1>
<p>이 논문은 도구 사용(tool-wielding)을 위한 다중 손가락 로봇 손의 디자인 문제를 다루며, 파운데이션 포즈(foundational poses, FPs)를 디자인 과정의 선택 메커니즘으로 사용하는 아이디어를 제안합니다. 도구 사용은 단순히 물체를 잡는 것(pick-and-place)과 달리 도구의 기능을 활용하기 위해 손이 특정 자세를 취하는 복잡한 조작입니다.</p>
<p>저자들은 인간이 도구를 사용할 때 특정 자세에서 시작하거나 해당 자세를 거치는 경향이 있음을 관찰하고 이를 FPs라 명명했습니다. FP는 도구와 손, 그리고 그들 간의 접촉으로 형성되는 tool-hand parallel mechanism의 작동 방식을 포착하는 ’스냅샷’으로 해석됩니다. 하나의 손은 같은 도구로 여러 메커니즘을 형성할 수 있습니다. 본 연구의 핵심 가설은 다음과 같습니다.</p>
<blockquote class="blockquote">
<p><strong>Hypothesis 1.</strong> If a tool and an anthropomorphic hand can reach a foundational pose, then they can act as a corresponding tool-hand parallel mechanism for the hand to wield the tool and achieve a non-zero tool motion range.</p>
<p>(도구와 인간형 손이 파운데이션 포즈에 도달할 수 있다면, 해당 손은 상응하는 tool-hand parallel mechanism으로 작동하여 도구를 사용하고 0이 아닌 tool motion range를 달성할 수 있을 것이다.)</p>
</blockquote>
<p>이 가설을 테스트하기 위해, 저자들은 FPs를 사용하여 다양한 손 디자인을 계산적으로 생성하고 평가하는 sampling-based design optimization framework를 개발했습니다. 디자인 공간은 6개의 design parameters <span class="math inline">\mathbf{d} = [d_1 \dots d_6]^\top</span>로 정의되는 인간형 4손가락 손 템플릿을 기반으로 합니다. FPs는 sculptors가 점토 조각 도구를 사용하는 세 가지 방식인 <code>carve</code>, <code>poke</code>, <code>press</code>에서 영감을 받아 수동으로 식별되었습니다.</p>
<p>각 FP는 tool-hand system의 특정 구성이며, kinematic constraints 및 static equilibrium을 만족해야 합니다. kinematic constraints는 도구 표면의 moving frame <span class="math inline">\{C\}</span>와 손가락 링크 표면의 moving frame <span class="math inline">\{P\}</span> 간의 접촉 조건으로 정의됩니다. i번째 접촉에 대해 위치 제약은 <span class="math inline">\mathbf{p}_{OC_i} = \mathbf{p}_{OP_i}</span>이고, 표면 법선 제약은 <span class="math inline">\mathbf{z}_{OC_i} + \mathbf{z}_{OP_i} = \mathbf{0}</span>입니다. 여기서 <span class="math inline">\mathbf{p} \in \mathbb{R}^3</span>는 원점의 Cartesian 위치이고, <span class="math inline">\mathbf{z} \in \mathbb{R}^3</span>는 z축 단위 벡터입니다. 이러한 제약은 <span class="math inline">\text{reachFP}(\boldsymbol{\theta}, \mathbf{d}) = \mathbf{0}</span> 형태의 비선형 방정식 시스템으로 표현되며, <span class="math inline">\boldsymbol{\theta}</span>는 손과 도구의 조인트 위치 및 접촉 매개변수를 포함합니다.</p>
<p>이 프레임워크는 RRT(rapidly exploring random tree) 샘플러를 사용하여 모든 FPs에 도달할 수 있는 디자인 공간(“feasible design space”)에서 손 디자인 <span class="math inline">\mathbf{d}</span>를 샘플링합니다. 새로운 샘플 <span class="math inline">\mathbf{d}_{\text{new}}</span>은 기존 후보들과 충분히 다르고, 모든 FP에 도달 가능하며 (비선형 최적화 문제 <span class="math inline">\min \Delta\boldsymbol{\theta} \text{ sampling\_cost}(\Delta\boldsymbol{\theta}; \boldsymbol{\theta}^{[i^*]}, \mathbf{d}_{\text{new}}) \text{ s.t. } \text{reachFPs}(\Delta\boldsymbol{\theta}; \boldsymbol{\theta}^{[i^*]}, \mathbf{d}_{\text{new}}) = \mathbf{0}, \text{collision}(\Delta\boldsymbol{\theta}; \boldsymbol{\theta}^{[i^*]}, \mathbf{d}_{\text{new}}) \ge 0, \boldsymbol{\theta}_{\text{min}} - \boldsymbol{\theta}^{[i^*]} \le \Delta\boldsymbol{\theta} \le \boldsymbol{\theta}_{\text{max}} - \boldsymbol{\theta}^{[i^*]}</span>를 풀어 확인), 외부 힘 하에서 static equilibrium을 만족하는 경우에만 후보로 수락됩니다. 최적화 비용 함수는 FP별로 다르게 정의되며, carve의 경우 도구의 cutting moment에 기여하는 접촉력 분율 최대화, poke 및 press의 경우 pinch를 revolute joint에 가깝게 만들기 위한 pinching finger 정렬 최대화를 목표로 합니다.</p>
<p>생성된 후보 손들은 tool-wielding 성능을 평가받습니다. 평가는 FP에서 시작하여 도구의 특정 경로(prescribed tool motion <span class="math inline">\dot{u}_t</span>)를 따라 손가락의 움직임(<span class="math inline">\dot{\mathbf{u}}_f</span>)을 계획하는 방식으로 이루어집니다. 이는 Quadratic Program (QP) <span class="math inline">\min_{\dot{\mathbf{u}}_f} \mathbf{v}_{CP}^T \mathbf{E}_{xy}^T \mathbf{E}_{xy} \mathbf{v}_{CP} \text{ s.t. } \mathbf{E}_z \mathbf{v}_{CP} = \mathbf{0}, \text{motion\_range}(\dots) \ge 0, \text{collision\_linearized}(\dots) \ge 0</span>를 풀어 접촉 슬라이딩을 최소화하고 kinematic/collision 제약을 만족하는 finger velocities <span class="math inline">\dot{\mathbf{u}}_f</span>를 계산하는 방식으로 수행됩니다. <span class="math inline">\mathbf{v}_{CP} = \mathbf{J} [\dot{u}_t^T \dot{\mathbf{u}}_f^T]^T</span>는 접촉점에서의 상대 속도이고, <span class="math inline">\mathbf{E}_{xy}</span>와 <span class="math inline">\mathbf{E}_z</span>는 각각 xy 및 z 성분을 추출하는 행렬입니다. 평가 지표로는 tool motion range, mean contact sliding speed, maximum finger torque가 사용됩니다.</p>
<p>실험 결과, 2D 디자인 공간에서는 785개 후보 모두, 6D 디자인 공간에서는 10,000개 후보 중 99.42%가 모든 FP에서 0보다 큰 tool motion range를 달성했습니다. 이는 Hypothesis 1을 강력하게 지지합니다. 또한, 성능 landscape와 Pareto front 분석을 통해 디자인 공간의 비볼록하고 다목적인 특성 및 디자인 후보들의 clustering 경향 등을 밝혀냈습니다.</p>
<p>이 프레임워크로 생성된 Pareto-optimal 디자인 중 하나를 기반으로 hardware prototype을 제작했습니다. 이 프로토타입은 rigid endoskeleton과 soft skin으로 구성되었으며, 간단한 PD 컨트롤 전략만으로도 점토 조각 도구를 사용하여 점토를 자르거나 표시를 남기는 tool-wielding 작업을 성공적으로 수행했습니다. 이는 FP 개념의 실제 적용 가능성을 보여줍니다.</p>
<p>본 연구의 주요 기여는 FPs를 tool-wielding 다중 손가락 로봇 손 디자인의 selection mechanism으로 제안하고 검증했다는 점입니다. 또한, feasible design space를 탐색하고 복잡한 디자인 문제에 대한 통찰을 제공하는 sampling-based design framework를 개발했습니다. hardware prototype을 통한 실제 시연도 중요한 기여입니다.</p>
<ul>
<li>한계점으로는 FPs가 수동으로 식별되었다는 점, FP 도달 최적화 단계가 실제 tool-wielding 성능 평가 지표를 직접 고려하지 않았다는 점, 고차원 디자인 공간 탐색의 어려움 등이 언급되었습니다.</li>
<li>향후 연구로는 <em>clustering 분석</em>을 통한 디자인 패밀리 식별, tool-wielding 과정의 velocities 및 forces 활용, FP 개념의 다른 dexterous manipulation 태스크로의 확장 등이 제안되었습니다.</li>
</ul>
</section>
<section id="detail-review" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Detail Review</h1>
<blockquote class="blockquote">
<p>도구-사용 로봇 손 설계를 위한 Foundational Pose: 논문 리뷰</p>
</blockquote>
<section id="연구-문제와-동기" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="연구-문제와-동기"><span class="header-section-number">2.1</span> 연구 문제와 동기</h2>
<p>로봇이 사람처럼 <strong>도구(tool)</strong>를 능숙하게 사용하는 것은 오랫동안 로봇 공학의 도전 과제였습니다. 도구를 사용한다는 것은 단순히 물체를 집어 옮기는 것과 달리, 그 도구의 <strong>기능을 발휘하도록 잡고 움직이는 것</strong>을 의미합니다. 예를 들어, 펜으로 글씨를 쓸 때 손이 취하는 자세나 가위로 무언가를 자를 때의 손 모양은, 그저 펜이나 가위를 들어 옮길 때와는 확연히 다릅니다. 이러한 <strong>특정한 손-도구 자세</strong>를 구현하지 못하면 도구의 본래 기능을 효과적으로 활용하기 어렵습니다. 그러나 기존 로봇 손 연구는 주로 집기나 물체 옮기기(pick-and-place) 등에 초점을 맞춰 발전해왔고, <strong>다지(多指) 로봇 손을 이용한 도구 사용</strong> 분야는 상대적으로 <strong>탐구가 부족한 실정</strong>입니다.</p>
<p>한편, 고령화와 인력 부족 문제를 대비하여 <strong>도구를 다루는 로봇</strong>에 대한 요구는 높아지고 있습니다. 기존 산업 자동화에서는 전용 그리퍼나 도구 교체 장치 등을 활용해 로봇이 공구를 사용하도록 설계하곤 했지만, 이는 특정 작업에 최적화되어 <strong>범용성이 떨어지고 장비가 복잡</strong>해지는 단점이 있었습니다. 사람 손과 유사한 <strong>인간형(anthropomorphic) 로봇 손</strong>을 사용하면 다양한 도구를 다룰 잠재력은 있지만, <strong>어떤 손 구조가 도구 사용에 유리한지</strong>에 대한 체계적인 설계 지침이 부족했습니다. 다지 로봇 손의 설계 문제는 <strong>비선형성과 다목적성</strong>을 띠기 때문에 한두 가지 성능 지표만으로 최적해를 찾기 어렵고, 여러 목표 간 <strong>트레이드오프(Pareto 최적)</strong>를 고려해야 합니다. 그럼에도 불구하고 많은 이전 연구들은 인간 설계자의 경험에 의존한 수작업 설계나, 하나의 “최적” 설계를 찾는 방식에 머물러 있어 설계 공간에 숨겨진 다양한 대안을 충분히 탐색하지 못했습니다. 이러한 배경에서, 리뷰 논문 <em>“The Foundational Pose as a Selection Mechanism for the Design of Tool-Wielding Multi-Finger Robotic Hands”</em>는 <strong>도구 사용에 적합한 로봇 손을 설계하는 새로운 접근법</strong>을 제시합니다.</p>
<blockquote class="blockquote">
<p>핵심 아이디어는 <strong>도구-손 시스템이 취하는 특정 기초 자세</strong>를 설계 과정의 선택 기준으로 삼는 것 입니다.</p>
</blockquote>
<p>이를 통해 복잡한 도구 사용 동작을 단일 자세로 단순화하여, 입문자도 이해하기 쉽고 전문가도 활용할 수 있는 손 설계 방법론을 탐색하고 있습니다.</p>
</section>
<section id="foundational-pose-개념-정의" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="foundational-pose-개념-정의"><span class="header-section-number">2.2</span> Foundational Pose 개념 정의</h2>
<p><strong>Foundational Pose (FP)</strong>란 이 연구에서 제안한 <strong>“기초 자세”</strong>로, 사람이 도구를 사용할 때 손과 도구가 함께 만들어내는 <strong>핵심 형태</strong>를 가리킵니다. 사람이 조각칼이나 펜과 같은 도구를 실제로 활용하기 위해서는, 우선 손과 도구를 <strong>특정 자세로 구성</strong>한 후 그 상태에서 도구를 움직이는 경향이 있습니다. 저자들은 인간 조각가들을 관찰한 결과, 도구를 쥔 손가락들이 <strong>일정한 형태의 닫힌 사슬 기구(병렬기구)</strong>를 형성하고 나면, 그 뒤로는 손가락들이 도구의 움직임에 맞춰 예측 가능한 방식으로 함께 움직인다는 직관을 얻었습니다. 다시 말해, 손과 도구가 <strong>여러 접촉점을 통해 연결</strong>되면 마치 손-도구 시스템 전체가 하나의 기계 장치처럼 움직이며, 복잡한 도구 사용 동작이 <strong>하나의 자세</strong>를 중심으로 전개될 수 있다는 것입니다.</p>
<p>이때 Foundational Pose는 바로 그 <strong>중심이 되는 자세</strong>를 의미합니다. 공식적으로는, <strong>도구가 손에 쥐어진 상태에서 양 방향으로 회전 운동을 시작할 수 있고</strong>, 손가락-도구 간 필요한 모든 <strong>접촉 제약</strong>이 만족되며, 도구 끝에 가해지는 외력에 대해 <strong>정적 평형</strong>을 이루는 자세로 정의됩니다. 쉽게 말해, 도구-손 시스템이 <strong>안정적으로 힘을 주고받으면서</strong> 도구를 움직일 준비가 된 <strong>출발 자세</strong>라고 볼 수 있습니다. 이 자세에서는 손가락과 도구 사이의 여러 접촉이 서로를 제약하여 (예: 집게손가락과 엄지로 도구를 집은 핀치 접촉이 하나의 회전 관절처럼 행동) 도구의 특정 운동을 가능하게 해줍니다. 이러한 FP는 도구 사용 동작의 <strong>핵심 메커니즘을 응축</strong>한 순간 사진(snapshot)과 같으며, <strong>동일한 도구라도 손이 잡는 방식에 따라 여러 FP</strong>를 가질 수 있습니다.</p>
<p>저자들은 특히 사람 조각가(sculptor)들이 찰흙 등을 다룰 때 손과 도구가 만들어내는 세 가지 대표적인 FP를 식별했습니다:</p>
<ul>
<li><strong>Carve:</strong> 손가락 <strong>3개</strong>로 도구를 감싸 쥐어, 도구의 단면을 삼각형 모양으로 <strong>세 점 접촉</strong>하는 형태. 이때 손가락 세 개는 모두 도구와 함께 움직이는 구조입니다. (예: 조각칼을 세 손가락으로 움켜쥐듯 잡아 파내는 동작)</li>
<li><strong>Poke:</strong> 손가락 <strong>4개</strong>를 이용하여 두 쌍의 핀치(pinching) <strong>접촉을 서로 수직</strong>이 되도록 배치한 형태. 즉 도구를 두 방향에서 집게손가락-엄지 등으로 집어, 두 개의 핀치 접촉이 서로 직교하는 구성입니다. 이 경우 <strong>두 개의 손가락 쌍</strong>이 마치 두 개의 직교하는 회전축을 형성하여 도구를 지탱하고, 그 중 두 손가락은 도구와 함께 움직이고 나머지 둘은 관절 역할을 합니다. (예: 송곳을 네 손가락으로 고정하고 찌르는 동작)</li>
<li><strong>Press:</strong> 손가락 <strong>4개</strong>로 도구를 잡되, 도구의 <strong>가운데 부분을 핀치</strong>하고 도구 양 끝을 다른 손가락으로 지지하는 형태입니다. 가운데의 핀치 접촉이 하나의 회전 관절처럼 기능하고, 양 끝의 접촉이 도구의 회전 중심을 고정하여 <strong>지렛대</strong>처럼 움직일 수 있게 합니다. 이 구성에서도 두 손가락은 도구와 함께 움직이고, 나머지 둘은 축 역할을 하며 도구를 지탱합니다. (예: 연필 중간을 집게손가락과 엄지로 쥐고 양 끝을 다른 손가락에 댄 채 누르는 동작)</li>
</ul>
<p> <em>그림 1</em> – Foundational Pose의 개념 예시. (위) 사람 손으로 식별된 세 가지 Foundational Pose: <strong>Carve, Poke, Press</strong> 각각의 자세를 사람이 도구(펜 모형)와 손가락 모형으로 보여준다. 이 포즈들은 도구 사용의 핵심 기구학적 관계를 나타낸다. (아래 좌) 본 연구에서 구현한 4손가락 로봇 손 프로토타입. 단단한 내부 골격과 부드러운 피부로 이루어져 있다. (아래 우) 물체를 단순 운반할 때의 그립(grasp)과 도구로 활용할 때의 그립의 차이를 사람 손으로 보여주는 예.</p>
<p>FP 개념의 <strong>직관적 의미</strong>는 이렇습니다. 사람 손이 도구를 제대로 <strong>휘두를 수 있는 자세</strong>는 사실 몇 가지로 한정되며, 그 자세에서는 손가락과 도구가 <strong>견고한 연결</strong>을 이뤄 하나의 체계로 움직입니다. 따라서 로봇 손 설계 시에도 이러한 FP를 손이 구현할 수 있다면, 그 손은 해당 도구를 제대로 사용할 수 있을 것이라는 <strong>가설</strong>을 세울 수 있습니다. 실제 논문에서도 다음과 같은 핵심 <strong>가설(Hypothesis 1)</strong>을 제시합니다:</p>
<blockquote class="blockquote">
<p><strong>“만약 어떤 도구와 로봇 손이 하나의 Foundational Pose를 만들어낼 수 있다면, 그 손은 해당 도구를 다루어 일정 범위 이상의 운동을 만들어낼 수 있다.”</strong></p>
</blockquote>
<p>이 가설은 <strong>복잡한 도구 사용 행동을 단일 자세로 요약</strong>함으로써 설계 검증을 쉽게 하겠다는 뜻입니다. 즉, 로봇 손이 일일이 전체 사용 과정을 시뮬레이션하지 않더라도, <strong>결정적인 순간의 자세</strong>만 구현 가능하면 그 도구를 다룰 수 있다고 보는 것입니다. 본 연구는 이 가설을 토대로 FP를 설계 선택의 기준으로 삼아, 다양한 손 설계안을 걸러내고 탐색하는 방법을 탐구했습니다.</p>
</section>
<section id="설계-공간-탐색에서-foundational-pose의-역할" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="설계-공간-탐색에서-foundational-pose의-역할"><span class="header-section-number">2.3</span> 설계 공간 탐색에서 Foundational Pose의 역할</h2>
<p>이 논문에서는 FP 개념을 실제 로봇 손 <strong>설계 공간(design space)</strong> 탐색에 적용하기 위해, 우선 손의 형태를 몇 가지 <strong>설계 파라미터</strong>로 나타낼 수 있는 <strong>디자인 템플릿(design template)</strong>을 정의했습니다. 저자들이 선택한 템플릿은 인간 손과 유사한 <strong>4개의 손가락</strong>을 가진 형태입니다. 각 손가락은 <strong>3자유도(3-DoF)</strong> 관절로 구성되며, 손바닥에 붙은 관절은 두 축으로 움직이는 유니버설 조인트(어깨 관절처럼 굽히고 옆으로 벌리는 움직임)이고 중간 마디는 한 축의 회전 관절로 되어 있습니다. 손가락 모양은 원통형/캡슐형으로 단순화했고, 이는 이후 접촉 계산을 용이하게 합니다. 이러한 구조를 택한 이유는 <strong>Carve, Poke, Press 세 가지 FP를 모두 구현하는 데 4개의 손가락(3자유도씩)이 최소한으로 필요</strong>하고, 단순한 형상일수록 접촉 및 충돌을 수치적으로 다루기 수월하기 때문입니다. 또한 파라미터로 정의된 설계 값들이 실제 하드웨어 변경으로 실현 가능하도록, 알루미늄 뼈대(rigid endoskeleton)와 3D 프린팅한 연질 피부(soft skin), 그리고 텐던-풀리 차동구동 메커니즘으로 손가락을 구현한 프로토타입까지 제작했습니다. (뼈대는 강성과 모델 정확도를, 연질 피부는 접촉 면에서의 유연성을 제공하는 설계입니다.)</p>
<p>이 손의 <strong>설계 파라미터</strong>들은 총 6개로 구성되어 설계 공간의 차원을 이룹니다. 구체적으로는 각 손가락의 <strong>길이 분포</strong>(손가락 마디 길이 비율를 결정짓는 값), 손바닥의 <strong>길이</strong>와 <strong>폭</strong>, 손가락의 <strong>두께(radius)</strong>, 손바닥에서 손가락들이 뻗어나가는 <strong>각도(palm angle)</strong>, 그리고 한 손가락(엄지)의 <strong>장착 각도</strong> 등이 포함됩니다. 이 파라미터들을 변화시키면 손가락이 길쭉하거나 짧아지고, 손바닥이 넓어지거나 좁아지며, 엄지의 대향 정도가 달라지는 등 다양한 손 형태를 만들어낼 수 있습니다. <strong>설계 공간</strong>이란 바로 이 파라미터들의 조합으로 표현되는 모든 손 형태의 집합이라고 할 수 있습니다.</p>
<p>하지만 이 방대한 설계 공간에서 <strong>어떤 손이 도구 사용에 적합한지</strong>를 찾는 것은 간단하지 않습니다. 여기서 <strong>Foundational Pose가 설계 선택의 기준</strong>으로 활용됩니다. 저자들은 설계 공간을 탐색하기 위해, <strong>FP를 만족하는 손</strong>들만을 추출하는 <strong>탐색 알고리즘</strong>을 개발했습니다. 먼저 하나의 기준 손 설계(인간 손 비슷하게 만든 초기 디자인)를 시작점으로 설정한 뒤, <strong>Rapidly-Exploring Random Tree (RRT)</strong> 알고리즘을 활용해 설계 공간에 무작위로 새 손 설계들을 <strong>샘플링</strong>합니다. 각 새로운 설계 샘플에 대해 다음 조건을 확인합니다:</p>
<ol type="1">
<li><strong>다양성:</strong> 이미 얻어진 다른 설계들과 <strong>충분히 다른지</strong> (설계 파라미터 값의 유클리드 거리가 일정 이상).</li>
<li><strong>FP 구현 가능성:</strong> 해당 설계의 손이 <strong>모든 FP를 구현</strong>할 수 있는지, 즉 Carve, Poke, Press <strong>각각의 자세를 IK(역기구학)</strong>로 찾아 손가락 관절 구성으로 만들 수 있는지. 이때 손가락-도구 사이에 지정된 접촉 지점들이 정확히 맞물리고(미끄러지거나 떼어지지 않고), 손에 가해지는 외력이 정적 평형을 이루는지도 검사합니다 (FP 정의 조건).</li>
<li><strong>정적 안정성:</strong> 추가로 도구 끝에 일정한 힘(예를 들면 조각할 때 도구에 가해지는 힘)을 가했을 때도 손과 도구가 <strong>버텨낼 수 있는지</strong> (접촉에 의한 마찰, 힘의 모멘트 균형 등) 확인합니다.</li>
</ol>
<p>위 조건을 <strong>모두 만족하면</strong> 그 설계는 유망한 후보(candidate)로 채택되고, 계속해서 다음 샘플을 생성합니다. 이렇게 FP 조건을 <strong>선택 메커니즘</strong>으로 삼음으로써, 탐색 과정에서 <strong>불필요한 설계</strong>(어차피 도구를 못 쓰는 구조)는 걸러내고 <strong>유망한 설계들만 축적</strong>하게 됩니다. 논문에서는 이 과정을 <strong>“가스 확산”</strong>에 비유하였는데, 마치 밀폐 용기 안에 가스를 넣으면 가스 분자가 용기 모양을 채워나가듯이, 초기 설계에서 시작한 샘플들이 <strong>FP가 만족되는 영역</strong>을 점차 채워나간다는 비유입니다. 이렇게 하여 <strong>설계 공간 내의 “FP 실현 가능 영역” (feasible design space)</strong>을 효과적으로 탐색할 수 있었습니다.</p>
<p>탐색 중에는 단순히 FP 만족 여부뿐 아니라, FP 자세에서의 손가락 <strong>자세 최적화</strong>도 함께 수행되었습니다. 예를 들어 Carve FP의 경우 손가락들이 낼 수 있는 힘 중 최대한 <strong>자르기 방향의 모멘트</strong>로 기여하도록 손가락 배치를 미세 조정하고, Poke와 Press FP의 경우 두 핀치 접촉이 이상적인 회전축을 이룰 수 있도록 정렬을 높이는 식입니다. 이러한 <strong>미세 조정 목표</strong>는 FP별 <strong>비용 함수(cost)</strong>로 설정하여, 각 설계의 FP 자세를 계산하는 비선형 최적화 문제에 반영했습니다. 쉽게 말해, “해당 손이 FP를 겨우 만족하는 정도”가 아니라 “좀 더 <strong>안정적이고 효과적인 FP</strong>”를 취할 수 있도록 한 단계 향상시킨 셈입니다.</p>
<p>이러한 <strong>샘플링 기반 설계 탐색 프레임워크</strong>를 통해 수천 개의 다양한 손 설계 후보가 자동으로 생성되었습니다. 그 결과 <strong>거의 모든 생성된 손 디자인(10,785개 중 99% 이상)</strong>이 시뮬레이션에서 성공적으로 도구를 사용할 수 있음이 확인되었는데, 이는 FP 가설을 강력하게 뒷받침합니다. 즉 무작위에 가깝게 뽑힌 손 모양이라도, <strong>FP 자세들만 만들어낼 수 있으면 실제 도구 동작도 수행</strong>된다는 의미입니다. FP를 통해 <strong>설계 공간을 거를 기준</strong>을 얻음으로써 복잡한 최적화 문제를 단순화하고, <strong>다양한 설계 대안들의 성능 분포</strong>까지 살펴볼 수 있게 되었는데, 이는 다음 실험 결과에서 자세히 드러납니다.</p>
<p> <em>그림 2</em> – <strong>손 설계 템플릿과 파라미터화</strong>. (좌) 4개의 3-DoF 손가락을 가진 로봇 손의 설계 템플릿과 주요 치수 파라미터 표시. 손바닥 폭, 길이, 손가락 길이, 두께, 손가락들 간 각도, 엄지 각도 등 6개의 파라미터로 손 형태를 결정한다. (우) 도구-손가락 시스템의 <strong>기구학 모델링</strong> 예시. 손가락 끝과 도구 표면의 접촉은 하나의 <strong>관절처럼</strong> 작용하며 (파란색 구=유니버설 조인트, 주황색 구=회전 조인트, 분홍색=접촉점), 이로써 손-도구가 하나의 병렬기구로 모델링된다.</p>
</section>
<section id="실험-설계-및-결과-요약-다양한-도구-사용-시-손-설계-예시" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="실험-설계-및-결과-요약-다양한-도구-사용-시-손-설계-예시"><span class="header-section-number">2.4</span> 실험 설계 및 결과 요약 (다양한 도구 사용 시 손 설계 예시)</h2>
<p>본 연구의 실험은 크게 <strong>시뮬레이션 설계 탐색 결과 분석</strong>과 <strong>하드웨어 검증 실험</strong>으로 구성됩니다. 먼저 시뮬레이션으로 얻은 수많은 설계 후보들의 <strong>성능을 평가</strong>하여, FP 기반 설계 방법의 효과와 특징을 살펴보았습니다. 평가를 위해 정의된 주요 <strong>성능 지표(metrics)</strong>는 다음 세 가지입니다:</p>
<ol type="1">
<li><strong>도구의 운동 범위(tool motion range):</strong> FP 자세에서 시작하여 도구를 움직일 수 있는 <strong>회전 각도 범위</strong>입니다. 클수록 도구를 더 크게 휘두를 수 있으므로 좋습니다.</li>
<li><strong>접촉 미끄름 속도(mean contact sliding speed):</strong> 도구 사용 동작 중 손가락과 도구 사이의 <strong>접촉점들이 미끄러지는 평균 속도</strong>입니다. 값이 작을수록 접촉이 잘 유지되어 안정적으로 힘을 전달하므로 바람직합니다.</li>
<li><strong>손가락 토크 최대치(max finger torque):</strong> 동작 중 손가락 관절에 걸리는 <strong>최대 토크</strong> 값입니다. 낮을수록 손가락 구동에 무리가 적고 효율적입니다.</li>
</ol>
<p>각 설계 후보에 대해, Carve, Poke, Press <strong>세 가지 FP에서 출발하는 도구 움직임 경로</strong>를 계획하고 (RRT를 이용한 경로 탐색 알고리즘으로), 위 세 가지 지표들을 측정했습니다. 그리고 <strong>지표값을 정규화</strong>하여 비교한 뒤, <strong>여러 목표가 상충</strong>하는 상황이므로 <strong>Pareto 최적해</strong> 분석도 수행했습니다. 그 결과 흥미로운 <strong>설계 성능 경향과 군집(클러스터)</strong>이 드러났습니다.</p>
<p>우선 비교적 이해하기 쉽도록 손 설계 파라미터 중 <strong>2차원만 변화</strong>시킨 단순한 경우(손바닥 폭과 엄지 각도만 다르게 함)를 살펴보면, 생성된 모든 설계들이 <strong>세 FP에서 모두 도구 운동을 만들어내는 것에 성공</strong>했음을 확인했습니다 (100% 성공). 이는 축약된 설계 공간에서도 FP 가설이 성립함을 보여줍니다. 또한 성능 지표 결과가 유사한 설계들끼리 <strong>뚜렷한 군집을 형성</strong>하고, 성능 지형이 매끄러운 <strong>등고선 형태</strong>를 보이기도 했습니다. 반면 일부 영역은 성능 변화가 급격하거나 불연속적인 “섬” 형태의 군집을 보여, 설계 공간 내에 <strong>여러 개의 설계 해법들이 공존</strong>함을 시사했습니다. 이러한 <strong>다양한 대안들의 존재</strong>와 <strong>성능 분포</strong>는 전통적으로 하나의 최적 설계만 찾는 방식이라면 놓치기 쉬운 통찰입니다. 다시 말해, FP 기반의 폭넓은 샘플링 접근법을 통해 비선형적이고 다목적인 손 설계 문제의 <strong>복잡한 양상</strong> 일부를 드러낼 수 있었던 것입니다.</p>
<p>이어서 <strong>전체 6차원 설계 공간</strong>에 대해 샘플링한 결과(약 만여 개의 설계)에 대한 분석을 보면, <strong>거의 모든 후보(99.42%)가 세 가지 FP 모두에서 0보다 큰 도구 운동 범위를 확보</strong>하여 성공적으로 도구를 휘둘렀습니다. 각 FP별로 따로 보면 <strong>Press와 Poke 동작은 대부분의 설계가 무리 없이 수행</strong>한 반면, <strong>Carve 동작만 약 5% 정도의 설계에서 실패</strong>가 나타났습니다. 이는 <strong>Carve FP가 세 가지 중 가장 구현이 까다로운 요소</strong>임을 보여주는데, 실패 원인을 들여다보니 손가락들이 FP를 이룬 후 움직이면서 <strong>정적 평형을 잃거나 관절 가동 한계에 다다르는 경우</strong>들이었습니다. 즉 Carve에서는 손가락 세 개가 모두 움직여야 하다 보니 힘 배분이 어렵고 각도 여유가 적어 <strong>설계에 더 엄격한 조건</strong>을 요구했던 것입니다. 그럼에도 전체적으로 볼 때 거의 모든 설계가 도구 사용을 달성했으므로, <strong>“FP를 만족하면 실제 작업 수행도 가능하다”</strong>는 가설은 통계적으로 매우 잘 성립했습니다.</p>
<p>또한 6차원 설계 공간의 후보들을 <strong>시각화</strong>하기 위해 t-SNE 기법으로 2차원 임베딩을 한 결과, 설계 파라미터상 충분히 다르게 샘플된 손들임에도 불구하고 <strong>임베딩 공간에서는 일부 겹치거나 모이는 현상</strong>이 관찰되었습니다. 이는 곧 <strong>서로 다른 설계들이 유사한 기능적 역할</strong>을 할 수 있다는 뜻으로, 향후 더 많은 데이터를 통해 이러한 <strong>설계 족(family)</strong>들을 분류해내는 연구 가능성을 열어줍니다.</p>
<p>다음으로, 저자들은 이렇게 얻어진 설계 중 <strong>하나를 선정하여 실제 로봇 손</strong>을 제작하고 <strong>현실의 도구 사용 실험</strong>을 수행했습니다. 하드웨어 제작을 위해서는 현실적인 제약도 고려해야 하므로, 성능 지표들 간 <strong>균형 잡힌 Pareto 최적</strong> 설계 중 하나를 고랄했습니다. 선택된 설계는 Carve와 Poke에서 도구 회전 범위가 넓고 나머지 지표들도 준수한 <strong>타협형 디자인</strong>이었습니다. 이 설계를 바탕으로 3D 프린터로 출력한 부품과 기성 부품들로 손을 조립하고, 서보 모터 구동 및 <em>텐던-풀리</em> 메커니즘으로 움직이는 로봇 손을 만들었습니다. 손가락 끝에는 앞서 설계한 대로 연질의 두꺼운 커버(foam 같은 재질)를 씌워 약간 더 큰 접촉 면적과 충격 흡수력을 주었습니다.</p>
<p><strong>제어</strong>는 비교적 간단하게 이루어졌습니다. 앞서 시뮬레이션에서 각 FP별로 계획된 손가락 움직임 경로를 불러와, 이를 <strong>5차(polynomial) 보간으로 매끄럽게 만든 후 PD 제어기로 추종</strong>하게 했습니다. 실험 대상 <strong>도구</strong>로는 단단한 <strong>찰흙 조각용 도구</strong>(예: 조각칼 모양 막대)를 사용하고, 작업 대상은 실제 찰흙 대신 부드러운 <strong>플레이도(Play-Doh)</strong> 반죽을 활용했습니다. 로봇 손가락을 시작 자세로 옮긴 뒤 사람이 도구를 손에 쥐여 주었고, 그 다음부터 로봇 손가락이 자동으로 경로를 따라 움직이며 찰흙을 자르고 누르는 동작을 수행했습니다.</p>
<p>그 결과, <strong>아주 단순한 제어 전략</strong>과 <strong>정확한 물리모델 보정 없이</strong>도 로봇 손이 <strong>실제로 도구를 활용한 동작을 성공적으로 재현</strong>해냈습니다. 손은 찰흙 덩어리에서 도구로 <strong>일부를 도려내는(Carve)</strong> 데 성공했고, 도구 끝을 찔러 <strong>자국을 내는(Poke/Press)</strong> 작업도 수행했습니다. 특히 실험 중 흥미로운 관찰은, <strong>Carve 동작 시 손가락 하나를 추가로 지지대로 사용</strong>하여 성능을 높일 수 있다는 점이었습니다. 구체적으로, 도구를 세 손가락으로 파듯이 누를 때 <strong>검지 손가락의 다른 마디 부분을 도구에 기대어 4번째 접촉</strong>을 만들어주니 자르는 힘 전달이 훨씬 향상되었습니다. 이는 원래 설계나 경로 계획에는 고려되지 않았던 접촉이지만, 실제 운용에서 <strong>로봇 손의 구조를 이용해 자연스럽게 얻어진 부가적 접촉</strong>으로 볼 수 있습니다. 이처럼 <strong>현실 세계의 마찰력, 추가 접촉 등</strong>이 설계 단계에서 가정한 것보다 유리하게 작용할 수도 있음을 보여주었는데, 반대로 말하면 설계 단계에서 배제한 요소들도 실제에서는 중요함을 시사합니다. 그럼에도 불구하고 전반적인 실험 결과는, <strong>FP를 기반으로 설계된 손이 실제 환경에서도 유의미한 작업을 수행할 수 있다</strong>는 것을 증명했습니다. 이는 본 연구의 주된 아이디어가 시뮬레이션 속 이론에 머무르지 않고 현실에 적용될 수 있음을 보여준 의미 있는 성과입니다.</p>
<p> <em>그림 3</em> – <strong>실험 결과 및 로봇 손 동작 장면</strong>. (위) 시뮬레이션으로 생성된 손 설계들의 성능 분포를 나타낸 그래프 예시. 2차원 설계공간(좌)과 6차원 설계공간(우)의 경우에 대해, Carve(검정), Poke(빨강), Press(파랑) 세 동작에서 확보한 도구 회전 각도가 임의 임계값(threshold)을 넘는 설계의 비율을 나타낸 누적 분포 곡선이다. 6차원 경우 (오른쪽 그래프) Carve 곡선(검정)이 좌측으로 치우쳐 있어, Carve 동작이 다른 동작보다 성공 조건을 만족시키기 어려움을 보여준다. (아래) 개발된 로봇 손 프로토타입이 실제 <strong>찰흙 덩어리</strong>에 대해 도구 사용 동작을 수행하는 장면들. <strong>Carve</strong>: 도구를 세 손가락으로 쥐고 찰흙을 도려냄. 이때 <strong>Bracing</strong>이라고 표시된 사진처럼, 검지 손가락의 다른 부분을 도구에 댐으로써 추가 지지 접촉을 형성하여 자르는 힘을 보강하였다 (초록색 원으로 표시). <strong>Poke</strong>: 도구 끝을 찰흙에 찔러 자국을 냄. <strong>Press</strong>: 도구를 쥔 채로 찰흙을 눌러서 평평하게 만드는 동작.</p>
</section>
<section id="주요-기여와-한계점" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="주요-기여와-한계점"><span class="header-section-number">2.5</span> 주요 기여와 한계점</h2>
<p>이 연구는 <strong>도구-사용 다지 로봇 손 설계</strong> 분야에 여러 중요한 기여를 했습니다.</p>
<p>첫째, <strong>Foundational Pose</strong>라는 새로운 개념을 도입하여, <strong>복잡한 도구 사용 동작을 단일 자세로 대표</strong>할 수 있다는 통찰을 제시했습니다. 이를 설계 과정의 <strong>선택 메커니즘(selection mechanism)</strong>으로 활용함으로써, 로봇 손이 특정 작업을 수행할 수 있는지를 간단히 판단할 수 있는 기준을 마련했습니다.</p>
<p>둘째, FP 개념을 활용한 <strong>샘플링 기반 설계 프레임워크</strong>를 개발하여, 전통적으로 난해한 다목적 손 설계 문제를 <strong>체계적으로 탐색</strong>했습니다. 하나의 “최적” 디자인만 찾는 대신 수많은 설계를 비교함으로써, <strong>설계 공간의 지형(landscape)</strong>을 파악하고 다양한 대안을 식별할 수 있음을 보였습니다. 특히 성능 군집화와 Pareto 해 분석을 통해, <strong>여러 가지 손 설계 철학들이 공존</strong>할 수 있음을 밝혔습니다.</p>
<p>셋째, <strong>시뮬레이션 검증</strong>에서 수치적으로 FP 가설의 타당성을 증명했을 뿐 아니라, <strong>실제 로봇 손 프로토타입</strong>으로 사람처럼 도구를 사용하는 데 성공함으로써 연구의 <strong>실용적 가능성</strong>을 시연했습니다. 흥미롭게도, 설계 시 고려하지 않은 추가 접촉의 이점 등 <strong>현실적인 통찰</strong>도 얻어내어 향후 설계에 반영할 수 있는 교훈을 제공했습니다. 요약하면, 본 논문은 <strong>“FP를 만족하면 그 손은 해당 도구를 다룰 수 있다”</strong>는 아이디어를 제안하고 입증함으로써, 향후 <strong>손 설계 및 조작 계획</strong> 연구에 새로운 길을 제시한 것입니다.</p>
<p>물론 이 연구에는 <strong>한계점</strong>도 존재합니다:</p>
<ul>
<li><strong>FP 범위의 한정:</strong> 본 논문에서 다룬 Foundational Pose들은 <strong>연구진이 수작업으로 식별하고 설정</strong>한 세 가지 경우에 불과합니다. 보다 일반적인 다른 도구나 작업에도 이 개념이 확장 가능한지는 추가 연구가 필요합니다. 예를 들어 망치질이나 드릴 사용 같은 전혀 다른 유형의 도구 동작에 대해서도 적절한 FP를 정의할 수 있을지는 미지수입니다.</li>
<li><strong>성능 지표 미반영:</strong> 설계 후보를 생성할 때 <strong>FP 형성 여부와 정적 안정성</strong>만을 고려했고, 실제 평가된 <strong>동적 성능 지표(운동 범위, 토크 등)</strong>는 생성 단계 최적화에 직접 활용되지 않았습니다. 그 결과 FP는 만족하지만 <strong>동작 품질이 떨어지는 설계</strong>들도 일부 생성되었습니다. 이는 <strong>자세와 정적 조건 외에 동적 요인(속도, 관성 등)</strong>도 설계에 반영할 필요가 있음을 시사합니다.</li>
<li><strong>고차원 탐색의 한계:</strong> 설계 공간 차원이 높아질수록 (여기서는 6D) <strong>필요한 샘플 수가 기하급수적으로 증가</strong>하여 모든 영역을 탐색하기 어렵고, 성능 분포를 <strong>직관적으로 시각화</strong>하는 것도 힘듭니다. 본 연구의 샘플링 효율은 6차원에서 점차 떨어져 약 1% 수준에서 중단되었는데, 차원이 더 늘어나면 현재 방식의 한계에 부딪힐 것으로 보입니다.</li>
</ul>
<p>이러한 한계들은 곧 향후 연구 방향이기도 합니다. 저자들은 <strong>설계 군집 분석</strong>을 더욱 심화하여 여러 <strong>손 설계 패밀리</strong>를 구분하고자 하며, 도구 사용 중의 <strong>속도와 힘(동적 요소)</strong>까지 고려하는 손의 <strong>설계 및 제어 최적화</strong>로 확장할 계획을 밝혔습니다. 더 나아가, 현재는 도구 사용에 초점을 맞췄지만 <strong>FP 개념을 보다 일반적인 섬세 조작(dexterous manipulation)</strong> 영역으로 넓혀, 예컨대 비도구적인 물체 조작 작업 등에도 적용할 수 있을지 연구할 것이라고 합니다.</p>
</section>
<section id="기존-접근법과의-비교" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="기존-접근법과의-비교"><span class="header-section-number">2.6</span> 기존 접근법과의 비교</h2>
<p>이번 연구의 FP 기반 손 설계 접근법은 기존의 여러 접근들과 대비됩니다. <strong>전통적인 설계 방법</strong>으로는 사람 전문가가 손 구조를 직접 구상하는 수동 설계(manual design)와, 컴퓨터로 미리 정한 목표를 최적화하는 과업 중심 최적화(task-centric optimization)를 들 수 있습니다. 수동 설계의 경우 인간의 풍부한 경험과 직관이 반영된다는 장점이 있지만, <strong>설계 공간이 복잡하고 넓기 때문에 놓치는 영역이 많을 수밖에 없습니다</strong>. 예를 들어 손가락 길이를 조금씩 바꾼 수백 가지 변형을 사람 머리로 모두 상상해보긴 어렵습니다.</p>
<p>반면 과업 중심의 자동 최적화는 컴퓨터의 계산력을 빌려 다양한 설계를 시험해볼 수 있지만, 보통 <strong>하나의 특정 목표</strong>(예: 특정 작업에서의 힘 전달 효율 등)만을 최적화하기 쉽고 다른 성능들은 희생되기 쉽습니다. 더욱이, 다수의 목표를 동시에 고려하면 문제는 다목적 최적화로 변질되어 <strong>단일 최적해가 존재하지 않게 되고</strong>, 결국 <strong>여러 가지 트레이드오프 해들(Pareto front)</strong>을 검토해야 하는데, 기존 방법론 중 많은 경우는 이를 하나의 가중치 합산 문제 등으로 단순화하여 <strong>국소 최적해</strong>만 찾는 경향이 있습니다. 이는 인간이 설계 시 적용하는 휴리스틱(경험적 요령)을 컴퓨터의 알고리즘 휴리스틱으로 바꿔치기 한 것에 불과하며, 문제 공간에 내재한 <strong>풍부한 대안들을 포착하지 못할 위험</strong>이 있습니다.</p>
<p>FP 기반 접근은 이들 기존 방식의 <strong>장단점을 절충 및 보완</strong>한다고 볼 수 있습니다. 우선 특정 작업 자체를 정교하게 최적화하지 않고 <strong>해당 작업의 핵심 자세(Foundational Pose)</strong>에 집중함으로써, 문제를 <strong>단순화</strong>하면서도 작업 특성을 놓치지 않았습니다. 이는 완전한 과업 최적화에 비해 계산량을 줄이고 해석을 용이하게 해주며, 동시에 단순 <strong>운반 동작이 아닌 도구 활용 동작의 본질</strong>을 설계에 반영하도록 합니다. 또한 하나의 설계를 출력하는 대신 <strong>다양한 설계 후보를 생성</strong>하여 그 성능을 비교하게 함으로써, 설계자가 <strong>여러 가능한 해법을 살펴보고 선택</strong>할 수 있게 합니다. 예컨대 본 연구에서는 특정 손가락 길이를 극단적으로 길게 하거나 짧게 한 디자인들도 FP 조건을 만족한다면 함께 분석되었고, 그 중 어떤 것은 힘 전달에 유리하지만 어떤 것은 제어가 쉬운 식으로 <strong>서로 다른 장단점</strong>을 지니는 것이 드러났습니다 (성능 군집의 형태로 나타남). 이런 정보는 기존에 하나의 최적값만 보고 끝내는 방식에서는 얻기 어려운 것입니다.</p>
<p>또한 FP 접근은 <strong>인간 공학적 설계 철학</strong>과 상충되지 않습니다. 실제로 이 연구는 기본 손 형태를 인간 손과 유사하게 설정한 뒤 파라미터를 변화시켰고, 그 결과 선정된 최종 디자인도 인간 손과 매우 흡사한 비율을 가지면서도 미묘한 조정(손바닥 폭, 엄지 각도 등)이 더해진 것이었습니다. 이는 <strong>인간 전문가의 초기 디자인 + 알고리즘적 탐색</strong>의 조합으로 볼 수도 있으며, 완전 자동 최적화에 비해 결과 해석이 직관적이고 구현도 수월합니다. 다른 한편으로는, 기존의 <strong>작업 중심 최적화 연구들</strong>에서 도입된 개념들도 활용되었습니다. 예를 들어 로봇과 도구(또는 환경)를 하나의 병렬 기구로 취급하는 관점, 그리고 여러 설계를 생성하여 성능 지형을 분석하는 기법은 이전에도 부분적으로 시도된 바 있는데, 본 연구는 여기에 <strong>FP라는 도메인 지식</strong>을 통합함으로써 <strong>도구 사용 손 설계</strong>라는 특수한 문제에 잘 들어맞는 프레임워크를 구축했습니다.</p>
<p>정리하면, Foundational Pose에 기반한 설계 방법은 <strong>기존의 수동 혹은 단일-최적화 접근</strong>에 비해 <strong>효율성과 통찰을 모두 향상</strong>시켰습니다. 이는 복잡한 로봇 손 설계 문제를 푸는 데 있어 하나의 예시적 진전이며, 앞으로 도구 사용 뿐만 아니라 일반적인 다지 로봇 손의 섬세 조작 설계에도 <strong>응용 범위가 확대</strong>될 것으로 기대됩니다. FP 개념을 통해 <strong>“이 손이 이 자세를 취할 수 있는가”</strong>라는 물음만으로 설계 선택을 거를 수 있게 된 것은, 향후 설계 자동화와 로봇 학습 등에서도 유용한 아이디어가 될 것입니다.</p>
<p><strong>Reference</strong> - Sunyu Wang, Jean H. Oh, Nancy S. Pollard, <em>“The Foundational Pose as a Selection Mechanism for the Design of Tool-Wielding Multi-Finger Robotic Hands,”</em> arXiv preprint arXiv:2409.14158, 2024.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>