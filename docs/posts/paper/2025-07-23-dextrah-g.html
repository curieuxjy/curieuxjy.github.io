<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-07-23">
<meta name="description" content="Chaining Dexterous Policies for Long-Horizon Manipulation">

<title>ğŸ“ƒSequential Dexterity ë¦¬ë·° â€“ Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ef56b68f8fa1e9d2ba328e99e439f80.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-b009f778f5cec7f34f624408a2b5b543.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review"><span class="header-section-number">1</span> Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review"><span class="header-section-number">2</span> Detail Review</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction"><span class="header-section-number">2.1</span> Introduction</a></li>
  <li><a href="#methodology-summary" id="toc-methodology-summary" class="nav-link" data-scroll-target="#methodology-summary"><span class="header-section-number">2.2</span> Methodology Summary</a></li>
  <li><a href="#key-innovations-and-differences-from-prior-work" id="toc-key-innovations-and-differences-from-prior-work" class="nav-link" data-scroll-target="#key-innovations-and-differences-from-prior-work"><span class="header-section-number">2.3</span> Key Innovations and Differences from Prior Work</a></li>
  <li><a href="#evaluation-and-results" id="toc-evaluation-and-results" class="nav-link" data-scroll-target="#evaluation-and-results"><span class="header-section-number">2.4</span> Evaluation and Results</a></li>
  <li><a href="#limitations" id="toc-limitations" class="nav-link" data-scroll-target="#limitations"><span class="header-section-number">2.5</span> Limitations</a></li>
  <li><a href="#final-assessment" id="toc-final-assessment" class="nav-link" data-scroll-target="#final-assessment"><span class="header-section-number">2.6</span> Final Assessment</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ğŸ“ƒSequential Dexterity ë¦¬ë·°</h1>
  <div class="quarto-categories">
    <div class="quarto-category">rl</div>
    <div class="quarto-category">assembly</div>
    <div class="quarto-category">hand</div>
  </div>
  </div>

<div>
  <div class="description">
    Chaining Dexterous Policies for Long-Horizon Manipulation
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 23, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://arxiv.org/abs/2407.02274">Paper Link</a></li>
<li><a href="https://sites.google.com/view/dextrah-g">Project Link</a></li>
</ul>
<ol type="1">
<li>ğŸ¤– DextrAH-GëŠ” Reinforcement Learning(RL)ê³¼ geometric fabrics, teacher-student distillationì„ ê²°í•©í•˜ì—¬ ì‹œë®¬ë ˆì´ì…˜ì—ì„œë§Œ í›ˆë ¨ëœ, ëìŠ¤ ì´ë¯¸ì§€ ê¸°ë°˜ì˜ ì •êµí•œ ë¡œë´‡ íŒ”-ì† ê·¸ë¦½ ì •ì±…ì…ë‹ˆë‹¤.</li>
<li>ğŸ› ï¸ ì´ ì‹œìŠ¤í…œì€ ê³ ì°¨ì› ê³µê°„, sim2real gap, ì¶©ëŒ íšŒí”¼ ë“± ì£¼ìš” ë‚œì œë¥¼ í•´ê²°í•˜ë©°, geometric fabricsë¡œ í•˜ë“œì›¨ì–´ ì•ˆì „ê³¼ í–‰ë™ ìœ ë„ë¥¼ ë³´ì¥í•˜ê³ , êµì‚¬-í•™ìƒ ì¦ë¥˜(distillation)ë¥¼ í†µí•´ ì‹¤ì œ í™˜ê²½ìœ¼ë¡œì˜ ì œë¡œ-ìƒ· ì „ì´(transfer)ë¥¼ ì„±ê³µì‹œì¼°ìŠµë‹ˆë‹¤.</li>
<li>ğŸš€ DextrAH-GëŠ” ì‹¤ì œ í™˜ê²½ì—ì„œ ë‹¤ì–‘í•œ ì‹ ê·œ ë¬¼ì²´ë¥¼ ì„±ê³µì ìœ¼ë¡œ íŒŒì§€ ë° ìš´ë°˜í•˜ë©°, 87%ì˜ ì„±ê³µë¥ ê³¼ ë¶„ë‹¹ 5.63íšŒ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•œ ìµœì²¨ë‹¨ ì„±ëŠ¥ì„ ì‹œì—°í–ˆê³ , í…ŒìŠ¤íŠ¸ ì¤‘ í•˜ë“œì›¨ì–´ ì†ìƒì´ ì „í˜€ ì—†ì–´ ë†’ì€ ì•ˆì „ì„±ì„ ì…ì¦í–ˆìŠµë‹ˆë‹¤.</li>
</ol>
<center>
<img src="../../images/2025-07-23-dextrah-g/2.gif" width="80%">
</center>
<hr>
<section id="brief-review" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Brief Review</h1>
<p>DextrAH-GëŠ” ê°•í™” í•™ìŠµ(RL), Geometric Fabrics, ê·¸ë¦¬ê³  êµì‚¬-í•™ìƒ ì¦ë¥˜(teacher-student distillation)ë¥¼ ê²°í•©í•˜ì—¬ ì‹œë®¬ë ˆì´ì…˜ í™˜ê²½ì—ì„œë§Œ í•™ìŠµí•˜ê³  ì‹¤ì œ ì„¸ê³„ì— ì œë¡œ-ìƒ·(zero-shot)ìœ¼ë¡œ ì „ì´ë  ìˆ˜ ìˆëŠ” ê¹Šì´(depth) ê¸°ë°˜ì˜ ëŠ¥ìˆ™í•œ íŒ”-ì† ë¡œë´‡ ì¡°ì‘(arm-hand grasping) ì •ì±…ì…ë‹ˆë‹¤. ì´ ì—°êµ¬ëŠ” ê³ ì°¨ì› ê´€ì¸¡ ë° í–‰ë™ ê³µê°„, sim2real gap, ì¶©ëŒ íšŒí”¼, í•˜ë“œì›¨ì–´ ì œì•½ ë“± ê´€ì ˆí˜• íŒ”-ì† ì •ì±… í•™ìŠµì˜ ì£¼ìš” ë‚œì œë¥¼ í•´ê²°í•©ë‹ˆë‹¤. DextrAH-GëŠ” 23ê°œì˜ ëª¨í„°ë¥¼ ê°€ì§„ ë¡œë´‡ì´ ìŠ¤íŠ¸ë¦¬ë° ê¹Šì´ ì´ë¯¸ì§€(streaming depth images)ë¥¼ ì‚¬ìš©í•˜ì—¬ ë‹¤ì–‘í•œ ë¬¼ì²´ë¥¼ ê³ ì†ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ì—°ì†ì ìœ¼ë¡œ ì¡ê³  ìš´ë°˜í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.</p>
<p>ì´ ì—°êµ¬ì˜ ì£¼ìš” ê¸°ì—¬ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤: 1. ì •ì±… í•™ìŠµì„ ìœ„í•œ ê·€ë‚©ì  í¸í–¥(inductive bias)ì„ ìƒì„±í•˜ê³ , ì¶©ëŒì„ í”¼í•˜ë©°, ê´€ì ˆ ì œì•½ì„ ìœ ì§€í•˜ê³ , í–‰ë™ì„ í˜•ì„±í•˜ëŠ” ë²¡í„°í™”ëœ Geometric Fabric controller. 2. ë²¡í„°í™”ëœ Geometric Fabrics ìœ„ì—ì„œ ì—¬ëŸ¬ ë‹¤ë¥¸ ë¬¼ì²´ì— ëŒ€í•œ ê³ ì„±ëŠ¥ ì¡°ì‘ì„ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ì‹œë®¬ë ˆì´ì…˜ ì „ìš© RL í›ˆë ¨ì˜ privileged FGP(Fabric-Guided Policy). 3. ì›ë˜ í–‰ë™ì„ ë³µì œí•˜ê³  ë¬¼ì²´ ìœ„ì¹˜ ì˜ˆì¸¡ì„ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ê¹Šì´(depth) ê¸°ë°˜, ë‹¤ì¤‘ ëª¨ë‹¬(multi-modal) FGPì˜ privileged FGP ì¦ë¥˜(distillation). 4. ì‹¤ì œ ì„¸ê³„ì˜ ë‹¤ì–‘í•œ ìƒˆë¡œìš´ ë¬¼ì²´ì— ëŒ€í•œ ìµœì‹  ëŠ¥ìˆ™í•œ ë¡œë´‡ ì¡°ì‘ ì„±ëŠ¥ì„ ë‹¬ì„±í•œ DextrAH-Gì˜ ì œë¡œ-ìƒ· sim2real ì „ì´(transfer).</p>
<p><strong>1. Geometric Fabrics ë° Fabric-Guided Policies (FGPs)</strong></p>
<p>Geometric FabricsëŠ” ê³ ì „ ì—­í•™ ì‹œìŠ¤í…œì˜ í–‰ë™ì„ ì¼ë°˜í™”í•˜ì—¬ ì„¤ê³„ ìœ ì—°ì„±, ì¡°í•©ì„± ë° ì•ˆì •ì„±ì„ ê°–ì¶˜ ì œì–´ê¸°ë¥¼ ëª¨ë¸ë§í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤. Geometric Fabricì€ ë‹¤ìŒ í˜•íƒœì˜ ë°©ì •ì‹ì„ ë”°ë¦…ë‹ˆë‹¤: <span class="math display">M_f (q_f , \dot{q}_f )\ddot{q}_f + f_f (q_f , \dot{q}_f ) + f_\pi (a) = 0</span> ì—¬ê¸°ì„œ <span class="math inline">M_f \in \mathbb{R}^{n \times n}</span>ëŠ” ì‹œìŠ¤í…œì˜ ìš°ì„ ìˆœìœ„ë¥¼ í¬ì°©í•˜ëŠ” ì–‘ì˜ ì •ë¶€í˜¸ ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­(mass), <span class="math inline">f_f \in \mathbb{R}^n</span>ëŠ” ëª…ëª© ê²½ë¡œ ìƒì„± Geometric Force, <span class="math inline">f_\pi (a) \in \mathbb{R}^n</span>ëŠ” í–‰ë™ <span class="math inline">a \in \mathbb{R}^m</span>ì— ëŒ€í•œ ì¶”ê°€ êµ¬ë™ë ¥ì…ë‹ˆë‹¤. <span class="math inline">q_f, \dot{q}_f, \ddot{q}_f \in \mathbb{R}^n</span>ëŠ” Fabricì˜ ìœ„ì¹˜, ì†ë„, ê°€ì†ë„ì…ë‹ˆë‹¤. ì´ ë°©ì •ì‹ì€ Fabric ìƒíƒœ <span class="math inline">q_f</span>ì™€ <span class="math inline">\dot{q}_f</span>ë¥¼ ì‹œê°„ì— ë”°ë¼ ì§„í™”ì‹œí‚¤ëŠ” ê°€ì†ë„ <span class="math inline">\ddot{q}_f</span>ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. <span class="math inline">f_\pi</span>ëŠ” <span class="math inline">\ddot{q}_f</span>ì— ì˜í–¥ì„ ë¯¸ì¹˜ë¯€ë¡œ Fabric ìƒíƒœì— ì˜í–¥ì„ ì¤ë‹ˆë‹¤.</p>
<p>Geometric Fabric controllerëŠ” ë„¤ ê°€ì§€ ì£¼ìš” ì´ìœ ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤: 1) ì›ì¹˜ ì•ŠëŠ” ì¶©ëŒ íšŒí”¼, 2) ì •ì±… íƒìƒ‰ì„ ë™ì‹œì— ìœ ë„í•˜ê³  ì „ì²´ ë¡œë´‡ ì›€ì§ì„ì„ ìœ ë¦¬í•˜ê²Œ í˜•ì„±í•˜ëŠ” ë…¸ì¶œëœ í–‰ë™ ê³µê°„ì„ í†µí•œ ê·€ë‚©ì  í¸í–¥ ìƒì„±, 3) ê´€ì ˆ ì œì•½ ì¡°ê±´ ì¤€ìˆ˜, 4) ìš´ë™í•™ì  ì¡°ì‘ì„±ì„ ì´‰ì§„í•˜ê¸° ìœ„í•œ ë¡œë´‡ ìì„¸ ìœ ì§€.</p>
<ul>
<li><p><strong>ì¶©ëŒ íšŒí”¼(Collision Avoidance):</strong> í™˜ê²½ ë° ìì²´ ì¶©ëŒ íšŒí”¼ëŠ” Geometric Fabric í•­ê³¼ forcing Fabric í•­ì„ í†µí•´ ì²˜ë¦¬ë©ë‹ˆë‹¤. ë¡œë´‡ì˜ ê¸°í•˜í•™ì  êµ¬ì¡°ëŠ” êµ¬(spheres)ì˜ ì§‘í•©ìœ¼ë¡œ ëª¨ë¸ë§ë©ë‹ˆë‹¤. <span class="math inline">x = \phi_{fk}(q) \in \mathbb{R}^3</span>ëŠ” ë¡œë´‡ êµ¬ì„±ì—ì„œ ê° êµ¬ì˜ ì›ì ìœ¼ë¡œì˜ í¬ì›Œë“œ ìš´ë™í•™ ë§¤í•‘ì…ë‹ˆë‹¤. <span class="math inline">\hat{n}_i = \frac{r_i-x}{\|r_i-x\|} \in \mathbb{R}^3</span>ëŠ” êµ¬ ì ì—ì„œ ì¶©ëŒ ë¬¼ì²´ <span class="math inline">i</span>ì˜ ê°€ì¥ ê°€ê¹Œìš´ ì  <span class="math inline">r_i \in \mathbb{R}^3</span>ê¹Œì§€ì˜ ë°©í–¥ì…ë‹ˆë‹¤. <span class="math inline">d_i = \max(d_{min}, d_i) \in \mathbb{R}^+</span>ëŠ” í•˜í•œì´ ìˆëŠ” ê±°ë¦¬ì…ë‹ˆë‹¤. Geometric ê°€ì†ë„ëŠ” <span class="math inline">\ddot{x} = k_g \|\dot{x}\|^2 \hat{\ddot{x}}_b</span>ì´ë©°, forcing ê°€ì†ë„ëŠ” <span class="math inline">\ddot{x} = k_f \hat{\ddot{x}}_b - b \dot{x}</span>ì…ë‹ˆë‹¤. ì—¬ê¸°ì„œ <span class="math inline">\ddot{x}_b = - \sum_i \frac{1}{d_i}\hat{n}_i</span>ëŠ” ì¶©ëŒì—ì„œ ë©€ì–´ì§€ëŠ” êµ¬ë‹¹ ê¸°ë³¸ ê°€ì†ë„ ë°˜ì‘ì…ë‹ˆë‹¤. Fabricì˜ ë©”íŠ¸ë¦­ì€ <span class="math inline">M = \beta e_d^2 \hat{M}_b</span>ë¡œ ì„¤ê³„ë˜ë©°, ì—¬ê¸°ì„œ <span class="math inline">e_d = \min_i\{d_i\}</span>ì…ë‹ˆë‹¤. <span class="math inline">M_b = \sum_i s_i d_i \hat{n}_i \otimes \hat{n}_i</span>ëŠ” êµ¬ë‹¹ ê¸°ë³¸ ë©”íŠ¸ë¦­ ë°˜ì‘ì´ë©°, <span class="math inline">s_i = \frac{1}{2} \tanh(-\alpha_1(v_i - \alpha_2) + 1)</span>ëŠ” êµ¬ê°€ ì¶©ëŒ ë¬¼ì²´ <span class="math inline">i</span>ë¡œ í–¥í•  ë•Œ í™œì„±í™”ë˜ëŠ” ìŠ¤ë¬´ìŠ¤ ì†ë„ ê²Œì´íŠ¸ì…ë‹ˆë‹¤(<span class="math inline">v_i = - \dot{x} \cdot \hat{n}_i</span>).</p></li>
<li><p><strong>í–‰ë™ ê³µê°„(Action Space):</strong> Allegro handì˜ ê²½ìš°, ì‚¬ëŒì˜ ì¡°ì‘ ë°ì´í„°(human grasping motion data)ë¥¼ Allegro handì— ë¦¬íƒ€ê²ŸíŒ…(retargeting)í•˜ê³  ì£¼ì„±ë¶„ ë¶„ì„(PCA)ì„ ì ìš©í•˜ì—¬ 5ì°¨ì› íŠ¹ì„± ì¡°ì‘(eigengrasp) ë§¤ë‹ˆí´ë“œë¥¼ ìƒì„±í•©ë‹ˆë‹¤. PCAë¥¼ í†µí•´ ì–»ì€ ì²˜ìŒ ë‹¤ì„¯ ê°œì˜ ì£¼ì„±ë¶„ <span class="math inline">A \in \mathbb{R}^{5 \times 16}</span>ì„ ì‚¬ìš©í•˜ì—¬ <span class="math inline">e_A = [0, A] \in \mathbb{R}^{5 \times 23}</span>ë¡œ ì •ì˜ëœ íƒœìŠ¤í¬ ë§µ(taskmap) <span class="math inline">x = e_A q \in \mathbb{R}^5</span>ë¥¼ ë§Œë“­ë‹ˆë‹¤. ì´ ê³µê°„ì—ì„œ ì¸ë ¥ Fabric í•­ì„ ì •ì˜í•˜ë©°, ë©”íŠ¸ë¦­ <span class="math inline">M(x) = mI</span>ì´ê³  ê°€ì†ë„ <span class="math inline">\ddot{x} = -k_a \tanh(\alpha_a\|x-x_{pca,target}\|) \frac{x-x_{pca,target}}{\|x-x_{pca,target}\|} -b \dot{x}</span>ì…ë‹ˆë‹¤. <span class="math inline">x_{pca,target}</span>ëŠ” 5ì°¨ì› ì† í–‰ë™ ê³µê°„ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤. íŒ” ì œì–´ë¥¼ ìœ„í•´ íŒœ(palm)ì— ë¶€ì°©ëœ 7ê°œì˜ 3ì°¨ì› ì ì„ 21ì°¨ì› ê³µê°„ìœ¼ë¡œ ë§¤í•‘í•˜ëŠ” ìƒˆë¡œìš´ íƒœìŠ¤í¬ ë§µì„ ìƒì„±í•©ë‹ˆë‹¤. íŒ”ì„ ìœ„í•œ 6ì°¨ì› í–‰ë™ ê³µê°„ì€ ëª©í‘œ íŒœ ìœ„ì¹˜ <span class="math inline">x_{f,target} \in \mathbb{R}^3</span>ì™€ ëª©í‘œ íŒœ ì˜¤ë¦¬ì—”í…Œì´ì…˜(Euler angles) <span class="math inline">r_{f,target} \in \mathbb{R}^3</span>ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤. ì „ì²´ ë¡œë´‡ì— ëŒ€í•œ í–‰ë™ ê³µê°„ì€ ì´ 11ì°¨ì›ì…ë‹ˆë‹¤.</p></li>
<li><p><strong>ê´€ì ˆ ì œì•½ ì¡°ê±´(Joint Constraints):</strong> Fabricì€ 2ì°¨ ì œì–´ê¸°ì´ë¯€ë¡œ, ê´€ì ˆ ê°€ì†ë„ ë° ì €í¬(jerk) ì œí•œì€ íì‡„í˜•ìœ¼ë¡œ ì²˜ë¦¬ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ì´ì°¨ ê³„íš(quadratic program)ì„ í’€ì–´ ì²˜ë¦¬í•©ë‹ˆë‹¤: <span class="math inline">L = \frac{1}{2} (\ddot{q}_f - \ddot{q})^T M_f (\ddot{q}_f - \ddot{q}) + \alpha^2 \ddot{q}_f^T M_f \ddot{q}_f</span> ì—¬ê¸°ì„œ <span class="math inline">\ddot{q}_f = -(M_f + \alpha I)^{-1}f_f</span>ì´ë©°, <span class="math inline">\alpha \rightarrow \infty</span>ì¼ ë•Œ <span class="math inline">||\ddot{q}_f|| \rightarrow 0</span>ì…ë‹ˆë‹¤. ë˜í•œ, ê´€ì ˆ ìœ„ì¹˜ ì œí•œì€ Fabricì˜ ê´€ì ˆ ë°˜ë°œ í•­ì„ í†µí•´ ì ìš©ë©ë‹ˆë‹¤.</p></li>
<li><p><strong>ìì„¸ ì œì–´(Posture Control):</strong> ë¡œë´‡ì˜ ì œì–´ë˜ëŠ” ê´€ì ˆë³´ë‹¤ Fabricì˜ ë…¸ì¶œëœ í–‰ë™ ê³µê°„ì˜ ì°¨ì›ì´ ì ê¸° ë•Œë¬¸ì— ì¤‘ë³µì„± ë¬¸ì œ(redundancy issues)ë¥¼ í•´ê²°í•´ì•¼ í•©ë‹ˆë‹¤. ì´ëŠ” êµ¬ì„± ê³µê°„(configuration space)ì˜ ê¸°í•˜í•™ì  ì¸ë ¥(geometric attractor)ì„ ë”°ë¦„ìœ¼ë¡œì¨ ë‹¬ì„±ë©ë‹ˆë‹¤. Fabricì´ ë¡œë´‡ ì „ì²´ ì›€ì§ì„ì„ êµ¬ì„± ê³µê°„ì˜ <span class="math inline">x_g</span>ë¡œ ì•ˆë‚´í•˜ë˜, PCA ë° í¬ì¦ˆ íƒœìŠ¤í¬ ë§µì—ì„œì˜ <span class="math inline">x_g</span>ë¡œì˜ ìˆ˜ë ´ì„ ë°©í•´í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.</p></li>
</ul>
<p><strong>2. Teacher Privileged FGP í›ˆë ¨ (ê°•í™” í•™ìŠµ)</strong></p>
<p>ëŠ¥ìˆ™í•œ ì¡°ì‘ì€ ê°•í™” í•™ìŠµ ë¬¸ì œë¡œ ê°„ì£¼ë˜ë©°, ì‹œë®¬ë ˆì´ì…˜ì—ì„œ privileged-state teacher policyê°€ 140ê°€ì§€ ë‹¤ë¥¸ ë¬¼ì²´ë¥¼ ëŠ¥ìˆ™í•˜ê²Œ ì¡°ì‘í•˜ë„ë¡ í›ˆë ¨ë©ë‹ˆë‹¤. Geometric Fabric í–‰ë™ ê³µê°„ì€ ë¡œë´‡ì´ ì•ˆì „í•˜ê³  ìì—°ìŠ¤ëŸ¬ìš´ í–‰ë™ì„ ìˆ˜í–‰í•˜ë„ë¡ ë³´ì¥í•˜ë¯€ë¡œ, ë³´ìƒ ì„¤ê³„ëŠ” ì „ì ìœ¼ë¡œ ì†ê°€ë½ ë-ë¬¼ì²´ ì ‘ì´‰ ë° ë¬¼ì²´ë¥¼ ëª©í‘œ ìœ„ì¹˜ë¡œ ë“¤ì–´ ì˜¬ë¦¬ëŠ” ë° ì¤‘ì ì„ ë‘¡ë‹ˆë‹¤.</p>
<ul>
<li><strong>ë¹„ëŒ€ì¹­ ì•¡í„°-í¬ë¦¬í‹±(Asymmetric Actor Critic):</strong> ì‹¤ì œ ì„¸ê³„ì— ë°°í¬ë  ë•Œ ì œì–´ ì •ì±…ì€ privileged ì‹œë®¬ë ˆì´ì…˜ ìƒíƒœ ì •ë³´ì— ì ‘ê·¼í•  ìˆ˜ ì—†ì§€ë§Œ, privileged ì •ë³´ëŠ” ì‹œë®¬ë ˆì´ì…˜ í›ˆë ¨ ì†ë„ë¥¼ ë†’ì´ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. í¬ë¦¬í‹± <span class="math inline">V(s)</span>ëŠ” ëª¨ë“  privileged ìƒíƒœ ì •ë³´ <span class="math inline">s</span>ë¥¼ ì–»ê³ , teacher policy <span class="math inline">\pi_{privileged}(o_{privileged})</span>ëŠ” ì´ privileged ìƒíƒœ ì •ë³´ì˜ ì œí•œëœ ë¶€ë¶„ì¸ ê´€ì¸¡ <span class="math inline">o_{privileged}</span>ë¥¼ ì–»ìŠµë‹ˆë‹¤.
<ul>
<li>Teacher policyì˜ ê´€ì¸¡ <span class="math inline">o_{privileged}</span>ëŠ” ë¡œë´‡ì˜ cspace ìœ„ì¹˜ <span class="math inline">q</span>, cspace ì†ë„ <span class="math inline">\dot{q}</span> (ì´ 23ê°œ), íŒœì˜ ì„¸ ì§€ì  ìœ„ì¹˜ <span class="math inline">x_{palm}, x_{palm-x}, x_{palm-y}</span>, 4ê°œ ì†ê°€ë½ ëì˜ ìœ„ì¹˜ <span class="math inline">x_{fingertips}</span>, Fabric ìƒíƒœ <span class="math inline">q_f, \dot{q}_f, \ddot{q}_f</span>, ëª©í‘œ ë¬¼ì²´ ìœ„ì¹˜ <span class="math inline">x_{goal}</span>, ê·¸ë¦¬ê³  ë…¸ì´ì¦ˆê°€ ìˆëŠ” ë¬¼ì²´ ìœ„ì¹˜ <span class="math inline">ex_{obj}</span> ë° ì¿¼í„°ë‹ˆì–¸ <span class="math inline">eq_{obj}</span>, ë¬¼ì²´ one-hot embedding <span class="math inline">e</span>ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.</li>
<li>í¬ë¦¬í‹±ì˜ ì…ë ¥ ìƒíƒœ <span class="math inline">s</span>ëŠ” <span class="math inline">o_{privileged}</span>ì™€ í•¨ê»˜ ë¡œë´‡ ê´€ì ˆë ¥ <span class="math inline">f_{dof}</span>, ì†ê°€ë½ ë ì ‘ì´‰ë ¥ <span class="math inline">f_{fingers}</span>, ì‹¤ì œ ë¬¼ì²´ ìœ„ì¹˜ <span class="math inline">x_{obj}</span>, ì‹¤ì œ ë¬¼ì²´ ì¿¼í„°ë‹ˆì–¸ <span class="math inline">q_{obj}</span>, ì‹¤ì œ ë¬¼ì²´ ì†ë„ <span class="math inline">v_{obj}</span>, ì‹¤ì œ ê°ì†ë„ <span class="math inline">w_{obj}</span>ë¥¼ í¬í•¨í•˜ëŠ” privileged ìƒíƒœ ì •ë³´ <span class="math inline">s_{privileged}</span>ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.</li>
<li>Teacher policyì˜ í–‰ë™ <span class="math inline">a</span>ëŠ” Underlying Geometric Fabricì— ëŒ€í•œ ì…ë ¥ìœ¼ë¡œ, ëª©í‘œ íŒœ ìœ„ì¹˜ <span class="math inline">x_{f,target} \in \mathbb{R}^3</span>, ëª©í‘œ íŒœ ì˜¤ë¦¬ì—”í…Œì´ì…˜ <span class="math inline">r_{f,target} \in \mathbb{R}^3</span>, ì†ê°€ë½ì˜ ëª©í‘œ PCA ìœ„ì¹˜ <span class="math inline">x_{pca,target} \in \mathbb{R}^5</span>ë¡œ êµ¬ì„±ëœ 11ì°¨ì› ë²¡í„°ì…ë‹ˆë‹¤. Fabricì€ 60Hzë¡œ í†µí•©ë˜ê³  ì‹œë®¬ë ˆì´ì…˜ì€ 60Hzë¡œ ì§„í–‰ë˜ë©°, Teacher policyëŠ” 15Hzë¡œ ì‹¤í–‰ë©ë‹ˆë‹¤.</li>
</ul></li>
<li><strong>ê°•ê±´í•œ ì¡°ì‘ì„ ìœ„í•œ í™˜ê²½ ìˆ˜ì •(Environment Modifications for Robust Grasping):</strong>
<ul>
<li><strong>ëœë¤ ë Œì¹˜ êµë€(Random Wrench Perturbations):</strong> ë¬¼ì²´ë¥¼ ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•˜ê²Œ ì›€ì§ì´ê³  íšŒì „ì‹œí‚¤ëŠ” ëœë¤ ë Œì¹˜ë¥¼ ì ìš©í•©ë‹ˆë‹¤. <span class="math inline">f_{perturb} = f_{scale} m u_f</span> ë° <span class="math inline">\tau_{perturb} = \tau_{scale} I u_\tau</span> (í™•ë¥  <span class="math inline">p=0.1</span>ë¡œ).</li>
<li><strong>í¬ì¦ˆ ë…¸ì´ì¦ˆ(Pose Noise):</strong> ë¬¼ì²´ í¬ì¦ˆ ê´€ì¸¡ì— ë¹„ìƒê´€(uncorrelated) ë° ìƒê´€(correlated) ë…¸ì´ì¦ˆë¥¼ ì¶”ê°€í•˜ì—¬ ìœ„ì¹˜ ë° ê¸°í•˜í•™ì  ë¶ˆí™•ì‹¤ì„±ì„ ì„¤ëª…í•˜ê³  ì†ì´ ë¬¼ì²´ì— ì ‘ê·¼í•  ë•Œ ë” ë„“ê²Œ ì—´ë¦¬ë„ë¡ ìœ ë„í•©ë‹ˆë‹¤.</li>
<li><strong>ë§ˆì°° ê°ì†Œ(Friction Reduction):</strong> ë¬¼ì²´ì˜ ê¸°ë³¸ ë§ˆì°° ê³„ìˆ˜ë¥¼ <span class="math inline">\mu = 0.7</span>ë¡œ ì¤„ì—¬ ë§ˆì°°ì— ì§€ë‚˜ì¹˜ê²Œ ì˜ì¡´í•˜ëŠ” ì¡°ì‘ í–‰ë™ì„ ì™„í™”í•©ë‹ˆë‹¤.</li>
<li><strong>ë„ë©”ì¸ ë¬´ì‘ìœ„í™”(Domain Randomization):</strong> ì‹œë®¬ë ˆì´ì…˜ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ ë„ë©”ì¸ ë¬´ì‘ìœ„í™”ë¥¼ ì‚¬ìš©í•˜ì—¬ ë‹¤ì–‘í•œ ë™ì  ìŠ¤í™íŠ¸ëŸ¼ì— ê±¸ì³ ê°•ê±´í•œ ì •ì±…ì„ í•™ìŠµí•©ë‹ˆë‹¤.</li>
</ul></li>
<li><strong>ë³´ìƒ í•¨ìˆ˜(Reward Function):</strong> ë³´ìƒì€ ê°œë³„ ë³´ìƒ í•­ <span class="math inline">r = \sum_i w_i r_i</span>ì˜ ê°€ì¤‘ í•©ìœ¼ë¡œ ì •ì˜ë©ë‹ˆë‹¤.
<ul>
<li><span class="math inline">r_{to-obj} = \text{minimize}(\|x_{fingertips} - x_{obj}\|)</span></li>
<li><span class="math inline">r_{lift} = \text{minimize}(z_{lifted} - z(x_{obj})) \times (1 - \text{lifted}(x_{obj}))</span></li>
<li><span class="math inline">r_{lifted} = \text{lifted}(x_{obj})</span> (ì²« ë²ˆì§¸ íƒ€ì„ìŠ¤í…)</li>
<li><span class="math inline">r_{to-goal} = \text{minimize}(\|x_{goal} - x_{obj}\|) \times \text{lifted}(x_{obj})</span></li>
<li><span class="math inline">r_{reached} = \mathbb{1}(\|x_{goal} - x_{obj}\| &lt; d_{success})</span></li>
<li><span class="math inline">r_{success} = \mathbb{1}(r_{reached} = 1 \text{ for } T_{success} \text{ consecutive timesteps}) \times (T_{max} - T)</span> ì—¬ê¸°ì„œ <span class="math inline">\text{minimize}(e)</span> í•¨ìˆ˜ëŠ” ì˜¤ì°¨ <span class="math inline">e</span>ê°€ í˜„ì¬ê¹Œì§€ì˜ ìµœì†Œ ì˜¤ì°¨ <span class="math inline">e_{smallest}</span>ë³´ë‹¤ ì‘ì•„ì§ˆ ë•Œë§Œ ì–‘ì˜ ë³´ìƒì„ ì œê³µí•©ë‹ˆë‹¤. <span class="math inline">\mathbb{1}(c)</span>ëŠ” ì¡°ê±´ <span class="math inline">c</span>ê°€ ì°¸ì´ë©´ 1, ì•„ë‹ˆë©´ 0ì…ë‹ˆë‹¤. í™˜ê²½ì€ ë¬¼ì²´ê°€ í…Œì´ë¸” ì•„ë˜ë¡œ ë–¨ì–´ì§€ê±°ë‚˜, <span class="math inline">r_{success}</span> ë³´ìƒì„ ë°›ê±°ë‚˜, ì—í”¼ì†Œë“œ ì‹œê°„ ì œí•œì— ë„ë‹¬í•˜ë©´ ë¦¬ì…‹ë©ë‹ˆë‹¤.</li>
</ul></li>
</ul>
<p><strong>3. Student Depth FGP í›ˆë ¨ (ì •ì±… ì¦ë¥˜)</strong></p>
<p>êµì‚¬-í•™ìƒ í”„ë ˆì„ì›Œí¬ì™€ ì˜¨ë¼ì¸ DAgger[23]ë¥¼ ì‚¬ìš©í•˜ì—¬ ì „ë¬¸ê°€ ì •ì±…ì„ ì‹¤ì œ ì„¸ê³„ì— ë°°í¬í•  ìˆ˜ ìˆëŠ” í•™ìƒ ì •ì±…ìœ¼ë¡œ ì¦ë¥˜í•©ë‹ˆë‹¤. ì´ ì¦ë¥˜ëŠ” 15Hzë¡œ ì—°ì†ì ì¸ ì´ë¯¸ì§€ ì…ë ¥ì„ ì‚¬ìš©í•˜ì—¬ ì‹¤ì œ ì„¸ê³„ì—ì„œ ë°˜ì‘ì ì´ê³  ë™ì ì¸ ì¡°ì‘ì„ ìˆ˜í–‰í•˜ëŠ” pixels-to-action ì •ì±…ì„ ë§Œë“­ë‹ˆë‹¤.</p>
<ul>
<li><strong>ì…ë ¥ ë° ì¶œë ¥:</strong> ì¦ë¥˜ ì¤‘ í•™ìƒ ì •ì±… <span class="math inline">\pi_{depth}(o_{depth})</span>ëŠ” ë¡œë´‡ ìƒíƒœ <span class="math inline">o_{robot}</span>, ëª©í‘œ ìœ„ì¹˜ <span class="math inline">x_{goal}</span>, ê·¸ë¦¬ê³  ì›ì‹œ ê¹Šì´ ì´ë¯¸ì§€ <span class="math inline">I \in [0.5, 1.5]^{160 \times 120}m</span>ë¥¼ í¬í•¨í•˜ëŠ” ê´€ì¸¡ <span class="math inline">o_{depth}</span>ë¥¼ ë°›ìŠµë‹ˆë‹¤. í•™ìƒì€ í–‰ë™ <span class="math inline">\hat{a} \in \mathbb{R}^{11}</span>ê³¼ ë¬¼ì²´ ìœ„ì¹˜ ì˜ˆì¸¡ <span class="math inline">\hat{x}_{obj} \in \mathbb{R}^3</span>ì„ ì¶œë ¥í•©ë‹ˆë‹¤.</li>
<li><strong>ì†ì‹¤ í•¨ìˆ˜(Loss Function):</strong> í•™ìƒì€ ê°ë… ì†ì‹¤ <span class="math inline">L = L_{action} + \beta L_{pos}</span>ë¡œ í›ˆë ¨ë©ë‹ˆë‹¤. ì—¬ê¸°ì„œ <span class="math inline">L_{action} = \|\hat{a} - a\|^2</span>ì´ê³  <span class="math inline">L_{pos} = \|\hat{x}_{obj} - x_{obj}\|^2</span>ì…ë‹ˆë‹¤. <span class="math inline">a</span>ëŠ” teacher policy <span class="math inline">\pi_{privileged}</span>ê°€ ì˜ˆì¸¡í•œ í–‰ë™ì´ê³  <span class="math inline">x_{obj}</span>ëŠ” ì‹œë®¬ë ˆì´í„°ì˜ ground-truth ë¬¼ì²´ ìœ„ì¹˜ì…ë‹ˆë‹¤.</li>
<li><strong>ê¹Šì´ ì´ë¯¸ì§€ ì¦ê°•(Depth Image Augmentations):</strong> ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ë Œë”ë§ëœ ê¹Šì´ ì´ë¯¸ì§€ì— í”½ì…€ ë“œë¡­ì•„ì›ƒ, ëœë¤ ê°’ ì„¤ì •, ì„ í˜• ì„¸ê·¸ë¨¼íŠ¸(robot wires mimic), ë¹„ìƒê´€/ìƒê´€ ê¹Šì´ ë…¸ì´ì¦ˆ ëª¨ë¸ ë“± ë‹¤ì–‘í•œ ì¦ê°•ì´ ì¶”ê°€ë©ë‹ˆë‹¤.</li>
</ul>
<p><strong>4. ì‹¤í—˜ ë° ê²°ê³¼</strong></p>
<ul>
<li><strong>ì‹œë®¬ë ˆì´ì…˜:</strong> <span class="math inline">\pi_{depth}</span>ëŠ” 140ê°œì˜ í›ˆë ¨ ë¬¼ì²´ì— ëŒ€í•´ í‰ê·  99%ì˜ ì„±ê³µë¥ ì„ ê¸°ë¡í•˜ì—¬ <span class="math inline">\pi_{privileged}</span>ì˜ ì„±ëŠ¥ê³¼ ê±°ì˜ ì¼ì¹˜í•©ë‹ˆë‹¤. ë¬¼ì²´ë‹¹ í‰ê·  80%ì˜ ì„±ê³µë¥ ì„ ë³´ì˜€ìŠµë‹ˆë‹¤.</li>
<li><strong>ì‹¤ì œ ì„¸ê³„(Real-World):</strong>
<ul>
<li><strong>í•˜ë“œì›¨ì–´ ì„¤ì •:</strong> Allegro Handê°€ Kuka LBR iiwa armì— ì¥ì°©ë˜ì–´ ìˆê³ , Intel Realsense D415 ì¹´ë©”ë¼ê°€ í…Œì´ë¸”ì— ê³ ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ë¡œë´‡ì€ 23ê°œì˜ ë…ë¦½ì ì¸ ëª¨í„°ë¥¼ ê°€ì§€ë©°, ë‹¨ì¼ ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ì„ ì •ì±… ì…ë ¥ìœ¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤. ê´€ì ˆ PD ì œì–´ê¸°ëŠ” íŒ”ì— ëŒ€í•´ 1kHz, ì†ì— ëŒ€í•´ 333Hzë¡œ ì‘ë™í•©ë‹ˆë‹¤. Geometric Fabricì€ 60Hzë¡œ, <span class="math inline">\pi_{depth}</span>ëŠ” 15Hzë¡œ ì‘ë™í•©ë‹ˆë‹¤.</li>
<li><strong>ë‹¨ì¼ ë¬¼ì²´ ì¡°ì‘ í‰ê°€(Single Object Grasping Assessment):</strong> 11ê°œì˜ í‘œì¤€ ë¬¼ì²´ì— ëŒ€í•´ ì‹œë„ë‹¹ 5ë²ˆì˜ ì¡°ì‘ì„ ìˆ˜í–‰í•œ ê²°ê³¼, DextrAH-GëŠ” Table 1ì— ë³´ê³ ëœ ë°”ì™€ ê°™ì´ ìƒˆë¡œìš´ ìµœì²¨ë‹¨ ì¡°ì‘ ì„±ê³µë¥ ì„ ë‹¬ì„±í–ˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, PitcherëŠ” 80%, PringlesëŠ” 100%, Coffee ContainerëŠ” 100%, Cupì€ 80% ë“±ì˜ ì„±ê³µë¥ ì„ ë³´ì˜€ìŠµë‹ˆë‹¤.</li>
<li><strong>ë¹ˆ íŒ¨í‚¹ í‰ê°€(Bin Packing Assessment):</strong> 30ê°€ì§€ ì´ìƒì˜ ë‹¤ì–‘í•œ ë¬¼ì²´ë¥¼ ì—°ì†ì ìœ¼ë¡œ ì¡ê³  ì˜†ì— ë†“ì¸ ë¹ˆìœ¼ë¡œ ìš´ë°˜í•˜ëŠ” í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤.
<ul>
<li><strong>ì—°ì† ì„±ê³µ(CS):</strong> DextrAH-GëŠ” 8ë²ˆì˜ ì‹œë„ì—ì„œ í‰ê·  6.56 Â± 2.41ê°œì˜ ë¬¼ì²´ë¥¼ ì—°ì†ì ìœ¼ë¡œ ìš´ë°˜í–ˆìŠµë‹ˆë‹¤.</li>
<li><strong>ì‚¬ì´í´ ì‹œê°„(Cycle time):</strong> í‰ê·  10.66 Â± 0.84ì´ˆ, ì¦‰ ë¶„ë‹¹ 5.63íšŒ ì§‘ê¸°(PPM)ì˜ ì†ë„ë¥¼ ê¸°ë¡í–ˆìŠµë‹ˆë‹¤.</li>
<li><strong>ì„±ê³µë¥ :</strong> ì´ 256ë²ˆì˜ ì‹œë„ ì¤‘ 87%ì˜ ì„±ê³µë¥ ë¡œ ëª¨ë“  ë¬¼ì²´ë¥¼ ì„±ê³µì ìœ¼ë¡œ ì¡ê³  ìš´ë°˜í–ˆìŠµë‹ˆë‹¤.</li>
</ul></li>
</ul></li>
</ul>
<p>DextrAH-GëŠ” ì´ëŸ¬í•œ ê²°ê³¼ë¥¼ í†µí•´ ëŠ¥ìˆ™í•œ ë¡œë´‡ ì¡°ì‘ ë¶„ì•¼ì—ì„œ ìµœì²¨ë‹¨ ì„±ëŠ¥ì„ í¬ê²Œ ë°œì „ì‹œì¼°ìœ¼ë©°, ì‹¤ì œ ì„¸ê³„ ì‘ìš©ì— ë” ê°€ê¹Œì›Œì¡ŒìŠµë‹ˆë‹¤. ìˆ˜ë§ì€ í…ŒìŠ¤íŠ¸ ì‹œê°„ ë™ì•ˆ í•˜ë“œì›¨ì–´ ì†ìƒì€ ë°œìƒí•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.</p>
<p><strong>5. í•œê³„(Limitations)</strong></p>
<p>DextrAH-Gì˜ í•œê³„ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:</p>
<ol type="1">
<li>FGPê°€ ì†ê°€ë½ ì œì–´ë¥¼ ìœ„í•´ PCA íƒœìŠ¤í¬ ë§µì—ì„œ ëª©í‘œë¥¼ ë°œí–‰í•˜ë¯€ë¡œ ë¡œë´‡ì˜ ìš´ë™í•™ì  ë¯¼ì²©ì„±ì„ ì œí•œí•©ë‹ˆë‹¤.</li>
<li>ëª¨ë¸ ê¸°ë°˜ í–‰ë™ì— ëŒ€í•œ ì˜ì¡´ë„ë¥¼ ì¤„ì´ê¸° ìœ„í•´ ê°ê° ì…ë ¥ ê¸°ë°˜ì˜ ì¥ì• ë¬¼ íšŒí”¼ í–‰ë™ì´ í•™ìŠµë˜ì–´ì•¼ í•©ë‹ˆë‹¤. Fabricì˜ ì¥ì• ë¬¼ íšŒí”¼ëŠ” ë¡œë´‡ì´ í…Œì´ë¸”ê³¼ ì‹¬ê°í•˜ê²Œ ì¶©ëŒí•˜ëŠ” ê²ƒì„ ë§‰ì§€ë§Œ, ì €ìì„¸ ë¬¼ì²´ì— ëŒ€í•œ íš¨ê³¼ì ì¸ íƒìƒ‰ì„ ì–´ë µê²Œ í•˜ì—¬ ì„±ëŠ¥ì„ ì €í•˜ì‹œí‚µë‹ˆë‹¤.</li>
<li>ì¥ë©´ì—ì„œ í•œ ë²ˆì— í•˜ë‚˜ì˜ ë¬¼ì²´ë§Œ ì²˜ë¦¬í•  ìˆ˜ ìˆìœ¼ë©°, ë³µì¡í•œ í™˜ê²½ì—ì„œ íš¨ê³¼ì ìœ¼ë¡œ ì‘ë™í•˜ë ¤ë©´ ë¶„í• (segmentation)ê³¼ ê°™ì€ ì¶”ê°€ ë³€ê²½ì´ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
</ol>
<hr>
</section>
<section id="detail-review" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Detail Review</h1>
<blockquote class="blockquote">
<p>Review of <em>â€œDextrAH-G: Pixels-to-Action Dexterous Arm-Hand Grasping with Geometric Fabricsâ€</em></p>
</blockquote>
<section id="introduction" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">2.1</span> Introduction</h2>
<p>Achieving <strong>fast, safe, and robust dexterous grasping</strong> across diverse objects remains a core challenge in robotics. Traditional grasping pipelines often separate perception, grasp pose planning, and execution, which can limit responsiveness and coordination between a robotâ€™s arm and hand. Many existing methods compute a grasp pose from vision and then rely on a motion planner or predefined controller to reach that pose. This approach is <strong>not continuously reactive</strong> and typically does not jointly plan through all degrees-of-freedom (DOFs) of a dexterous arm-hand system, often ignoring coordinated finger-arm adjustments after grasping. Furthermore, prior solutions frequently suffer from <strong>limited speed, unnatural motions, poor generalization,</strong> or lack safety guarantees (e.g.&nbsp;risk of self-collisions or joint limit violations). These limitations hinder real-world deployment in tasks like warehouse bin picking or home assistance, where a robot must rapidly grasp a variety of unknown objects safely and reliably.</p>
<p><strong>DextrAH-G</strong> (Dexterous Arm-Hand Grasping with Geometric Fabrics) is a new system that directly addresses these challenges. It introduces a <strong>pixels-to-actions policy</strong> for a 23-DOF robotic arm-hand (7-DOF robot arm + 16-DOF Allegro hand) that continuously <strong>reacts to streaming depth images</strong> to grasp and transport objects in real time. The policy is trained entirely in simulation and deployed <strong>zero-shot</strong> on real hardware, achieving <strong>state-of-the-art dexterous grasping performance</strong> on many novel objects without any on-hardware fine-tuning. A key insight of DextrAH-G is to combine <strong>deep reinforcement learning (RL)</strong> with a <strong>geometric fabric controller</strong> and a <strong>teacherâ€“student distillation</strong> strategy. This integrated approach provides several benefits: (1) the geometric fabric imposes physics-based constraints and bias that ensure safety and natural motion, (2) the RL policy learns on top of this fabric, simplifying learning by focusing on high-level objectives, and (3) a privileged teacher policy (with access to additional state information) is distilled into a <strong>vision-based student policy</strong>, enabling robust perception-to-control mapping.</p>
<p>In summary, <strong>DextrAH-G</strong> offers a <strong>unified arm-hand grasping framework</strong> that is <strong>continuously reactive</strong>, <strong>safety-guaranteed</strong>, and <strong>generalizes</strong> across object geometries. It represents a significant step toward â€œgrasp anythingâ€ capability in dexterous robotics. This review will delve into the <strong>proposed methodology</strong> â€“ how DextrAH-Gâ€™s architecture works and how <strong>Geometric Fabrics</strong> are integrated â€“ and highlight <strong>key innovations and differences</strong> from prior works. We will also summarize the <strong>experimental results</strong> that validate the approach, discuss <strong>limitations</strong>, and provide a final assessment of the workâ€™s impact.</p>
</section>
<section id="methodology-summary" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="methodology-summary"><span class="header-section-number">2.2</span> Methodology Summary</h2>
<p><strong>System Overview:</strong> <em>DextrAH-G</em> comprises a <strong>fabric-guided policy (FGP)</strong> layered on top of a <strong>geometric fabric controller</strong>. The fabric controller serves as a low-level motion generator that respects safety constraints, while the high-level policy issues goals (actions) in an abstract action space defined by the fabric. The overall training and deployment pipeline has three stages: (1) Train a <strong>privileged teacher FGP</strong> in simulation via reinforcement learning (the teacher has access to certain state information for easier learning), (2) <strong>Distill</strong> this teacher policy into a <strong>student FGP</strong> that uses only realistic inputs (depth images and proprioception), and (3) <strong>Deploy</strong> the student policy on the real robot zero-shot, using a simple state machine to handle repetitive grasp-and-drop cycles. Figure 2 illustrates this pipeline: a teacher policy is trained in a vectorized simulation environment, then a student is learned from it, and finally the learned policy is run on a real robot performing continuous bin-picking.</p>
<p> <em>Figure 2: Overview of the DextrAH-G framework. A teacher policy is trained with reinforcement learning over a geometric fabric controller (top). The teacherâ€™s behavior is then distilled into a depth-image-based student policy (middle). At deployment, the student policy controls a 23-DOF arm-hand robot in real time, coordinated by a state machine for continuous grasp-and-transport tasks (bottom). The geometric fabric runs as an underlying controller throughout, ensuring safety and shaping motions.</em></p>
<p><strong>Geometric Fabric Controller:</strong> At the core of DextrAH-G is a <strong>geometric fabrics</strong>-based controller that drives the robotâ€™s joint motions. Geometric fabrics are a mathematical framework that generalizes classical mechanics and Riemannian Motion Policies (RMPs) to design stable, composable motion behaviors. In essence, a fabric defines a second-order dynamical system: it specifies a state-dependent metric (analogous to a mass/inertia matrix) and a set of potential fields or â€œforcesâ€ that govern acceleration of the system. Multiple fabric terms can be combined, each encoding a desired behavior (e.g.&nbsp;move toward a target, avoid collision), and the framework guarantees <strong>stable and smooth motions</strong> without sacrificing modeling fidelity. Prior work showed that fabric-based controllers can outperform RMPs and other motion primitives in complex tasks, providing strong theoretical underpinnings for stability and optimality.</p>
<p>For DextrAH-G, the authors design <strong>the most feature-rich geometric fabric to date</strong> for an arm-hand system. This fabric controller explicitly handles:</p>
<ul>
<li><strong>Joint Limit Enforcement:</strong> Joint angle and velocity limits are incorporated into the fabric (similarly to prior work by Allshire et al.) to ensure the robot never commands motions outside its safe joint range. This guarantees hardware safety by construction.</li>
<li><strong>Collision Avoidance:</strong> Both <strong>self-collisions</strong> and <strong>environment collisions</strong> are avoided through dedicated fabric terms. The robotâ€™s geometry is approximated by a set of spheres on each link; using forward kinematics, the fabric monitors distances between these spheres and any obstacles (including the robotâ€™s own links or the table). If a sphere approaches a collision, the fabric generates a <strong>repulsive acceleration</strong> pushing the robot away from the obstacle. The avoidance behavior is tuned to be <strong>velocity-aware</strong> (slowing or diverting motion toward collision) and to produce smooth, <strong>speed-invariant evasive paths</strong>. A damping term prevents any residual penetration when near contact, ensuring the robot safely slows as it nears a surface. These design elements let the robot operate quickly while <strong>provably preventing crashes</strong>, even if the high-level policy issues aggressive or unsafe commands.</li>
<li><strong>Posture and Redundancy Control:</strong> A fabric term is included to maintain a favorable arm posture for dexterous manipulation. In high-DOF systems, there are typically infinitely many arm configurations (elbow angles, etc.) to reach a target pose. The DextrAH-G fabric biases the arm toward configurations that maximize <strong>kinematic manipulability</strong> and natural movement (details are given in Appendix, but intuitively it means the arm avoids kinematic singularities or overly stretched postures). This <strong>posture-shaping</strong> fabric guides the robot to move in a human-like, balanced way without explicit instruction.</li>
<li><strong>Low-Dimensional Action Spaces:</strong> Perhaps most critically, the fabric exposes a <strong>compressed action space</strong> for the RL policy. Directly controlling all 23 joints would be a huge action space for learning. The authors leverage human grasping synergies to reduce this dimensionality. They retargeted a dataset of human grasp motions to the robot hand and performed a <strong>Principal Component Analysis (PCA)</strong> on these motions. The first 5 principal components of finger joint movement (which capture common grasp shapes like power grasps and pinch grasps) form a 5-dimensional <strong>hand action manifold</strong>. Essentially, rather than commanding each finger joint, the policy will command a 5-D vector that corresponds to a coordinated finger posture (a combination of joint movements) along human-derived grasp axes. Likewise, for the arm, instead of commanding 7 joint angles, the policy controls the <strong>end-effector (palm) pose</strong> in 6 dimensions (3 for translation and 3 for orientation). The fabric maps these 6-D end-effector targets to the full arm joint motions by treating the palm as a rigid body with multiple reference points (7 points on the palm, giving a 21-D configuration space that the fabric controller uses internally). In summary, the <strong>policyâ€™s action space is 11-D</strong> (5 dimensions for hand configuration + 6 for arm pose), which greatly simplifies learning while still affording dexterous control. The geometric fabric continuously converts these 11-D high-level actions into smooth 23-D joint commands at 60 Hz, obeying all the above constraints. This acts as a form of <strong>inductive bias</strong> â€“ the policyâ€™s outputs always result in safe, reasonable motions, so the RL agent can focus on <em>what</em> grasping motion to perform rather than <em>how</em> to execute it safely.</li>
</ul>
<p><strong>Reinforcement Learning of a Privileged Teacher Policy:</strong> With the fabric in place, the authors formulate dexterous grasping as an RL problem. They train a <strong>teacher policy</strong> in simulation using a massive set of 140 diverse objects. The teacher is a <em>fabric-guided policy</em> (FGP) â€“ meaning its actions are the 11-D target commands (palm pose + PCA finger coordinates) that get fed into the fabric controller. Training such a policy end-to-end from pixels would be difficult, so they adopt an <strong>asymmetric actor-critic</strong> approach with privileged information. In asymmetric training, the <strong>critic</strong> (value function) has access to full state information (ground-truth object pose, velocities, contact forces, etc.) to better judge the value of states, while the <strong>actor (policy)</strong> is given a limited, more realistic observation. Notably, the teacherâ€™s observation is not raw pixels but rather a curated set of state features: it includes the robotâ€™s proprioceptive state (joint positions/velocities, fingertip positions, etc.), the fabricâ€™s internal state, and a <strong>noisy estimate of the objectâ€™s position and orientation</strong>, along with a one-hot object identity vector. By providing the objectâ€™s approximate pose (with noise) and an object ID, the teacher policy can learn grasp strategies specific to the object geometry without needing to infer everything from vision. At the same time, the added noise and the limited sensing (no raw image) ensure the teacher doesnâ€™t become too reliant on perfectly accurate state information, which the student wonâ€™t have. The critic, on the other hand, gets the true object state and contact forces, enabling more precise reward estimation and helping stabilize training.</p>
<p>Thanks to the geometric fabricâ€™s guarantees, the <strong>reward function</strong> for RL can be kept remarkably simple. The fabric already prevents collisions or unnatural motions, so the reward focuses on <strong>what matters for grasp success</strong>: encouraging the fingers to make contact with the object and lifting the object off the table to a target height. In fact, the authors report that the reward is <em>entirely centered on fingertip-object contact and lifting the object</em>, with no terms needed for collision avoidance or arm posture. This significantly reduces reward shaping effort and avoids â€œreward hackingâ€ behaviors, since the policy doesnâ€™t get extraneous incentives beyond grasp success. The training was done in a <em>vectorized simulation</em> (likely using a platform like NVIDIA Isaac Gym, given the involvement of NVIDIA) to collect massive experience. To promote <strong>robustness and generalization</strong>, the authors applied several environment randomizations and perturbations during training: random wrench forces were applied to objects to disturb them (forcing the policy to learn strong, stable grasps), noise was added to the perceived object pose (making the teacher open the hand wider or be tolerant to uncertainty), the friction of objects was artificially reduced (preventing the policy from relying on unrealistically high friction), and standard domain randomization (varying simulation dynamics, textures, etc.) was used to bridge the sim-to-real gap. These measures encourage the learned policy to be <strong>robust to perturbations, sensing errors, and different object properties</strong>, which is crucial for success in the real world.</p>
<p>After training, the teacher FGP is a policy that takes in a partial state observation and outputs an 11-D action (target arm pose and hand PCA coordinates) at <strong>15 Hz</strong>, which is then upsampled by the fabric controller (running at 60 Hz) to smooth joint commands. This teacher achieved high performance in simulation (as we will discuss in the results section). However, the teacher still relies on knowing an approximate object pose and identity â€“ information that would come from a vision system in reality. Instead of building a separate object estimator, the authors opt to <strong>distill this expertise into a single depth-based policy</strong>.</p>
<p><strong>Student Policy Distillation (Depth-Based FGP):</strong> The next stage is to obtain a <strong>vision-driven policy</strong> that can replace the teacher. DextrAH-G employs a <strong>teacherâ€“student distillation via DAgger (Dataset Aggregation)</strong>. In the distillation process, the <strong>student</strong> policy is a neural network that takes <strong>raw depth images</strong> (from an onboard depth camera) along with the robotâ€™s proprioceptive readings as input, and outputs the same type of action as the teacher (the 11-D fabric action) <em>plus an auxiliary prediction of the objectâ€™s 3D position</em>. The student is trained in simulation by having it mimic the teacherâ€™s actions: at each time-step, the student observes the depth image of the scene and the robot state, and the teacher provides the â€œground truthâ€ action for that state. The training uses a supervised loss that penalizes the difference between the studentâ€™s predicted action and the teacherâ€™s action, as well as the error in the studentâ€™s predicted object position (compared to the true object position in simulation). Essentially, the student learns to imitate the teacherâ€™s control decisions and simultaneously perform <strong>object pose estimation</strong> from depth. Importantly, because the student fuses depth vision with proprioceptive inputs, its internal estimate of object position can be more <strong>robust to occlusions</strong> (e.g., fingers partially blocking the object) than an external vision module alone. The authors note that the studentâ€™s learned object position prediction is accurate enough to be used by the high-level state machine (to know, for example, when an object has been grasped and lifted). To further aid sim-to-real transfer, the depth images in training are augmented with realistic noise and distractor artifacts (to resemble real sensor data with clutter or imperfect readings). After this imitation learning stage (which can be thought of as <em>online learning from the teacher</em> in simulation), the resulting student FGP is a <strong>15 Hz closed-loop vision policy</strong>: it observes depth frames continuously and outputs smooth arm-hand actions through the geometric fabric controller, now <strong>without needing any explicit object pose input</strong>.</p>
<p><strong>Real-World Deployment:</strong> The final system, dubbed <strong>DextrAH-G</strong>, consists of the learned depth-based student policy running in tandem with the geometric fabric controller on a real robot. A simple finite-state machine coordinates the overall <strong>grasp-and-transport sequence</strong>. In practice, this means the robot will: look for an object, reach and grasp it under policy control, then once grasped, switch to a transport sub-policy to move the object to a drop location (e.g.&nbsp;a bin) and release it, then reset for the next object. The policy handles the continuous movements during reaching and grasping, while the state machine likely handles discrete events like â€œobject lifted â€“ now transition to drop motionâ€ using the studentâ€™s predicted object position and contact feedback. Importantly, the <strong>geometric fabric runs in real time (60 Hz)</strong> on the robot, taking the studentâ€™s 15 Hz high-level commands and ensuring all motions remain safe and smooth. The authors emphasize that even if the learned policy were to output a hazardous action (say, moving the arm quickly toward a wall or singular configuration), the fabric controller would automatically modulate that into a safe behavior or refuse to execute motions that violate constraints. In fact, during extensive hardware testing, <strong>no damage occurred to the robot</strong>, attesting to the safety guarantees provided by the fabric-based control layer.</p>
<p>In summary, the DextrAH-G methodology marries <strong>learning and control</strong>: a sophisticated model-based controller (geometric fabric) provides a scaffold that makes training feasible and safe, and in turn a learned policy can operate directly from perceptual inputs to achieve dexterous grasping. This design addresses many challenges of joint arm-hand manipulation, as we will contrast with prior approaches next.</p>
</section>
<section id="key-innovations-and-differences-from-prior-work" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="key-innovations-and-differences-from-prior-work"><span class="header-section-number">2.3</span> Key Innovations and Differences from Prior Work</h2>
<p>DextrAH-G introduces several innovations and improvements over prior <strong>arm-hand grasping frameworks</strong>:</p>
<ul>
<li><p><strong>Integrated Arm-Hand <em>Pixels-to-Actions</em> Control:</strong> Unlike many previous dexterous grasping methods that decompose the problem (e.g.&nbsp;first select a grasp for the hand, then plan an arm motion), DextrAH-G learns a <em>unified policy</em> that jointly controls <strong>all DOFs of the arm and hand</strong> in one closed-loop system. Prior works often focused either on the hand manipulation given a fixed end-effector pose or assumed a separate arm motion planner. For example, Agarwal et al.&nbsp;(2022) first selected a pre-grasp position via vision and then used a â€œblindâ€ hand policy (eigen-grasp based) to close the fingers. Qin et al.&nbsp;(2023) trained a hand policy conditioned on point clouds for objects in a single category. <strong>In contrast, DextrAH-Gâ€™s policy uses depth images to simultaneously decide how to move the arm and fingers</strong>, resulting in more <strong>agile and coordinated</strong> reaches and grasp closures. This end-to-end perception-to-control approach allows reactive adjustment of the arm and hand throughout the grasp â€“ if the object shifts or is in a different pose, the policy can continuously correct the arm-hand trajectory. The result is a more <strong>dynamic and generalizable behavior across novel objects</strong> than methods that rely on a fixed grasp pose followed by open-loop execution.</p></li>
<li><p><strong>Use of Geometric Fabrics for Safe and Bias-Shaped Control:</strong> A major novelty of DextrAH-G is leveraging a <strong>geometric fabric controller</strong> to underpin learning. Many prior RL-based robotic policies simply output joint torques or desired joint positions to a low-level PD controller. Such simple controllers place the entire burden of achieving sophisticated behavior on the neural policy, which is prone to learning unnatural or unsafe strategies (e.g., jerky motions, visiting dangerous states). DextrAH-G instead embeds expert knowledge of physics and kinematics into the control layer. This <strong>fabric-guided policy (FGP)</strong> approach was previously explored in a much simpler context (in-hand cube reorientation) by Allshire et al., who found it dramatically improved learning outcomes. DextrAH-G extends this idea to <em>grasping</em>, building the most extensive fabric to date with features like integrated collision avoidance, joint limit handling, posture optimization, and custom action manifolds. By doing so, it <strong>guarantees hardware safety</strong> (the robot will not self-collision or exceed limits) and produces <strong>natural, human-like motions</strong> by design. This is a key differentiator: earlier works had to accept slow or conservative motions to ensure safety, or they risked damage during fast maneuvers. DextrAH-G can move at high speeds confidently because the geometric fabric enforces safety continuously. Moreover, the fabric <strong>provides an inductive bias</strong> for learning. The policy operates in a <em>reduced action space</em> (the 11-D space of meaningful arm-hand movements) which simplifies the learning problem compared to controlling 23 raw joints. Similar dimension reduction existed in some prior work (e.g.&nbsp;Agarwalâ€™s use of an eigengrasp space for the hand), but DextrAH-Gâ€™s approach is more holistic â€“ it couples arm and hand synergies and does so within a reactive motion framework (RMP/fabric) that blends multiple objectives. Additionally, geometric fabrics come with rigorous mathematical tools, and have been shown to outperform alternative motion representation frameworks like Dynamic Movement Primitives (DMPs) or Koopman operator approaches in comparable settings. By choosing geometric fabrics, the authors build on a strong theoretical foundation for <strong>composable, stable behavior</strong> synthesis.</p></li>
<li><p><strong>Teacher-Student Training for Perception and Generalization:</strong> Another differentiator is the <strong>two-stage training</strong> (privileged RL teacher then vision-based student). Prior deep dexterous grasping methods often struggled with generalization when training directly from pixels or needed enormous data. For instance, some works require collecting large grasp datasets or point cloud simulations to pre-train grasp proposals, and others rely on known object models or categories to succeed (e.g.&nbsp;Liu et al.&nbsp;needed object models registered to point clouds). DextrAH-G bypasses the need for any labeled grasp datasets or prior object models by training entirely in simulation with reinforcement learning. The asymmetric teacher policy makes learning more efficient by utilizing additional state information (object pose, etc.) without requiring the student to have it. This <strong>privileged training</strong> paradigm has been used in legged locomotion and manipulation (to leverage simulation state), but in dexterous grasping it is relatively novel and powerful â€“ it allows the teacher to attain a high level of performance with less training time or tricky exploration. Then, via <strong>online distillation (DAgger)</strong>, DextrAH-G successfully transfers that capability to a <strong>vision-based student</strong>. The result is an end-to-end <strong>depth image to action</strong> policy that is both skilled and robust. This addresses the sim-to-real gap more elegantly than some prior approaches. For example, other works have attempted zero-shot sim-to-real by heavy domain randomization alone or by using coarse perception (like classifying object identity then using a specific strategy). Here, the combination of domain randomization, robust teacher training, and supervised distillation yields a policy that directly handles real depth images and varied objects without additional real-world fine-tuning. The authors explicitly demonstrate <strong>generalization to novel objects</strong> outside the training set, which we discuss below (achieving high success on unseen objects) â€“ a feat that many earlier RL-based graspers did not evaluate or achieve to this extent.</p></li>
<li><p><strong>High Speed and Continuous Reactivity:</strong> DextrAH-G distinguishes itself in terms of <strong>operational speed and closed-loop reactivity</strong>. Traditional grasp planners might take seconds to plan a grasp and arm trajectory, and even learning-based grasping systems often execute slow, cautious motions. In contrast, DextrAH-Gâ€™s policy runs at 15 Hz, and the low-level fabric control at 60 Hz, enabling <strong>real-time adjustments</strong>. The system can complete a grasp-and-drop cycle in around 10 seconds on average (â‰ˆ5-6 picks per minute) in real-world tests. This is significantly faster than previous dexterous hand systems, which often were not benchmarked on pick-per-minute but generally ran much slower or only in simulation. The continuous feedback from depth sensing means if an object moves or the grasp is not perfect, DextrAH-G can correct mid-flight, something static grasp execution canâ€™t do. The paper explicitly notes that this combination of <strong>â€œcelerity and reliabilityâ€</strong> is a notable advance in dexterous robot grasping, bringing it closer to real-world utility. For comparison, a recent generative grasp planner like DexDiffuser (Weng et al.&nbsp;2024) focuses on grasp synthesis but does not incorporate such real-time feedback or arm-hand coordination, and as a result, it may require careful execution and is tested mostly per grasp rather than continuous operation. The empirical results (Table&nbsp;1 in the paper) indeed show DextrAH-G outperforming DexDiffuser and other baselines on a variety of test objects, indicating both higher success rates and the ability to handle more objects (those baselines often failed or did not even attempt certain objects).</p></li>
<li><p><strong>Robustness and Safety Guarantees:</strong> DextrAH-Gâ€™s robustness comes from both its training regime and its control design. The heavy perturbations (random object pushes, pose noise, low friction) used during RL training force the policy to learn <strong>grasp strategies that work in less-than-ideal conditions</strong>. This is a contrast to some earlier works where a policy might overfit to clean simulation scenarios and then struggle with real-world variability (e.g., a policy that only learned to grasp perfectly placed objects might fail if the object is slightly out of expected position or if the vision sensing has noise). The results demonstrate that DextrAH-G can grasp objects even as they move slightly or when perception is noisy, thanks to this robust training. On the safety side, few (if any) prior dexterous grasping papers provided <em>formal guarantees</em> of safety during execution. By embedding the constraints in the geometric fabric, DextrAH-G guarantees that even if the RL policy hasnâ€™t learned to avoid, say, the table or its own arm, the controller will automatically prevent a collision. This not only protects the hardware (no damage was observed over extensive tests) but also enables the policy to train and operate in regimes that might be risky for other methods. For example, the policy can aggressively explore reaching near the table or making tight grasps without fear of a catastrophic collision, whereas a pure learning method might either avoid these regimes (leading to poor performance on low objects) or crash the robot. This integration of analytical safety measures with learning is a clear differentiator from prior art, which typically handled safety via mere caution or not at all.</p></li>
</ul>
<p>In summary, DextrAH-Gâ€™s novelty lies in <strong>combining advanced control (geometric fabrics) with deep learning (RL and distillation)</strong> in the context of dexterous arm-hand grasping. It achieves a <strong>holistic solution</strong> where others tackled pieces of the problem. By doing so, it <strong>surpasses prior work</strong> in <em>coordination</em> (arm + hand together), <em>input modality</em> (directly using depth images, no requirement for full point cloud or known models), <em>performance</em> (speed &amp; success rates), and <em>safety</em>. As we will see next, the experimental results back up these claims, showing new state-of-the-art levels of dexterous grasping performance.</p>
</section>
<section id="evaluation-and-results" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="evaluation-and-results"><span class="header-section-number">2.4</span> Evaluation and Results</h2>
<p>The authors validate DextrAH-G through both <strong>simulation benchmarks</strong> and extensive <strong>real-world tests</strong> on a physical robot. Key findings from the experiments include:</p>
<ul>
<li><p><strong>Simulation Performance:</strong> In simulation, the <strong>privileged teacher policy</strong> achieves near-perfect grasp success on the 140 training objects, and the <strong>distilled student policy</strong> (depth-based) almost matches it. Quantitatively, when evaluating over many parallel simulation trials, the teacher FGP had about <em>85% per-object success rate</em> on average, and the student FGP achieved about <em>80%</em> on those same objects. The difference is small, indicating the student learned to mimic the teacherâ€™s grasp behavior well. The paper reports a 99% success rate per batch of trials (when counting success if an object is grasped in any attempt of the episode), and ~80% success per object when each object is attempted individually. The slight drop for the student is attributed to the fact that the teacher had access to privileged info and an object ID, but importantly the studentâ€™s performance was still high enough to enable successful transfer to real. The <strong>average successful grasp execution time in simulation was only ~4 seconds</strong>, highlighting how quickly the policy can achieve a stable grasp and lift. This fast cycle (enabled by the 60&nbsp;Hz control and aggressive motion possible under the fabricâ€™s safety net) is promising for throughput.</p></li>
<li><p><strong>Real-World Single-Object Tests:</strong> DextrAH-G was deployed on a real robot (an Allegro hand on a KUKA arm, as per the paper setup) to grasp a variety of objects <strong>one at a time</strong>. Table&nbsp;1 of the paper summarizes the success rates over 5 trials for several representative objects, including a pitcher, a Pringles can, a coffee canister, a cup, a Cheez-It box, a spray bottle (cleaner), a toy brick, a Spam can, a cooking pot, and a toy airplane. <strong>DextrAH-G achieved success on most of these objects in 4 or 5 out of 5 trials</strong>, i.e., 80% or 100% success rates on each item. Notably, it succeeded in some challenging cases like a small cup (grasped 5/5 times) and a heavy spam can (5/5), and even the hardest item (a flat toy airplane) was grasped 3 out of 5 times. These results are <em>at or above</em> the success rates reported for prior methods. For comparison, the table includes <strong>DexDiffuser (2024)</strong>, a diffusion-model-based grasp planner, which only succeeded on a subset of those objects (and wasnâ€™t attempted on others) â€“ for instance DexDiffuser had ~60% on the Pringles can and cup, and only 20% on the airplane. Another baseline, <strong>ISAGrasp (2023)</strong>, and a prior method by Matak et al., likewise show patchy performance (some objects 0% or 40% success). DextrAH-Gâ€™s consistently high rates across all objects demonstrate its <em>general grasping ability</em>. These objects vary in shape, size, and weight (from boxes to cylinders to objects with handles), indicating the policy did not overfit to a single category. The use of depth input and training on 140 objects likely enabled this broad generalization. Itâ€™s important to highlight that <strong>these successes are achieved with no fine-tuning on hardware</strong> â€“ the same student policy trained in sim was run on the robot, attesting to the effectiveness of the sim-to-real transfer techniques (domain randomization, noise, etc.).</p></li>
<li><p><strong>Continuous </strong>Bin-Packing** Task:** Beyond isolated grasps, the authors devised a <strong>bin packing (or pick-and-place) evaluation</strong> to test DextrAH-G in an application-like scenario. In this setup, the robot faced a pile or set of over 30 different objects and had to continuously pick them up one by one and drop them into a bin. This is a stringent test because it requires sustained performance over time, handling various objects in sequence, and measuring both <strong>speed and consistency</strong>. Three metrics were used: (1) <strong>Consecutive Successes (CS)</strong> â€“ how many objects in a row the robot can pick and place correctly before a failure, (2) <strong>Cycle Time</strong> â€“ how long it takes per object (from starting a grasp to dropping and returning to start), and (3) overall <strong>Success Rate</strong> across attempts. DextrAH-G performed impressively: across 8 continuous runs, it achieved an average <strong>CS of 6.5 objects</strong> (with some runs exceeding 8+ in a row). This means on average it could successfully pick up six or seven objects sequentially before any mistake (like a drop or miss) occurred. Its average <strong>cycle time was ~10.7 seconds</strong>, which translates to <strong>5.6 picks per minute (PPM)</strong>. For a dexterous hand (with complex finger control), this speed is quite high â€“ approaching the realm of industrial pickers, though still about one-third the speed of a human operator who might achieve ~16 PPM on similar tasks. Most importantly, the <strong>overall success rate was 87% across 256 grasp attempts</strong> in these runs. This indicates reliability: the majority of picks succeeded even in an extended, varied sequence. According to the authors, this combination of speed (cycle time) and reliability is a <strong>significant advance in the state of the art</strong> for dexterous grasping. Many prior dexterous hand results were either in simulation or single-grasp demonstrations; achieving nearly 90% success over hundreds of grasps on different objects, at several picks per minute, is a new milestone. It suggests that such a system could be approaching practicality for tasks like automated sorting or bin clearing, especially as hardware and policies improve further.</p></li>
<li><p><strong>Generalization to Novel Objects:</strong> The paper also tested DextrAH-G on <strong>novel objects not seen in training</strong> (beyond the 140). It is reported that on a set of unseen objects, the system reached about <strong>87% grasp success</strong> as well. The failure modes observed were mostly sensible issues: about 8% of failures were due to the robot accidentally <strong>pushing the object out of a stable grasping region</strong> (e.g., sliding it away before grabbing), and ~3% due to repeated failed grasp attempts on very challenging shapes. A very small percentage (1â€“2%) were cases of losing the object during transport (either a slightly loose grip or a poor grasp that gave way en route). These analyses show that while not perfect, the policy is quite robust â€“ the dominant failure mode (pushing objects) is something that could potentially be improved with better strategy or recognizing when to stop pushing and re-grasp. Itâ€™s encouraging that <strong>no single object type completely defeated the system</strong>; even the low-profile objects (which are generally hard because the hand has to get very low without hitting the table) were sometimes grasped, albeit with lower success rates. This broad generalization stems from the training on many objects and the policyâ€™s ability to see depth â€“ it wasnâ€™t restricted to known shapes or a fixed set of grasps.</p></li>
<li><p><strong>Safety and Motion Quality:</strong> While harder to quantify, the authors note qualitatively that DextrAH-Gâ€™s motions are <strong>natural-looking and smooth</strong>, a benefit of the fabric controller. They also explicitly mention that over many hours of testing various policies (including intentionally <em>â€œill-behavedâ€</em> ones for stress-testing), <strong>no hardware damage occurred</strong>. This is a strong testament to the safety framework: even if the RL policy had some bad outputs, the geometric fabricâ€™s built-in safeguards (collision avoidance, limit enforcement) protected the robot. In contrast, pure end-to-end learned policies could easily drive a real robot to self-collision or joint overextension if not carefully constrained.</p></li>
</ul>
<p>Overall, the experimental results support the authorsâ€™ claims that DextrAH-G achieves <strong>state-of-the-art performance</strong> in dexterous grasping. It not only surpasses prior success rates on standard test objects, but it also introduces the metric of <strong>picks-per-minute with a dexterous hand</strong>, demonstrating a level of speed that wasnâ€™t seen before. The combination of an <strong>87% success rate and ~5.6 PPM throughput</strong> in the continuous task is highlighted as a considerable step forward. For context, most earlier dexterous hand studies didnâ€™t even report such metrics; DextrAH-G is bringing dexterous manipulation closer to the practicality seen in simpler parallel-jaw gripper systems, but with the added versatility of a human-like hand.</p>
</section>
<section id="limitations" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="limitations"><span class="header-section-number">2.5</span> Limitations</h2>
<p>Despite its impressive contributions, DextrAH-G has some <strong>limitations</strong> acknowledged by the authors, which also point to avenues for future improvement:</p>
<ul>
<li><p><strong>Reduced Finger Dexterity:</strong> By using a 5-D PCA manifold for the hand action space, the policy <strong>limits the range of hand motions</strong> to those spanned by the principal components. This was an intentional design choice to focus on grasping (closing around objects) and not in-hand manipulation. However, it means the robot cannot perform more fine-grained finger movements or reorient objects within the grasp that fall outside of those PCA modes. In other words, the <strong>kinematic dexterity is traded off for simplicity</strong>. If a task required complex finger gaiting or precise repositioning of an object in-hand, the current policy might not handle it. Future work could consider increasing the hand action dimensionality or using hierarchical policies to regain some dexterity beyond the PCA subspace.</p></li>
<li><p><strong>Limited Learning of Obstacle Avoidance:</strong> DextrAH-G relies on the model-based geometric fabric for collision avoidance (with the table and robot itself). The policy thus does not explicitly learn obstacle avoidance from sensory input. In scenarios with dynamic or novel obstacles (e.g., clutter or a moving human), the fabricâ€™s built-in avoidance might not be enough, and the policy currently has no mechanism to alter its plan based on unseen obstacles except via the fabricâ€™s reactive forces. The authors suggest that <strong>ideally some obstacle avoidance behavior should be learned from perception</strong>, to reduce dependency on the known geometric model. For instance, if the policy could visually detect obstacles or foresee collisions, it might perform better in clutter. As is, DextrAH-G is best suited to relatively structured scenes (a table, known robot model, one object at a time).</p></li>
<li><p><strong>RL Exploration Near Contact Limits:</strong> The use of a strong avoidance fabric has a side effect: it makes it <strong>hard for the RL policy to explore grasps that require approaching very close to obstacles</strong>. For example, picking up a very thin object lying flat on the table requires the fingers to come extremely close to the table surface. The fabricâ€™s collision avoidance will resist motions that get too close to the table (to prevent crashes), which in training could lead to the policy rarely experiencing successful grasps of such low-profile objects. The authors observed reduced performance on objects that lie low on the table due to this issue. This highlights an inherent tension: too strong a safety barrier can impede learning of risky-but-necessary maneuvers. They suggest that improving exploration strategies or using curricula to gradually allow closer approaches could help, as might advances in RL algorithms that handle constraints better. Learning-based collision avoidance (where the policy is penalized for collision but not outright prevented) could also be a future direction, to give the policy more flexibility near contact boundaries.</p></li>
<li><p><strong>Single Object Assumption (No Clutter Handling):</strong> Currently, DextrAH-G is designed to <strong>grasp one object at a time</strong> in an otherwise clear environment. The depth image input is used to localize and grasp a single target object. In a cluttered scene with multiple objects touching or overlapping, the system would likely face difficulties. The authors note that <strong>extensions like visual segmentation or scene parsing</strong> would be needed to handle multiple objects or clutter piles. In practical terms, the policy doesnâ€™t â€œknowâ€ how to choose among many objects or avoid knocking one object into another because it was never trained on clutter. This is a common limitation â€“ many learning-based graspers assume a single target at a time. Future work could integrate an object detection module or train the policy in cluttered simulations to make it effective in more unstructured piles of items.</p></li>
</ul>
<p>In summary, DextrAH-G excels at what it was designed for â€“ single-object grasps in a constrained action space â€“ but <strong>does not yet solve all aspects</strong> of dexterous manipulation. It doesnâ€™t do complex finger tricks (due to PCA action space), it doesnâ€™t inherently understand obstacles beyond its pre-modeled avoidance (limiting adaptation to new surroundings), it struggles with objects that require pushing into â€œforbiddenâ€ zones (very flat objects on surfaces), and it is not directly applicable to cluttered scenes without additional perception help. Recognizing these limitations is important, as it frames the scope of the contribution and points to how the approach might be expanded (e.g., using higher-dimensional action spaces or multi-object vision in future work).</p>
</section>
<section id="final-assessment" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="final-assessment"><span class="header-section-number">2.6</span> Final Assessment</h2>
<p><strong>DextrAH-G</strong> represents a significant advancement in the domain of dexterous robotic grasping. By intelligently blending model-based control (geometric fabrics) with model-free learning, the authors achieve a synergy that capitalizes on the strengths of each. The geometric fabric endows the system with <strong>safety, stability, and structured knowledge</strong> of the robotâ€™s dynamics, while reinforcement learning and distillation inject <strong>adaptability and perceptual intelligence</strong>. This combination enabled, for the first time, a 23-DOF dexterous hand-arm robot to grasp a wide array of objects <em>directly from vision</em> at high speed <strong>without retraining on the robot</strong>. The methodological contributions â€“ such as the use of a <strong>fabric-guided policy (FGP)</strong>, the design of a reduced <strong>PCA-based hand action space</strong>, and the extensive use of <strong>privileged training with domain randomization</strong> â€“ tackle long-standing challenges like high-dimensional control, sim-to-real transfer, and exploration in contact-rich tasks. These ideas are likely to influence future research, suggesting that complex skills can be better learned when the right inductive biases (like motion fabrics or synergies) are built into the learning process.</p>
<p>From a performance standpoint, DextrAH-G clearly pushes the state of the art. It achieves <strong>higher success rates across diverse objects</strong> than prior methods and does so with <strong>remarkable efficiency (5+ picks per minute)</strong>, all while maintaining safety (zero collisions or hardware issues reported). The real-world demonstrations of continuous picking of novel objects with ~87% success are especially compelling â€“ they indicate that the policy generalizes well and could be deployed in practical settings with minimal fuss. Few works in dexterous manipulation have shown this level of generality and reliability so far.</p>
<p>It should be noted that DextrAH-Gâ€™s focus was on <strong>powerful grasp execution</strong> rather than fine manipulation or multi-step tasks. Thus, its constrained finger motion space and single-object assumption are reasonable trade-offs for its target application (fast picking tasks). The limits identified (e.g., difficulty with flat objects or clutter) highlight that there is still room to grow: integrating more perception for clutter, improving exploration near contact limits, and expanding the action space for greater dexterity are all interesting future directions. The concept of <strong>learning within a fabric (or RMP) framework</strong> might also extend to other tasks â€“ for instance, bimanual manipulation or tool use â€“ where safe coordination of many DOFs is needed.</p>
<p>In conclusion, <em>DextrAH-G</em> demonstrates how marrying <strong>geometry and learning</strong> can yield robust robot skills. It offers a template for <strong>â€œgrasp anythingâ€ policies</strong> that are not only proficient but also hardware-friendly and efficient. This deep integration of a physics-based controller with deep RL is a notable innovation, and the successful results validate the approach. As the field progresses, DextrAH-G paves the way toward dexterous robots that can operate with a human-like combination of caution and agility â€“ fast when needed, careful when required, and effective across a broad range of real-world objects. The work is a <strong>significant step toward deploying dexterous robotic hands in industrial and everyday environments</strong>, bridging the gap between simulation-trained policies and reliable real-world performance.</p>
<p><strong>Sources:</strong> The analysis above is based on the paper by Lum <em>et al.</em> (2024) and associated results in the text, which provide detailed descriptions of the DextrAH-G system, its innovations, and experimental outcomes.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>