<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-07-03">
<meta name="description" content="A Survey on Physics Informed Reinforcement Learning - Review and Open Problems">

<title>📃Physics Informed RL Survey 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ef56b68f8fa1e9d2ba328e99e439f80.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-b009f778f5cec7f34f624408a2b5b543.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review">Brief Review</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#piml-an-overview" id="toc-piml-an-overview" class="nav-link" data-scroll-target="#piml-an-overview">PIML: An Overview</a></li>
  <li><a href="#pirl-fundamentals-taxonomy-and-examples" id="toc-pirl-fundamentals-taxonomy-and-examples" class="nav-link" data-scroll-target="#pirl-fundamentals-taxonomy-and-examples">PIRL: Fundamentals, Taxonomy and Examples</a></li>
  <li><a href="#pirl-review-and-analysis" id="toc-pirl-review-and-analysis" class="nav-link" data-scroll-target="#pirl-review-and-analysis">PIRL: Review and Analysis</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃Physics Informed RL Survey 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">rl</div>
    <div class="quarto-category">physics-informed</div>
    <div class="quarto-category">survey</div>
  </div>
  </div>

<div>
  <div class="description">
    A Survey on Physics Informed Reinforcement Learning - Review and Open Problems
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 3, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://arxiv.org/pdf/2309.01909">Paper Link</a></li>
</ul>
<ol type="1">
<li>이 논문은 Physics-Informed Reinforcement Learning(PIRL) 연구 동향을 조사하고, 물리학 정보를 RL에 통합하는 새로운 분류 체계를 제시합니다.</li>
<li>PIRL은 방정식, 제약 조건, 시뮬레이터 등 다양한 물리학적 사전 정보를 RL 파이프라인의 상태, 액션, 보상, 네트워크, 모델 등 다양한 부분에 통합하여 RL의 효율성과 안전성을 향상시킵니다.</li>
<li>이 논문의 분석은 PIRL의 다양한 적용 분야와 함께 해결되지 않은 문제점 및 향후 연구 방향을 제시하여 분야의 성장에 기여합니다.</li>
</ol>
<hr>
<section id="brief-review" class="level1">
<h1>Brief Review</h1>
<p>본 논문은 물리 정보를 활용한 강화 학습(Physics-Informed Reinforcement Learning, PIRL)에 대한 포괄적인 조사 논문입니다. PIRL은 물리적 제약 조건과 물리 법칙을 학습 과정에 통합하여 기계 학습 프레임워크, 특히 강화 학습(RL)의 성능을 향상시키는 접근 방식입니다.</p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>RL은 시행착오를 통해 의사 결정 및 최적화 문제를 해결하는 유망한 접근 방식입니다. 자율 주행, 로봇 공학, 연속 제어 등 다양한 분야에서 성공을 거두었지만, 실제 데이터의 샘플 효율성 부족, 고차원 연속 상태/액션 공간 처리의 어려움, 안전한 탐색, 적절한 보상 함수 정의, 시뮬레이터-실제 환경 간의 차이 등의 문제에 직면해 있습니다. 물리 정보를 ML 모델에 통합하는 <strong>PIML(Physics-Informed Machine Learning)</strong>은 불완전한 물리 정보와 데이터로부터 더 효율적으로 학습하고, 더 나은 일반화 성능을 보이며, 물리적으로 타당한 솔루션을 제공하는 장점이 있습니다. RL은 대부분 실제 세계 문제와 관련이 있으며 설명 가능한 물리적 구조를 가지고 있기 때문에 물리 정보 통합에 적합한 분야입니다. 최근 연구들은 물리 정보를 RL 파이프라인에 통합하여 이러한 과제를 해결하고 있습니다. 예를 들어, 물리 정보를 사용하여 고차원 연속 상태를 직관적인 표현으로 줄이거나 더 나은 시뮬레이션을 구축하며, 안전한 학습을 위한 물리적 제약 조건을 보상 함수에 통합하는 등의 시도가 이루어지고 있습니다. PIRL 연구는 지난 6년간 증가하는 추세를 보이며 주목받고 있습니다.</p>
<ol type="1">
<li><strong>Taxonomy:</strong> 어떤 물리 지식/프로세스가 모델링되고, 어떻게 표현되며, RL 접근 방식에 어떻게 통합되는지에 대한 통합 분류 체계를 제시합니다.</li>
<li><strong>Algorithmic Review:</strong> 물리 정보 기반 RL 방법론에 대한 최신 접근 방식을 통일된 표기법과 기능 다이어그램을 사용하여 검토합니다.</li>
<li><strong>Training and evaluation benchmark Review:</strong> 검토된 문헌에서 사용된 평가 벤치마크를 분석하여 인기 있는 플랫폼/도구를 제시합니다.</li>
<li><strong>Analysis:</strong> 다양한 도메인에 걸친 model-based 및 model-free RL 애플리케이션에서 물리 정보가 특정 RL 접근 방식에 어떻게 통합되는지, 어떤 물리 프로세스가 모델링/통합되는지, 어떤 네트워크 아키텍처 또는 증강이 사용되는지 상세히 분석합니다.</li>
<li><strong>Open Problems:</strong> 현재 직면한 과제, 미해결 연구 질문 및 향후 연구 방향에 대한 관점을 제시합니다.</li>
</ol>
</section>
<section id="piml-an-overview" class="level2">
<h2 class="anchored" data-anchor-id="piml-an-overview">PIML: An Overview</h2>
<blockquote class="blockquote">
<p>물리 정보를 활용한 기계 학습 개요</p>
</blockquote>
<p>PIML은 수학적 물리 모델과 관측 데이터를 학습 과정에 통합하여, 불완전하고 불확실하며 고차원적인 복잡한 시나리오에서도 물리적으로 일관된 솔루션을 찾는 것을 목표로 합니다. 물리 지식을 ML 모델에 추가하는 것은 물리/과학적 일관성 보장, 데이터 효율성 증가, 학습 과정 가속화, 일반화 능력 향상, 투명성/해석 가능성 증진과 같은 이점을 제공합니다. 물리 지식을 통합하는 세 가지 주요 전략은 다음과 같습니다.</p>
<ul>
<li><strong>Observational bias:</strong> 물리적 원리를 반영하는 multi-modal 데이터를 사용하여 DNN을 학습시킵니다. 관측, 시뮬레이션, 물리 방정식 생성 데이터, 지도, 추출된 물리 데이터 등 다양한 소스의 데이터를 활용합니다.</li>
<li><strong>Learning bias:</strong> 손실 함수에 물리 기반의 페널티 항을 추가하여 사전 지식을 강화하는 방식입니다. PINN(Physics-Informed Neural Networks)은 PDE를 신경망의 손실 함수에 포함시키는 대표적인 예입니다.</li>
<li><strong>Inductive biases:</strong> custom neural network 구조를 통해 물리 원리를 ‘하드’ 제약 조건으로 통합하는 방식입니다. Hamiltonian NN, Lagrangian Neural Networks (LNNs) 등이 있습니다.</li>
</ul>
</section>
<section id="pirl-fundamentals-taxonomy-and-examples" class="level2">
<h2 class="anchored" data-anchor-id="pirl-fundamentals-taxonomy-and-examples">PIRL: Fundamentals, Taxonomy and Examples</h2>
<blockquote class="blockquote">
<p>물리 정보를 활용한 강화 학습: 기본, 분류 및 예시</p>
</blockquote>
<p><strong>RL 기본 (RL fundamentals)</strong></p>
<p>RL은 MDP (Markov Decision Process) 프레임워크를 따르는 순차적 의사 결정 문제를 해결합니다. 에이전트(agent)와 환경(environment)이 상호 작용하며, 에이전트는 상태(<span class="math inline">s_t</span>)를 관찰하고 행동(<span class="math inline">a_t</span>)을 선택하며, 환경은 다음 상태(<span class="math inline">s_{t+1}</span>)와 보상(<span class="math inline">r_t</span>)을 제공합니다. 목표는 누적 보상을 최대화하는 정책 <span class="math inline">\pi_\phi(a_t|s_t)</span>의 매개변수 <span class="math inline">\phi</span>를 찾는 것입니다. MDP는 튜플 <span class="math inline">(S, A, R, P, \gamma)</span>로 표현되며, <span class="math inline">S</span>는 상태 공간, <span class="math inline">A</span>는 액션 공간, <span class="math inline">R</span>은 보상 함수, <span class="math inline">P(s_{t+1}|s_t, a_t)</span>는 환경 모델(전이 확률), <span class="math inline">\gamma \in [0, 1]</span>는 할인 계수입니다. 목표 함수는 다음과 같습니다. <span class="math inline">J(\phi) = \mathbb{E}_{\tau \sim p_\phi(\tau)} \left[ \sum_{t=1}^T \gamma^{t-1} R(a_t, s_{t+1}) \right]</span> 여기서 <span class="math inline">\tau</span>는 에피소드의 상태-액션 시퀀스입니다. RL 알고리즘은 model-free (환경 모델 없이 학습)와 model-based (환경 모델을 사용하여 계획/학습)로 나눌 수 있습니다. 또한, online (최신 정책으로 수집한 데이터 사용), off-policy (경험 리플레이 버퍼의 데이터 사용), offline (고정된 데이터셋 사용)으로 분류됩니다.</p>
<p><strong>PIRL 소개 (PIRL: Introduction)</strong></p>
<p>PIRL은 물리 구조, 사전 지식(priors), 실제 물리 변수를 정책 학습 또는 최적화 과정에 통합하는 개념입니다. 이는 RL 알고리즘의 효율성, 샘플 효율성, 훈련 가속화에 기여합니다.</p>
<p><strong>PIRL 분류 체계 (PIRL Taxonomy)</strong></p>
<p>이 논문은 물리 정보 유형, 물리 정보를 통합하는 PIRL 방법, 그리고 RL 파이프라인의 세 가지 축을 중심으로 PIRL 분류 체계를 제시합니다.</p>
<ul>
<li><strong>Physics information (types): representation of physics priors</strong>
<ol type="1">
<li>Differential and algebraic equations (DAE): PDE/ODE, 경계 조건(BC) 등 시스템 동역학 표현 (예: PINN).</li>
<li>Barrier certificate and physical constraints (BPC): CLF, BF, CBF/CBC 등 안전 제약 조건 (예: 안전 중요 애플리케이션의 탐색 규제).</li>
<li>Physics parameters, primitives and physical variables (PPV): 환경/시스템에서 추출/도출된 물리 값 (예: jam-avoiding distance, dynamic movement primitives).</li>
<li>Offline data and representation (ODR): 시뮬레이터 기반 학습 개선을 위한 오프라인 데이터 또는 물리적으로 관련된 저차원 표현 학습.</li>
<li>Physics simulator and model (PS): RL 알고리즘의 테스트베드 또는 물리적 정확성을 부여하기 위한 시뮬레이터 활용 (예: MBRL에서 시스템 모델 학습).</li>
<li>Physical properties (PPR): 시스템 형태, 대칭 등 기본적인 물리 구조/속성 지식.</li>
</ol></li>
<li><strong>PIRL methods: physics prior augmentations to RL</strong>
<ol type="1">
<li>State design: 관찰된 상태 공간 수정/확장 (예: 상태 융합, 특징 추출).</li>
<li>Action regulation: 액션 값에 제약 조건 부과 (예: 안전 필터).</li>
<li>Reward design: 효과적인 보상 설계 또는 보상 함수 증강.</li>
<li>Augment policy or value N/W: 정책 또는 가치 함수의 업데이트 규칙, 손실, 구조 변경.</li>
<li>Augment simulator or model: 기초 물리 지식 통합을 통한 시뮬레이터/모델 개선.</li>
</ol></li>
<li><strong>RL Pipeline</strong>
<ol type="1">
<li>Problem Representation: 실제 문제를 MDP로 모델링 (상태, 액션, 보상 정의).</li>
<li>Learning strategy: 에이전트-환경 상호 작용 방식, 학습 아키텍처, 알고리즘 선택 결정.</li>
<li>Network design: 정책/가치 네트워크의 세부 구조 설계.</li>
<li>Training: 네트워크 학습 (Sim-to-real 등 훈련 증강 포함).</li>
<li>Trained policy deployment: 훈련된 정책 배포.</li>
</ol></li>
</ul>
<p><strong>추가 분류 (Further categorization)</strong></p>
<p>이 논문은 추가적으로 두 가지 범주를 사용하여 PIRL 구현을 설명합니다.</p>
<ul>
<li><strong>Bias:</strong> PIML에서 사용되는 bias 개념(Observational, Learning, Inductive)과 PIRL 접근 방식의 관계를 분석합니다.</li>
<li><strong>Learning architecture:</strong> 물리 정보 통합을 위해 전통적인 RL 학습 아키텍처에 도입된 변경 사항에 따라 분류합니다.
<ol type="1">
<li>Safety filter: 안전 제약 조건을 보장하기 위해 에이전트의 액션을 조절하는 모듈 포함.</li>
<li>PI reward: 보상 함수를 물리 정보로 수정.</li>
<li>Residual learning: 물리 정보 기반 제어기와 데이터 기반 정책을 결합.</li>
<li>Physics embedded network: 정책 또는 가치 함수 네트워크에 시스템 동역학 등 물리 정보 직접 통합.</li>
<li>Differentiable simulator: 손실 기울기를 제어 액션에 대해 직접 계산할 수 있는 미분 가능한 물리 시뮬레이터 사용.</li>
<li>Sim-to-Real: 시뮬레이터에서 학습 후 실제 환경으로 전이.</li>
<li>Physics variable: 물리 매개변수, 변수, 프리미티브를 상태/보상 등에 추가.</li>
<li>Hierarchical RL: 계층적 또는 커리큘럼 학습 설정에서 물리 정보를 통합.</li>
<li>Data augmentation: 입력 상태를 저차원 표현 등으로 대체/증강하여 물리적으로 관련된 특징 도출.</li>
<li>PI model identification: MBRL 설정에서 물리 정보를 모델 식별 과정에 통합.</li>
</ol></li>
</ul>
</section>
<section id="pirl-review-and-analysis" class="level2">
<h2 class="anchored" data-anchor-id="pirl-review-and-analysis">PIRL: Review and Analysis</h2>
<ul>
<li><p><strong>Algorithmic review:</strong> 위에 제시된 PIRL 방법 및 학습 아키텍처 범주를 기반으로 연구들을 그룹화하여 논의합니다. 예를 들어, State design에서는 CAV 제어에서의 물리 기반 상태 융합, Adaptive cruise control에서의 jam-avoiding distance 활용 등이 논의됩니다. Action regulation에서는 안전 중요 시스템의 CBF/CBC를 활용한 액션 제약이 강조되며, <span class="math inline">B_\epsilon(x)</span>와 Lie derivative <span class="math inline">\mathcal{L}_f(x, u_{RL}) B_\epsilon(x)</span>를 이용한 안전 조건이 언급됩니다. Reward design에서는 로봇 보행, 에너지 관리, 유체역학 등 다양한 분야에서 물리 기반 보상 함수 설계 사례가 제시됩니다. Augment simulator or model에서는 LNN을 사용한 시스템 모델 학습, sim-to-real 전이 개선을 위한 시뮬레이터 증강, 미분 가능한 시뮬레이터 사용 등이 포함됩니다. Augment policy and/or value N/W에서는 신경망 정책에 동적 시스템을 미분 가능한 레이어로 통합하는 Neural Dynamic Policies (NDP), 가치 함수를 HJB PDE를 푸는 PINN으로 취급하는 접근 방식 등이 소개됩니다.</p></li>
<li><p><strong>Simulation/ evaluation benchmarks:</strong> 연구에서 사용된 다양한 시뮬레이터 및 평가 환경을 OpenAI Gym, MuJoCo, Pybullet, Deep mind control suite와 같은 표준 벤치마크와 SUMO, CARLA, IEEE distribution system benchmarks 같은 도메인별 플랫폼, 그리고 다수의 맞춤형 환경으로 분류하여 제시합니다.</p></li>
<li><p><strong>Analysis:</strong></p>
<ul>
<li><strong>연구 동향 및 통계:</strong> 가장 많이 사용되는 RL 알고리즘은 PPO이며, 그 뒤를 DDPG, SAC 등이 잇습니다. 물리 정보 유형으로는 물리 시뮬레이터, 시스템 모델, 배리어 인증서/물리 제약이 가장 흔하게 사용됩니다. 학습 아키텍처 중 PI reward와 safety filter는 주로 learning bias를 통해, physics embedded network는 inductive bias를 통해 물리를 통합합니다. 애플리케이션 도메인의 85% 가량이 제어 또는 정책 설계와 관련 있으며, 그 중 Miscellaneous control, Safe control and exploration, Dynamic control이 주를 이룹니다.</li>
<li><strong>RL 해결 과제:</strong> PIRL은 다음과 같은 RL 과제 해결에 기여합니다. Sample efficiency (시뮬레이터/모델 증강), Curse of dimensionality (물리 관련 저차원 표현 학습), Safety exploration (CBF/CLF 등 제어 이론 활용), Partial observability (상태 증강/융합), Under-defined reward function (물리 기반 보상 설계/증강).</li>
</ul></li>
</ul>
<p><strong>미해결 과제 및 연구 방향 (Open Challenges and Research Directions)</strong></p>
<ol type="1">
<li><strong>High Dimensional Spaces:</strong> 고차원 공간에서 물리적으로 관련된 정보성이 풍부한 저차원 표현을 학습하는 것이 여전히 과제입니다.</li>
<li><strong>Safety in Complex and Uncertain Environments:</strong> 복잡하고 불확실한 환경에서 model-agnostic하며 일반화 가능한 안전한 탐색 및 제어 접근 방식 개발이 필요합니다. 데이터 기반 모델 학습에 물리를 통합하는 일반화된 접근 방식도 중요합니다.</li>
<li><strong>Choice of physics prior:</strong> 문제에 적합한 물리 사전 지식을 선택하는 것은 어렵고 도메인별 전문 지식이 필요합니다. 새로운 물리적 태스크를 다룰 수 있는 포괄적인 프레임워크 구축이 필요합니다.</li>
<li><strong>Evaluation and bench-marking platform:</strong> PIRL 연구를 위한 포괄적인 벤치마킹 및 평가 환경이 부족하여 새로운 방법론의 비교 및 평가가 어렵습니다. 도메인별로 맞춤화된 환경에 의존하는 경향이 있습니다.</li>
</ol>
<p><strong>결론 (Conclusions)</strong>: 본 논문은 PIRL 패러다임을 소개하고, 물리 사전 지식 유형 및 물리 정보 통합 방식(RL 방법)에 기반한 분류 체계를 제시합니다. 또한, 학습 아키텍처 및 bias에 따른 추가 분류를 통해 PIRL 구현을 더 잘 이해할 수 있도록 돕습니다. 최신 문헌을 검토하고, 물리 정보가 RL 파이프라인의 다양한 단계에 어떻게 통합되는지 분석하며, 사용된 벤치마크를 요약합니다. 마지막으로, 현재 PIRL 연구의 한계점과 미해결 과제를 논의하며 향후 연구 방향을 제시합니다. PIRL은 물리적 타당성, 정밀도, 데이터 효율성, 실제 환경 적용 가능성을 높여 RL 알고리즘을 향상시킬 잠재력이 있습니다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>