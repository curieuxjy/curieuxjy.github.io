<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-09-29">
<meta name="description" content="A Vision-Language-Action Flow Model for General Robot Control">

<title>📃π0 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review">Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review">Detail Review</a>
  <ul class="collapse">
  <li><a href="#논문의-주요-기여-요약" id="toc-논문의-주요-기여-요약" class="nav-link" data-scroll-target="#논문의-주요-기여-요약">논문의 주요 기여 요약</a></li>
  <li><a href="#기술적-설명" id="toc-기술적-설명" class="nav-link" data-scroll-target="#기술적-설명">기술적 설명</a></li>
  <li><a href="#실험-및-결과-분석" id="toc-실험-및-결과-분석" class="nav-link" data-scroll-target="#실험-및-결과-분석">실험 및 결과 분석</a></li>
  <li><a href="#장점과-한계-분석" id="toc-장점과-한계-분석" class="nav-link" data-scroll-target="#장점과-한계-분석">장점과 한계 분석</a></li>
  <li><a href="#향후-연구-방향" id="toc-향후-연구-방향" class="nav-link" data-scroll-target="#향후-연구-방향">향후 연구 방향</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃π0 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">vla</div>
    <div class="quarto-category">flow</div>
    <div class="quarto-category">cross-embodiment</div>
  </div>
  </div>

<div>
  <div class="description">
    A Vision-Language-Action Flow Model for General Robot Control
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 29, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://www.physicalintelligence.company/download/pi0.pdf">Paper Link</a></li>
<li><a href="https://www.physicalintelligence.company/blog/pi0">Homepage</a></li>
<li><a href="https://github.com/Physical-Intelligence/openpi">Code Link</a></li>
</ul>
<ol type="1">
<li>π0는 사전 학습된 Vision-Language Model(VLM) 백본과 플로우 매칭(flow matching) 아키텍처를 기반으로 로봇 제어의 일반성과 정밀성을 향상시킨 새로운 로봇 파운데이션 모델입니다.</li>
<li>이 모델은 인터넷 규모의 시맨틱 지식을 활용하며, 7가지 로봇 구성과 68개 작업에 걸친 10,000시간 이상의 방대한 교차-embodiment 데이터셋으로 사전 학습 및 미세 조정을 거칩니다.</li>
<li>실험 결과, π0는 빨래 개기, 상자 조립 등 복잡하고 섬세한 조작 작업에서 기존 모델들을 능가하는 강력한 성능을 보여주며, VLM 사전 학습이 언어 지시 이해 능력을 크게 향상시킴을 입증했습니다.</li>
</ol>
<hr>
<section id="brief-review" class="level1">
<h1>Brief Review</h1>
<p>이 논문은 유연하고 일반적이며 정교한 로봇 시스템을 위한 범용 로봇 제어 정책인 π0를 제안합니다. 이 모델은 Vision-Language Model (VLM)을 백본으로 활용하고, 인터넷 규모의 방대한 데이터에서 학습된 의미론적 지식을 로봇 제어로 확장하는 것을 목표로 합니다.</p>
<p>π0의 핵심 방법론은 다음과 같습니다:</p>
<ol type="1">
<li><strong>VLM 백본 활용</strong>: PaliGemma [5]와 같은 사전 학습된 VLM을 기반으로 하여, 이미지와 텍스트로부터 학습된 광범위한 지식, 의미론적 추론 및 문제 해결 능력을 계승합니다. 이는 인터넷 규모의 데이터에서 얻은 경험을 로봇 제어에 통합하는 역할을 합니다.</li>
<li><strong>Flow Matching을 통한 연속적인 액션 생성</strong>: 기존의 VLA 모델들이 주로 autoregressive discretization 방식을 사용하여 액션을 텍스트 토큰처럼 처리하는 것과 달리, π0는 <code>conditional flow matching</code> [28, 32]을 도입하여 연속적인 액션 분포를 모델링합니다. Flow matching은 <code>diffusion</code> [20, 46]의 한 변형으로, 고주파수 (최대 50 Hz)의 액션 청크(action chunk) [57]를 정밀하게 모델링하고 복잡한 연속 액션 분포를 표현할 수 있어 세밀한 조작(dexterous manipulation)이 요구되는 작업에 특히 적합합니다. 액션 청크 <span class="math inline">A_t = [a_t, a_{t+1},..., a_{t+H-1}]</span>는 미래 H 스텝의 액션을 나타내며, H는 50으로 설정됩니다. 학습 시 손실 함수는 다음과 같습니다: <span class="math display">L_\tau (\theta) = \mathbb{E}_{p(A_t|o_t), q(A_t^\tau|A_t)}[\|v_\theta (A_t^\tau, o_t) - u(A_t^\tau|A_t)\|^2]</span> 여기서 <span class="math inline">o_t</span>는 관측값 (다중 RGB 이미지, 언어 명령어, 로봇의 고유수용성 상태), <span class="math inline">A_t^\tau</span>는 노이즈가 추가된 액션 청크, <span class="math inline">v_\theta</span>는 학습된 벡터 필드, <span class="math inline">u</span>는 디노이징 벡터 필드입니다. 확률 경로(probability path)는 <span class="math inline">q(A_t^\tau|A_t) = \mathcal{N}(\tau A_t, (1-\tau)\mathbf{I})</span>로 정의되며, 디노이징 벡터 필드 <span class="math inline">u(A_t^\tau|A_t) = \epsilon - A_t</span>는 무작위 노이즈 <span class="math inline">\epsilon \sim \mathcal{N}(0, \mathbf{I})</span>와 실제 액션 <span class="math inline">A_t</span>로 구성됩니다. 추론 시에는 학습된 벡터 필드를 <span class="math inline">\tau = 0</span>에서 <span class="math inline">\tau = 1</span>까지 <code>forward Euler integration</code> 규칙을 사용하여 통합하여 액션을 생성합니다: <span class="math display">A_t^{\tau+\delta} = A_t^\tau + \delta v_\theta (A_t^\tau, o_t)</span> 이때 <span class="math inline">\delta</span>는 통합 스텝 크기이며, 실험에서는 10개의 통합 스텝을 사용합니다 (<span class="math inline">\delta=0.1</span>).</li>
<li><strong>액션 전문가 (Action Expert) 아키텍처</strong>: VLM 백본에 로봇 고유의 입력 (고유수용성 상태 <span class="math inline">q_t</span>) 및 출력 (액션 <span class="math inline">A_t</span>)을 처리하기 위한 별도의 가중치 세트(“액션 전문가”)를 추가합니다. 이는 이미지 및 텍스트 입력을 처리하는 VLM 백본과 로봇 관련 입출력을 처리하는 액션 전문가로 구성된 <code>mixture of experts</code> [45] 디자인과 유사합니다. PaliGemma (30억 파라미터)와 액션 전문가 (3억 파라미터)를 결합하여 총 33억 파라미터의 모델을 구성합니다.</li>
<li><strong>크로스-엔바디먼트 (Cross-Embodiment) 학습</strong>: 다양한 로봇 플랫폼 (단일 팔 로봇, 이중 팔 로봇, 모바일 매니퓰레이터 등)에서 수집된 데이터를 단일 모델에 결합하여 학습합니다. 이는 다양한 구성 공간과 액션 표현을 가진 로봇 시스템에 대한 일반화를 가능하게 합니다.</li>
</ol>
<p><strong>학습 레시피</strong>:</p>
<p>논문은 <code>pre-training</code> 및 <code>post-training</code> (미세 조정) 단계를 따르는 다단계 학습 절차를 제안합니다.</p>
<ul>
<li><strong>Pre-training</strong>: Physical Intelligence에서 수집한 7가지 로봇 구성, 68가지 태스크에 대한 정교한 조작 데이터셋 (약 9억 3천만 스텝)과 공개된 OXE [10] 데이터셋 (22개 로봇 포함)을 포함한 대규모의 다양한 데이터 혼합 (총 10,000시간 이상의 로봇 데이터)으로 모델을 사전 학습합니다. 이 단계는 광범위한 기능과 일반화 능력을 부여하는 것을 목표로 합니다.</li>
<li><strong>Post-training</strong>: 사전 학습된 모델을 더 적고 엄선된 고품질의 태스크별 데이터셋으로 미세 조정하여 특정 다운스트림 태스크에 대한 숙련되고 유창한 실행 능력을 부여합니다. 이는 LLM의 “정렬(alignment)” 과정과 유사합니다.</li>
</ul>
<p><strong>실험 및 결과</strong>:</p>
<p>π0는 다양한 실험을 통해 그 성능을 입증합니다.</p>
<ul>
<li><strong>Out-of-box 평가</strong>: 사전 학습만으로도 셔츠 접기, 테이블 정리, 식료품 포장 등의 다양한 태스크에서 기존의 OpenVLA [24] 및 Octo [50]와 같은 로봇 파운데이션 모델들을 크게 능가하는 성능을 보였습니다. 특히, VLM 사전 학습이 없는 π0-small 버전보다 월등한 성능을 보이며 VLM 사전 학습의 중요성을 강조합니다.</li>
<li><strong>언어 명령어 추종</strong>: π0는 언어 명령어 추종 능력에서 π0-small보다 현저히 우수한 성능을 보여, VLM 사전 학습이 모델의 언어 이해 능력 향상에 크게 기여함을 시사합니다. 인간 전문가 또는 <code>high-level VLM policy</code>가 제공하는 중간 언어 명령어를 통해 복잡한 태스크를 더 잘 수행할 수 있습니다.</li>
<li><strong>새로운 정교한 태스크 학습</strong>: 사전 학습 데이터와는 다른 새로운 태스크(예: 그릇 쌓기, 수건 접기, 전자레인지에 용기 넣기, 종이 타월 교체, 서랍에 물건 넣기)에 대한 미세 조정 평가에서, π0는 기존의 ACT [57] 및 Diffusion Policy [9]를 포함한 다른 방법들보다 우수한 성능을 보였습니다. 사전 학습은 특히 적은 미세 조정 데이터로도 성능 향상에 기여합니다.</li>
<li><strong>복합 다단계 태스크 숙달</strong>: 세탁물 접기 (정지형/이동형 로봇), 식탁 정리, 상자 조립, 달걀 포장, 도시락 포장 등 복잡하고 시간적으로 확장된 다단계 태스크에서, π0는 사전 학습 및 미세 조정 조합을 통해 높은 성공률을 달성했습니다. 이러한 태스크는 수십 개의 개별 행동과 다양한 물체 구성, 그리고 변형 가능한 물체와 같은 복잡한 물리적 특성을 다루는 능력을 요구합니다. 논문은 이러한 수준의 자율 성능이 정교한 로봇 조작 분야에서 새로운 <code>state-of-the-art</code>를 제시한다고 주장합니다.</li>
</ul>
<p><strong>결론</strong>:</p>
<p>π0는 VLM 사전 학습과 flow matching 기반 액션 생성, 그리고 대규모의 다각적인 데이터셋을 활용하는 사전 학습-미세 조정 레시피를 통해 범용적이고 정교한 로봇 제어 능력을 달성할 수 있음을 보여줍니다. 이 연구는 로봇 파운데이션 모델의 현실화를 위한 중요한 발걸음으로 평가되며, 미래 연구를 위한 데이터 구성 및 전이 학습 범위 확장 등의 과제를 제시합니다.</p>
<hr>
</section>
<section id="detail-review" class="level1">
<h1>Detail Review</h1>
<blockquote class="blockquote">
<p>π0: 범용 로봇 제어를 위한 비전-언어-액션 플로우 모델</p>
</blockquote>
<section id="논문의-주요-기여-요약" class="level2">
<h2 class="anchored" data-anchor-id="논문의-주요-기여-요약">논문의 주요 기여 요약</h2>
<p>이 논문에서는 사전학습된 비전-언어 모델(VLM)과 연속 행동 생성용 플로우 매칭(flow matching) 구조를 결합한 새로운 범용 로봇 제어 정책 π0를 제안한다. π0는 인터넷 규모의 시각·언어 정보를 학습한 VLM(예: 3B 파라미터 규모의 PaliGemma)을 백본으로 사용하며, 별도의 액션 전문가(action expert) 모듈을 추가하여 연속적이고 고주파의 로봇 행동을 생성할 수 있다. 학습 방식은 대규모 사전학습(Pre-training) – 파인튜닝(Post-training) 레시피를 따른다. 먼저 7가지 로봇 구성에서 수집된 68개 과제로 이루어진 총 10,000시간 이상의 복잡한 조작 데이터(자사 데이터 + 공개 OXE 데이터셋)를 사용해 모델을 사전학습한다. 그런 다음 고품질 데이터로 파인튜닝하여 세탁물 접기, 상자 조립 같은 복합 다단계 작업을 수행한다. <strong>주요 기여점</strong>은 (1) VLM 기반의 신경망과 플로우 매칭 기반 행동 생성을 통합한 새로운 모델 아키텍처, (2) 다양한 로봇과 작업을 포함하는 대규모 데이터셋 구성 및 사전학습/파인튜닝 레시피, (3) 실험을 통한 일반화 성능 검증이다.</p>
<center>
<img src="../../images/2025-09-29-pi-zero/00.png" width="100%">
</center>
</section>
<section id="기술적-설명" class="level2">
<h2 class="anchored" data-anchor-id="기술적-설명">기술적 설명</h2>
<ul>
<li>비전-언어-액션 통합: π0의 입력 관찰(observation)은 여러 카메라의 RGB 이미지, 텍스트 명령어, 그리고 로봇 관절 상태(프로프리오셉티브 정보)로 구성된다. 이때 이미지와 텍스트 토큰은 사전학습된 VLM 백본(예: PaliGemma)으로 처리되고, 관절 상태와 예측할 액션 토큰은 별도의 액션 전문가(action expert) 모듈로 분리된다. 즉, 하나의 트랜스포머 모델 안에 두 개의 전문가(experts)를 두어, 이미지·언어 입력은 VLM 전문가로, 로봇 상태 및 행동 토큰은 액션 전문가로 각각 라우팅된다. 이때 블록 단위 인과적(attention mask) 주의 메커니즘을 사용하여, 이미지/언어 정보 블록과 행동 토큰 블록이 서로 영향을 주고받도록 설계되었다.</li>
<li>Flow Matching을 통한 행동 예측: π0는 플로우 매칭(flow matching)이라는 확산(diffusion) 기법 변형을 사용해 연속 행동 분포를 모델링한다. 학습 시에는 실제 행동에 가우시안 노이즈를 더한 후, 네트워크가 노이즈 추가된 행동( <span class="math inline">A^τ</span> )에서 원래 행동으로 되돌아가는 노이즈 속도 벡터장을 예측하도록 한다. 이로써 행동 생성이 다중 모드의 연속 분포로 표현되고 높은 정밀도를 유지한다. 추론 시에는 무작위 노이즈로부터 시작하여, 학습한 벡터장을 이용해 여러 단계(논문에서는 10단계, δ=0.1)의 오일러 적분으로 점진적으로 행동 청크(action chunk)를 생성한다. 이 과정에서 모든 행동 토큰은 서로 완전 양방향(attend)이 가능하도록 설계되었으며, 이전에 계산된 키/값은 캐싱하여 효율성을 높였다.</li>
<li>액션 청킹(Action Chunking): π0는 H=50 타임스텝에 해당하는 액션 청크를 한꺼번에 예측한다. 즉, 50프레임 분량의 연속 행동 시퀀스를 한 번에 생성하여 고주파(최대 50Hz)의 세밀한 동작이 가능하다. 이는 단일 스텝씩 디코딩하는 기존의 텍스트 토큰 기반 VLA(vision-language-action) 모델이 어려워했던 복잡한 조작 작업에서 유리하게 작용한다.</li>
<li>크로스 엠바디드먼트 학습: π0는 서로 다른 로봇 플랫폼들의 데이터를 하나의 모델로 통합 학습한다. 실험에 사용된 로봇은 단일/듀얼 암 로봇(UR5e, Franka 등)과 이동형 로봇(모바일 ALOHA 기반) 등 총 7가지 구성이다. 논문에서는 이들 7개 로봇 구성에서 수집된 68개 작업 데이터와 공개 OXE 데이터셋을 결합해 사전학습했으며 , 이를 통해 서로 다른 로봇 간 경험 공유와 범용 제어 능력을 확보하였다.</li>
</ul>
</section>
<section id="실험-및-결과-분석" class="level2">
<h2 class="anchored" data-anchor-id="실험-및-결과-분석">실험 및 결과 분석</h2>
<ul>
<li>Out-of-Box 평가: 사전학습된 π0(파인튜닝 없이) 모델은 다양한 조작 작업에 대해 언어 명령만으로도 높은 성능을 보였다. 예를 들어, “티셔츠 접기”, “식탁 치우기(쉬운/어려운 버전)”, “식료품 봉지 담기”, “토스터에서 토스트 꺼내기” 등의 테스트에서 π0는 기존의 대형 비전-언어-액션 모델(OpenVLA 7B)이나 Octo(93M)보다 월등한 성능을 기록했다. 그림 7에 따르면, 연산량(학습 스텝) 동등 조건(160k 스텝)에서도 π0는 모든 작업에서 기존 모델을 앞섰으며, 풀 학습(700k 스텝)을 거친 π0-full은 모든 과제에서 최상의 성능을 보였다. 성능 지표는 작업별 성공률 및 진행도(예: 정답 물체 배치 개수)로 측정되었다.</li>
<li>언어 명령 수행: π0는 언어 지시에 따라 물체를 집어놓는 작업에서도 좋은 결과를 보였다. “테이블 비우기”나 “식탁 차리기” 등 일련의 객체 옮기기 작업에서, 단순한 “전체 작업만 명령(π0-flat)” 대신 중간 단계별 명령(π0-human)이나 상위 정책(π0-HL)으로 안내할 때 성공률이 크게 올랐다. 특히 π0는 작은 크기(VLM 비적용)의 비교모델(π0-small)에 비해 언어 이해 능력이 월등하여, 사람이 제공한 단계별 지시를 잘 따랐고, 상위 VLM 정책의 지시를 받았을 때에도 성능 향상이 뚜렷했다. 이는 VLM 사전학습이 언어 명령 수행 능력을 크게 향상시킴을 보여준다.</li>
<li>파인튜닝 과제: 파인튜닝을 통해 π0는 새로운 단일 단계 조작 과제도 학습했다. 예를 들어, 쌓아 올린 그릇 정리(stack bowls), 수건 접기(towel folding), 전자레인지 조작 등에서 π0는 비교적 적은 양의 데이터로도 높은 완성도를 달성했다. 그림 11에 따르면, 사전학습된 π0는 무작위 초기화 모델에 비해 적은 학습 데이터(1~10시간)로도 빠르게 성능을 향상시켰으며, 특히 쉬운 과제에서는 소량의 데이터만으로도 50% 이상의 성능을 달성했다. 이는 사전학습이 파인튜닝 데이터 효율성과 일반화에 기여함을 의미한다.</li>
<li>복합 다단계 과제: π0는 세탁물 접기, 이동식 세탁물 처리, 건조기 옮기기, 실물 점심 테이블 청소, 박스 조립, 포장 계란 등 매우 복잡한 다단계 작업에서도 성능을 보였다. 그림 12, 13에 나타난 바와 같이, 사전학습+파인튜닝된 π0-full은 모든 과제에서 10회 평균 50% 이상의 점수를 기록했으며, 사전학습 없는 scratch 모델이나 사전학습만(out-of-box) 모델보다 월등히 높은 성능을 보였다. 특히 빨랫감 접기나 박스 조립처럼 난이도가 높은 작업에서는 사전학습 효과가 크게 나타났는데, π0-full은 과제별 최고 점수의 절반 이상을 꾸준히 달성하며 새로운 SOTA 수준의 제어 능력을 입증했다. 이러한 평가는 객관적 채점 기준(1.0 완벽 수행)으로 10회 반복 평균을 사용했다.</li>
</ul>
</section>
<section id="장점과-한계-분석" class="level2">
<h2 class="anchored" data-anchor-id="장점과-한계-분석">장점과 한계 분석</h2>
<ul>
<li><p><strong>장점</strong>: π0의 강점은 범용성과 데이터 효율성에 있다. 사전학습된 VLM을 활용함으로써 인터넷 규모의 시각-언어 지식을 계승하여, 각 작업별로 특화된 모델보다 광범위한 상황에 대응할 수 있다. 다양한 로봇 플랫폼의 데이터를 단일 모델로 통합 학습하였기에, 서로 다른 로봇 간 전이 학습이 가능하다. 또한 액션 청킹과 플로우 매칭 덕분에 최대 50Hz의 고주파 연속 제어가 가능하여 세밀한 조작 수행이 가능하다. 실험 결과, 사전학습 π0는 적은 파인튜닝 데이터만으로도 빠르게 성능을 높였는데, 예를 들어 일부 쉬운 과제에서는 1시간 미만의 데이터만으로도 기본 성능에 도달했다.</p></li>
<li><p><strong>한계</strong>: π0는 현재의 대규모 데이터 요구량과 계산 비용 때문에 현실적 한계도 존재한다. 사전학습에는 10,000시간 이상의 행동 데이터가 필요했고 , 전체 모델 크기는 33억 파라미터에 달한다. 따라서 모델 학습 및 추론 시 고성능 하드웨어와 긴 시간이 필요하다. 실시간 제어 측면에서도, 플로우 매칭은 다중 적분 단계를 요구하므로(논문에서는 10스텝) 응답 지연이 있을 수 있다. 또한 모든 과제에서 완벽한 성공률을 보장하지는 못했다. 논문에서도 일부 과제는 신뢰성에 한계가 있었음을 언급하며, 사전학습 데이터 구성(어떤 작업, 어떤 비율이 중요한지)과 추가 데이터의 효과는 아직 연구 과제로 남아있다. 마지막으로, 실제 로봇에 적용할 때 발생할 수 있는 안전성 문제(예: 예기치 않은 행동, 환경과의 충돌)도 고려되어야 한다.</p></li>
</ul>
</section>
<section id="향후-연구-방향" class="level2">
<h2 class="anchored" data-anchor-id="향후-연구-방향">향후 연구 방향</h2>
<p>논문 저자들은 데이터 구성과 범용성 등에 대해 추가 연구의 여지를 제시했다. 실제 로봇 시스템으로 확장하려면 실시간 제어와 안전성 보장이 중요하다. 예를 들어, 추론 속도를 높이거나 안전 필터를 추가하는 연구가 필요할 것이다. 모델이 적응성을 갖추도록 온라인 학습이나 도메인 적응 방법도 유망하다. 또한 고수준 계획(Low-level 제어와 상위 레벨 계획 통합)을 위해 언어 기반 플래너나 강화학습 기법과의 연동도 고려할 수 있다. 마지막으로, 논문에서는 자동차 자율주행이나 보행 로봇 등 매우 다른 도메인으로의 확장 가능성도 언급한다. 예를 들어 주행 네비게이션, 보행 제어 같은 분야에 π0 같은 로봇 파운데이션 모델 개념을 적용할 수 있는지 탐구하는 것이 향후 과제다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>