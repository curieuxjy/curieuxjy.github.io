<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-04-20">
<meta name="description" content="Physics-Informed Reconstruction and Simulation of Deformable Objects from Videos">

<title>📃PhysTwin 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-1e438c382a17f6d88d3993662a872df6.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-a37c72dd2dbac68997fcdc15a3622e78.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-84849963b3550dada6ad14ca0722a3fc.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-1da3f21b942a7af985a78b7d88029ecb.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-84849963b3550dada6ad14ca0722a3fc.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    window.setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      window.setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    window.hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(darkModeDefault) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const darkModeDefault = false;
    document.querySelector('link.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !window.hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
    };
    // Switch to dark mode if need be
    if (window.hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review"><span class="header-section-number">1</span> Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review"><span class="header-section-number">2</span> Detail Review</a>
  <ul class="collapse">
  <li><a href="#서론-introduction" id="toc-서론-introduction" class="nav-link" data-scroll-target="#서론-introduction"><span class="header-section-number">2.1</span> 서론 (Introduction)</a></li>
  <li><a href="#배경-디지털-트윈과-변형체-재구성" id="toc-배경-디지털-트윈과-변형체-재구성" class="nav-link" data-scroll-target="#배경-디지털-트윈과-변형체-재구성"><span class="header-section-number">2.2</span> 배경: 디지털 트윈과 변형체 재구성</a></li>
  <li><a href="#phystwin-프레임워크-개요" id="toc-phystwin-프레임워크-개요" class="nav-link" data-scroll-target="#phystwin-프레임워크-개요"><span class="header-section-number">2.3</span> PhysTwin 프레임워크 개요</a></li>
  <li><a href="#단계-기하-및-물리-파라미터-최적화-physics-and-geometry-optimization" id="toc-단계-기하-및-물리-파라미터-최적화-physics-and-geometry-optimization" class="nav-link" data-scroll-target="#단계-기하-및-물리-파라미터-최적화-physics-and-geometry-optimization"><span class="header-section-number">2.4</span> 1단계: 기하 및 물리 파라미터 최적화 (Physics and Geometry Optimization)</a>
  <ul class="collapse">
  <li><a href="#a-생성적-shape-prior를-활용한-초기-형상-복원" id="toc-a-생성적-shape-prior를-활용한-초기-형상-복원" class="nav-link" data-scroll-target="#a-생성적-shape-prior를-활용한-초기-형상-복원"><span class="header-section-number">2.4.1</span> (a) 생성적 Shape Prior를 활용한 초기 형상 복원</a></li>
  <li><a href="#b-스프링-질점-모델-구성과-계층적-물리-파라미터-최적화" id="toc-b-스프링-질점-모델-구성과-계층적-물리-파라미터-최적화" class="nav-link" data-scroll-target="#b-스프링-질점-모델-구성과-계층적-물리-파라미터-최적화"><span class="header-section-number">2.4.2</span> (b) 스프링-질점 모델 구성과 계층적 물리 파라미터 최적화</a></li>
  </ul></li>
  <li><a href="#단계-appearance-최적화-appearance-optimization" id="toc-단계-appearance-최적화-appearance-optimization" class="nav-link" data-scroll-target="#단계-appearance-최적화-appearance-optimization"><span class="header-section-number">2.5</span> 2단계: Appearance 최적화 (Appearance Optimization)</a></li>
  <li><a href="#phystwin의-성과와-응용" id="toc-phystwin의-성과와-응용" class="nav-link" data-scroll-target="#phystwin의-성과와-응용"><span class="header-section-number">2.6</span> PhysTwin의 성과와 응용</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃PhysTwin 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">paper</div>
    <div class="quarto-category">manipulation</div>
  </div>
  </div>

<div>
  <div class="description">
    Physics-Informed Reconstruction and Simulation of Deformable Objects from Videos
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 20, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://arxiv.org/abs/2503.17973">논문 링크</a></li>
<li><a href="https://jianghanxiao.github.io/phystwin-web/">Project Homepage</a></li>
<li><a href="https://github.com/Jianghanxiao/PhysTwin">Code Repository</a></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../images/2025-04-20-phystwin/pipeline.png" class="img-fluid figure-img"></p>
<figcaption>pipeline</figcaption>
</figure>
</div>
<p>이 논문은 동적 객체의 물리 기반 디지털 트윈(PhysTwin)을 생성하는 새로운 프레임워크를 제시합니다. PhysTwin은 로봇 공학, 콘텐츠 제작, 확장 현실(XR) 분야에서 현실 세계 객체를 모델링하고 미래 상태를 시뮬레이션하는 데 중요한 역할을 할 수 있습니다. 이 프레임워크는 상호 작용 중인 변형 가능한 객체의 희소한 비디오로부터 완전한 geometry, 고화질 appearance, 정확한 physical parameter를 갖춘 시뮬레이션 가능한 디지털 트윈을 재구성합니다.</p>
<ol type="1">
<li>📦 PhysTwin은 상호 작용 하에서 변형 가능한 객체의 스파스 비디오로부터 사실적인 디지털 트윈을 재구성하고 시뮬레이션하는 새로운 프레임워크입니다.</li>
<li>🤖 이 프레임워크는 미래 상태를 정확하게 예측하고 보이지 않는 액션으로 일반화되는 객체 상호 작용을 시뮬레이션하는 데 탁월합니다.</li>
<li>✨ PhysTwin은 고속 시뮬레이션과 정확한 미래 예측을 요구하는 다양한 다운스트림 작업을 가능하게 하며 로봇 조작에 대한 귀중한 통찰력을 제공합니다.</li>
</ol>
<section id="brief-review" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Brief Review</h1>
<p><strong>핵심 방법론</strong></p>
<p>PhysTwin은 다음과 같은 두 가지 핵심 요소로 구성됩니다.</p>
<ol type="1">
<li><p><strong>Physics-informed representation:</strong> spring-mass model을 사용하여 realistic physical simulation을 수행하고, generative shape model을 사용하여 geometry를 생성하며, Gaussian splat을 사용하여 렌더링합니다. Spring-mass model은 변형 가능한 객체를 spring으로 연결된 mass node의 집합으로 표현하며, Newtonian dynamics에 따라 시간이 지남에 따라 진화합니다. Gaussian splat은 object appearance를 모델링하는 데 사용됩니다.</p></li>
<li><p><strong>Multi-stage, optimization-based inverse modeling framework:</strong> 비디오로부터 완전한 geometry를 재구성하고, dense physical parameter를 추론하며, realistic appearance를 복제합니다. 이 프레임워크는 inverse physics framework와 visual perception cue를 통합하여 부분적으로 가려지거나 제한된 시점에서 촬영된 비디오에서도 고화질 재구성이 가능하도록 합니다. Hierarchical sparse-to-dense optimization strategy는 non-differentiable topology 및 sparse physical parameter에 대해 zero-order optimization을 통합하고, dense spring stiffness를 개선하고 collision parameter를 추가로 최적화하기 위해 first-order gradient-based optimization을 사용합니다.</p></li>
</ol>
<p><strong>수식</strong></p>
<ul>
<li><p>Force on node i:</p>
<p><span class="math inline">F_i = \sum_{(i,j) \in E} F_{spring_{i,j}} + F_{dashpot_{i,j}} + F_{ext_i}</span></p></li>
<li><p>Spring force between nodes i and j:</p>
<p><span class="math inline">F_{spring_{i,j}} = k_{ij} (||x_j - x_i|| - l_{ij}) \frac{x_j - x_i}{||x_j - x_i||}</span></p></li>
<li><p>Dashpot damping force between nodes i and j:</p>
<p><span class="math inline">F_{dashpot_{i,j}} = -\gamma (v_i - v_j)</span></p></li>
<li><p>Dynamic model:</p>
<p><span class="math inline">X_{t+1} = f_{\alpha, G_0} (X_t, a_t)</span></p></li>
<li><p>Velocity update:</p>
<p><span class="math inline">v_i^{t+1} = \delta (v_i^t + \Delta t \frac{F_i}{m_i})</span></p></li>
<li><p>Position update:</p>
<p><span class="math inline">x_i^{t+1} = x_i^t + \Delta t v_i^{t+1}</span></p></li>
<li><p>Overall optimization problem:</p>
<p><span class="math inline">\min_{\alpha, G_0, \theta} \sum_{t,i} C(\hat{O}_{t,i}, O_{t,i})</span></p>
<p>subject to <span class="math inline">\hat{O}_{t,i} = g_\theta(\hat{X}_t, i)</span>, <span class="math inline">\hat{X}_{t+1} = f_{\alpha, G}(\hat{X}_t, a_t)</span></p></li>
<li><p>Physics and geometry optimization:</p>
<p><span class="math inline">\min_{\alpha, G_0} \sum_t (C_{geometry}(\hat{X}_t, X_t) + C_{motion}(\hat{x}_i^t, x_i^t))</span></p>
<p>subject to <span class="math inline">\hat{X}_{t+1} = f_{\alpha, G_0}(\hat{X}_t, a_t)</span></p></li>
<li><p>Gaussian kernel transformations</p>
<p><span class="math inline">R_i^t = \argmin_{R \in SO(3)} \sum_{j \in N(i)} ||R(\hat{\mu}_j^t - \hat{\mu}_i^t) - (\hat{\mu}_j^{t+1} - \hat{\mu}_i^{t+1})||^2</span></p>
<p><span class="math inline">\mu_j^{t+1} = \sum_{k \in N(j)} w_{jk}^t (R_k^t (\mu_j^t - \hat{\mu}_k^t) + \hat{\mu}_k^t + T_k^t)</span></p>
<p><span class="math inline">q_j^{t+1} = (\sum_{k \in N(j)} w_{jk}^t r_k^t) \otimes q_j^t</span></p>
<p><span class="math inline">w_{jk}^t = \frac{||\mu_j^t - \hat{\mu}_k||^{-1}}{\sum_{k \in N(j)} ||\mu_j^t - \hat{\mu}_k||^{-1}}</span></p></li>
<li><p>Appearance optimization:</p>
<p><span class="math inline">\min_{\theta} \sum_{t,i} C_{render}(\hat{I}_{i,t}, I_{i,t})</span></p>
<p>subject to <span class="math inline">\hat{I}_{i,t} = g_{\theta}(\hat{X}_t, i)</span></p></li>
</ul>
<p><strong>결과</strong></p>
<p>실험 결과 PhysTwin은 재구성, 렌더링, 미래 예측, 새로운 상호 작용에서의 시뮬레이션 측면에서 기존 방법보다 우수한 성능을 보입니다. 또한, 실시간 상호 작용 시뮬레이션 및 모델 기반 로봇 동작 계획과 같은 응용 분야에서도 효과적인 것으로 나타났습니다. PhysTwin은 로프, 봉제 인형, 천, 배달 패키지 등 다양한 변형 가능한 객체를 모델링할 수 있습니다.</p>
</section>
<section id="detail-review" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Detail Review</h1>
<blockquote class="blockquote">
<p>PhysTwin: Physics-Informed Reconstruction and Simulation of Deformable Objects from Videos – 심층 리뷰</p>
</blockquote>
<section id="서론-introduction" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="서론-introduction"><span class="header-section-number">2.1</span> 서론 (Introduction)</h2>
<p>물리적으로 실제와 같은 <strong>디지털 트윈</strong>(digital twin)을 구축하는 것은 로봇 공학, 콘텐츠 제작, XR 등 다양한 분야에서 중요합니다. 특히 밧줄, 인형, 천과 같은 <strong>변형체</strong>(deformable object)를 다룰 경우, 디지털 트윈은 객체의 <strong>기하학적 형상(geometry)</strong>, <strong>겉보기 속성(appearance)</strong>, 그리고 <strong>물리적 특성(physical properties)</strong>을 정확히 캡처하여 실제 세계와 잘 일치하는 시뮬레이션을 가능하게 해야 합니다. 하지만 제한된 <strong>관찰 영상</strong>(sparse videos)만으로 이러한 변형체의 디지털 트윈을 만드는 것은 매우 어려운 문제입니다. 기존의 동적 3D 재구성 기법들, 예를 들어 <strong>dynamic NeRF</strong>나 <strong>dynamic 3D Gaussian splatting</strong> 기반 방법들은 동영상으로부터 장면의 모양, 움직임, 외형을 고품질로 복원할 수 있었지만, 근본적인 물리 법칙(underlying physics)을 포함하지 않기 때문에 새로운 상호작용 상황을 시뮬레이션하기에는 적합하지 않았습니다. 최근에는 학습 기반으로 물리를 모사하려는 시도도 있었지만, 완전한 초기 3D 스캔이 필요하거나 실제 물리와 어긋난 단순화된 모델을 사용하는 등의 한계가 있었습니다. 예를 들어 2024년의 Spring-Gaus 방법은 물리 모델에서 관성 보존이나 실제 중력과 같은 요소가 빠져 있어 현실성을 떨어뜨렸고, 초기 상태의 전체 형상을 재구성하려면 많은 관측 시야가 필요했습니다.</p>
<p>이러한 한계를 극복하기 위해 2025년 Jiang 등은 <strong>PhysTwin</strong>이라는 새로운 프레임워크를 제안했습니다. PhysTwin은 상호작용 중인 변형체의 <strong>드문 시점 영상</strong>(sparse multi-view videos)을 입력으로 받아, <strong>사진처럼 현실적이고 물리적으로 일관된(realistic)</strong> 가상 객체를 재구성하며 실시간 상호작용이 가능한 디지털 트윈을 생성합니다. 이 방법의 핵심은 두 가지입니다. 첫째, <strong>물리 지식이 반영된 표현(physics-informed representation)</strong>으로, <strong>spring-mass model</strong>을 이용한 물리 시뮬레이션에 <strong>생성적 형상 모델(generative shape model)</strong>을 통한 3D 형상 표현과 <strong>Gaussian splats</strong>를 통한 렌더링 표현을 결합합니다. 둘째, <strong>다단계 최적화 기반 역모델링 절차(multi-stage, optimization-based inverse modeling)</strong>로, 영상으로부터 객체의 완전한 3D 형상과 밀도 있는 물리 파라미터를 추론하고, 현실감 있는 외형을 복원합니다. 요약하면, PhysTwin은 <strong>시각 정보</strong>(visual perception cues)와 <strong>역물리 시뮬레이션(inverse physics)</strong>을 통합함으로써, 가려지거나 일부만 보이는 상황에서도 높은 완성도의 복원을 이루어냅니다. 이러한 접근을 통해 PhysTwin은 밧줄, 봉제인형, 천, 포장 상자 등 다양한 변형체에 적용 가능하며, 복원된 디지털 트윈을 이용한 재시뮬레이션(resimulation), 미래 상태 예측, 새로운 상호작용 시나리오 시뮬레이션 등에서 기존 방법들을 능가하는 성능을 보였습니다. 더불어 실시간 상호작용 시뮬레이션이나 로봇의 모션 플래닝에 PhysTwin을 활용하는 응용 가능성도 제시되었습니다.</p>
<p>예를 들어, 아래 <strong>Figure 1</strong>과 같이 PhysTwin은 사람 손으로 물체를 변형시키는 장면이 담긴 몇 개의 동영상을 입력으로 받아서, 해당 물체의 완전한 3D 형태, 정확한 물리 파라미터, 그리고 고품질의 질감을 가진 <strong>가상 복제물</strong>을 만들어냅니다. 그런 다음 사용자가 키보드나 로봇 인터페이스로 가상 물체를 실시간 조작하거나, 로봇 플래닝에 활용하는 등 다양한 응용이 가능해집니다. (Figure 1: PhysTwin 결과의 개요)</p>
</section>
<section id="배경-디지털-트윈과-변형체-재구성" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="배경-디지털-트윈과-변형체-재구성"><span class="header-section-number">2.2</span> 배경: 디지털 트윈과 변형체 재구성</h2>
<p>현실 세계의 <strong>동적 장면 재구성</strong>(dynamic scene reconstruction)은 오래전부터 도전적인 연구 주제였습니다. 최근 등장한 <strong>NeRF</strong>(Neural Radiance Fields) 계열 기법이나 3D Gaussian splatting 기법들은 동영상 데이터를 이용해 시간에 따라 변하는 장면의 형태와 색상을 정밀하게 복원할 수 있게 되었습니다. 예를 들어 Dynamic NeRF는 변형 필드를 최적화하여 시간에 따른 3D 장면을 표현하고, Dynamic 3D Gaussian Splatting은 매 프레임 Gaussian 커널들의 위치를 최적화함으로써 장면의 변화를 포착합니다. 그러나 이러한 방법들은 <strong>장면의 겉보기와 기하</strong>에만 집중할 뿐, 객체가 어떻게 움직이고 힘에 반응하는지 <strong>물리적 동역학</strong>(dynamics)은 모델링하지 않습니다. 그 결과, 단순히 관찰된 범위 내의 <strong>재현(replay)</strong>에는 성공하더라도, 사용자가 새롭게 힘을 가하거나 다른 상호작용을 가했을 때 객체가 어떻게 거동할지 <strong>예측하거나 시뮬레이션하는 능력</strong>이 부족합니다. 다시 말해, <strong>action-conditioned</strong> 미래 예측이나 상호작용 시뮬레이션에 한계가 있는 것이죠.</p>
<p>한편, <strong>물리 기반 시뮬레이션</strong>을 재구성에 활용하려는 연구들도 있었습니다. 시스템 식별을 위해 물리 시뮬레이터를 활용한 방법들은 대개 미리 스캔된 정적 3D 모델 또는 매우 깨끗한 포인트 클라우드 데이터를 필요로 했습니다. 예전 접근법들은 카메라로 얻은 데이터만으로 동시에 3D 형상과 물리 파라미터를 추정하기 어려워, 보통 형상을 별도로 스캔하거나 단순화된 물리 모델을 사용하곤 했습니다. 2024년의 Spring-Mass + Gaussian 방법 (Spring-Gaus)은 영상으로부터 탄성 객체를 복원하려 했지만, 초기 상태에서 객체의 전 표면이 보이는 다수의 시점이 필요했고 물리 모델도 엄밀하지 않아 한계가 있었습니다. 이처럼 기존 방법들은 <strong>시각적 정확도</strong>와 <strong>물리적 정확성</strong>을 모두 충족시키지 못하거나, 완전한 입력 정보를 가정해야 했습니다.</p>
<p>PhysTwin은 이러한 배경에서 제안된 것으로, <strong>시각 정보</strong>와 <strong>물리 시뮬레이션</strong>을 긴밀히 결합하여 부분적인 관찰만으로도 <strong>물리적으로 충실한 디지털 트윈</strong>을 구축하는 최초의 프레임워크 중 하나입니다. 다음으로, PhysTwin의 전체적인 구성과 작동 방식을 살펴보고, 주요 기술 구성 요소들을 단계별로 자세히 리뷰하겠습니다.</p>
</section>
<section id="phystwin-프레임워크-개요" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="phystwin-프레임워크-개요"><span class="header-section-number">2.3</span> PhysTwin 프레임워크 개요</h2>
<p>PhysTwin의 입력으로는 상호작용 중인 변형체를 촬영한 <strong>세 개의 RGB-D 카메라 영상</strong>(세 시점의 RGB 영상과 깊이 맵 시퀀스)이 주어집니다. 목표는 시간 <span class="math inline">t=0</span>부터 <span class="math inline">T</span>까지의 영상 관측 <span class="math inline">\{I_i^t, D_i^t\}_{i=1..3}</span>으로부터 객체의 <strong>기하, 물리, 외형 파라미터</strong>를 모두 식별하여, 임의의 새로운 상호작용에 대해서도 현실과 일치하는 동적 거동을 보이는 <strong>시뮬레이션 모델</strong>을 구축하는 것입니다. 이를 위해 PhysTwin은 다음과 같은 <strong>코어 representation</strong>을 사용합니다:</p>
<ul>
<li><strong>Geometry(기하)</strong>: 객체를 나타내는 3D 메시(mesh) 혹은 포인트들의 집합 (질점들의 집합).<br>
</li>
<li><strong>Topology(토폴로지)</strong>: 질점들 간을 연결하는 <strong>spring-mass 모델</strong>의 구조 (어떤 점들이 스프링으로 연결되는지).<br>
</li>
<li><strong>Physical Parameters(물리 파라미터)</strong>: 각 스프링의 강성(stiffness) 계수, 감쇠(damping), 충돌 처리 계수, 질점 질량 등 물리 시뮬레이션에 필요한 변수들. 또한 사람 손과 같은 외부 <strong>제어점(control point)</strong>과 객체를 연결하는 스프링의 속성도 포함됩니다.<br>
</li>
<li><strong>Appearance(외형)</strong>: 객체의 겉보기 색깔과 질감을 나타내는 표현으로, PhysTwin에서는 다수의 3D <strong>Gaussian kernel</strong> (Gaussian splat)들로 표현합니다. 각 Gaussian은 공간상의 위치와 크기, 방향성 및 색상, 불투명도 등을 파라미터로 갖는 3차원적인 흐릿한 점으로 이해할 수 있습니다.</li>
</ul>
<p>이러한 표현을 최적화하기 위해 PhysTwin은 <strong>전체 목표 함수</strong>를 정의합니다. 시뮬레이터로 예측한 시점 <span class="math inline">t</span>의 <strong>예측 관측</strong>과 실제 카메라의 <strong>실제 관측</strong> 사이의 차이를 최소화하는 것이 목적입니다. 보다 구체적으로, 전체 <strong>코스트 함수(cost)</strong> <span class="math inline">\mathcal{C}</span>는 세 가지 항의 합으로 표현됩니다:</p>
<p><span class="math display"> \mathcal{C} \;=\; \mathcal{C}_{geometry} + \mathcal{C}_{motion} + \mathcal{C}_{render} </span></p>
<p>각각 <strong>3D 기하 오차</strong>(geometry term), <strong>3D 모션/추적 오차</strong>(motion term), 그리고 <strong>영상 재현 오차</strong>(render term)를 의미합니다. 첫 번째 항 <span class="math inline">\mathcal{C}_{geometry}</span>는 시뮬레이션된 객체 상태와 실제 관찰된 3D 정보 간의 차이를 측정합니다. 예를 들어, 각 프레임에서 카메라 깊이 정보를 모아 얻은 <strong>부분적인 3D 포인트 클라우드</strong> <span class="math inline">P_t</span>와, 동일 시각에 시뮬레이터로 예측한 객체의 질점들 <span class="math inline">X_t</span> 사이의 <strong>챔퍼 거리(Chamfer distance)</strong>를 계산하여 형상 간 불일치를 정량화합니다. 두 번째 항 <span class="math inline">\mathcal{C}_{motion}</span>는 객체 표면의 특징점 움직임을 비교하는데, <strong>비전 파운데이션 모델</strong>인 <strong>CoTracker</strong>를 활용해 영상에서 추적한 2D 점들을 깊이 맵으로 3D 공간에 투영하여 얻은 <strong>추적 점 궤적들</strong>(pseudo 3D tracks)과 시뮬레이션된 질점들의 궤적을 대응시켜 오차를 계산합니다. 세 번째 항 <span class="math inline">\mathcal{C}_{render}</span>는 복원된 객체를 렌더링한 결과 영상과 실제 RGB 영상 간의 차이를 측정합니다. 이 항은 주로 객체의 색상, 텍스쳐 등 <strong>겉보기 차이</strong>를 penalize하며, 구체적인 항목은 후술할 <strong>Appearance 최적화 단계</strong>에서 정의됩니다.</p>
<p>PhysTwin은 이 목표 함수를 직접 한 번에 최적화하는 대신, <strong>2단계에 걸쳐 최적화</strong>를 수행합니다. <strong>첫 번째 단계</strong>에서는 주로 <strong>geometry와 physical parameters</strong> (형상 및 물리 파라미터)에 초점을 맞춰, 객체의 형태와 역학적 거동을 복원합니다. 이 단계에서는 주로 <span class="math inline">\mathcal{C}_{geometry}</span>와 <span class="math inline">\mathcal{C}_{motion}</span> 항의 감소에 주력하며, 객체의 <strong>정적 3D 형상</strong>과 <strong>스프링-질점 모델의 물리계수</strong>들을 조정합니다. <strong>두 번째 단계</strong>에서는 <strong>appearance 관련 파라미터</strong>들을 최적화하여, 객체의 시각적 품질을 높입니다. 이때 <span class="math inline">\mathcal{C}_{render}</span> 항을 최소화하는 방향으로 Gaussian 커널들의 색상, 투명도 등을 학습하며, 1단계에서 구한 기하/물리 모델은 고정해 둡니다. Figure 2는 PhysTwin 프레임워크의 개괄적인 구조를 보여주는데, 입력 영상으로부터 얻은 기하/모션 관찰치와 시뮬레이터의 예측을 비교하는 <strong>렌더링 손실</strong>과 <strong>기하/모션 손실</strong>로 구성 요소들을 최적화함을 도식적으로 표현하고 있습니다.</p>
<p><strong>Figure 2: PhysTwin 프레임워크 개요</strong> – 카메라 영상으로부터 부분 점군 및 추적 데이터를 얻어내고(오른쪽 상단: Pseudo Track 및 GT Observation), 이를 토대로 PhysTwin의 representation(왼쪽 하단: Geometry, Topology, Physical parameters, Gaussians로 구성)을 최적화합니다. 최적화는 시뮬레이션된 기하/모션 상태(오른쪽 하단)와 영상 관찰치를 비교하는 비용 <span class="math inline">\mathcal{C} = C_{geometry} + C_{motion} + C_{render}</span>를 줄이는 방향으로 수행됩니다. 이 과정에서 기하/모션 불일치는 Chamfer 거리 등의 지표로 측정되고, 렌더링 불일치는 영상 비교 손실(D-SSIM 등)로 계산됩니다. 최종적으로 물리 시뮬레이터를 통해 예측한 변형체의 거동(Simulated Geometry and Motion)이 실제 영상과 잘 맞아떨어지고, Gaussian splatting을 통해 렌더링한 결과도 실제 영상(GT Observation)에 가까워지도록 학습됩니다.</p>
<p>이제 각 단계를 순차적으로 살펴보겠습니다.</p>
</section>
<section id="단계-기하-및-물리-파라미터-최적화-physics-and-geometry-optimization" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="단계-기하-및-물리-파라미터-최적화-physics-and-geometry-optimization"><span class="header-section-number">2.4</span> 1단계: 기하 및 물리 파라미터 최적화 (Physics and Geometry Optimization)</h2>
<p>첫 단계에서는 객체의 <strong>정적 형상</strong>과 <strong>동적 거동에 관한 물리 파라미터</strong>를 복원합니다. 입력으로 주어진 RGB-D 영상들로부터 먼저 얻을 수 있는 정보는 제한적입니다. 각 카메라 뷰에서 매 프레임마다 객체의 일부만 보이기 때문에, 깊이 맵을 <strong>점군(point cloud)</strong>으로 변환하면 객체 표면의 <strong>일부 조각들</strong>만 얻어지게 됩니다. 이를 <span class="math inline">P_t</span>라고 하면 <span class="math inline">P_t</span>는 시각 <span class="math inline">t</span>에 관찰된 객체 표면의 부분 집합입니다. 또한 객체 표면 위의 임의의 점들의 움직임을 포착하기 위해, CoTracker로 다수의 특징점을 추적하여 2D 궤적을 얻은 뒤, 해당 점들의 깊이 값을 이용해 3D 공간의 <strong>추정 궤적(pseudo-ground-truth tracks)</strong> <span class="math inline">\{T_j(t)\}</span>를 복원합니다. 이렇게 얻은 <span class="math inline">P_t</span>와 <span class="math inline">T_j(t)</span>는 PhysTwin의 물리 모델을 맞추기 위한 <strong>관찰 데이터</strong>로 활용됩니다. 이들을 활용하여 앞서 언급한 <span class="math inline">\mathcal{C}_{geometry}</span> (예측 형상 vs 관찰 점군 간 차이)와 <span class="math inline">\mathcal{C}_{motion}</span> (예측 질점 vs 추적 점 궤적 간 차이) 항을 계산하고, 이를 줄이는 방향으로 모델 파라미터를 찾는 것이 1단계의 핵심 목표입니다.</p>
<p>그러나 이 최적화는 몇 가지 <strong>난제</strong>가 있습니다. 첫째, 관찰은 <strong>부분적(partial)</strong>이어서 객체의 보이지 않는 뒷면이나 내부 구조를 알 수 없습니다. 둘째, 우리가 최적화해야 할 파라미터들 중 일부는 <strong>이산적인(topology)</strong> 것들입니다 (예: 어떤 질점들 사이에 스프링을 연결할지 여부 등), 반면 나머지는 연속적인 물리 계수들입니다. 형상(topology)과 물리 파라미터를 <strong>동시에</strong> 최적화해야 하는데, 이산적 의사결정이 섞여 있어 매우 복잡합니다. 셋째, 객체의 시간에 따른 동적 거동을 길게 시뮬레이션해야 하고, 파라미터 공간 차원도 매우 높기 때문에 (수만 개의 스프링 강성 등) <strong>경사하강법</strong>(gradient descent)을 바로 적용하면 지역해에 빠지거나 수렴이 어렵습니다. 또한 물리 시뮬레이션 자체도 충돌 등으로 인해 <strong>비연속적 현상</strong>(discontinuities)이 존재해 미분 가능한 최적화에 어려움을 줍니다.</p>
<p>PhysTwin은 이러한 문제를 해결하기 위해 <strong>geometry</strong>와 그 외 <strong>물리 파라미터</strong> 최적화를 분리하고, 거친 수준에서 세밀한 수준으로 가는 <strong>계층적 최적화 전략(hierarchical sparse-to-dense optimization)</strong>을 도입합니다. 크게 두 단계로 나뉘는데, 먼저 <strong>형상(geometry)</strong>을 비교적 정확히 초기화한 뒤, 이를 기반으로 물리 파라미터(토폴로지 및 강성 등)를 1차 조정하고, 이후에 <strong>세밀한 파라미터</strong>까지 포함하여 최종 미세 조정을 하는 방식입니다. 아래에 그 내용을 순서대로 정리합니다.</p>
<section id="a-생성적-shape-prior를-활용한-초기-형상-복원" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="a-생성적-shape-prior를-활용한-초기-형상-복원"><span class="header-section-number">2.4.1</span> (a) 생성적 Shape Prior를 활용한 초기 형상 복원</h3>
<p>부분 관찰만으로 객체의 전체 모양을 추정하기 위해, 저자들은 <strong>사전 학습된 3D 생성 모델</strong>을 활용했습니다. Microsoft의 <strong>TRELLIS</strong>라는 이미지-투-3D 모델을 사용하여, 첫 번째 카메라 뷰의 RGB 이미지에 기반한 <strong>형상 priors</strong>를 얻었습니다. 먼저 각 영상에서 <strong>Segment Anything Model (SAM)</strong>을 기반으로 객체의 마스크를 얻고, 해당 객체 부위 이미지를 <strong>초해상(super-resolution)</strong> 모델로 고해상도로 업스케일링합니다. 그 이미지를 TRELLIS에 입력하면, 객체의 전체 3D 메쉬를 생성해줍니다. 이는 마치 “이런 이미지를 가진 물체라면 3D 형태는 이럴 것이다”라고 사전에 학습된 지식을 활용해 추측하는 과정입니다. 이렇게 얻은 초기 메쉬는 실제 관찰과 <strong>대략적인 형태 유사성</strong>은 있지만, 정확한 <strong>크기(scale)</strong>나 <strong>위치(pose)</strong>, 세부 <strong>변형(deformation)</strong> 면에서 차이가 있을 수 있습니다.</p>
<p>이를 보완하기 위해 <strong>정합(registration) 모듈</strong>을 설계하여 초기 메쉬를 실제 관찰 데이터에 맞게 정렬합니다. 먼저, 특징 매칭 알고리즘인 <strong>SuperGlue</strong>를 통해 초기 메쉬의 가상 투영과 실제 이미지 간 2D 특징점 대응을 찾아 <strong>카메라 회전</strong>(orientation)을 추정합니다. 이는 <strong>PnP(Perspective-n-Point)</strong> 방법으로 세밀히 보정됩니다. 다음으로, 대응되는 3D 점 쌍 간 거리를 카메라 좌표계에서 맞추는 최적화를 통해 <strong>스케일(scale)</strong>과 <strong>평행이동(translation)</strong> 불일치를 해결합니다. 이후 메쉬를 실제 관찰에 최대한 맞추기 위해 <strong>ARAP (As-Rigid-As-Possible) 변형</strong> 알고리즘을 적용, 큰 형태는 유지하면서도 세부적으로 메쉬를 관찰 점군에 밀착시키도록 변형합니다. 마지막으로 <strong>레이캐스팅 정합(ray-casting alignment)</strong> 단계에서는 카메라에서 본 실제 점들이 메쉬 표면에 정확히 닿도록 미세 조정하여, occlusion 없이 관찰된 점들이 메쉬에 맵핑되게 합니다. 이러한 일련의 정합 과정을 거치면 <strong>초기 프레임의 관찰치에 정렬된 전체 형상 메쉬</strong>를 얻을 수 있고, 이는 이후 물리 및 appearance 최적화의 <strong>중요한 초기값(initialization)</strong>으로 활용됩니다.</p>
<p>요약하면, PhysTwin은 <strong>학습 기반 3D 생성(prior)</strong>과 <strong>전통적 정합 알고리즘</strong>을 조합하여, <strong>부분 관찰 → 완전한 초기 형상</strong>으로 복원하는 단계를 수행합니다. 이를 통해 얻어진 메쉬의 <strong>버텍스들(vertex)</strong>는 곧바로 우리 <strong>질점-스프링 모델</strong>의 질점들이 됩니다. 이로써 아직 보지 못한 영역까지 포함된 객체의 “canonical” 상태를 정의하고 (보통 초기 프레임 상태를 정준 상태로 사용), 물리 시뮬레이션의 기반으로 삼을 수 있습니다.</p>
</section>
<section id="b-스프링-질점-모델-구성과-계층적-물리-파라미터-최적화" class="level3" data-number="2.4.2">
<h3 data-number="2.4.2" class="anchored" data-anchor-id="b-스프링-질점-모델-구성과-계층적-물리-파라미터-최적화"><span class="header-section-number">2.4.2</span> (b) 스프링-질점 모델 구성과 계층적 물리 파라미터 최적화</h3>
<p>초기 형상이 마련되었으므로, 이제 이 <strong>메쉬를 물리 시뮬레이터가 다룰 수 있는 형태</strong>로 변환해야 합니다. PhysTwin에서는 메쉬의 기하를 <strong>spring-mass 모델</strong>로 표현합니다. 메쉬의 각 버텍스는 질량을 가진 <strong>질점(mass node)</strong>으로 취급되고, 이들 사이를 가상 스프링으로 연결하여 물체의 탄성 거동을 모델링합니다. 스프링 연결은 메쉬의 인접 관계를 그대로 사용할 수도 있지만, 저자들은 일반적인 적용을 위해 단순히 <strong>최근접 이웃</strong> 기반으로 연결하도록 했습니다. 즉, 일정 거리(radius) 이내에서 가장 가까운 몇몇(max neighbors로 제한) 점들끼리 스프링으로 연결하여 <strong>토폴로지</strong>를 형성합니다. 이렇게 하면 메쉬의 삼각형 구조에 얽매이지 않고도 유연한 그래프 형태의 스프링망을 구축할 수 있고, radius와 최대 이웃 수 파라미터로 <strong>스프링 밀도</strong>를 조절할 수 있습니다.</p>
<p>또한 상호작용을 모사하기 위해 <strong>제어점(control point)</strong> 개념을 도입합니다. 예를 들어 사람이 물체를 손으로 잡아당기는 경우, 손의 위치를 나타내는 외부 제어점을 정의하고, 이 제어점과 객체 표면의 질점들을 스프링으로 연결하면 손이 끄는 힘을 시뮬레이션할 수 있습니다. PhysTwin에서는 영상에서 <strong>손 부위</strong>를 Grounded-SAM으로 분리(segmentation)하고, CoTracker로 손의 움직임을 추적하여 3D 궤적을 얻은 뒤, <strong>Farthest Point Sampling</strong>으로 적절히 간격을 둔 몇 개의 제어점을 취합니다. 그리고 마찬가지로 반경-이웃 기반으로 각 제어점을 객체 질점들과 연결하는 스프링들을 추가했습니다. 이로써 외력이 가해지는 지점과 객체 사이의 연결관계까지 포함한 <strong>완전한 spring-mass 물리 모델</strong>의 구조가 결정됩니다.</p>
<p>정리하면, 현재까지 우리는: <strong>(i)</strong> 객체 질점의 초기 위치 (정렬된 전체 형상), <strong>(ii)</strong> 질점들 간 스프링 연결 구조 및 초기 물리 파라미터 (강성, 감쇠 등), <strong>(iii)</strong> 제어점과의 연결 등을 정의했습니다. 이제 남은 것은 이러한 파라미터 값을 실제 객체의 거동에 맞게 <strong>최적화(추정)</strong>하는 것입니다. 최적화해야 할 파라미터로는 각 스프링의 <strong>강성 계수(k)</strong>와 <strong>댐핑 계수(c)</strong>, <strong>스프링의 rest length(평균길이)</strong> 보정, <strong>충돌 처리 파라미터</strong> 등이 있습니다. 이들은 모두 연속적인 실수 값들로 볼 수 있지만, 앞서 언급한 <strong>radius</strong>나 <strong>max neighbors</strong> 같은 <strong>토폴로지 설정값</strong>은 이산적으로 간주됩니다. 전체 파라미터 수는 잠재적으로 매우 크며 (수천~수만 개 수준), 일반적인 gradient descent를 적용하기엔 부담이 큽니다.</p>
<p>PhysTwin은 이를 위해 <strong>2단계 계층적 최적화</strong>를 사용했습니다: 먼저 <strong>저해상도 파라미터 공간</strong>에서 탐색한 후, 점차 <strong>고해상도(세밀한)</strong> 파라미터로 refinement하는 방식입니다. 구체적으로, <strong>초기 단계</strong>에서는 모든 스프링의 강성을 <strong>동일한 값으로 가정(균일 강성)</strong>하고, 토폴로지 밀도나 충돌 계수 등 몇 안 되는 대표 파라미터만을 대상으로 <strong>zero-order 최적화</strong>(미분 없이 가능한 탐색 기반 최적화)를 수행합니다. 여기서 말하는 zero-order 최적화란, 예를 들어 파라미터 조합을 샘플링하여 시뮬레이션 결과와 관찰치의 차이를 평가하면서 조금씩 탐색해나가는 방법으로, gradient를 직접 쓰지 않아도 되므로 미분 불가능한 변수들도 다룰 수 있습니다. 이 단계에서 radius나 neighbor 수와 같은 토폴로지 설정, 그리고 전체 강성의 크기 등을 적절히 찾아내면, 시뮬레이터가 대략 관찰된 움직임을 따라가게 됩니다.</p>
<p>다음으로 <strong>세부 단계</strong>에서는, 위에서 얻은 초기값을 기반으로 각 스프링마다 강성이 달라지는 <strong>밀도 있는 파라미터 공간(dense parameter space)</strong>을 <strong>일阶 미분 가능한 방식(first-order gradient descent)</strong>으로 최적화합니다. 이를 위해 PhysTwin은 커스텀 <strong>differentiable spring-mass simulator</strong>를 구현하였습니다. 시뮬레이터는 주어진 물리 파라미터에 따라 시간 발달을 계산할 뿐 아니라, 목표 코스트 <span class="math inline">\mathcal{C}_{geometry} + \mathcal{C}_{motion}</span>에 대한 파라미터의 <strong>gradient</strong>를 계산할 수 있습니다. 따라서 이 단계에서는 모든 스프링들의 <span class="math inline">k_{ij}</span> (강성) 값을 개별적으로 조정하고, 충돌 처리 계수 등 연속 파라미터들도 함께 미세 조정합니다. 그 결과, 시뮬레이션 예측이 관찰 데이터와 훨씬 정밀하게 맞아떨어지도록 파라미터가 보정됩니다. 특히 이 과정에서 앞서 계산한 <strong>3D 추적 점(코Tracker 기반)</strong>들이 일종의 <strong>지도 신호(supervision)</strong> 역할을 톡톡히 합니다. 추적점들은 객체 표면의 여러 지점이 시간에 따라 어떻게 움직였는지를 알려주므로, 물리 파라미터 최적화 시 해당 지점들의 시뮬레이션 궤적이 실제 궤적과 가까워지도록 유도합니다. 이는 부분 관찰의 한계를 보완해 주는 추가 단서로 작용하여, 효율적이고 정확한 역동학 파라미터 추정을 가능케 합니다.</p>
<p>以上 과정을 통해, PhysTwin의 1단계 최적화는 <strong>객체의 형상과 동역학 모델</strong>을 영상에 부합하게 만들어 줍니다. 구체적으로는, 우리의 spring-mass 시스템 내 질점들의 초기 배치가 실제 객체의 초기 형상과 일치하고, 시뮬레이터에 정의된 물리 파라미터로 인해 객체를 움직이면 (예: 손 제어점에 실제 영상에서 가해졌던 힘을 재연하면) 시뮬레이션 결과가 영상 속 실제 객체의 움직임과 잘 맞게 됩니다. 즉, <strong>역물리(inverse physics)</strong> 문제를 풀어내어, 관찰된 거동을 모사하는 <strong>물리적으로 일치하는 모델</strong>을 얻은 것입니다.</p>
<p>참고로, PhysTwin의 spring-mass 물리 시뮬레이션 자체는 <strong>뉴턴 역학</strong>에 충실하게 따릅니다. 각 질점 <span class="math inline">i</span>에 작용하는 힘 <span class="math inline">F_i</span>는 연결된 이웃 질점 <span class="math inline">j</span>들과의 스프링 힘 및 댐핑 힘의 합으로 계산됩니다. 스프링 힘은 훅의 법칙에 따라 <span class="math inline">F_{spring} = k_{ij} (||x_i - x_j|| - L_{ij})</span> 형태로 작용하여 질점들 간 거리가 <strong>rest length</strong>로부터 벗어날 경우 복원력이 발생하고, <strong>dashpot 댐핑</strong> 힘 <span class="math inline">F_{damping} = -c_{ij}(v_i - v_j)</span>은 상대 속도의 차이를 줄이는 방향으로 운동에 저항력을 부여합니다. 여기에 중력이나 충돌, 외부 제어점(예: 손 위치 변화에 의한 힘) 등으로 인한 <strong>외력</strong> <span class="math inline">F_{ext}</span>까지 합산하여 각 질점의 최종 힘을 계산합니다. 그런 다음 이 힘을 이용해 explicit <strong>Euler integration</strong> 방식으로 각 질점의 가속도, 속도, 위치를 시간 <span class="math inline">t \to t+\Delta t</span>로 갱신합니다. 이러한 시뮬레이션은 질량-스프링 시스템의 <strong>운동량 보존</strong>, <strong>에너지 감쇠</strong>, <strong>충돌 반발</strong> 등을 정확히 재현하므로, Spring-Gaus 등이 간과했던 실제 물리적 거동을 보다 사실적으로 모사합니다. PhysTwin 구현에서는 NVIDIA Warp 라이브러리를 활용하여 이 모든 계산을 GPU에서 효율적으로 수행하였고, 이는 뒤에 소개할 실시간 상호작용 시뮬레이션을 가능케 하는 기반이 되었습니다.</p>
</section>
</section>
<section id="단계-appearance-최적화-appearance-optimization" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="단계-appearance-최적화-appearance-optimization"><span class="header-section-number">2.5</span> 2단계: Appearance 최적화 (Appearance Optimization)</h2>
<p>1단계 최적화를 거친 후에는 객체의 <strong>형상 구조와 물리 파라미터(geometry &amp; physics)</strong>가 확정됩니다. 이제 남은 과제는 <strong>겉보기(appearance)</strong>를 복원하여, 시뮬레이션된 객체를 화면에 렌더링했을 때 원본 영상처럼 보이도록 만드는 것입니다. PhysTwin은 appearance 복원을 위해 <strong>NeRF</strong> 대신 <strong>3D Gaussian splatting</strong>을 채택한 점이 특징적입니다. Gaussian splatting은 다수의 3D Gaussian 커널 (흐릿한 입자들)을 배치하고 각자 색과 투명도를 부여하여 합성 렌더링하는 기법으로, 복잡한 기하 형태나 광원 모델링 없이도 <strong>실시간에 가까운 고속 렌더링</strong>이 가능하다는 장점이 있습니다. 특히 2023년 이후로 Gaussian splat 기반의 신경방사장 기법들이 등장하면서, NeRF 대비 훨씬 빠른 렌더링이 가능해져 주목받았습니다. PhysTwin에서는 이 아이디어를 받아들여, 복원한 객체 표면을 덮는 <strong>정지된 3D Gaussian들의 집합</strong>으로 appearance를 표현합니다.</p>
<p>우선, Gaussian 커널들의 <strong>파라미터</strong>를 정의해야 합니다. 각각의 Gaussian <span class="math inline">G_n</span>은 다음과 같은 속성을 지닙니다: 중심 위치 <span class="math inline">\mathbf{p}_n = (x,y,z)</span>, 방향을 나타내는 회전 <span class="math inline">q_n</span> (quaternion 형태), 크기를 나타내는 스케일 벡터 <span class="math inline">\mathbf{s}_n = (s_x,s_y,s_z)</span>, 투명도(alpha) <span class="math inline">\alpha_n</span>, 그리고 색상 계수 <span class="math inline">c_n</span> (RGB 값). 초기에는 이 Gaussian들을 객체의 표면을 따라서 일정한 간격으로 분포시키고, 색상은 임의값이나 평균색으로 설정합니다 (논문에서는 초기화에 대한 상세 언급은 없지만, 보통 영상 기준으로 색을 뿌리거나 합니다). 그런 다음 <strong>appearance 최적화</strong>에서는 이러한 Gaussian들의 파라미터를 조정하여 <strong>렌더링 손실</strong> <span class="math inline">\mathcal{C}_{render}</span>를 최소화합니다. 렌더링 손실은 카메라 뷰로 Gaussian들을 투영하여 얻은 합성 영상과 실제 RGB 영상 간의 차이를 측정하는데, 단순 픽셀 L2 오차 대신 <strong>D-SSIM (Differentiable Structural Similarity)</strong> 지표를 활용했습니다. SSIM은 구조적 유사도를 평가하는 지표로, 인간 시각에 더 근접한 비교를 제공하며, D-SSIM은 그 미분 가능한 변형입니다. 이를 이용해 렌더된 이미지와 실제 이미지 사이의 차이를 계산하고, 이 값을 줄이는 방향으로 각 Gaussian의 색과 위치 등을 업데이트합니다. <strong>효율성</strong>을 위해 이 최적화는 여러 프레임에 대해 하는 대신 <strong>첫 번째 프레임</strong>에 대해서만 수행되었습니다. 이는 객체의 외형이 시간에 따라 바뀌지 않는다고 가정할 수 있기 때문에, 한 프레임 (가장 가려짐이 적은 프레임을 선택)만으로도 충분히 색상을 맞출 수 있다는 아이디어입니다. 이렇게 하면 계산량을 크게 줄이면서도 전체 외형 품질을 확보할 수 있습니다.</p>
<p>Gaussian 기반 표현을 사용할 때 주의할 점은, 나중에 객체가 변형될 때 Gaussian들이 <strong>어색한 잔상</strong>을 남기지 않아야 한다는 것입니다. 이를 위해 저자들은 Gaussian들의 <strong>형상을 등방성(isotropic)</strong>으로 제한하였습니다. 즉, 각 Gaussian의 스케일 행렬이 구(球) 형태가 되도록 강제하여, 어떤 특정 방향으로 찌르는(spiky) 모양을 가지지 못하게 합니다. 이렇게 해야 나중에 객체가 움직여도 Gaussian들이 국소적으로 뾰족하게 찢어지는 아티팩트를 방지할 수 있습니다. 결국 2단계 최적화를 마치면 객체 초기 상태에 대한 <strong>시각적으로 그럴듯한 Gaussian 분포</strong>가 완성됩니다.</p>
<p>이제 마지막으로 남은 문제는, <strong>객체가 변형될 때 appearance를 어떻게 업데이트할 것인가</strong> 입니다. 1단계의 물리 모델을 통해 임의의 새로운 힘이나 움직임에 대한 질점들의 변위는 결정되겠지만, Gaussian들은 그저 공간상의 점들이므로, 질점들이 움직였을 때 함께 따라 움직여야 일관된 렌더링이 가능합니다. PhysTwin은 이를 위해 <strong>Linear Blend Skinning (LBS)</strong>이라는 전통적 그래픽스 기법을 활용했습니다. LBS는 주로 캐릭터 애니메이션에서 본(bone)에 붙은 피부를 움직일 때 쓰이는 방식인데, 여기서는 질점들이 일종의 “본” 역할을, Gaussian들이 “피부의 점” 역할을 합니다. 각 Gaussian <span class="math inline">G_n</span>에 대해 가까운 몇 개의 질점들을 찾아 <strong>가중치</strong>를 할당합니다. 그리고 시뮬레이션 시 각 프레임마다 질점들이 새로운 위치 <span class="math inline">X_t</span>로 이동하면, <span class="math inline">G_n</span>의 중심 <span class="math inline">\mathbf{p}_n</span>도 그 질점들의 움직임을 보간한 위치로 옮겨주고, 회전 <span class="math inline">q_n</span>도 질점 움직임에 따라 조정해줍니다. 이렇게 하면 객체가 변형되어도 Gaussian들이 객체 표면에 붙어있는 듯이 함께 변형됩니다. 요약하면, <strong>appearance는 1단계에서 얻은 물리 모델에 종속</strong>되도록 설계하여, 시간에 따른 일관성을 확보한 것입니다.</p>
<p>이로써 PhysTwin이 생성한 디지털 트윈은 완성됩니다. 1단계의 spring-mass 모델은 <strong>물리적으로 현실적인 동역학</strong>을 재현하고, 2단계의 Gaussian splats는 <strong>시각적으로 그럴듯한 영상 재현</strong>을 보장합니다. 최종 모델은 새로운 초기 조건이나 외력에 대해서 시뮬레이션을 수행할 수 있으며, 그 결과를 <strong>렌더링</strong>해서 마치 실제 영상을 보는 것처럼 출력할 수 있습니다.</p>
</section>
<section id="phystwin의-성과와-응용" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="phystwin의-성과와-응용"><span class="header-section-number">2.6</span> PhysTwin의 성과와 응용</h2>
<p>PhysTwin이 복원한 디지털 트윈의 <strong>정확도</strong>는 다양한 실험을 통해 입증되었습니다. 저자들의 평가에 따르면, PhysTwin은 제한된 시점의 입력만 가지고도 실제 객체의 형상과 물리 특성을 잘 캡처하여, <strong>재구성 정확도(reconstruction)</strong>와 <strong>새로운 시점에서의 렌더링 품질(rendering)</strong>, <strong>미래 상태 예측(future prediction)</strong>, 그리고 <strong>새 상호작용에 대한 시뮬레이션</strong> 등에서 기존 방법들보다 우수한 결과를 보였습니다. 예를 들어 PhysTwin으로 복원한 모델에 이전에 없던 힘을 가하거나 새로운 방식으로 변형시키는 실험에서, Spring-Gaus 등의 과거 방법보다 실제 물체의 반응을 더 그럴듯하게 예측해냈습니다. 다양한 객체 타입(유연한 로프부터 탄성이 있는 봉제인형, 옷감, 심지어 단단한 택배 상자까지)에 대해 이러한 성능을 보여 <strong>범용성</strong>도 확인되었습니다.</p>
<p>무엇보다 PhysTwin의 큰 장점 중 하나는 <strong>시뮬레이션 속도</strong>입니다. GPU 가속을 통해 spring-mass 물리 시뮬레이션과 Gaussian 렌더링을 실시간에 가깝게 수행할 수 있으므로, 복원된 모델을 이용한 <strong>인터랙티브 시뮬레이션</strong>이 가능합니다. 사용자가 키보드로 가상 손을 움직이며 물체를 잡아당기는 등의 조작을 하면, PhysTwin의 객체도 즉각 반응하여 변형되고 화면에 렌더링되어 보여집니다. 논문에서는 사람이 로봇 팔을 원격 조작(teleoperation)할 때 PhysTwin이 실시간으로 객체의 미래 상태를 예측하여 화면에 겹쳐 보여주는 데모를 통해, 이러한 기능이 로봇 작업시 <strong>피드백 도구</strong>로 활용될 수 있음을 보여주었습니다. 또한 복원된 디지털 트윈은 로봇의 <strong>모델 기반 플래닝</strong>에 바로 활용될 수 있습니다. 예컨대 로봇이 유연한 밧줄을 특정 모양으로 움직이고자 할 때, PhysTwin으로 얻은 동적 모델을 시뮬레이터로 사용하여 다양한 동작 시도들을 가상환경에서 시험해보고 최적의 계획을 세울 수 있습니다. 이런 <strong>모델 예측 제어(MPC)</strong>나 <strong>강화학습</strong>과 결합하면, 물체를 실제로 다루기 전에 가상으로 여러 시나리오를 신속히 테스트해볼 수 있어 효율적인 로봇 조작이 가능해집니다.</p>
<hr>
<p>마지막으로, PhysTwin의 <strong>기술적 기여</strong>를 정리해보면 다음과 같습니다:</p>
<ul>
<li>부분 관찰 영상만으로 <strong>완전한 객체 형상</strong>을 복원하기 위해 <strong>사전 학습된 생성 모델</strong>을 효과적으로 활용하고, 전통 기법과 결합해 정밀한 초기 shape을 얻었습니다.<br>
</li>
<li><strong>Spring-Mass 물리 모델</strong>을 디지털 트윈에 통합하여, <strong>현실 물리 법칙</strong>(뉴턴 역학, 충돌, 중력 등)이 반영된 시뮬레이션을 가능하게 했습니다. 이를 통해 단순 보간이 아닌 <strong>원인-결과에 기반한</strong> 객체 거동 예측이 가능해졌습니다.<br>
</li>
<li><strong>다단계 최적화(framework)</strong>를 고안하여, 이산적 토폴로지 결정과 연속적 물리 파라미터 추정을 순차적으로 해결하였습니다. 특히 <strong>zero-order + differentiable simulation</strong>을 결합한 <strong>계층적 최적화 전략</strong>으로 거대한 파라미터 공간을 효과적으로 탐색했습니다.<br>
</li>
<li>Segment Anything, CoTracker 등의 <strong>비전 기반 파운데이션 모델</strong>을 활용하여, 추가적인 지도 신호(객체 마스크, 3D 추적점)를 얻고 이를 코스트 함수에 통합함으로써 데이터 부족과 최적화 난이도를 극복했습니다.<br>
</li>
<li><strong>Gaussian splatting 기반 표현</strong>을 도입하여, 복잡한 라이팅 없이도 객체의 appearance를 사실적으로 복원하고 실시간 렌더링을 실현했습니다. 또한 LBS를 통해 변형 시 일관된 텍스처 대응을 유지하도록 함으로써, <strong>시각적 품질과 물리적 일관성</strong>을 모두 잡았습니다.</li>
</ul>
<p>PhysTwin은 <strong>시각적 재구성</strong>과 <strong>물리 시뮬레이션</strong>의 가교 역할을 함으로써, 로봇 상호작용이나 가상현실 등에서 현실 세계의 물체를 더 잘 모방하고 예측하는 방향으로 한 걸음 나아갔다는 평가를 받습니다. 향후 더 다양한 객체나 유체와 같은 복잡한 재질에도 이러한 <strong>물리-학습 결합 방식</strong>이 확장될 수 있을 것이며, 인간과 상호작용하는 가상 환경 구성에도 기여할 수 있을 것으로 기대됩니다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    window.setColorSchemeToggle(window.hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>