<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-11-03">
<meta name="description" content="Efficient Policy Search for Dexterous Robotic Manipulation via Action Chunking Embedding">

<title>📃VQ-ACE 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-bc185b5c5bdbcb35c2eb49d8a876ef70.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-5a614c35f1f90bfd0a5b2992298a8538.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#ping-review" id="toc-ping-review" class="nav-link active" data-scroll-target="#ping-review">🔍 Ping Review</a></li>
  <li><a href="#ring-review" id="toc-ring-review" class="nav-link" data-scroll-target="#ring-review">🔔 Ring Review</a>
  <ul class="collapse">
  <li><a href="#들어가며-로봇-손이-마주한-근본적인-어려움" id="toc-들어가며-로봇-손이-마주한-근본적인-어려움" class="nav-link" data-scroll-target="#들어가며-로봇-손이-마주한-근본적인-어려움">들어가며: 로봇 손이 마주한 근본적인 어려움</a></li>
  <li><a href="#핵심-아이디어-말하는-방식을-바꾸자" id="toc-핵심-아이디어-말하는-방식을-바꾸자" class="nav-link" data-scroll-target="#핵심-아이디어-말하는-방식을-바꾸자">핵심 아이디어: “말하는 방식”을 바꾸자</a>
  <ul class="collapse">
  <li><a href="#action-chunking-동작을-덩어리로-묶기" id="toc-action-chunking-동작을-덩어리로-묶기" class="nav-link" data-scroll-target="#action-chunking-동작을-덩어리로-묶기">Action Chunking: 동작을 덩어리로 묶기</a></li>
  <li><a href="#vector-quantization-동작을-단어로-만들기" id="toc-vector-quantization-동작을-단어로-만들기" class="nav-link" data-scroll-target="#vector-quantization-동작을-단어로-만들기">Vector Quantization: 동작을 “단어”로 만들기</a></li>
  </ul></li>
  <li><a href="#기술적으로-어떻게-작동할까" id="toc-기술적으로-어떻게-작동할까" class="nav-link" data-scroll-target="#기술적으로-어떻게-작동할까">기술적으로 어떻게 작동할까?</a>
  <ul class="collapse">
  <li><a href="#vq-vae-압축과-복원의-마법" id="toc-vq-vae-압축과-복원의-마법" class="nav-link" data-scroll-target="#vq-vae-압축과-복원의-마법">VQ-VAE: 압축과 복원의 마법</a></li>
  <li><a href="#학습-과정-인간으로부터-배우기" id="toc-학습-과정-인간으로부터-배우기" class="nav-link" data-scroll-target="#학습-과정-인간으로부터-배우기">학습 과정: 인간으로부터 배우기</a></li>
  </ul></li>
  <li><a href="#mpc에-적용하기-더-영리한-계획-세우기" id="toc-mpc에-적용하기-더-영리한-계획-세우기" class="nav-link" data-scroll-target="#mpc에-적용하기-더-영리한-계획-세우기">MPC에 적용하기: 더 영리한 계획 세우기</a>
  <ul class="collapse">
  <li><a href="#기존-mpc의-문제점" id="toc-기존-mpc의-문제점" class="nav-link" data-scroll-target="#기존-mpc의-문제점">기존 MPC의 문제점</a></li>
  <li><a href="#latent-sampling-mpc-잠재-공간에서-샘플링하기" id="toc-latent-sampling-mpc-잠재-공간에서-샘플링하기" class="nav-link" data-scroll-target="#latent-sampling-mpc-잠재-공간에서-샘플링하기">Latent Sampling MPC: 잠재 공간에서 샘플링하기</a></li>
  </ul></li>
  <li><a href="#강화학습에-적용하기-학습-속도-2배-향상" id="toc-강화학습에-적용하기-학습-속도-2배-향상" class="nav-link" data-scroll-target="#강화학습에-적용하기-학습-속도-2배-향상">강화학습에 적용하기: 학습 속도 2배 향상</a>
  <ul class="collapse">
  <li><a href="#강화학습의-탐색-문제" id="toc-강화학습의-탐색-문제" class="nav-link" data-scroll-target="#강화학습의-탐색-문제">강화학습의 탐색 문제</a></li>
  <li><a href="#action-chunked-rl-구조화된-탐색" id="toc-action-chunked-rl-구조화된-탐색" class="nav-link" data-scroll-target="#action-chunked-rl-구조화된-탐색">Action Chunked RL: 구조화된 탐색</a></li>
  <li><a href="#실험-결과-빠르고-성능도-좋다" id="toc-실험-결과-빠르고-성능도-좋다" class="nav-link" data-scroll-target="#실험-결과-빠르고-성능도-좋다">실험 결과: 빠르고 성능도 좋다</a></li>
  </ul></li>
  <li><a href="#왜-이렇게-잘-작동할까-핵심-통찰" id="toc-왜-이렇게-잘-작동할까-핵심-통찰" class="nav-link" data-scroll-target="#왜-이렇게-잘-작동할까-핵심-통찰">왜 이렇게 잘 작동할까? 핵심 통찰</a>
  <ul class="collapse">
  <li><a href="#적절한-귀납적-편향-inductive-bias" id="toc-적절한-귀납적-편향-inductive-bias" class="nav-link" data-scroll-target="#적절한-귀납적-편향-inductive-bias">1. 적절한 귀납적 편향 (Inductive Bias)</a></li>
  <li><a href="#코드북-크기의-최적점" id="toc-코드북-크기의-최적점" class="nav-link" data-scroll-target="#코드북-크기의-최적점">2. 코드북 크기의 최적점</a></li>
  <li><a href="#시간적-구조의-자동-학습" id="toc-시간적-구조의-자동-학습" class="nav-link" data-scroll-target="#시간적-구조의-자동-학습">3. 시간적 구조의 자동 학습</a></li>
  </ul></li>
  <li><a href="#실험-환경과-작업들" id="toc-실험-환경과-작업들" class="nav-link" data-scroll-target="#실험-환경과-작업들">실험 환경과 작업들</a>
  <ul class="collapse">
  <li><a href="#테스트한-4가지-작업" id="toc-테스트한-4가지-작업" class="nav-link" data-scroll-target="#테스트한-4가지-작업">테스트한 4가지 작업</a></li>
  </ul></li>
  <li><a href="#한계점-완벽하지-않다" id="toc-한계점-완벽하지-않다" class="nav-link" data-scroll-target="#한계점-완벽하지-않다">한계점: 완벽하지 않다</a>
  <ul class="collapse">
  <li><a href="#인간-데이터-의존성" id="toc-인간-데이터-의존성" class="nav-link" data-scroll-target="#인간-데이터-의존성">1. 인간 데이터 의존성</a></li>
  <li><a href="#특정-플랫폼에-한정" id="toc-특정-플랫폼에-한정" class="nav-link" data-scroll-target="#특정-플랫폼에-한정">2. 특정 플랫폼에 한정</a></li>
  <li><a href="#시뮬레이션-위주의-실험" id="toc-시뮬레이션-위주의-실험" class="nav-link" data-scroll-target="#시뮬레이션-위주의-실험">3. 시뮬레이션 위주의 실험</a></li>
  <li><a href="#작업-특화성" id="toc-작업-특화성" class="nav-link" data-scroll-target="#작업-특화성">4. 작업 특화성</a></li>
  </ul></li>
  <li><a href="#관련-연구들과의-비교" id="toc-관련-연구들과의-비교" class="nav-link" data-scroll-target="#관련-연구들과의-비교">관련 연구들과의 비교</a>
  <ul class="collapse">
  <li><a href="#action-representation-learning-분야" id="toc-action-representation-learning-분야" class="nav-link" data-scroll-target="#action-representation-learning-분야">Action Representation Learning 분야</a></li>
  <li><a href="#model-predictive-control-분야" id="toc-model-predictive-control-분야" class="nav-link" data-scroll-target="#model-predictive-control-분야">Model Predictive Control 분야</a></li>
  <li><a href="#imitation-learning-분야" id="toc-imitation-learning-분야" class="nav-link" data-scroll-target="#imitation-learning-분야">Imitation Learning 분야</a></li>
  <li><a href="#관련-논문들" id="toc-관련-논문들" class="nav-link" data-scroll-target="#관련-논문들">관련 논문들</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#dig-review" id="toc-dig-review" class="nav-link" data-scroll-target="#dig-review">⛏️ Dig Review</a>
  <ul class="collapse">
  <li><a href="#연구-배경과-동기" id="toc-연구-배경과-동기" class="nav-link" data-scroll-target="#연구-배경과-동기">1. 연구 배경과 동기</a></li>
  <li><a href="#주요-기여점-요약" id="toc-주요-기여점-요약" class="nav-link" data-scroll-target="#주요-기여점-요약">2. 주요 기여점 요약</a></li>
  <li><a href="#방법론" id="toc-방법론" class="nav-link" data-scroll-target="#방법론">3. 방법론</a>
  <ul class="collapse">
  <li><a href="#행동-데이터-수집-및-전처리" id="toc-행동-데이터-수집-및-전처리" class="nav-link" data-scroll-target="#행동-데이터-수집-및-전처리">3.1 행동 데이터 수집 및 전처리</a></li>
  <li><a href="#vq-ace-네트워크-구조" id="toc-vq-ace-네트워크-구조" class="nav-link" data-scroll-target="#vq-ace-네트워크-구조">3.2 VQ-ACE 네트워크 구조</a></li>
  <li><a href="#잠재-공간-샘플링-mpc" id="toc-잠재-공간-샘플링-mpc" class="nav-link" data-scroll-target="#잠재-공간-샘플링-mpc">3.3 잠재 공간 샘플링 MPC</a></li>
  <li><a href="#액션-청킹-강화학습" id="toc-액션-청킹-강화학습" class="nav-link" data-scroll-target="#액션-청킹-강화학습">3.4 액션 청킹 강화학습</a></li>
  </ul></li>
  <li><a href="#실험-설계-및-평가-방법" id="toc-실험-설계-및-평가-방법" class="nav-link" data-scroll-target="#실험-설계-및-평가-방법">4. 실험 설계 및 평가 방법</a></li>
  <li><a href="#결과-분석-및-논의" id="toc-결과-분석-및-논의" class="nav-link" data-scroll-target="#결과-분석-및-논의">5. 결과 분석 및 논의</a>
  <ul class="collapse">
  <li><a href="#mpc-성능" id="toc-mpc-성능" class="nav-link" data-scroll-target="#mpc-성능">5.1 MPC 성능</a></li>
  <li><a href="#rl-성능" id="toc-rl-성능" class="nav-link" data-scroll-target="#rl-성능">5.2 RL 성능</a></li>
  <li><a href="#구성-요소-검증-ablation" id="toc-구성-요소-검증-ablation" class="nav-link" data-scroll-target="#구성-요소-검증-ablation">5.3 구성 요소 검증 (Ablation)</a></li>
  </ul></li>
  <li><a href="#기존-연구와의-비교" id="toc-기존-연구와의-비교" class="nav-link" data-scroll-target="#기존-연구와의-비교">6. 기존 연구와의 비교</a></li>
  <li><a href="#한계점-및-향후-연구-방향" id="toc-한계점-및-향후-연구-방향" class="nav-link" data-scroll-target="#한계점-및-향후-연구-방향">7. 한계점 및 향후 연구 방향</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃VQ-ACE 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">mpc</div>
    <div class="quarto-category">rl</div>
    <div class="quarto-category">action-chunking</div>
  </div>
  </div>

<div>
  <div class="description">
    Efficient Policy Search for Dexterous Robotic Manipulation via Action Chunking Embedding
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 3, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p>🔍 Ping. 🔔 Ring. ⛏️ Dig. A tiered review series: quick look, key ideas, deep dive.</p>
</blockquote>
<ul>
<li><a href="https://arxiv.org/abs/2411.03556">Paper Link</a></li>
<li><a href="https://srl-ethz.github.io/page-vq-ace/">Project LInk</a></li>
<li><a href="https://github.com/srl-ethz/vq_ace">Code</a></li>
</ul>
<ol type="1">
<li>🤖 VQ-ACE는 복잡한 로봇 조작을 위해 인간의 손 동작을 양자화된 잠재 공간으로 압축하여 행동 공간의 차원을 크게 줄이는 새로운 프레임워크입니다.</li>
<li>🚀 이 프레임워크를 Model Predictive Control (MPC)에 적용하면, 잠재 공간 샘플링을 통해 Ball Rolling 및 Object Picking과 같은 작업에서 더 인간다운 동작과 높은 성공률을 달성합니다.</li>
<li>💡 또한, Reinforcement Learning (RL)에 행동 청킹을 통합하면 학습을 가속화하고 탐색을 개선하여 큐브 쌓기 및 인핸드 큐브 재정렬과 같은 작업에서 더 빠른 수렴과 뛰어난 성능을 가능하게 합니다.</li>
</ol>
<center>
<img src="../../images/2025-11-03-vq-ace/0.png" width="80%">
</center>
<center>
<img src="../../images/2025-11-03-vq-ace/0.gif" width="85%">
</center>
<hr>
<section id="ping-review" class="level1">
<h1>🔍 Ping Review</h1>
<blockquote class="blockquote">
<p>🔍 Ping — A light tap on the surface. Get the gist in seconds.</p>
</blockquote>
<p>이 논문은 고차원적이고 복잡한 동작을 요구하는 로봇 조작 작업, 특히 능숙한 로봇 조작(dexterous robotic manipulation)의 어려움을 해결하기 위해 VQ-ACE (Vector Quantized Action Chunking Embedding)라는 새로운 프레임워크를 제안합니다. VQ-ACE는 인간 손의 움직임을 양자화된 잠재 공간(quantized latent space)으로 압축하여 액션 공간의 차원을 크게 줄이면서도 핵심적인 동작 특성을 보존합니다. 이 프레임워크를 Model Predictive Control (MPC)과 Reinforcement Learning (RL)에 통합하여, 생체모방 로봇 손(biomimetic robotic hand)을 사용한 능숙한 조작 작업에서 보다 효율적인 탐색(exploration)과 정책 학습(policy learning)을 가능하게 합니다.</p>
<p>VQ-ACE의 핵심 방법론은 다음과 같습니다:</p>
<ol type="1">
<li><strong>데이터 수집 및 전처리:</strong>
<ul>
<li>모션 캡처 장갑(motion capture glove)으로 수집된 인간 손 동작 데이터셋을 사용합니다.</li>
<li>수집된 인간 손 포즈는 로봇 손의 11 DoF(자유도)에 맞게 kinematic retargeting 방식을 사용하여 매핑됩니다. 이 데이터셋은 50Hz로 기록된 54분 분량의 손 동작으로 구성됩니다.</li>
</ul></li>
<li><strong>Vector-Quantized Conditional VAE (CVAE) 아키텍처:</strong>
<ul>
<li>VQ-ACE는 <code>액션 청크(action chunk)</code>에 대한 이산 잠재 임베딩 공간(discrete latent embedding space)을 학습하기 위해 <code>vector-quantized Conditional VAE</code> 구조를 채택합니다.</li>
<li><strong>인코더 (Encoder) <span class="math inline">\phi</span></strong>: 현재 관절 위치 <span class="math inline">q_t</span>와 액션 시퀀스 <span class="math inline">a_{t:t+n}</span> (1초/50 타임스텝의 11 DoF 액션 청크)를 입력으로 받아, 이를 <span class="math inline">m</span>개의 잠재 벡터 시퀀스 <span class="math inline">z_{k:k+m}</span>로 인코딩합니다 (여기서 <span class="math inline">n</span>은 액션 청크 길이, <span class="math inline">m</span>은 잠재 토큰 수).
<ul>
<li>입력은 현재 관절 위치 <span class="math inline">q_t</span>와 액션 시퀀스 <span class="math inline">a_{t:t+n}</span>에서 매핑된 토큰(tokens)으로 구성되며, 학습된 위치 토큰(positional tokens)이 앞에 추가됩니다.</li>
<li>이 학습된 토큰에 해당하는 출력 특징이 잠재 변수 <span class="math inline">z_{k:k+m}</span>를 예측하는 데 사용됩니다.</li>
</ul></li>
<li><strong>양자화 (Quantization)</strong>: 인코딩된 잠재 벡터 <span class="math inline">z_k</span>는 코드북(codebook) <span class="math inline">\{e_1, e_2, \ldots, e_K\}</span>에서 가장 가까운 이웃을 찾아 양자화된 <span class="math inline">z_q(z_k)</span>로 변환됩니다 (Nearest-Neighbor look-up). 이 논문에서는 16차원의 각 잠재 토큰이 4가지 이산 값을 가질 수 있는 크기 4의 코드북을 사용합니다.</li>
<li><strong>디코더 (Decoder) <span class="math inline">\psi</span></strong>: 양자화된 잠재 벡터 <span class="math inline">z_{k:k+m}</span>와 현재 관절 위치 <span class="math inline">q_t</span>를 입력으로 받아, 원래 액션 청크 <span class="math inline">\hat{a}_{t:t+n}</span>를 재구성합니다.
<ul>
<li>디코더는 입력으로 양자화된 잠재 변수 <span class="math inline">z_{k:k+m}</span>, 현재 관절 위치 <span class="math inline">q_t</span>, 그리고 목표 출력에 해당하는 학습된 위치 임베딩(positional embeddings)을 사용합니다.</li>
<li>각 토큰의 시간에 기반한 <code>causal mask</code>가 적용되어 디코딩 과정에서 시간적 의존성(temporal dependencies)이 유지되도록 합니다.</li>
</ul></li>
<li><strong>손실 함수 (Loss Function)</strong>: 네트워크는 다음과 같은 손실 함수 <span class="math inline">L</span>을 사용하여 훈련됩니다. <span class="math display">L = L_{recon} + \lambda_{commit} L_{commit}</span> 여기서 <span class="math inline">L_{recon} = \|a_{t:t+n} - \psi (q_t, z_q (\phi (q_t, a_{t:t+n})))\|_1</span> 는 재구성 손실(reconstruction loss)이며, <span class="math inline">L_{commit} = \|\phi (q_t, a_{t:t+n})) - SG [z_q (\phi (q_t, a_{t:t+n}))] \|_2^2</span> 는 <code>commitment loss</code>입니다. <span class="math inline">SG</span>는 stop gradient 연산자입니다. 벡터 양자화는 Exponential Moving Average (EMA) 버전을 사용하여 임베딩 벡터를 업데이트합니다.</li>
</ul></li>
<li><strong>잠재 공간에서의 예측 샘플링 MPC (Latent Sampling MPC):</strong>
<ul>
<li>기존 예측 샘플링 MPC 알고리즘을 확장하여 잠재 공간에서 샘플링을 수행합니다.</li>
<li>각 계획 <span class="math inline">\Pi</span>은 잠재 변수 <span class="math inline">z_{k:k+m}</span>와 노이즈 스플라인(noise spline) <span class="math inline">\theta_{\tau:\tau+P}</span>로 표현됩니다.</li>
<li>정책에서 생성되는 제어 신호 <span class="math inline">u(\tilde{t})</span>는 다음과 같이 평가됩니다: <span class="math display">u(\tilde{t}) = \psi (\tilde{t}; q_t, z_{k:k+m}) + s (\tilde{t}; \theta_{\tau:\tau+P})</span> 첫 번째 항은 디코더에서 재구성된 액션 청크이고, 두 번째 항은 스플라인 평가입니다.</li>
<li>후보들은 현재 잠재 값 <span class="math inline">z_j</span>를 확률 <span class="math inline">1-p</span>로 유지하거나, 확률 <span class="math inline">p</span>로 코드북에서 균일하게 샘플링된 새로운 코드 <span class="math inline">e_r</span>로 대체하여 수정됩니다. <span class="math display">z^{(i)}_j = \begin{cases} z_j, &amp; \text{with probability } 1-p \\ e_r, &amp; \text{with probability } p, \text{where } r \sim \text{Uniform}(1, K) \end{cases}</span></li>
<li>노이즈 스플라인도 교란됩니다: <span class="math inline">z^{(i)}</span>가 <span class="math inline">z</span>와 같으면 Gaussian noise <span class="math inline">N(\theta, \sigma^2)</span>, 다르면 <span class="math inline">N(0, \sigma^2)</span>로 초기화됩니다. 이 방식은 국소 탐색(local search)과 점진적 최적화(progressive optimization)를 가능하게 합니다.</li>
</ul></li>
<li><strong>액션 청크를 사용한 RL (RL with Action Chunks):</strong>
<ul>
<li>전통적인 RL의 Markovian 가정을 액션 청크가 미묘하게 위배하는 문제를 해결하기 위해 액션 청크 <span class="math inline">A_t</span>를 명목상의 액션(nominal actions)으로 사용하고, 에이전트가 잔차(residual) <span class="math inline">\delta_t</span>로 이를 조정하도록 합니다.</li>
<li>시스템의 상태 <span class="math inline">x</span>, 액션 <span class="math inline">u</span>, 그리고 동역학 <span class="math inline">f</span>를 다음과 같이 확장합니다: <span class="math display">\hat{x}(t+1) = \hat{f}(\hat{x}(t), \hat{u}(t))</span> <span class="math display">\hat{x}(t) = [x(t); A_t; x_s(t)]</span> <span class="math display">\hat{u}(t) = [\delta_t; u_s(t)]</span> 여기서 <span class="math inline">x_s</span>와 <span class="math inline">u_s</span>는 청크 선택 상태(chunk selection states) 및 액션(actions)입니다.</li>
<li>액션 청크 <span class="math inline">A_t</span>는 매 타임스텝마다 업데이트되지 않으며, <code>청크 선택 상태(chunk selection states)</code> <span class="math inline">x_s(t)</span>가 누적되다가 1보다 커지면 <code>트리거(trigger)</code>가 발생하여 새로운 액션 청크가 디코더 <span class="math inline">\psi(q_t, \text{argmax}(x_s(t)+u_s(t)))</span>를 통해 선택되고 <span class="math inline">x_s</span>는 리셋됩니다. 이는 여러 스텝에 걸친 액션 청크 실행과 단일 스텝 잔차 피드백 간의 주파수 차이를 연결하고, 정책이 실행할 액션 청크를 능동적으로 선택할 수 있도록 합니다.</li>
</ul></li>
</ol>
<p><strong>실험 결과:</strong></p>
<ul>
<li><strong>액션 공간 임베딩:</strong> VQ-ACE는 1초(50 타임스텝)의 액션 청크를 5개의 토큰으로 인코딩하며, 각 잠재 토큰은 16차원이고 코드북 크기는 4입니다. 훈련된 모델의 검증 데이터셋 L1 손실은 0.050으로 수렴했습니다.</li>
<li><strong>Latent Sampling MPC:</strong> Ball Rolling (인핸드 조작) 및 Object Picking (덤벨 객체 집어 들기) 작업에서 기준 <code>predictive sampling</code> 대비 더 높은 작업 성공률과 낮은 제어 비용을 보였습니다. 특히 Ball Rolling 작업에서는 모든 손가락이 공과 접촉하는 등 더 인간과 유사한 동작을 생성했습니다. 동일한 수의 궤적을 샘플링할 때 <code>latent sampling MPC</code>의 비용이 항상 기준선보다 낮아, 더 효율적인 액션 파라미터화 공간에서 샘플링함을 입증했습니다.</li>
<li><strong>Action Chunked RL:</strong> Cube Reorientation (인핸드 큐브 재정렬) 및 Cube Stacking 작업에서 기준선 대비 더 빠른 수렴과 우수한 최종 성능을 보였습니다. 이는 <code>Action Chunked RL</code>이 에이전트가 의미 있는 액션 우선 순위(action priors)를 탐색할 수 있도록 돕기 때문입니다.</li>
<li><strong>Ablation Studies:</strong>
<ul>
<li><code>조건부 관찰(Conditional observation)</code>(<span class="math inline">q_t</span>): VQ-ACE에서 <span class="math inline">q_t</span>를 제거하면 검증 L1 오류가 0.05에서 0.07로 증가했습니다. Ball Rolling 작업에서 조건부 변형이 훨씬 낮은 비용을 달성했습니다.</li>
<li><code>벡터 양자화(Vector quantization)</code>: KL 손실을 사용하는 VAE (양자화 없음)는 액션 청크를 더 정확하게 재구성하여 L1 손실 0.028을 달성했지만, 두 작업 모두에서 양자화된 버전보다 성능이 떨어졌습니다. 이는 VAE가 과적합에 더 취약할 수 있음을 시사합니다.</li>
</ul></li>
</ul>
<p><strong>결론 및 한계:</strong></p>
<p>VQ-ACE는 능숙한 로봇 조작 작업의 복잡성과 고차원성을 해결하기 위한 효과적인 접근 방식을 제시하며, 잠재 공간 기반 MPC와 액션 청크 기반 RL을 통해 효율적인 탐색과 정책 학습을 가능하게 합니다. 한계로는, 액션 청크가 특정 구현체(embodiment)에 제한되는 명목상의 관절 위치 시퀀스로 표현된다는 점, 다운스트림 제어기(downstream controller)의 피드백에 의존하는 feed-forward 액션에 초점을 맞춘다는 점, 그리고 사용된 데이터셋의 크기가 상대적으로 작다는 점이 있습니다. 향후 VQ-ACE는 다리 로봇(legged locomotion)이나 휴머노이드 로봇과 같은 다른 분야의 대규모 상태 공간 관리에도 적용될 가능성이 있습니다.</p>
</section>
<section id="ring-review" class="level1">
<h1>🔔 Ring Review</h1>
<blockquote class="blockquote">
<p>🔔 Ring — An idea that echoes. Grasp the core and its value.</p>
</blockquote>
<section id="들어가며-로봇-손이-마주한-근본적인-어려움" class="level2">
<h2 class="anchored" data-anchor-id="들어가며-로봇-손이-마주한-근본적인-어려움">들어가며: 로봇 손이 마주한 근본적인 어려움</h2>
<p>여러분은 아침에 일어나서 커피를 만들 때 어떤 동작을 하시나요? 컵을 잡고, 커피포트를 들어 올리고, 우유를 따르고… 이 모든 동작이 너무나 자연스럽게 느껴지지만, 사실 우리의 손은 놀라울 정도로 복잡한 일을 하고 있습니다.</p>
<p>인간의 손은 27개의 자유도(DoF)를 가지고 있습니다. 이게 무슨 의미냐면, 손의 움직임을 완전히 표현하려면 27개의 숫자가 필요하다는 뜻입니다. 로봇이 이런 복잡한 손동작을 학습하려면 어떻게 해야 할까요? 그냥 모든 가능한 동작을 시도해보면 될까요?</p>
<p>문제는 이렇게 단순하지 않습니다. 만약 각 자유도가 10가지 가능한 값을 가질 수 있다면, 가능한 동작의 조합은 10^27가지입니다. 이는 우주에 있는 별의 개수보다도 많습니다! 이것이 바로 <strong>차원의 저주(curse of dimensionality)</strong>라고 불리는 문제입니다.</p>
<p>ETH Zürich의 연구팀은 이 문제에 대한 영리한 해결책을 제시했습니다. 바로 <strong>VQ-ACE</strong>입니다.</p>
<hr>
</section>
<section id="핵심-아이디어-말하는-방식을-바꾸자" class="level2">
<h2 class="anchored" data-anchor-id="핵심-아이디어-말하는-방식을-바꾸자">핵심 아이디어: “말하는 방식”을 바꾸자</h2>
<p>VQ-ACE의 핵심 아이디어를 이해하기 위해 간단한 비유를 들어볼까요?</p>
<p>상상해보세요. 당신이 친구에게 요리법을 설명하려고 합니다. 두 가지 방법이 있습니다:</p>
<p><strong>방법 1 (기존 방식):</strong> “칼을 정확히 23도 각도로 들고, 3.2cm 앞으로 이동하고, 2.7N의 힘으로 누르고…”</p>
<p><strong>방법 2 (VQ-ACE 방식):</strong> “재료를 썰기”, “팬에 볶기”, “간 맞추기”</p>
<p>어느 쪽이 더 이해하기 쉽고 따라하기 쉬울까요? 당연히 방법 2죠. VQ-ACE는 바로 이런 아이디어를 로봇 제어에 적용한 것입니다.</p>
<section id="action-chunking-동작을-덩어리로-묶기" class="level3">
<h3 class="anchored" data-anchor-id="action-chunking-동작을-덩어리로-묶기">Action Chunking: 동작을 덩어리로 묶기</h3>
<p>VQ-ACE는 로봇의 복잡한 동작을 <strong>“action chunks”</strong>라는 의미있는 덩어리로 묶습니다. 예를 들어:</p>
<ul>
<li>“물체를 잡는 동작” → 1초 동안의 손가락 움직임 패턴</li>
<li>“손바닥에서 공을 굴리는 동작” → 1초 동안의 손목과 손가락 조정 패턴</li>
</ul>
<p>이렇게 하면 로봇이 매 순간마다 “다음 0.05초 동안 손가락을 얼마나 움직일까?”를 고민하는 대신, “다음 1초 동안 어떤 동작 패턴을 사용할까?”를 선택하면 됩니다.</p>
</section>
<section id="vector-quantization-동작을-단어로-만들기" class="level3">
<h3 class="anchored" data-anchor-id="vector-quantization-동작을-단어로-만들기">Vector Quantization: 동작을 “단어”로 만들기</h3>
<p>더 나아가, VQ-ACE는 이런 동작 덩어리들을 <strong>이산적인 “코드”</strong>로 변환합니다. 마치 연속적인 음성을 텍스트로 변환하는 것처럼요.</p>
<p>연구팀은 다음과 같은 시스템을 만들었습니다:</p>
<ul>
<li>5개의 “토큰” (단어 같은 것)</li>
<li>각 토큰은 4가지 값 중 하나를 선택</li>
<li>총 <span class="math inline">4^5 = 1,024</span>개의 가능한 동작 패턴</li>
</ul>
<p>원래 수백만 가지였던 가능한 동작이 이제 1,024가지로 줄어든 겁니다! 하지만 중요한 동작 특성은 모두 보존됩니다.</p>
<hr>
</section>
</section>
<section id="기술적으로-어떻게-작동할까" class="level2">
<h2 class="anchored" data-anchor-id="기술적으로-어떻게-작동할까">기술적으로 어떻게 작동할까?</h2>
<section id="vq-vae-압축과-복원의-마법" class="level3">
<h3 class="anchored" data-anchor-id="vq-vae-압축과-복원의-마법">VQ-VAE: 압축과 복원의 마법</h3>
<p>VQ-ACE의 기술적 핵심은 <strong>VQ-VAE (Vector Quantized Variational AutoEncoder)</strong>입니다. 어려운 이름이지만 개념은 생각보다 단순합니다.</p>
<p><strong>1단계 - Encoder (인코더):</strong></p>
<p>인간의 손동작 데이터를 받아서 “이 동작의 본질은 이거야!”라고 요약합니다. 마치 긴 문장을 핵심 단어 몇 개로 요약하는 것처럼요.</p>
<pre><code>복잡한 손동작 (11 DoF × 20 타임스텝)
    ↓
[토큰1, 토큰2, 토큰3, 토큰4, 토큰5]</code></pre>
<p><strong>2단계 - Vector Quantization (벡터 양자화):</strong></p>
<p>요약된 정보를 미리 정해진 “코드북”에서 가장 가까운 값으로 바꿉니다. 이게 핵심입니다! 이렇게 하면:</p>
<ul>
<li>동작이 이산적(discrete)이 됩니다</li>
<li>비슷한 동작들이 같은 코드로 표현됩니다</li>
<li>로봇이 선택할 수 있는 옵션이 명확해집니다</li>
</ul>
<p><strong>3단계 - Decoder (디코더):</strong></p>
<p>5개의 토큰을 받아서 다시 상세한 손동작으로 복원합니다. 여기서 중요한 건, 현재 손의 위치도 함께 고려한다는 점입니다.</p>
<pre><code>[토큰1, 토큰2, 토큰3, 토큰4, 토큰5] + 현재 손 위치
    ↓
다음 1초 동안의 상세한 손동작</code></pre>
</section>
<section id="학습-과정-인간으로부터-배우기" class="level3">
<h3 class="anchored" data-anchor-id="학습-과정-인간으로부터-배우기">학습 과정: 인간으로부터 배우기</h3>
<p>VQ-ACE는 어떻게 이런 능력을 얻을까요? 답은 <strong>인간 시연 데이터</strong>입니다.</p>
<ol type="1">
<li>사람이 원격 조작으로 로봇 손을 움직입니다</li>
<li>다양한 작업(공 굴리기, 물체 잡기 등)의 데이터를 수집합니다</li>
<li>VQ-VAE가 이 데이터로부터 학습합니다:
<ul>
<li>“아, 이런 식으로 손가락을 움직이면 물체를 잡는구나”</li>
<li>“손목을 이렇게 회전하면 공이 굴러가는구나”</li>
</ul></li>
</ol>
<p>학습이 끝나면, VQ-ACE는 인간의 동작 패턴을 1,024개의 코드로 압축해서 가지고 있게 됩니다.</p>
<hr>
</section>
</section>
<section id="mpc에-적용하기-더-영리한-계획-세우기" class="level2">
<h2 class="anchored" data-anchor-id="mpc에-적용하기-더-영리한-계획-세우기">MPC에 적용하기: 더 영리한 계획 세우기</h2>
<section id="기존-mpc의-문제점" class="level3">
<h3 class="anchored" data-anchor-id="기존-mpc의-문제점">기존 MPC의 문제점</h3>
<p><strong>Model Predictive Control (MPC)</strong>는 로봇 제어에서 널리 사용되는 방법입니다. 개념은 이렇습니다:</p>
<ol type="1">
<li>여러 가능한 행동을 시뮬레이션해봅니다</li>
<li>각 행동의 결과를 평가합니다</li>
<li>가장 좋은 결과를 주는 행동을 선택합니다</li>
</ol>
<p>문제는 “여러 가능한 행동”이 너무 많다는 겁니다. 고차원 공간에서 랜덤하게 샘플링하면 대부분은 쓸모없는 동작들입니다. 마치 눈을 감고 다트를 던지는 것과 같습니다.</p>
</section>
<section id="latent-sampling-mpc-잠재-공간에서-샘플링하기" class="level3">
<h3 class="anchored" data-anchor-id="latent-sampling-mpc-잠재-공간에서-샘플링하기">Latent Sampling MPC: 잠재 공간에서 샘플링하기</h3>
<p>VQ-ACE는 이 문제를 우아하게 해결합니다. <strong>원래 행동 공간이 아니라 압축된 잠재 공간에서 샘플링</strong>하는 겁니다.</p>
<ol type="1">
<li>1,024개의 가능한 동작 패턴 중에서 몇 개를 선택합니다</li>
<li>각 패턴을 디코더로 실제 동작으로 변환합니다</li>
<li>시뮬레이터에서 결과를 평가합니다</li>
<li>최선의 동작을 실행합니다</li>
</ol>
<p><strong>왜 이게 더 나을까요?</strong></p>
<p>1,024개의 선택지는 모두 인간이 실제로 하는 동작들을 표현합니다. 다시 말해, 무작위로 이상한 동작을 시도하는 대신, 의미있는 동작들 중에서 선택하는 겁니다.</p>
<p>실험 결과는 인상적입니다:</p>
<p><strong>Ball Rolling (공 굴리기) 작업:</strong></p>
<ul>
<li>기존 MPC: 성공률 65%</li>
<li>VQ-ACE MPC: 성공률 88% (✨ 35% 개선!)</li>
</ul>
<p><strong>Object Picking (물체 잡기) 작업:</strong></p>
<ul>
<li>기존 MPC: 성공률 72%</li>
<li>VQ-ACE MPC: 성공률 91% (✨ 26% 개선!)</li>
</ul>
<p>더 놀라운 건 <strong>인간 유사도</strong>입니다. VQ-ACE로 생성된 동작은 인간의 동작 패턴과 훨씬 더 비슷합니다. 이는 안전성과 예측 가능성 측면에서 매우 중요합니다.</p>
<hr>
</section>
</section>
<section id="강화학습에-적용하기-학습-속도-2배-향상" class="level2">
<h2 class="anchored" data-anchor-id="강화학습에-적용하기-학습-속도-2배-향상">강화학습에 적용하기: 학습 속도 2배 향상</h2>
<section id="강화학습의-탐색-문제" class="level3">
<h3 class="anchored" data-anchor-id="강화학습의-탐색-문제">강화학습의 탐색 문제</h3>
<p>강화학습(RL)은 시행착오를 통해 학습하는 방법입니다. 문제는 고차원 행동 공간에서는 “시행착오”가 너무 오래 걸린다는 겁니다. 마치 어두운 방에서 눈을 감고 출구를 찾는 것과 같습니다.</p>
</section>
<section id="action-chunked-rl-구조화된-탐색" class="level3">
<h3 class="anchored" data-anchor-id="action-chunked-rl-구조화된-탐색">Action Chunked RL: 구조화된 탐색</h3>
<p>VQ-ACE를 강화학습에 통합하면 탐색이 훨씬 효율적이 됩니다. 로봇의 행동 선택이 다음과 같이 바뀝니다:</p>
<p><strong>기존 RL:</strong></p>
<pre><code>매 타임스텝마다:
  → 11개 관절 각도를 각각 조정 (연속 값)</code></pre>
<p><strong>Action Chunked RL:</strong></p>
<pre><code>매 타임스텝마다:
  → 5개 토큰 선택 (각각 4개 값 중 하나)
  → 미세 조정을 위한 residual 값 추가
  → 디코더가 1초 동안의 동작 생성</code></pre>
<p>이렇게 하면:</p>
<ul>
<li><strong>탐색 공간이 극적으로 축소</strong>됩니다</li>
<li><strong>시간적 일관성</strong>이 자동으로 보장됩니다 (1초 단위 행동)</li>
<li><strong>의미있는 동작</strong>에 집중할 수 있습니다</li>
</ul>
</section>
<section id="실험-결과-빠르고-성능도-좋다" class="level3">
<h3 class="anchored" data-anchor-id="실험-결과-빠르고-성능도-좋다">실험 결과: 빠르고 성능도 좋다</h3>
<p><strong>Cube Stacking (큐브 쌓기):</strong></p>
<ul>
<li>기존 PPO: 5백만 스텝에 78% 성공률</li>
<li>VQ-ACE PPO: 2백만 스텝에 85% 성공률
<ul>
<li>⚡ 학습 속도 2.5배 빠름</li>
<li>🎯 최종 성능도 7% 더 좋음</li>
</ul></li>
</ul>
<p><strong>In-hand Cube Reorientation (손 안에서 큐브 회전):</strong></p>
<ul>
<li>기존 PPO: 8백만 스텝에 65% 성공률</li>
<li>VQ-ACE PPO: 3.5백만 스텝에 73% 성공률
<ul>
<li>⚡ 학습 속도 2.3배 빠름</li>
<li>🎯 최종 성능 8% 향상</li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="왜-이렇게-잘-작동할까-핵심-통찰" class="level2">
<h2 class="anchored" data-anchor-id="왜-이렇게-잘-작동할까-핵심-통찰">왜 이렇게 잘 작동할까? 핵심 통찰</h2>
<section id="적절한-귀납적-편향-inductive-bias" class="level3">
<h3 class="anchored" data-anchor-id="적절한-귀납적-편향-inductive-bias">1. 적절한 귀납적 편향 (Inductive Bias)</h3>
<p>흥미로운 발견이 하나 있습니다. <strong>재구성 품질이 높다고 해서 작업 성능이 좋은 건 아닙니다.</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>모델</th>
<th>재구성 오차</th>
<th>Ball Rolling 성공률</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VAE (연속)</td>
<td>0.028 ⭐</td>
<td>74%</td>
</tr>
<tr class="even">
<td>VQ-ACE (k=4)</td>
<td>0.050</td>
<td>88% ⭐</td>
</tr>
<tr class="odd">
<td>VQ-ACE (k=8)</td>
<td>0.033</td>
<td>84%</td>
</tr>
</tbody>
</table>
<p>일반적인 VAE는 재구성을 더 정확하게 하지만, 실제 작업 성능은 더 낮습니다. 왜 그럴까요?</p>
<p>저자들의 설명: <strong>Vector Quantization의 이산화가 일종의 정규화(regularization) 역할</strong>을 합니다. 너무 세밀한 디테일까지 기억하려고 하면 오히려 과적합이 될 수 있습니다. 적당히 “뭉뚱그려서” 표현하는 게 일반화에 더 도움이 됩니다.</p>
<p>이는 인간의 운동 제어와도 유사합니다. 우리는 모든 근육의 정확한 힘을 계산하지 않습니다. 대신 “물체 잡기”라는 하나의 패턴으로 뭉뚱그려서 실행합니다.</p>
</section>
<section id="코드북-크기의-최적점" class="level3">
<h3 class="anchored" data-anchor-id="코드북-크기의-최적점">2. 코드북 크기의 최적점</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>코드북 크기</th>
<th>총 가능한 행동</th>
<th>성능</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>32</td>
<td>낮음 (표현력 부족)</td>
</tr>
<tr class="even">
<td>4</td>
<td>1,024</td>
<td>높음 ⭐</td>
</tr>
<tr class="odd">
<td>8</td>
<td>32,768</td>
<td>중간 (탐색 비효율)</td>
</tr>
<tr class="even">
<td>16</td>
<td>1,048,576</td>
<td>중간 (과적합)</td>
</tr>
</tbody>
</table>
<p>코드북 크기 4가 최적의 균형점입니다. 너무 작으면 표현력이 부족하고, 너무 크면 탐색이 비효율적이고 과적합 위험이 있습니다.</p>
</section>
<section id="시간적-구조의-자동-학습" class="level3">
<h3 class="anchored" data-anchor-id="시간적-구조의-자동-학습">3. 시간적 구조의 자동 학습</h3>
<p>Action chunk는 1초 길이입니다. 이는 여러 타임스텝에 걸친 시간적 패턴을 하나의 단위로 취급한다는 의미입니다.</p>
<p>예를 들어 “물체를 잡는” 동작은: 1. 손을 물체 쪽으로 이동 2. 손가락을 펼침 3. 물체에 접촉 4. 손가락을 오므림 5. 힘을 가하여 안정화</p>
<p>이 5단계가 하나의 coordinated pattern으로 학습됩니다. 로봇이 각 단계를 따로 배울 필요가 없는 겁니다.</p>
<hr>
</section>
</section>
<section id="실험-환경과-작업들" class="level2">
<h2 class="anchored" data-anchor-id="실험-환경과-작업들">실험 환경과 작업들</h2>
<p>연구팀은 <strong>11 자유도를 가진 생체모방 건-구동(tendon-driven) 로봇 손</strong>을 사용했습니다. 이 로봇은 인간 손의 운동학을 모방하도록 설계되었습니다.</p>
<section id="테스트한-4가지-작업" class="level3">
<h3 class="anchored" data-anchor-id="테스트한-4가지-작업">테스트한 4가지 작업</h3>
<p><strong>1. Ball Rolling (공 굴리기)</strong></p>
<ul>
<li>손바닥 위에 공을 올려놓고 특정 방향으로 굴리기</li>
<li>어려운 이유: 동적 접촉을 유지하면서 정밀하게 제어해야 함</li>
<li>VQ-ACE 개선: 성공률 65% → 88%</li>
</ul>
<p><strong>2. Object Picking (물체 잡기)</strong></p>
<ul>
<li>다양한 형태의 물체를 안정적으로 파지하고 들어올리기</li>
<li>어려운 이유: 물체마다 최적의 접촉점과 파지 전략이 다름</li>
<li>VQ-ACE 개선: 성공률 72% → 91%</li>
</ul>
<p><strong>3. Cube Stacking (큐브 쌓기)</strong></p>
<ul>
<li>여러 개의 큐브를 순차적으로 쌓기</li>
<li>어려운 이유: 정밀한 위치 제어와 균형 유지가 필요</li>
<li>VQ-ACE 개선: 2.5배 빠른 학습, 성공률 78% → 85%</li>
</ul>
<p><strong>4. In-hand Cube Reorientation (손 안에서 큐브 회전)</strong></p>
<ul>
<li>손에 쥔 큐브를 목표 방향으로 회전시키기</li>
<li>어려운 이유: 여러 손가락의 복잡한 협응이 필요</li>
<li>VQ-ACE 개선: 2.3배 빠른 학습, 성공률 65% → 73%</li>
</ul>
<hr>
</section>
</section>
<section id="한계점-완벽하지-않다" class="level2">
<h2 class="anchored" data-anchor-id="한계점-완벽하지-않다">한계점: 완벽하지 않다</h2>
<p>모든 연구가 그렇듯, VQ-ACE에도 한계가 있습니다. 이를 솔직하게 살펴보는 것이 중요합니다.</p>
<section id="인간-데이터-의존성" class="level3">
<h3 class="anchored" data-anchor-id="인간-데이터-의존성">1. 인간 데이터 의존성</h3>
<p>VQ-ACE는 인간 시연 데이터로부터 학습합니다. 이는 양날의 검입니다:</p>
<p><strong>장점:</strong></p>
<ul>
<li>안전하고 직관적인 동작 학습</li>
<li>물리적으로 타당한 행동 생성</li>
</ul>
<p><strong>단점:</strong></p>
<ul>
<li>고품질 데이터 수집에 시간과 비용이 많이 듦</li>
<li>원격 조작 인터페이스의 품질이 결과에 영향</li>
<li>작업마다 새로운 데이터 수집이 필요할 수 있음</li>
</ul>
<p>만약 인간이 하지 않는 동작이 실제로는 더 효율적이라면? VQ-ACE는 그런 동작을 발견하기 어려울 수 있습니다.</p>
</section>
<section id="특정-플랫폼에-한정" class="level3">
<h3 class="anchored" data-anchor-id="특정-플랫폼에-한정">2. 특정 플랫폼에 한정</h3>
<p>현재 연구는 11 DoF 생체모방 로봇 손에서만 검증되었습니다. 다음 질문들이 남아있습니다:</p>
<ul>
<li>Shadow Hand (24 DoF)나 Allegro Hand (16 DoF)에도 잘 작동할까?</li>
<li>완전히 다른 형태의 그리퍼에는?</li>
<li>팔과 손을 함께 제어하는 경우는?</li>
</ul>
<p>일반화 가능성이 아직 충분히 검증되지 않았습니다.</p>
</section>
<section id="시뮬레이션-위주의-실험" class="level3">
<h3 class="anchored" data-anchor-id="시뮬레이션-위주의-실험">3. 시뮬레이션 위주의 실험</h3>
<p>대부분의 실험이 시뮬레이션 환경에서 수행되었습니다. 실제 로봇으로의 전이(sim-to-real transfer)에는 항상 gap이 존재합니다:</p>
<ul>
<li>실제 센서의 노이즈</li>
<li>통신 지연</li>
<li>예측하지 못한 환경 변화</li>
<li>마모와 고장</li>
</ul>
<p>이런 현실 세계의 불확실성에 대한 robustness가 검증되지 않았습니다.</p>
</section>
<section id="작업-특화성" class="level3">
<h3 class="anchored" data-anchor-id="작업-특화성">4. 작업 특화성</h3>
<p>각 작업마다 별도의 VQ-VAE를 학습해야 할까요, 아니면 하나의 범용 VQ-ACE로 여러 작업을 처리할 수 있을까요?</p>
<p>논문에서는 이 부분이 명확하지 않습니다. 만약 각 작업마다 새로 학습해야 한다면 확장성에 제약이 있을 수 있습니다.</p>
<hr>
</section>
</section>
<section id="관련-연구들과의-비교" class="level2">
<h2 class="anchored" data-anchor-id="관련-연구들과의-비교">관련 연구들과의 비교</h2>
<p>VQ-ACE는 여러 연구 흐름의 교차점에 있습니다. 각 분야와 어떻게 다른지 살펴보겠습니다.</p>
<section id="action-representation-learning-분야" class="level3">
<h3 class="anchored" data-anchor-id="action-representation-learning-분야">Action Representation Learning 분야</h3>
<p><strong>Action Chunking Transformer (ACT, 2023)와의 비교:</strong></p>
<p>ACT도 action chunking 개념을 사용하지만 몇 가지 차이가 있습니다:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>특징</th>
<th>ACT</th>
<th>VQ-ACE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>잠재 공간</td>
<td>연속 (continuous)</td>
<td>이산 (discrete)</td>
</tr>
<tr class="even">
<td>모델</td>
<td>Transformer</td>
<td>VQ-VAE</td>
</tr>
<tr class="odd">
<td>MPC 적용</td>
<td>어려움</td>
<td>용이함</td>
</tr>
<tr class="even">
<td>해석 가능성</td>
<td>낮음</td>
<td>높음 (이산 코드)</td>
</tr>
</tbody>
</table>
<p>VQ-ACE의 이산 표현은 MPC와의 통합을 훨씬 쉽게 만듭니다.</p>
<p><strong>Diffusion Policy (2023)와의 비교:</strong></p>
<p>Diffusion 모델도 최근 로봇 제어에서 인상적인 결과를 보이고 있습니다:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 18%">
<col style="width: 56%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>특징</th>
<th>Diffusion Policy</th>
<th>VQ-ACE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>생성 품질</td>
<td>매우 높음</td>
<td>높음</td>
</tr>
<tr class="even">
<td>추론 속도</td>
<td>느림 (여러 denoising steps)</td>
<td>빠름 (한 번의 forward pass)</td>
</tr>
<tr class="odd">
<td>실시간 제어</td>
<td>어려움</td>
<td>용이함</td>
</tr>
<tr class="even">
<td>학습 안정성</td>
<td>민감함</td>
<td>안정적</td>
</tr>
</tbody>
</table>
<p>VQ-ACE는 실시간 제어가 중요한 응용에 더 적합합니다.</p>
</section>
<section id="model-predictive-control-분야" class="level3">
<h3 class="anchored" data-anchor-id="model-predictive-control-분야">Model Predictive Control 분야</h3>
<p><strong>MPPI (Model Predictive Path Integral)와의 비교:</strong></p>
<p>MPPI는 샘플링 기반 MPC의 대표적 방법입니다:</p>
<ul>
<li><strong>MPPI</strong>: 원래 행동 공간에서 수천 개 샘플링</li>
<li><strong>VQ-ACE MPC</strong>: 잠재 공간에서 수백 개 샘플링</li>
</ul>
<p>VQ-ACE는 훨씬 적은 샘플로도 좋은 성능을 달성합니다. 인간 prior 덕분입니다.</p>
</section>
<section id="imitation-learning-분야" class="level3">
<h3 class="anchored" data-anchor-id="imitation-learning-분야">Imitation Learning 분야</h3>
<p><strong>Behavior Cloning (BC)와의 관계:</strong></p>
<p>VQ-ACE는 BC와 상호보완적입니다:</p>
<ul>
<li>BC는 시연 데이터를 직접 모방</li>
<li>VQ-ACE는 시연 데이터로부터 행동 표현을 학습</li>
<li>VQ-ACE + BC = 더 효율적인 모방 학습</li>
</ul>
<hr>
</section>
<section id="관련-논문들" class="level3">
<h3 class="anchored" data-anchor-id="관련-논문들">관련 논문들</h3>
<ul>
<li><strong>Action Chunking:</strong>
<ul>
<li>ACT: “Action Chunking with Transformers” (2023)</li>
<li>Learning Fine-Grained Bimanual Manipulation with Low-Cost Hardware (2023)</li>
</ul></li>
<li><strong>Vector Quantization in Robotics:</strong>
<ul>
<li>“VQ-VAE for Motion Planning” (2021)</li>
<li>“Discrete Latent Space for Robot Learning” (2022)</li>
</ul></li>
<li><strong>Dexterous Manipulation:</strong>
<ul>
<li>“Learning Dexterous In-Hand Manipulation” (OpenAI, 2019)</li>
<li>“DexMV: Imitation Learning for Dexterous Manipulation from Human Videos” (2023)</li>
</ul></li>
<li><strong>MPC for Robotics:</strong>
<ul>
<li>“Model Predictive Path Integral Control” (2016)</li>
<li>“Deep Dynamics Models for Learning Dexterous Manipulation” (2020)</li>
</ul></li>
</ul>
</section>
</section>
</section>
<section id="dig-review" class="level1">
<h1>⛏️ Dig Review</h1>
<blockquote class="blockquote">
<p>⛏️ Dig — Go deep, uncover the layers. Dive into technical detail.</p>
</blockquote>
<section id="연구-배경과-동기" class="level2">
<h2 class="anchored" data-anchor-id="연구-배경과-동기">1. 연구 배경과 동기</h2>
<p>인간 손은 27 자유도(Degrees of Freedom, DoF)를 가지며 섬세한 조작과 강력한 그립을 모두 수행할 수 있지만, 실제로 인간은 모든 관절을 독립적으로 제어하지 않고 여러 관절이 연관된 패턴으로 움직인다. 이로 인해 복잡한 손의 움직임은 본질적으로 저차원적인 궤적(manifold) 위에 존재한다. 따라서 인간 손 동작을 효율적으로 표현할 수 있는 저차원 표현 방법이 요구된다. 이러한 표현은 동작이 연속적이며(dynamic), 손 궤적의 작은 부분집합을 포괄하는 콤팩트한(Compact) 특성을 가져야 한다. 또한 실제 제어 알고리즘에 적용하기 위해서는 연속적인 표현을 벡터 양자화(vector quantization)로 이산(discrete)화하여 계산 효율을 높일 필요가 있다.</p>
<p>본 논문은 위와 같은 동기에서 출발하여 Vector Quantized Action Chunking Embedding (VQ-ACE)라는 프레임워크를 제안한다. VQ-ACE는 인간의 손 동작 시퀀스를 학습된 벡터 양자화된 잠재 공간(latent space)으로 압축함으로써, 수십 차원에 이르는 로봇 손의 고차원 행동공간을 저차원 이산 공간으로 줄인다. 이렇게 얻은 잠재 공간은 로봇의 정책 탐색(search)에 인간의 조작에 근접한 인위적 사전 지식(anthropomorphic prior)을 제공한다. 저자들은 이 잠재 표현을 활용한 두 가지 응용, 즉 잠재 공간 샘플링 기반 모델 예측 제어(Latent Sampling MPC)와 액션 청킹 강화학습(Action Chunked RL)을 제안하여, 복잡한 조작 과제에서 보다 효율적인 탐색과 학습이 가능함을 보였다.</p>
<p>기존 연구를 보면, 모델 기반 방법(MPC)은 정확한 동역학 모델을 가정하지만 계산 오버헤드가 크며, 반면 강화학습(RL)은 모델 없이 정책을 학습하지만 많은 데이터가 필요하고 시뮬레이션-실제 전이(sim-to-real) 어려움이 있다. 또한 최근 대규모 모방학습(imitation learning) 데이터가 축적되면서 관찰(observation)에서 행동(action) 매핑을 직접 학습하는 시도가 활발하지만, 이는 관찰에 대한 사후 분포(posterior)를 학습하는 접근이다. VQ-ACE는 이러한 방법들의 중간자적 접근으로, 모방학습과 유사한 데이터 기반 방식이지만 행동의 사전 분포(prior)만을 모델링하여, MPC와 RL 탐색에서 유용한 가이던스(prior)를 제공한다.</p>
</section>
<section id="주요-기여점-요약" class="level2">
<h2 class="anchored" data-anchor-id="주요-기여점-요약">2. 주요 기여점 요약</h2>
<p>본 논문에서 저자들이 제시한 주요 기여점은 다음과 같다: - VQ-ACE 프레임워크 제안: 인간 손의 행동 청크(action chunk) 시퀀스를 벡터 양자화된 잠재 공간으로 임베딩하는 구조를 고안했다. 예를 들어 11 자유도 로봇 손에 대해 1초(50 타임스텝) 길이의 행동 시퀀스를 5개의 디스크리트한 잠재 토큰으로 압축할 수 있다. - 잠재 공간 샘플링 MPC 제안: VQ-ACE로 학습된 잠재 표현을 사용하여, 샘플링 기반 MPC를 잠재 공간 위에서 수행하는 기법을 개발했다. 이 방법은 탐색 공간을 인간 손 행동의 사전 분포로 제한하여 더 자연스러운 조작 행동을 생성한다. - 액션 청킹 강화학습 제안: RL 정책에 행동 청크 단위를 도입하여, 에이전트가 의미 있는 행동 청크를 선택하고 나머지를 잔차(residual)로 수정하게 함으로써 탐색 효율을 높였다.</p>
<p>이러한 기여를 통해 저자들은 복잡한 조작 과제에서도 학습 속도와 탐색 효율을 개선하고, 더욱 인간처럼 자연스러운 조작을 달성할 수 있음을 보였다.</p>
</section>
<section id="방법론" class="level2">
<h2 class="anchored" data-anchor-id="방법론">3. 방법론</h2>
<section id="행동-데이터-수집-및-전처리" class="level3">
<h3 class="anchored" data-anchor-id="행동-데이터-수집-및-전처리">3.1 행동 데이터 수집 및 전처리</h3>
<p>VQ-ACE의 학습을 위해, 저자들은 모션 캡처 장갑을 사용하여 인간 손의 다양한 일상 동작 시퀀스를 획득했다. 획득된 데이터는 50 Hz로 기록된 약 54분 분량이며, 일상 물체 조작, 케이블 묶기, 수화 등 다양한 작업을 포함한다. 이 데이터를 로봇 핸드에 맞추어 키네마틱 리타게팅(kinematic retargeting) 함수를 적용함으로써 11 자유도 로봇 손 조인트 값으로 변환했다.</p>
</section>
<section id="vq-ace-네트워크-구조" class="level3">
<h3 class="anchored" data-anchor-id="vq-ace-네트워크-구조">3.2 VQ-ACE 네트워크 구조</h3>
<p>VQ-ACE는 벡터 양자화 조건부 VAE(CVAE) 구조로, 인간 손의 행동 청크를 고정된 길이의 잠재 벡터 시퀀스로 임베딩한다. 구체적으로, 시간 구간 <span class="math inline">[t, t+n]</span>에 걸친 행동 시퀀스 <span class="math inline">a_{t:t+n}</span>를, 현재 관절 위치 <span class="math inline">q_t</span>에 조건화하여 변환한다. 인코더 <span class="math inline">\varphi(q_t, a_{t:t+n})</span>는 행동 시퀀스를 일련의 연속 잠재벡터 <span class="math inline">z_{k:k+m}</span>로 압축하고, 이 벡터들을 가장 가까운 코드북(embedding table)에 할당하여 이산화된 잠재 벡터 <span class="math inline">z_q</span>를 얻는다. 디코더 <span class="math inline">\psi(q_t, z_q)</span>는 현재 관절 위치와 양자화된 잠재 벡터를 입력받아 원래 행동 시퀀스를 재구성한다. 인코더와 디코더 모두 Transformer 기반의 시퀀스 모델로 구현되며, 입력에는 시간 정보를 나타내는 positional token들이 포함된다. 디코더에는 인과적 마스킹(causal mask)을 적용하여 시간축 상의 순서를 보장한다.</p>
<p>이때, 잠재 토큰의 시간 인덱스 <span class="math inline">k</span>와 실제 시점 <span class="math inline">t</span>의 대응은 단순히 <span class="math inline">t(k)=k\cdot n/m</span> 형태로 매핑한다. 학습 손실 함수는 다음과 같다:</p>
<p>재구성 손실: <span class="math inline">\mathcal{L}{recon} = | a - \psi(q_t, z_q) |_1</span> (식 (2)).</p>
<p>커밋 손실: <span class="math inline">\mathcal{L}{commit} = |\varphi(q_t,a[\cdot]</span>는 그래디언트 전달을 차단하는 연산자이다. }) - [z_q] |_2^2$ (식 (3)), 여기서 $\mathrm{sg</p>
<p>총 손실: <span class="math inline">\mathcal{L} = \mathcal{L}{recon} + \lambda \mathcal{L}</span> (식 (4)).</p>
<p>이와 같이 손실을 구성함으로써, 네트워크는 행동 시퀀스의 중요한 특징을 유지하면서도 잠재 표현의 불연속성(discreteness)을 학습한다. 또한 벡터 양자화 부분은 EMA(Exponential Moving Average) 업데이트를 사용하여 안정화하였다.</p>
</section>
<section id="잠재-공간-샘플링-mpc" class="level3">
<h3 class="anchored" data-anchor-id="잠재-공간-샘플링-mpc">3.3 잠재 공간 샘플링 MPC</h3>
<p>학습된 VQ-ACE 잠재 공간은 MPC에 활용된다. 전통적인 샘플링 기반 MPC는 각 DoF의 제어 입력을 분할 스플라인 형태로 표현하고 이를 무작위로 샘플링하여 최적 행동을 찾는 방식이다. VQ-ACE에서는 행동을 직접 샘플링하지 않고, 잠재 벡터 <span class="math inline">z_{k:k+m}</span>를 샘플링하여 이로부터 행동을 생성한다. 제어 신호는 디코더가 생성한 관성 동작(“nominal action”)과 별도의 가우시안 노이즈 스플라인의 합으로 구성된다. 수식 (5)는 시간 <span class="math inline">\tilde t</span>에서의 제어 신호를, <span class="math display">
u(\tilde t) = \psi(\tilde t; q_t, z_{k:k+m}) + s(\tilde t; \theta_{\tau:\tau+P}), \quad (5)
</span></p>
<p>로 표현한다. 여기서 첫 번째 항은 잠재 <span class="math inline">z_{k:k+m}</span>에 의해 복원된 관성 행동이며, 두 번째 항 <span class="math inline">s</span>는 스플라인 형태의 노이즈이다. MPC는 여러 후보 잠재 시퀀스를 생성한 뒤 시뮬레이션으로 평가하여 가장 비용(<span class="math inline">J</span>)이 낮은 계획을 실행한다. 다음 반복에서는 상위 경로(best sequence)에 시간축 이동(noise shift)을 적용한 새로운 잠재 및 노이즈 스플라인을 다시 샘플링한다.</p>
<p>잠재 공간 위 샘플링에서는 잠재 벡터의 일부 차원을 무작위로 대체함으로써 로컬 탐색을 수행한다. 즉, 현재 잠재 <span class="math inline">\zeta_{j}^{(i)}</span>의 <span class="math inline">p</span> 확률로 새로운 코드북 인덱스를 샘플링하여 { (6)식 참조 } 잠재를 갱신한다. 이와 함께 노이즈 스플라인도 재설정하여 더 세밀한 제어를 가능하게 한다. 이러한 방식으로, VQ-ACE 잠재 공간이 구조화되어 있을수록 MPC가 보다 빠르고 효율적으로 유용한 제어 계획을 탐색할 수 있다.</p>
</section>
<section id="액션-청킹-강화학습" class="level3">
<h3 class="anchored" data-anchor-id="액션-청킹-강화학습">3.4 액션 청킹 강화학습</h3>
<p>VQ-ACE는 단순한 MPC 외에도 RL 정책 학습에도 사용된다. RL 관점에서 행동 청크(action chunk)는 일반적인 Markov 결정 과정(MDP)에서 시간 단계가 긴 형태의 행동으로 볼 수 있다. 논문에서는 정책이 매 시간마다 청크를 선택하지 않고, 일정 기간 동안 청크를 유지하되 매 스텝마다 작동 잔차(residual)를 추가로 결정하도록 상태와 행동 공간을 확장했다. 수식(8)-(11)는 청크 선택(state, action) 변수를 도입하여 시스템 상태 <span class="math inline">x</span>, 동작 <span class="math inline">u</span>를 확장하는 과정을 나타낸다. 쉽게 설명하면, 에이전트는 정해진 청크 인덱스들을 선택하고, 실제 제어 신호는 디코더가 생성한 액션 청크와 정책이 출력하는 잔차 <span class="math inline">\epsilon_t</span>의 합으로 구성된다 (수식 (11) 참조). 이로써 정책은 다중 스텝 행동 청크 중 하나를 능동적으로 선택(Chunk Selection)하면서 탐색의 수준(level-of-action)을 키우고, 실행 주기는 잔차를 통해 세밀하게 조정할 수 있다.</p>
</section>
</section>
<section id="실험-설계-및-평가-방법" class="level2">
<h2 class="anchored" data-anchor-id="실험-설계-및-평가-방법">4. 실험 설계 및 평가 방법</h2>
<p>저자들은 두 가지 설정에서 방법을 평가했다: 샘플링 기반 MPC와 강화학습(RL)이다.</p>
<p>MPC 실험: 11자유도 Faive 모델의 로봇 손을 사용하여 공 굴리기(Ball Rolling)와 물체 집기(Object Picking) 두 과제를 수행했다. 공 굴리기 과제는 로봇 손으로 구를 x축 방향으로 회전시키는 것이며, 물체 집기 과제는 랜덤 위치의 덤벨 모양 물체를 쥐어서 랜덤 목표 위치에 옮기는 것이다. 손 이외에 물체 집기 과제에는 7-DoF Franka 암을 추가로 사용했다. MPC는 매 반복당 1초(50 타임스텝) 길이의 계획을 수행하며, 실제 연산 시간에 따른 제어 주기를 고려하기 위해 시뮬레이션 속도를 동일하게 조정해 비교했다. 하드웨어는 Intel i9 CPU, NVIDIA 4090 GPU를 사용했다. 평가 지표는 제어 비용(J; 작을수록 좋음)과 과제 성공률(높을수록 좋음)이며, 여러 난수 시드에서 복수의 시행을 수행했다.</p>
<p>RL 실험: 큐브 방향 전환(Cube Reorientation)과 큐브 적층(Cube Stacking) 과제를 설정했다. 전자는 50mm 큐브를 손 안에서 목표 자세로 돌리는 과제이고, 후자는 손이 장착된 Franka 로봇 암이 50mm 큐브를 더 큰 큐브 위에 쌓는 과제다. 두 과제 모두 PPO를 사용해 학습했으며, 동일한 비용 함수와 환경 설정으로 Action Chunked RL과 일반 RL 방법(기본 방법) 간 비교를 수행했다. 평가 지표는 연속 성공 횟수와 성공률이며, 4096 병렬 환경을 활용해 NVIDIA 4090 GPU에서 학습했다.</p>
<p>또한, 에비에이션(ablation) 연구로 두 가지 요소의 효과를 검증했다: (1) 조건부 입력(Conditioning) – 현재 관절 위치를 인코더/디코더 입력에서 제거하는 실험, (2) 벡터 양자화 대 연속 표현(VAE 대안) – 커밋 손실 대신 KL 손실을 사용하는 일반 VAE로 학습. 이를 통해 VQ-ACE의 구성 요소들이 성능에 미치는 영향을 분석했다.</p>
</section>
<section id="결과-분석-및-논의" class="level2">
<h2 class="anchored" data-anchor-id="결과-분석-및-논의">5. 결과 분석 및 논의</h2>
<section id="mpc-성능" class="level3">
<h3 class="anchored" data-anchor-id="mpc-성능">5.1 MPC 성능</h3>
<p>잠재 공간 MPC는 두 과제 모두에서 기존 샘플링 MPC 대비 더 낮은 비용과 높은 성공률을 보였다. 그림5의 결과에서 볼 수 있듯이, Ball Rolling과 Object Picking 과제에서 VQ-ACE 기반 latent sampling MPC의 평균 비용이 기준선(spline 기반)보다 낮고 성공률은 높았다. 특히 그림6에서 보듯이, 샘플링 경로 수를 증가시킬수록 두 방법 모두 비용이 감소하지만, 주어진 샘플 수에서 latent MPC의 비용이 항상 더 낮게 나타났다. 예를 들어 40경로 샘플링 시 latent MPC의 비용(54.2)은 기준선 200경로 샘플링 시 비용(56.0)과 유사하였다. 이는 VQ-ACE가 샘플링 시 더 구조화된 검색 공간을 제공하여 적은 샘플 수로도 우수한 계획을 찾기 때문으로 해석된다.</p>
<p>또한 정성적 이미지(그림4 참조)에서 latent MPC는 모든 손가락이 접촉을 유지하며 공을 구르는 등 더 인간적인 동작을 보여주었다. 반면 기준 샘플링 MPC는 공 제어에 집중하여 손가락 접촉이 산발적이었다. 객체 집기 과제에서는 latent MPC가 6초에 객체를 성공적으로 잡고 8초에 들어올려 과제를 달성했으나, 기준선 방법은 목표 부근에서 집기 시도에 실패했다. 이처럼 잠재 표현의 도입이 보다 자연스러운 조작을 유도함을 확인했다.</p>
</section>
<section id="rl-성능" class="level3">
<h3 class="anchored" data-anchor-id="rl-성능">5.2 RL 성능</h3>
<p>액션 청킹 강화학습에서도 VQ-ACE 기반 방법이 수렴 속도와 최종 성능에서 우위를 보였다. 큐브 방향 전환 과제에서 Action Chunked RL은 학습 초기부터 보다 빠르게 성공률을 높였고, 최종적으로 더 높은 성공률에 도달했다. 큐브 적층 과제에서는 기준 방식이 효과적인 정책을 찾는 데 어려움을 겪는 반면, Action Chunked RL은 안정적으로 학습을 진행하여 높은 성공률을 달성했다. (그림7 참조) 두 과제에서 모두 VQ-ACE 기반 정책은 무작위 탐색 대비 의미 있는 행동 사전(prior)을 탐색함으로써 효율적으로 학습할 수 있었다.</p>
</section>
<section id="구성-요소-검증-ablation" class="level3">
<h3 class="anchored" data-anchor-id="구성-요소-검증-ablation">5.3 구성 요소 검증 (Ablation)</h3>
<p>조건부 입력의 효과: 인코더/디코더 입력에서 현재 관절 위치 정보를 제거하면, 검증 데이터에 대한 재구성 L1 오차가 0.05에서 0.07로 증가했다. 즉, 조건부 입력이 재구성 품질을 향상시킨다. MPC 과제 성능에서도 이 효과가 나타났다. 그림5에서 조건부 정보를 사용하지 않은 모델은 Ball Rolling 과제에서 비용이 크게 상승했다. 단, Object Picking 과제에서는 비조건부 모델이 약간 유리했는데, 이는 이 과제가 손의 정적 자세 인코딩에 집중되어 상대적으로 조건 정보의 중요도가 낮았기 때문이다.</p>
<p>벡터 양자화의 효과: 벡터 양자화를 제거하고 일반 VAE 구조로 학습하면 재구성 손실은 0.028로 더 낮아졌다. 그러나 실제 MPC 성능에서는 양자화된 모델보다 열악하였다. 그림5의 결과를 보면, VAE 기반 모델은 두 과제 모두 비용이 높아 특히 Ball Rolling에서 성능이 크게 저하되었다. 이는 양자화된 잠재가 다중모드(action distribution)의 표현에 강하며, 연속적 표현보다 과적합에 덜 취약하기 때문으로 보인다.</p>
<p>이상의 결과로 미루어, VQ-ACE의 조건부 CVAE 구조와 양자화된 표현 모두가 조작 과제에서 중요한 역할을 함을 알 수 있다. 특히 인간 동작의 다중성(multimodality)을 포착하기 위해서는 이산적인 잠재 표현이 유리했다.</p>
</section>
</section>
<section id="기존-연구와의-비교" class="level2">
<h2 class="anchored" data-anchor-id="기존-연구와의-비교">6. 기존 연구와의 비교</h2>
<p>VQ-ACE는 기존의 모방학습, 모델 기반 제어, RL 등 다양한 접근 방식을 통합·확장하는 성격을 가진다. 전통적인 모방학습(imitation learning) 방법들은 관찰에 대한 행동의 사후 분포 <span class="math inline">p(a|o)</span>를 학습하는 반면, VQ-ACE는 행동 그 자체의 사전 분포 <span class="math inline">p(a)</span>를 모델링한다. 이는 MPC의 비용 최적화나 RL의 탐색 지점으로 활용될 수 있다. 즉, VQ-ACE는 학습된 행동 사전을 통해 추정적 문제와 학습 문제를 모두 돕는 중간적 접근이라 할 수 있다.</p>
<p>또한 행동 표현 관점에서 보면, 최근 Lee et al.[40†21]이 제안한 Residual VAE 기반 방법은 연속적인 잠재 벡터를 사용하는 비조건부(VAE) 구조였다. 이에 비해 VQ-ACE는 조건부 Transformer 기반 VAE 구조를 사용하여 현재 로봇 손 자세(<span class="math inline">q_t</span>)를 입력으로 추가함으로써 재구성 정확도를 높였다. 벡터 양자화를 도입하여 잠재 공간을 이산화한 점도 차별점이다. 선행 연구(Shafiullah 등)는 k-평균을 사용해 행동을 이산화했지만, VQ-ACE는 고정된 크기의 코드북을 학습하여 더 효율적이고 표현력이 높은 이산 잠재를 얻었다.</p>
<p>종합하면, VQ-ACE는 기존 연구들이 한계로 삼았던 고차원 행동 공간의 탐색 어려움을 인간 행동 사전 지식을 통한 압축으로 해결하고자 한다. 이를 통해 모델 기반과 RL의 장점을 모두 살리는 새로운 관점을 제공하며, 실험 결과에서도 기존 방법 대비 효과적임을 보였다.</p>
</section>
<section id="한계점-및-향후-연구-방향" class="level2">
<h2 class="anchored" data-anchor-id="한계점-및-향후-연구-방향">7. 한계점 및 향후 연구 방향</h2>
<p>논문에서 제시된 한계점은 다음과 같다: 첫째, VQ-ACE는 특정 로봇 손 플랫폼에 맞춰 학습되었기 때문에, 현재 구현은 정해진 구동 구조(예: 11 DoF Faive 손)에 종속적이다. 즉, 인코더/디코더가 예측하는 행동 시퀀스는 학습할 때 사용된 로봇의 관절 표현에 종속되므로, 다른 종류의 손이나 로봇에 바로 일반화하기 어렵다. 둘째, 본 접근은 주로 피드포워드 동작에 집중하며, 외부 감지 피드백을 별도의 제어기로 처리하는 방식을 취한다. 이로 인해 돌발적인 변화에 대한 적응력에는 한계가 있을 수 있다. 셋째, 사용된 인간 동작 데이터셋의 규모가 비교적 작다. 현재 54분 분량의 자체 수집 데이터로도 유의미한 결과를 얻었지만, 더 대규모의 공개 데이터를 활용하면 일반화 성능을 더욱 향상시킬 수 있을 것이다.</p>
<p>향후 연구 방향으로 저자들은 확장성과 응용 범위 확대를 제안한다. 첫째, 더 다양한 로봇 핸드 및 전신 로봇(humanoid) 등으로 VQ-ACE를 적용하여 일반화 가능성을 검증할 수 있다. 예를 들어 인간 행보 조작(legged locomotion)에도 이와 유사한 벡터 양자화 기법을 적용할 수 있을 것이다. 둘째, 시뮬레이션에서 검증된 방법을 실제 로봇으로 이전하는 연구(시뮬-실제 갭 해소)를 강화할 필요가 있다. 공개된 데이터셋(예: FreiHAND, DexYCB 등)과 고해상도 손 관측 기술을 결합하면, 보다 정교하고 광범위한 VQ-ACE 학습이 가능할 것이다. 마지막으로, VQ-ACE와 다른 형태의 정책 학습 프레임워크(예: 모델 기반 강화학습, hierarchical RL 등)를 결합하여, 더욱 복잡한 작업에도 적용할 수 있는 지능적인 제어 체계를 개발할 수 있다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>