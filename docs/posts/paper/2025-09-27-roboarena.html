<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-09-27">
<meta name="description" content="Distributed Real-World Evaluation of Generalist Robot Policies">

<title>RoboArena 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ef56b68f8fa1e9d2ba328e99e439f80.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-b009f778f5cec7f34f624408a2b5b543.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review">Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review">Detail Review</a>
  <ul class="collapse">
  <li><a href="#주요-기여" id="toc-주요-기여" class="nav-link" data-scroll-target="#주요-기여">주요 기여</a></li>
  <li><a href="#기술적-방법론" id="toc-기술적-방법론" class="nav-link" data-scroll-target="#기술적-방법론">기술적 방법론</a></li>
  <li><a href="#실험-설계-및-결과-분석" id="toc-실험-설계-및-결과-분석" class="nav-link" data-scroll-target="#실험-설계-및-결과-분석">실험 설계 및 결과 분석</a></li>
  <li><a href="#기존-연구와의-비교" id="toc-기존-연구와의-비교" class="nav-link" data-scroll-target="#기존-연구와의-비교">기존 연구와의 비교</a></li>
  <li><a href="#실제-적용-가능성-및-활용-방안" id="toc-실제-적용-가능성-및-활용-방안" class="nav-link" data-scroll-target="#실제-적용-가능성-및-활용-방안">실제 적용 가능성 및 활용 방안</a></li>
  <li><a href="#한계점-및-향후-연구-방향" id="toc-한계점-및-향후-연구-방향" class="nav-link" data-scroll-target="#한계점-및-향후-연구-방향">한계점 및 향후 연구 방향</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">RoboArena 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">vla</div>
    <div class="quarto-category">dataset</div>
  </div>
  </div>

<div>
  <div class="description">
    Distributed Real-World Evaluation of Generalist Robot Policies
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 27, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://arxiv.org/abs/2506.18123">Paper Link</a></li>
<li><a href="https://robo-arena.github.io/">Homepage</a></li>
<li><a href="https://github.com/robo-arena/roboarena">Code Link</a></li>
</ul>
<ol type="1">
<li>🤖 이 논문은 현대의 제너럴리스트 로봇 정책 평가에서 기존 중앙 집중식, 표준화된 접근 방식의 확장성과 다양성 한계를 극복하기 위해 RoboArena라는 새로운 분산형 평가 프레임워크를 제안합니다.</li>
<li>🌐 RoboArena는 분산된 평가자 네트워크가 자유롭게 선택한 다양한 실제 태스크 및 환경에서 정책 쌍을 이중 맹검으로 비교하고, 그 선호도 피드백을 집계하여 정책 성능의 전역 순위를 도출합니다.</li>
<li>📈 7개 기관에 걸친 DROID 로봇 플랫폼에서 600개 이상의 실제 로봇 평가를 통해, 이 접근 방식이 기존 중앙 집중식 평가보다 제너럴리스트 정책의 순위를 더 정확하게 매기면서도 더 확장 가능하고, 복원력이 뛰어나며, 신뢰할 수 있음을 입증했습니다.</li>
</ol>
<hr>
<section id="brief-review" class="level1">
<h1>Brief Review</h1>
<p>본 논문은 현대의 제너럴리스트 로봇 정책(generalist robot policies)을 포괄적이고, 편향되지 않으며, 비교 가능한 방식으로 평가하는 고유한 과제를 다루기 위해 RoboArena라는 새로운 접근 방식을 제안합니다. 기존 로봇 벤치마킹 방식은 고정된 평가 작업 및 환경 지정이나 중앙 집중식 “로봇 챌린지” 주최를 통해 높은 표준화에 의존하여 다양한 작업 및 환경에 걸친 제너럴리스트 정책 평가에 확장하기 어려웠습니다.</p>
<p><strong>핵심 방법론 (Core Methodology)</strong></p>
<p>RoboArena는 분산된 평가자 네트워크를 통해 평가를 크라우드소싱(crowd-source)하는 방식을 제안합니다. 이는 고정된 작업, 환경 또는 위치를 중심으로 평가를 표준화하는 대신, 평가자가 평가할 작업과 환경을 자유롭게 선택할 수 있게 하여 다양성을 쉽게 확장할 수 있도록 합니다. 중요한 점은 평가자들이 두 정책 쌍에 대해 이중 맹검(double-blind) 평가를 수행해야 한다는 것입니다. 평가자는 실제 로봇을 사용하여 두 정책(<span class="math inline">\pi_A, \pi_B</span>)을 동일한 초기 조건(그러나 평가 세션 간에는 자유롭게 변경 가능)에서 순차적으로 실행하고, 다음 세 가지 유형의 피드백을 제공합니다:</p>
<ol type="1">
<li><strong>연속 진행 점수 (continuous progress score)</strong>: <span class="math inline">[0 \dots 100]</span> 범위로, 정책이 작업에서 달성한 최대 진행률에 비례합니다.</li>
<li><strong>이진 쌍대 선호도 레이블 (binary, pairwise preference label)</strong>: 두 정책 중 평가자가 어떤 정책을 선호했는지 나타냅니다.</li>
<li><strong>자유 형식 자연어 설명 (free-form, natural language explanation)</strong>: 선호도에 대한 이유를 설명합니다.</li>
</ol>
<p>이러한 쌍대 비교로부터 얻은 선호도 피드백을 다양한 작업 및 환경에 걸쳐 통합하여 정책 순위를 도출합니다.</p>
<p><strong>글로벌 정책 순위 계산 (Computing Global Policy Rankings)</strong></p>
<p>정책 순위를 계산하기 위해 Bradley-Terry (BT) 모델 [60]을 확장한 방법을 사용합니다. 표준 BT 모델은 모든 쌍대 비교가 동일한 조건에서 이루어진다고 가정하지만, RoboArena의 경우 작업이 다양하게 변하므로 이 가정이 충족되지 않습니다. 따라서 “작업 효과(task-effects)”를 고려하기 위해 BT 모델에 추가 파라미터들을 도입합니다.</p>
<p>확장된 BT 모델은 정책 <span class="math inline">\pi_A</span>가 <span class="math inline">\pi_B</span>보다 선호될 확률 <span class="math inline">p(\pi_A &gt; \pi_B)</span>를 다음과 같이 모델링합니다: <span class="math display"> p(\pi_A &gt; \pi_B) = \sum_{t=1}^{T} \nu_t \cdot \sigma(\theta_A + \psi_{At} - \tau_t) \cdot (1 - \sigma(\theta_B + \psi_{Bt} - \tau_t)) </span></p>
<p>여기서:</p>
<ul>
<li><span class="math inline">N</span>: 정책의 총 개수</li>
<li><span class="math inline">\Pi = \{\pi_1, \dots, \pi_N\}</span>: 정책 집합</li>
<li><span class="math inline">D_p = \{P_{\pi_A, \pi_B}, t\}</span>: 쌍대 선호도 데이터셋. <span class="math inline">P_{\pi_A, \pi_B} \in \{0, 1\}</span>는 이진 선호도를 나타내고, <span class="math inline">t</span>는 A/B 평가가 실행된 작업을 식별합니다.</li>
<li><span class="math inline">\theta = (\theta_1, \dots, \theta_N)</span>: 각 정책 <span class="math inline">\pi_p</span>의 전역 “로그 능력(log-ability)” 파라미터로, 정책의 전반적인 강도를 나타냅니다.</li>
<li><span class="math inline">T</span>: 잠재된 작업 버킷(task buckets)의 수 (하이퍼파라미터).</li>
<li><span class="math inline">\tau = (\tau_1, \dots, \tau_T)</span>: 각 버킷 <span class="math inline">t</span>의 기본 난이도 파라미터.</li>
<li><span class="math inline">\nu = (\nu_1, \dots, \nu_T)</span>: 잠재된 버킷의 한계 작업 확률로, <span class="math inline">\sum_{t=1}^{T} \nu_t = 1</span>을 만족합니다. 이는 주어진 A/B 평가가 잠재된 버킷 <span class="math inline">t</span>에 속할 사전 확률을 정의합니다.</li>
<li><span class="math inline">\psi = ((\psi_{11} \dots \psi_{1T}), \dots, (\psi_{N1} \dots \psi_{NT}))</span>: 정책-작업 오프셋으로, 정책별 작업 난이도를 모델링합니다. 두 정책이 다른 작업 하위 집합에서 다른 상대적 성능 관계를 보일 수 있는 효과를 반영합니다.</li>
<li><span class="math inline">\sigma(z) = 1/(1 + e^{-z})</span>: 로지스틱 시그모이드 함수.</li>
</ul>
<p>모든 파라미터(<span class="math inline">\theta, \tau, \nu, \psi</span>)는 오직 선호도 데이터로부터 최대 우도 추정(maximum likelihood estimation, MLE) 과정을 통해 학습됩니다. 이는 근사 MLE를 위한 기대-최대화(Expectation-Maximization, EM) 알고리즘을 사용하여 수행됩니다. 이 알고리즘은 현재 모델 파라미터 하에서 데이터의 우도를 측정하고, 이 우도의 1차 및 2차 미분을 계산한 후, 클리핑된 뉴턴 업데이트(clipped Newton updates)를 통해 최대화 단계를 수행하고, 새로운 파라미터를 중앙에 배치하여 제로 평균을 유지하는 과정을 반복합니다. Davidson 확장 [63]을 통해 무승부(tie)도 처리할 수 있도록 모델링에 포함됩니다.</p>
<p><strong>정성적 정책 특성 추출 (Extracting Qualitative Policy Characteristics)</strong></p>
<p>정책의 정성적 특성(예: 언어 지시 따르기 능력, 다단계 작업 수행 능력)을 추출하기 위해 대규모 언어 모델(LLMs) 및 시각-언어 모델(VLMs)을 활용합니다. 평가 비디오의 첫 이미지와 해당 작업 지시를 VLM (OpenAI GPT-4.5)에 전달하여 작업 유형(예: pick-place vs.&nbsp;open-close)을 분류하고 장면의 조명, 복잡성, 객체 가시성 등을 설명하도록 합니다. 그런 다음 LLM (OpenAI GPT-4o)을 사용하여 모든 평가에 대한 선호도 주석, 분류 결과 및 자유 형식 평가자 피드백을 요약하여 정책 보고서를 생성합니다. LLM은 다른 정책과 비교하여 성능을 평가하고 언어 피드백에서 정성적 특성을 추출하도록 지시받습니다. 특히, LLM은 보고서의 모든 주장에 대한 증거로 평가 에피소드를 인용하고, 연구자가 주장을 검증할 수 있도록 해당 롤아웃 비디오와 보고서를 자동 연결합니다.</p>
<p><strong>DROID-RoboArena 평가 시스템 (The DROID-RoboArena Evaluation System)</strong></p>
<p>RoboArena는 Franka Panda 7DoF 로봇 팔, Robotiq 2F-85 평행-턱 그리퍼, ZED-mini 스테레오 손목 카메라 및 여러 외부 ZED 2 스테레오 카메라로 구성된 DROID 로봇 플랫폼 [1]에 구현되었습니다. 시스템은 정책 추론 서버(policy inference servers), 평가 클라이언트(evaluation clients), 평가 데이터베이스(evaluation database), 중앙 평가 서버(central evaluation server)의 네 가지 핵심 구성 요소로 이루어져 있습니다. 정책 추론 서버는 모든 정책을 원격으로 호스팅하여 여러 평가자가 자원을 공유하고 클라이언트 측 계산 부담을 줄입니다. 평가 클라이언트는 중앙 서버 및 정책 서버와 통신하며 평가 프로토콜을 안내합니다. 평가 데이터베이스는 모든 평가 결과와 롤아웃 비디오를 저장합니다. 중앙 평가 서버는 평가자에게 정책을 할당하고, 정책 풀의 신규 또는 폐기 정책을 추적하며, 시간 초과 시 평가를 취소합니다.</p>
<p><strong>실험 결과 (Experiments)</strong></p>
<p>7개의 제너럴리스트 DROID 정책(PaliGemma 또는 <span class="math inline">\pi_0</span> 기반 모델)을 사용하여 평가를 수행했습니다. “오라클(oracle)” 정책 순위는 모든 정책을 모든 테스트된 작업에 대해 철저히 평가하고 평균 진행 점수를 비교하여 설정되었으며, 총 4284개의 평가가 사용되었습니다. RoboArena는 기존의 로봇 평가 접근 방식(Pertsch et al.&nbsp;[5]에서 사용된 DROID 평가 절차)과 비교되었습니다.</p>
<p>결과는 다음과 같습니다:</p>
<ol type="1">
<li><strong>정확성</strong>: RoboArena의 쌍대 비교 기반 정책 순위는 Pearson 상관 계수(<span class="math inline">r</span>) 및 MMRV (Mean Maximum Rank Violation) 지표에서 기존 로봇 평가 방식(“Regular”)보다 오라클 순위와 훨씬 더 높은 상관 관계를 보였습니다. 특히, 제안된 작업 인지 순위 접근 방식(“TASK”)이 표준 Elo [61] 또는 Bradley-Terry (“BT”) 모델보다 가장 정확한 순위를 제공했습니다. 진행 점수(“PROG”)를 사용한 순위도 효과적이었지만, 정책 성능에 대한 미묘한 피드백(예: 동일한 진행 점수라도 더 신속하거나 자신감 있는 동작)을 놓칠 수 있습니다.</li>
<li><strong>샘플 효율성 (Sample Efficiency)</strong>: RoboArena는 불과 100개의 쌍대 비교 내에서 고품질 순위에 수렴하며, 이는 기존 로봇 평가 방식과 유사한 수렴 속도를 보이면서도 훨씬 더 정확한 순위를 제공합니다. 더 많은 비교가 수집될수록 순위의 품질은 더욱 향상됩니다.</li>
<li><strong>정성적 통찰력 추출</strong>: VLM을 통한 작업 분류는 약 95%의 정확도를 보였으며, LLM 지원 분석 도구가 생성한 정책 보고서의 비교 주장은 실제 평가 데이터의 승률과 일치하는 것으로 나타났습니다.</li>
</ol>
<p><strong>일반화된 정책의 강점 및 약점 (Strengths and Weaknesses of Generalist Policies)</strong></p>
<p>RoboArena를 통한 광범위한 평가를 통해 현재 제너럴리스트 정책들의 일관된 행동 패턴과 실패 모드가 확인되었습니다. 주요 강점은 다양한 시점, 조명 조건 및 배경에서 작동하는 능력입니다. 직접적인 객체 조작(예: 집어서 놓기, 밀기, 넘어뜨리기, 간단한 열고 닫기)과 관련된 작업은 도구 사용, 천 조작 또는 복잡한 의미론적 이해를 요구하는 작업보다 더 안정적으로 해결됩니다. 특히, 정책들은 목표가 간단하고 시각적으로 기반을 둘 때 더 잘 수행되지만, 정밀한 정렬, 다단계 추론 또는 특정 속성(객체 클래스, 색상) 인식이 필요할 때는 어려움을 겪습니다. 변형 가능한 객체(예: 접기, 덮기) 및 도구를 사용하는 동작(예: 닦기, 퍼내기)과 관련된 작업은 여전히 주요 도전 과제입니다.</p>
<p>정책 계열을 비교할 때, 자동 회귀 정책(autoregressive policies, 예: PG-FAST-DROID, PG-FAST+-DROID, <span class="math inline">\pi_0</span>-FAST-DROID)은 더 정확한 언어 지시 따르기 능력 덕분에 집어서 놓기, 쌓기 및 분류 작업에서 더 높은 성공률을 보였습니다. 확산 기반 정책(diffusion-based policies, 예: PG-flow-DROID, <span class="math inline">\pi_0</span>-flow-DROID)은 미끄러뜨리기 및 닦기와 같은 유연하거나 연속적인 동작 작업에서 잘 수행되지만, 정밀한 언어 지시가 필요한 작업에서는 뒤처지는 경향이 있습니다. 비닝(binning) 정책(예: PG-Bin-DROID)은 거의 모든 작업에서 지속적으로 저조한 성능을 보였습니다.</p>
<p><strong>결론 (Conclusion)</strong></p>
<p>RoboArena는 분산된 평가자 네트워크를 통해 제너럴리스트 로봇 정책을 평가하는 새로운 분산형 프레임워크를 제시합니다. 이는 기존 중앙 집중식 평가 방식보다 더 정확한 정책 성능 순위를 생성하면서도 높은 평가 샘플 효율성을 유지할 수 있음을 보여주었습니다. 또한, LLM 지원 분석 도구를 통해 평가 결과에서 정성적 통찰력을 추출하는 방법도 소개했습니다. RoboArena 평가 프레임워크는 커뮤니티에 공개될 예정이며, 이를 통해 제너럴리스트 로봇 정책의 비교 가능성을 높일 수 있을 것으로 기대됩니다.</p>
<hr>
</section>
<section id="detail-review" class="level1">
<h1>Detail Review</h1>
<blockquote class="blockquote">
<p>RoboArena: 범용 로봇 정책의 분산 실세계 평가</p>
</blockquote>
<section id="주요-기여" class="level2">
<h2 class="anchored" data-anchor-id="주요-기여">주요 기여</h2>
<p>이 논문은 RoboArena라는 분산형 실세계 벤치마크를 제안하여, 기존의 중앙집중식 방식이 아닌 크라우드소싱에 기반한 로봇 정책 평가 방법을 소개한다. RoboArena에서는 평가자가 특정 환경과 과제를 자유롭게 선택하고, 두 개의 정책을 블라인드로 비교 평가(A/B 쌍비교)하여 어떤 정책이 더 우수한지 선호도를 기록한다. 이렇게 모인 선호도 피드백을 Bradley-Terry 모델과 같은 통계적 순위 모형으로 종합하여 정책의 전역 순위를 추정한다. 이 방식의 핵심은 고정된 작업이나 환경에 얽매이지 않고 평가 다양성을 극대화하는 것이다. 기존 벤치마크처럼 과제나 환경을 표준화하지 않고, 여러 평가자가 서로 다른 조건에서 평가에 참여하도록 함으로써, 광범위한 시나리오를 포용하면서도 결과의 공정성과 신뢰성을 확보할 수 있다. 특히 RoboArena는 단순 실험 결과의 순위화뿐 아니라, 언어형 피드백을 분석해 각 정책의 정성적 강약점도 도출한다. 실제 7개 기관의 DROID 로봇 플랫폼을 활용해 600회 이상의 쌍비교(총 4284 에피소드)를 수행한 결과, RoboArena는 기존 중앙집중식 평가보다 범용 정책들의 성능을 더 정확히 순위화함을 보였다. 이 평가 네트워크와 DROID 플랫폼을 오픈소스로 공개하여, 누구나 정책을 제출하고 평가에 참여할 수 있게 하는 것도 중요한 기여이다.</p>
<center>
<img src="../../images/2025-09-27-roboarena/0.png" width="100%">
</center>
</section>
<section id="기술적-방법론" class="level2">
<h2 class="anchored" data-anchor-id="기술적-방법론">기술적 방법론</h2>
<p>RoboArena의 평가 프로토콜은 중앙서버와 분산형 평가자(Client)로 구성된다. 평가자는 중앙 서버에서 무작위로 두 정책을 할당받아 로봇에게 동작을 실행시키며, 정책의 이름 등은 알 수 없게 블라인드로 진행된다. 이때 평가자는 장면을 재배치하고(예: 로봇과 물체의 위치 조정) 언어 지시문으로 새로운 과제를 정의하여, 두 정책을 차례로 실행한다. 실행 후 평가자는 세 가지 피드백을 제공한다: (1) 과제 수행 정도에 따른 진행도 점수(progress score), (2) 두 정책 중 더 나은 정책을 선택하는 선호도(Preference), (3) 선택 이유를 설명하는 자유 서술형 언어 피드백. 쌍비교 데이터는 Bradley-Terry(BT) 모델이나 Elo 모델로 통합 순위를 계산하는 데 활용된다. 논문에서는 표준 BT/Elo 기반의 순위 산출과, 작업 특성을 반영하는 Task-aware 순위기법을 비교한다. 그 결과 작업별 특성 고려하는 방법(TASK)이 가장 정확한 순위를 낸다. 또한 단순히 진행도 평균으로 순위 매기기(PROG)도 꽤 효과적이나, 정책 간 미세한 차이를 놓칠 수 있어 선호도와 함께 병행 보고할 것을 제안한다. 평가 시스템은 원격 호스팅 정책 서버와 클라이언트, 중앙 서버, 데이터베이스로 구성된다. 정책 서버에는 제출된 정책이 올라가 있으며, 여러 평가자가 동시에 사용할 수 있다. 평가 클라이언트는 로봇에 연결된 컴퓨터로, 중앙 서버와 통신하면서 평가 진행 과정을 안내한다. 로봇 현장에는 별도의 추론 연산이 필요 없으므로, 평가자가 로봇이 있는 실험실만 있으면 쉽게 참여할 수 있다. 중앙 서버는 평가 과제 배정 및 데이터 저장을 관리하며, 시간초과된 실험을 자동 종료한다.</p>
<p>정성적 분석을 위해 논문은 비전·언어 모델(VLM)과 대형 언어 모델(LLM)을 활용한다. 먼저 평가 동영상의 첫 프레임과 언어 지시문을 GPT-4o 같은 VLM에 입력해 과제 범주(예: 집기, 열기 등) 및 장면 특성(조명, 난이도 등)을 분류한다. 이어 각 정책에 대해 수집된 선호도와 피드백, 분류 결과를 GPT-3.5o LLM으로 요약 보고서를 생성한다. 이 보고서는 “어떤 상황에서 정책 A가 B보다 낫다/못하다”와 같은 내용을 에피소드 증거와 함께 기술하며, 각 주장의 근거가 되는 실험 영상을 참조로 달아 검증 가능하게 한다.</p>
<p>실험에 사용된 정책들은 DROID 데이터셋에 맞춰 미리 학습된 범용 비전-언어-행동 모델들이다. 구체적으로 PaliGemma 기반 또는 GPT-VLM 기반의 여러 변종(VLA Flow, FAST 등)을 DROID 데이터로 미세조정하여 사용한다. 이들은 모두 out-of-the-box 로 새로운 환경과 과제에서 작동하도록 설계되었다.</p>
</section>
<section id="실험-설계-및-결과-분석" class="level2">
<h2 class="anchored" data-anchor-id="실험-설계-및-결과-분석">실험 설계 및 결과 분석</h2>
<p>실험에는 7개 기관의 DROID 로봇 플랫폼(Frank Panda 7-DoF 팔+2F-85 그리퍼)에서 총 7개 정책을 평가했다. 각정책은 PaliGemma 또는 GPT-4o 기반의 사전학습 모델을 DROID 데이터셋으로 미세조정한 것으로, 대표적으로 flow-DROID, FAST-DROID, PG-FAST-DROID, PG-FSQ-DROID 등 다양한 액션 표현을 사용한다. 실험 데이터 수집에는 총 612회의 쌍비교가 수행되었고, 평가 과정에서의 개별 정책 실행(롤아웃)은 총 4284회에 달한다. 비교 기준으로 “오라클 순위”를 정의했다. 이는 모든 정책을 모든 과제에서 평가한 후 평균 진행도 점수로 얻은 순위로, 실제 완전 탐색 기준의 순위라 볼 수 있다. 오라클을 얻기 위해 각 쌍비교가 끝날 때마다 나머지 정책들도 동일 조건에서 실행해 총 4284회의 성능 점수를 모았다. 기존 방식인 중앙집중식 평가는 Pertsch et al.의 17개 고정 과제 평가 절 차(정제된 환경, 정책당 44 에피소드)를 사용했다.</p>
<p>실험 결과, RoboArena의 분산 쌍비교 방식이 오라클 순위와의 상관관계가 기존 평가보다 유의미하게 높았다. 그림 6에 따르면, 일반 평가(Regular)는 상관계수가 낮게 나온 반면, RoboArena(BT, Elo, TASK) 모두 훨씬 높은 상관관계를 보였다. 특히 Task-aware 방식을 사용한 순위 계산이 가장 정확했으며, 기본 BT나 Elo에 비해 정책 간 세부 성능 차이를 잘 반영했다. 이 결과는 표현력이 풍부한 액션 표현(flow, FAST 등)이 단순 토크나이제이션보다 더 나은 성능을 발휘한 기존 연구 결과와 일치한다.</p>
<p>또 다른 결과로, 진행도 기반 순위(PROG)도 상당히 효과적이었다. 하지만 실험을 통해 평가자는 두 정책에 동일한 진행도 점수를 줄 때도 명백히 하나를 선호할 수 있음이 관찰됐다(예: 더 빠르거나 자신감 있게 행동하는 정책). 따라서 RoboArena는 진행도 점수와 선호도 모두를 함께 사용하는 것이 전체적 정책 비교에 유용함을 시사한다. 한편 샘플 효율성 분석에서는 RoboArena가 약 100회의 쌍비교만으로도 고품질 순위에 수렴함을 확인했다. 이는 기존 중앙집중식 평가가 정책당 44에피소드 수행하는 데 소요되는 정도와 유사한 수준이다. 즉, 분산 평가라도 총 실험 수는 비슷하지만 다양한 환경으로 분산되므로 순위 정확도가 더 높아진다. 쌍비교 횟수가 많아질수록 순위의 품질도 계속 향상되었으며 , 이는 RoboArena가 많은 기여자가 참여할수록 더욱 정밀한 평가가 가능하다는 것을 의미한다.</p>
<p>정성 분석 평가도 진행했다. VLM(예: GPT-4o)을 이용한 과제 분류 결과는 전문가 수동 분류와 95% 일치할 정도로 정확했다. 또한 LLM을 통해 작성된 정책 보고서에는 각 정책의 강·약점이 명확히 기술되었고, 그 근거가 되는 실제 에피소드 비디오 참조도 포함되어 있었다. 전반적으로 RoboArena 평가 데이터는 정책 성능을 정확히 반영했으며, 이를 바탕으로 정책 개발자에게 유용한 통찰을 제공할 수 있음을 보였다.</p>
</section>
<section id="기존-연구와의-비교" class="level2">
<h2 class="anchored" data-anchor-id="기존-연구와의-비교">기존 연구와의 비교</h2>
<p>전통적인 로봇 평가 방법들은 제한된 과제와 환경에 대한 고도로 표준화된 실험을 수행한다. 예를 들어 과제 목록과 장면을 미리 정의하고, 조명, 카메라 위치, 물체 초기 위치까지 엄밀히 통제한다. 이러한 접근은 소수의 정책을 소수의 환경에서 비교하는 데는 유리하지만, 범용 정책처럼 다양한 상황에서 작동해야 하는 모델의 평가에는 부적합하다. Dasari 등은 여러 기관의 결과를 모아 종합 평가를 시도했지만, 각 기관에서 정책을 별도로 재학습해야 했고 적용 환경이 제한적이었다.</p>
<p>반면 RoboArena는 과제나 환경을 고정하지 않고 분산 쌍비교로 순위를 매긴다. 이는 다양한 장면과 과제를 자연스럽게 다루어 검증의 포용성을 높이고, 실험 조건의 완전 일치를 강제하지 않아 로봇 제조 차이나 환경 차이의 영향을 줄인다. 본 논문의 실험에서 확인했듯, 전통적 평가 방식(“Regular”)은 오라클 순위와의 상관이 낮아 일반화된 정책 성능을 신뢰도 있게 반영하지 못했다. 따라서 RoboArena의 분산 평가가 범용 정책 비교에 더 적합함을 제안한다.</p>
<p>한편 OpenX-Embodiment 같은 연구 는 다양한 로봇 플랫폼에서 수집한 대규모 시연 데이터를 통합해 범용 정책 학습을 목표로 한다. 예컨대 RT-X는 여섯 개 이상의 로봇 데이터를 모아 학습하며, 다른 로봇에 긍정적 전이(positive transfer)가 있음을 보였다. 그러나 이러한 연구들은 정책의 학습과 관련된 것으로, 로봇 정책의 성능 평가 방법론을 다루지는 않았다. RoboArena는 이미 학습된 범용 정책을 실제 환경에서 종합 비교하는 데 집중한다는 점에서 차이가 있다. 즉, OpenX나 RT-X가 정책 학습을 위한 데이터와 모델을 제공했다면, RoboArena는 이들 정책의 실질적 성능 검증을 위한 인프라를 제공한다고 볼 수 있다.</p>
<p>또한 최근 발표된 AutoEval(자율 평가 시스템) 연구는 사람의 개입을 최소화한 자동 평가를 제안한다. AutoEval은 특정 로봇(예: WidowX)에서 24시간 자동으로 평가 작업을 돌려, 인간이 채점하는 전통적 방법과 유사한 결과를 얻었다고 한다. RoboArena는 반대로 사람 평가자를 통해 유연성을 확보한다. AutoEval이 설정된 환경에서 완전 자동화를 추구한다면, RoboArena는 여러 기관의 사람이 다양한 환경을 창의적으로 활용하도록 장려한다는 차이가 있다.</p>
<p>종합하면, RoboArena는 기존의 중앙집중형 벤치마크 방식과 Open-X, AutoEval 등의 연구에 비해 평가의 범용성·확장성·신뢰성 측면에서 새로운 대안을 제시한다. 특히 범용 로봇 정책의 성능을 실제 환경의 다양성 속에서 객관적으로 비교하고자 할 때, RoboArena 방식이 적합함을 보여준다.</p>
</section>
<section id="실제-적용-가능성-및-활용-방안" class="level2">
<h2 class="anchored" data-anchor-id="실제-적용-가능성-및-활용-방안">실제 적용 가능성 및 활용 방안</h2>
<p>RoboArena는 로봇 공학 커뮤니티에 공용 평가 플랫폼을 제공함으로써 연구 및 산업에서 활용될 수 있다. 예를 들어 새로운 범용 강화학습 정책이나 대화형 로봇 모델을 개발하는 연구자는, 자신의 정책을 RoboArena 네트워크에 추가해 기존 모델들과 성능을 비교할 수 있다. 이렇게 하면 특정 연구팀 로컬 환경에 한정된 검증을 넘어, 다양한 실제 실험실 환경에서의 성능을 검증하게 된다. 결과적으로 실제 로봇 제품 개발에서도 어느 정도 준비된 정책인지를 판단할수 있는 척도가 된다.</p>
<p>또한 RoboArena는 로봇 제어 및 강화학습 분야의 벤치마크 역할을 할 수 있다. 로봇 제어기 개발자들은 RoboArena로부터 얻은 순위와 피드백을 활용해 어떤 정책 구조(예: 액션 표현)와 학습 데이터가 더 일반화에 유리한지 판단할 수 있다. 예컨대 본 논문에서 시사하듯 복잡한 토크나이제이션 모델이 기존 모델보다 우수하다는 인사이트를 얻을 수 있다. 이는 학습 방식 개선이나 시뮬레이션-실세계 전이 기법 개발에도 중요한 정보를 준다.</p>
<p>커뮤니티 참여성 측면에서, DROID-RoboArena는 로봇이 없는 연구자들도 실세계 정책 평가에 기여할 수 있게 해준다. DROID 데이터셋과 소프트웨어 프레임워크가 공개되어 있으므로, 멀티로봇 데이터로 정책을 훈련시킨 후 RoboArena를 통해 실제 성능을 검증할 수 있다. 결과적으로 데이터 중심의 강화학습 연구와 실제 로봇 적용 사이의 간극을 줄이는 매개체 역할을 할 수 있다. 게다가 RoboArena의 평가 리포트(LLM 기반 약점 분석 등)는 로봇 연구자들에게 구체적 피드백을 제공한다. 단순히 성공률만 알려주는 것이 아니라 “이 정책은 A 과제에서는 잘 수행하지만 B 과제에서는 미숙하다”는 식으로 설명함으로써, 정책 개선 방향을 제시한다. 이런 질적 정보는 예를 들어 잘못된 동작 패턴 개선, 학습 데이터 보강, 알고리즘 선택 등에 활용될 수 있다.</p>
<p>요약하면, RoboArena는 범용 로봇 정책 평가의 표준 인프라로 사용될 수 있으며, 이를 통해 정책 개발자는 현실 세계에서의 성능과 한계를 명확히 파악하여 더 나은 제어 알고리즘을 설계할 수 있다. 또한 산업계에서도 안전·효율적인 로봇 시스템 개발을 위해 RoboArena 결과를 벤치마킹 자료로 활용할 수 있을 것이다.</p>
</section>
<section id="한계점-및-향후-연구-방향" class="level2">
<h2 class="anchored" data-anchor-id="한계점-및-향후-연구-방향">한계점 및 향후 연구 방향</h2>
<p>RoboArena는 분산형 평가라는 강점을 지니지만, 본 연구에는 몇 가지 한계도 있다. 우선 플랫폼 제약이다. 현재 실험은 모두 DROID 로봇 플랫폼(Franka Panda arm)에 기반하였기 때문에, 다른 로봇 형태(cross-embodiment)의 정책까지 평가하는 것은 별도 작업이 필요하다. 예컨대 로봇 손의 관절수나 감각장치가 크게 다른 경우, 동일한 정책을 실행할 수 없거나 평가 기준 자체가 달라질 수 있다. 따라서 향후 연구에서는 다양한 로봇 시스템(예: 모바일 로봇, 드론, 휴머노이드 등)으로 평가 네트워크를 확장하고, 로봇 간 비교 방법을 고안해야 한다.</p>
<p>또한 실험 제어 문제도 있다. RoboArena는 의도적으로 환경 통제를 완화했기 때문에, 개별 변수(예: 조명, 카메라 각도)만 독립적으로 분석하기 힘들다. 이러한 점은 정책의 일반화 성능을 종합적으로 보기에는 이점이나, 특정 조건 변화에 따른 민감도를 연구하기에는 부적절할 수 있다. 따라서 RoboArena 평가 결과는 기존의 표준화된 벤치마크 실험과 상호 보완적으로 사용되어야 한다. 예를 들어 먼저 RoboArena로 정책들을 맥락 없이 비교한 뒤, 성능이 모자란 부분에 대해 별도의 통제된 실험으로 상세 분석하는 접근이 바람직하다.</p>
<p>보안 측면으로는 평가자 악의적 행위 가능성이 있다. 분산된 참여자가 많아지면 일부가 고의로 무작위 평점을 주거나 잘못된 피드백을 줄 수 있다. 논문에서는 RoboArena의 이중맹검 설계가 일부 영향력을 제한한다고 설명하지만, 실제 악의적인 공격에 대한 실험은 이루어지지 않았다. 향후에는 평가자의 신뢰도를 검증하거나 비정상 데이터를 자동 감지하는 메커니즘을 도입하여, 데이터 왜곡에 강한 평가 시스템으로 발전시킬 필요가 있다.</p>
<p>마지막으로 측정 기준의 최적화 문제(Goodhart’s Law)도 고민거리다. 일반지능 벤치마크에서 지표가 연구의 목표가 되면 생기는 것과 마찬가지로, RoboArena 순위 자체가 연구자들에게 최적화 대상이 될 수 있다. 실제로 모델 개선보다는 순위 조작을 시도할 유인이 이론상 존재한다. 현재로서는 범용 정책들의 성능이 아직 제한적이어서 걱정이 덜하지만, 정책 기술이 발전할수록 이 문제도 중요해진다. 이를 방지하기 위해 향후에는 평가 프로토콜을 주기적으로 갱신하거나 새로운 무작위 검증 단계를 도입하는 등 대책 연구가 필요하다.</p>
<p>이러한 한계에도 불구하고, RoboArena는 범용 정책 시대의 새로운 평가 패러다임을 제시한다. 후속 연구는 다른 로봇 플랫폼에의 적용, 평가 보안 강화, 그리고 평가 지표 자체의 견고성 확보 등을 통해 RoboArena를 더욱 발전시킬 수 있을 것이다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>