<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-08-15">
<meta name="description" content="A General Vision-Based Dexterous Robot Arm-Hand Teleoperation System">

<title>📃AnyTeleop 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-bc185b5c5bdbcb35c2eb49d8a876ef70.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-5a614c35f1f90bfd0a5b2992298a8538.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review">Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review">Detail Review</a>
  <ul class="collapse">
  <li><a href="#주요-기여-및-기술적-내용-요약" id="toc-주요-기여-및-기술적-내용-요약" class="nav-link" data-scroll-target="#주요-기여-및-기술적-내용-요약">1. 주요 기여 및 기술적 내용 요약</a>
  <ul class="collapse">
  <li><a href="#지역적-형태-매칭-알고리즘" id="toc-지역적-형태-매칭-알고리즘" class="nav-link" data-scroll-target="#지역적-형태-매칭-알고리즘">지역적 형태 매칭 알고리즘</a></li>
  <li><a href="#다중-단계-최적화-파이프라인" id="toc-다중-단계-최적화-파이프라인" class="nav-link" data-scroll-target="#다중-단계-최적화-파이프라인">다중 단계 최적화 파이프라인</a></li>
  </ul></li>
  <li><a href="#기존-연구와의-차별점-및-비교-분석" id="toc-기존-연구와의-차별점-및-비교-분석" class="nav-link" data-scroll-target="#기존-연구와의-차별점-및-비교-분석">2. 기존 연구와의 차별점 및 비교 분석</a>
  <ul class="collapse">
  <li><a href="#손-모션-리타게팅-분야" id="toc-손-모션-리타게팅-분야" class="nav-link" data-scroll-target="#손-모션-리타게팅-분야">손 모션 리타게팅 분야</a></li>
  <li><a href="#형상-매칭-분야" id="toc-형상-매칭-분야" class="nav-link" data-scroll-target="#형상-매칭-분야">형상 매칭 분야</a></li>
  <li><a href="#접촉-기반-모션-생성-분야" id="toc-접촉-기반-모션-생성-분야" class="nav-link" data-scroll-target="#접촉-기반-모션-생성-분야">접촉 기반 모션 생성 분야</a></li>
  </ul></li>
  <li><a href="#실험-설정-및-결과에-대한-평가" id="toc-실험-설정-및-결과에-대한-평가" class="nav-link" data-scroll-target="#실험-설정-및-결과에-대한-평가">3. 실험 설정 및 결과에 대한 평가</a>
  <ul class="collapse">
  <li><a href="#실험-설정" id="toc-실험-설정" class="nav-link" data-scroll-target="#실험-설정">실험 설정</a></li>
  <li><a href="#성과-지표" id="toc-성과-지표" class="nav-link" data-scroll-target="#성과-지표">성과 지표</a></li>
  <li><a href="#결과-평가" id="toc-결과-평가" class="nav-link" data-scroll-target="#결과-평가">결과 평가</a></li>
  </ul></li>
  <li><a href="#활용-가능성-및-한계점-분석" id="toc-활용-가능성-및-한계점-분석" class="nav-link" data-scroll-target="#활용-가능성-및-한계점-분석">4. 활용 가능성 및 한계점 분석</a></li>
  <li><a href="#결론" id="toc-결론" class="nav-link" data-scroll-target="#결론">결론</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃AnyTeleop 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">teleoperation</div>
    <div class="quarto-category">vision</div>
  </div>
  </div>

<div>
  <div class="description">
    A General Vision-Based Dexterous Robot Arm-Hand Teleoperation System
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 15, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://arxiv.org/abs/2402.04820">Paper Link</a></li>
</ul>
<ol type="1">
<li>✨ 이 논문은 접촉 영역 활용을 통해 다양한 형태와 운동학적 특성을 가진 타겟 손으로 인간의 손-객체 조작 모션을 리타겟팅하는 새로운 프레임워크를 제안합니다.</li>
<li>🛠️ 제안된 방법은 리타겟팅을 비등방성 형태 매칭 문제로 접근하며, 접촉 데이터 전송을 위한 아틀라스 기반 국소 형태 매칭 및 IK를 사용하여 타겟 손 궤적을 생성합니다.</li>
<li>✅ 여러 타겟 손과 다양한 조작에 대한 실험을 통해 이 방법이 효과적이고 예측 가능하며, 디자인 선택 시각화 및 객체 대체와 같은 새로운 기능도 지원함을 보여줍니다.</li>
</ol>
<hr>
<section id="brief-review" class="level1">
<h1>Brief Review</h1>
<p>이 논문은 객체와의 접촉이 풍부한 인간형 조작(contact-rich anthropomorphic manipulations) 동작을 기하학적, 형태학적, 운동학적으로 다양한 타겟 손에 키네마틱 방식으로 리타겟팅(kinematic retargeting)하는 간단하지만 효과적인 프레임워크를 제시합니다. 복잡한 객체 파지(grasps)에 대한 손 모션 캡처 데이터는 비교적 얻기 쉬워졌지만, 이를 특정 캐릭터나 로봇의 손에 리타겟팅하는 기능 없이는 활용도가 제한됩니다. 타겟 손은 기하학, 자유도(DOFs), 손가락 수 등에서 크게 다를 수 있습니다. 저자는 공개 데이터셋에서 가져온 여러 인간 손-객체 조작 데이터를 접촉 영역을 활용하여 다양한 타겟 손에 리타겟팅하는 방법을 제안합니다.</p>
<p>이 프레임워크는 리타겟팅 작업을 비등거리 형상 매칭(non-isometric shape matching) 문제로 공식화하고, 표면 접촉(surface contact) 및 마커 데이터의 조합을 사용하여 역운동학(IK)을 통해 최종 타겟 손 궤적(trajectory)을 점진적으로 추정, 정제, 피팅합니다. 프레임워크의 기반은 새로운 형상 매칭 프로세스 도입으로, 이를 통해 전체 조작 과정에서 접촉 데이터를 예측 가능하고 견고하게 전송할 수 있으며, 아티스트가 비교적 적은 입력으로 대응점(correspondences)을 지정할 수 있는 직관적인 방법을 제공합니다. 저자는 5가지 다른 손 형태와 6가지 객체 조작 동작에 걸쳐 30가지 데모를 통해 프레임워크를 검증하고, 기존 손 리타겟팅 접근 방식과 비교합니다. 또한, 객체 교체(object substitution) 및 전체 궤적에 걸쳐 디자인 선택의 영향을 시각화하는 등 새로운 기능을 시연합니다.</p>
<p>핵심 방법론은 다음과 같은 단계로 구성됩니다:</p>
<ol type="1">
<li><strong>밀집된 접촉 영역 쌍 추출 (Dense Contact Pairing):</strong> 객체와 소스 손 간의 프레임별 밀집된 접촉 영역 세트를 추출합니다. GRAB 데이터셋처럼 한쪽에만 밀집된 접촉 데이터가 있는 경우, 레이캐스팅(raycasting)을 통해 소스 메시 위치에서 법선(normal) 방향으로 추적하여 반대쪽 메시와 교차하는 지점을 찾고, 이를 대응하는 밀집된 쌍으로 생성합니다. 접촉점은 메시의 삼각화(triangulations) 변화에 강건하도록 barycentric coordinates로 저장됩니다.</li>
<li><strong>소스에서 타겟 손으로 접촉 전송 (Procedural Contact Transfer):</strong> 접촉 데이터가 시간 가변적이며 동작 프레임 간에 크게 달라질 수 있다는 점에 착안하여, 대량의(bulk) 접촉 전송을 고유(intrinsic) 비등거리 형상 매칭 문제로 모델링합니다. 핵심 통찰은 대응 관계를 여러 coordinate chart의 아틀라스(atlas)에 의해 제어되는 것으로 공식화하는 것입니다.
<ul>
<li>소스 손 매니폴드(manifold) Ω𝑆의 아틀라스는 <span class="math inline">M</span>개의 chart <span class="math inline">(U_i, \psi_i)</span>로 구성되며, <span class="math inline">\psi_i</span>는 logmap 함수로 <span class="math inline">U_i</span> 영역 내의 접촉점 <span class="math inline">c</span>를 해당 chart의 원점 <span class="math inline">q</span>에 대한 logmap 좌표 <span class="math inline">(r_c, \theta_c)_q</span>로 변환합니다. chart 영역 <span class="math inline">U_i</span>는 서로소(disjoint)입니다.</li>
<li>타겟 매니폴드 Ω𝑇의 아틀라스는 <span class="math inline">(V_i, \psi_i^{-1})</span> 형태로, <span class="math inline">\psi_i^{-1}</span>는 expmap 함수로, <span class="math inline">q_c</span>에서 logmap 좌표 <span class="math inline">(r_c, \theta_c)_q</span>를 갖는 측지선(geodesic)을 추적하여 접촉점을 재구성합니다.</li>
<li>landmark (axial curves에서 추출)를 사용하여 Ω𝑆 상의 각 영역 <span class="math inline">U_i</span>를 결정하고, 각 접촉점에 가장 가까운 landmark를 원점 <span class="math inline">q^*</span>으로 사용합니다 (geodesic Voronoi segmentation과 유사). Vector Heat Method와 MMP를 사용하여 접촉점의 logmap 좌표를 추출합니다.</li>
<li>아티스트가 제공한 axial curves는 landmark 역할을 하며, sparse한 입력으로 여러 landmark를 쉽게 생성하고 조정할 수 있게 합니다. 이는 logmap 0도 각도의 일관된 방향 지정 및 Ω𝑇에서의 대응 landmark 지정을 단순화합니다.</li>
<li>손가락 또는 손바닥 형태/두께 변화를 다루기 위해 expmap scaling metric <span class="math inline">\lambda_s(\theta)</span>를 도입하여 Ω𝑇 상에서 접촉 분포를 변형할 수 있게 합니다. ( <span class="math inline">\psi_i^{-1}</span>는 <span class="math inline">( \lambda_s(\theta)r, \theta )</span> 형태의 측지선을 추적).</li>
<li>손가락 길이 변화를 다루기 위해 axial curve 표현의 측지선 길이를 변경하는 파라미터 <span class="math inline">\lambda_a</span>를 도입합니다. 이는 Ω𝑇 상의 landmark 위치, 즉 <span class="math inline">V_i</span>의 위치를 이동시킵니다.</li>
<li><span class="math inline">\lambda_a</span>와 <span class="math inline">\lambda_s</span>는 아티스트의 한 번의 주석(annotation)에서 얻어지며, 이를 통해 모든 프레임의 접촉 데이터를 소스에서 타겟 손으로 절차적으로 전송합니다.</li>
</ul></li>
<li><strong>타겟 손의 초기 궤적 추정 (Initial Trajectory Estimation):</strong> 가상 마커와 전송된 접촉 정보를 사용하여 타겟 손의 프레임별 초기 궤적 <span class="math inline">\boldsymbol{\Theta}^* = \{ \boldsymbol{\theta}_0^*, \boldsymbol{\theta}_1^*, ..., \boldsymbol{\theta}_F^* \}</span>를 추정합니다. 각 프레임의 추정은 이웃 프레임의 추정치와 독립적으로 이루어지며, 이는 긴 시퀀스에서 오류 누적을 완화하는 데 중요합니다. 최적화 문제(Eq. 3)를 해결하여 각 프레임의 최적 DOF 벡터 <span class="math inline">\boldsymbol{\theta}_f^*</span>를 찾습니다. 목적 함수는 마커 페널티 <span class="math inline">\Gamma_M</span>, 접촉 페널티 <span class="math inline">\Gamma_C</span>, 테이블 페널티 <span class="math inline">\Gamma_T</span>, 및 prior/정규화 페널티 <span class="math inline">\Gamma_J</span>의 가중치 합으로 구성됩니다.
<ul>
<li><span class="math inline">\Gamma_M = \sum_{m=0}^M \Gamma_{MD,m}</span>: 대응하는 가상 마커 점들 간의 <span class="math inline">L_2</span> 거리 합.</li>
<li><span class="math inline">\Gamma_C = \sum_{c=0}^C (\lambda_{cd} \Gamma_{CD,c} + \lambda_{cn} \Gamma_{CN,c})</span>: 대응하는 접촉점 위치 간의 <span class="math inline">L_2</span> 거리 및 접촉점에서의 표면 법선 역전으로부터의 편차 합.</li>
<li><span class="math inline">\Gamma_T = \sum_{s=0}^S \max(0, -\Gamma_{SD,s})</span>: 타겟 손의 샘플링 점(vertex)에서 테이블의 signed distance function (SDF) 값의 합 (음수 값, 즉 침투 방지).</li>
<li><span class="math inline">\Gamma_J = \sum_j \Gamma_{P,j}</span>: DOF <span class="math inline">j</span>와 기존 값(rest pose 또는 이전 키 값) 간의 편차 합.</li>
<li>최적화 해결은 MMA (Method of Moving Asymptotes)와 같은 로컬 그래디언트 기반 솔버를 사용합니다.</li>
<li>궤적 추정은 두 단계로 진행됩니다: 먼저 프레임별로 root joint 위치만 해결하고, 그 다음 root 추정치를 시드로 사용하여 전체 포즈를 해결합니다.</li>
</ul></li>
<li><strong>초기 추정치 정제 (Trajectory Refinement):</strong> 초기 추정된 궤적의 시간적 일관성을 개선하기 위해 유한 가속도(finite acceleration)를 평활화 기준(smoothing metric)으로 사용합니다. 가속도 임계값 E𝑎𝑐𝑐를 위반하는 프레임을 제거하고, 가장 가까운 유효한 좌우 이웃 간의 선형 보간으로 대체한 후 다시 해결합니다. 이 과정은 위반이 더 이상 발견되지 않거나 최대 반복 횟수에 도달할 때까지 반복적으로 수행됩니다. 전처리 단계에서 저대역 필터(low-pass filter)와 피크 제거 필터(peak removal filter)를 적용하여 가속도 위반 수를 줄입니다.</li>
<li><strong>최종 궤적 구성 (Spline Fitting):</strong> 정제된 프레임 솔루션을 샘플 점으로 사용하여 계산된 시계열에 걸쳐 각 DOF에 대해 cubic B-spline을 피팅하여 최종 동작을 복구합니다. 고정된 수의 제어점(control points)을 지정하고 최소 제곱(least squares) 의사 역행렬(pseudo-inverse) 근사를 사용하여 값과 시간상의 위치를 동시에 해결합니다. 이는 <span class="math inline">C^2</span> 연속성을 보장하며, 아티스트가 피팅된 스플라인을 제어하거나 제어점 수를 늘려 더 나은 근사를 얻을 수 있게 합니다.</li>
</ol>
<p>결과 평가에서, 저자는 손-객체, 자체(self), 테이블 침투(intersection)의 양을 정량화합니다. 침투량은 레이캐스팅으로 침투하는 vertex를 찾고, 이를 클러스터링한 후 convex hull 부피를 계산하여 측정됩니다. 결과는 명시적인 침투 해결 절차 없이도 침투 부피가 낮음을 보여주며, 접촉 영역이 자연스러운 파지 상태를 암묵적으로 인코딩하여 물리적인 동작과 침투 최소화에 기여함을 시사합니다.</p>
<p>제안된 방법은 디자인 선택(예: 손가락 길이, DOF 수)이 특정 작업의 동작에 미치는 영향을 시각화하거나, 기존 조작 데모를 다른 객체로 리타겟팅하는 확장 기능을 제공합니다. 객체 대체 시, 새로운 객체의 접촉 세트는 레이캐스팅, 원본 객체 추적, 확산 모델 또는 손 접촉 전송에 사용된 것과 동일한 아틀라스 기반 접근 방식을 통해 생성될 수 있습니다.</p>
<p>기존 접촉 없는 방법(손끝 키포인트 추적, 기능적 포즈 등가(functional pose equivalence))과의 비교를 통해 접촉 정보의 중요성을 검증합니다. 접촉 정보가 없는 방법들은 객체와의 접촉 및 동작 정렬(motion alignment)에 어려움을 겪으며, 특히 소스 및 타겟 손 기하학이 크게 다를 때 아티팩트가 발생합니다. 제안된 방법은 사람의 개입 없이도 양호한 접촉 결과를 제공합니다. Ablation study를 통해 root pre-conditioning 및 접촉 데이터의 필요성을 확인했습니다.</p>
<p>한계점으로는 아틀라스가 불연속적이며 미분 불가능하여 그래디언트 계산이나 부드러운 함수/텍스처와 같은 전역 데이터(global media) 전송에는 부적합하다는 점, 궤적 추정 노이즈 또는 스플라인 피팅으로 인한 흔들림(wobbles)과 같은 아티팩트 가능성이 있다는 점, 테이블 침투 해결이 항상 자연스럽지 않을 수 있다는 점, 형태학적/운동학적 편차가 큰 손(예: Allegro Hand)에 대해서는 효과가 떨어질 수 있다는 점 등이 언급됩니다.</p>
<p>향후 연구로는 현재의 키네마틱 프레임워크에 접촉 동역학(contact dynamics)을 통합하고, 촉각 센싱을 통해 실제 접촉 데이터를 수집하여 역동역학(inverse dynamics)으로부터의 힘 추정 정확도를 높이고 접촉 위치 파악 정확도를 개선하는 방안, 접촉 기반 방법을 강화 학습 및 모방 학습(imitation learning) 분야에 적용하여 정책 학습을 개선하는 방안, 그리고 접촉 데이터의 수집 및 온라인 인식을 통해 실제 환경에서 복잡한 인간-로봇 조작 전송을 가능하게 하는 방안 등을 제시합니다.</p>
<hr>
</section>
<section id="detail-review" class="level1">
<h1>Detail Review</h1>
<blockquote class="blockquote">
<p>Kinematic Motion Retargeting for Contact-Rich Anthropomorphic Manipulations – 심층 리뷰</p>
</blockquote>
<section id="주요-기여-및-기술적-내용-요약" class="level2">
<h2 class="anchored" data-anchor-id="주요-기여-및-기술적-내용-요약">1. 주요 기여 및 기술적 내용 요약</h2>
<p>문제 배경: 이 논문의 연구 대상은 손-물체 상호작용 모션을 다양한 형태의 손(캐릭터 손이나 로봇 손)으로 전달하는 키네마틱 모션 리타게팅 기법이다. 기존에는 사람의 손 동작 데이터를 다른 손 모델에 적용하려 하면 접촉 불일치나 모션 어긋남 등의 문제가 흔했고, 특히 손가락 수나 형태가 다른 경우 그 어려움이 극심했다. 이 논문은 이러한 과제를 해결하기 위해 접촉 영역(contact areas) 정보를 활용한 새로운 프레임워크를 제안한다. 요약하면, 원본 손 동작에서 객체와 손 사이의 접촉 분포(어떤 부위가 언제 물체를 잡고 있는지)를 비등거리(non-isometric) 형태 매칭 문제로 공식화하고, 이를 이용해 대상(hand)의 손으로 동일한 접촉 패턴을 옮긴 뒤, 해당 접촉을 만족하는 손 자세 시퀀스를 계산하는 방식이다.</p>
<p><strong>주요 기여</strong></p>
<p>논문에서 저자들은 두 가지 핵심 기술적 기여를 강조한다:</p>
<section id="지역적-형태-매칭-알고리즘" class="level3">
<h3 class="anchored" data-anchor-id="지역적-형태-매칭-알고리즘">지역적 형태 매칭 알고리즘</h3>
<p>원본 손과 대상 손 사이에 조밀한 접촉 대응(dense contact correspondences)을 얻기 위한 새로운 형태 매칭 기법을 도입하였다. 이 알고리즘은 손바닥과 손가락 표면에 대한 로컬 차트(local chart) 기반 매핑을 활용하며, 비교적 적은 수의 사용자 지정 마커와 곡선(annotation) 입력만으로 두 손의 대응 접촉 지점을 효율적으로 찾아낸다. 구체적으로, 아티스트나 사용자가 원본 손과 대상 손에 소수의 가상 마커(virtual markers)와 축 곡선(axial curves)을 지정하면, 알고리즘이 이를 경계 조건으로 활용하여 손가락/손바닥의 대응 위치를 정의한다. 각 손가락의 축 곡선은 손가락의 중심선을 따라 그려진 곡선으로서, 원본 손의 곡선을 대상 손의 대응 부분으로 옮겨와 지역 좌표계를 생성한다. 이렇게 생성된 좌표계를 통해 원본 손에서 물체에 닿은 접촉점들을 대상 손 표면의 적절한 위치로 절차적 변환(procedural transfer)함으로써, 시간에 따라 변화하는 접촉 분포를 한 손에서 다른 손으로 일관되게 옮길 수 있다. 이 과정은 단발성의 사전 매핑 작업으로 수행되며, 한 번 설정된 대응관계는 전체 모션 시퀀스에 걸쳐 사용된다. 이러한 방법을 통해 손가락 수나 길이가 달라도 접촉 지점들을 논리적으로 대응시킬 수 있고, 소수의 몇개 기준점만 지정하면 복잡한 접촉 분포 전체를 매핑할 수 있다는 점에서 효율적이다.</p>
</section>
<section id="다중-단계-최적화-파이프라인" class="level3">
<h3 class="anchored" data-anchor-id="다중-단계-최적화-파이프라인">다중 단계 최적화 파이프라인</h3>
<p>접촉 매핑 후에는, 다단계 역기구학 최적화를 통해 대상 손의 모션을 생성하는 파이프라인을 제시하였다. 이 키네마틱 리타게팅 파이프라인은 총 5단계로 구성되며, Figure 2에 그 개요가 제시되어 있다.</p>
<ul>
<li>첫째, 원본 손과 물체 사이의 조밀한 접촉쌍 추출(원본 손의 매 프레임 접촉점과 물체 표면점의 1:1 쌍을 추출).</li>
<li>둘째, 앞서 언급한 형태 매핑을 이용해 모든 프레임의 접촉점을 대상 손으로 전달.</li>
<li>셋째, 전달된 접촉점들과 가상 마커를 활용하여 대상 손의 초기 자세 시퀀스 추정 (프레임별 초기 역기구학 해를 계산).</li>
<li>넷째, 연속적인 모션의 자연스러움을 높이기 위해 시간적 일관성 개선을 위한 세부 Refinement(연속 프레임 간 부드럽게 연결되도록 최적화 재조정).</li>
<li>다섯째, 최종적으로 스플라인 곡선 피팅을 통해 모션을 매끄럽게 보간하여 연속적인 최종 궤적을 완성한다.</li>
</ul>
<p>이 파이프라인은 접촉 역학의 보존을 목표로 설계되었기 때문에, 리타게팅 후에도 원본 시연과 동일한 상호작용 기법(예컨대 손가락이 어떤 방식으로 물체를 감싸쥐는지)을 최대한 재현하려 한다. 이를 위해 “모든 손은 동일한 물체 접촉을 공유한다”는 가정을 두어, 다른 손으로 옮길 때도 물체상의 접촉 위치와 순서는 유지되도록 하였다. 기술적 내용 요약: 제안된 방법의 핵심은 접촉 정보를 중심으로 한 모션 재구성이다. 원본 데이터로부터 얻은 손-물체 접촉 분포(시계열 접촉 점들의 집합)를 대상 손으로 옮기기 위해, 저자들은 앞서 언급한 형태 매칭을 통해 원본 손의 각 접촉 지점에 대응하는 대상 손의 접촉 지점을 계산한다. 이렇게 하면 대상 손이 매 시점에 물체의 어느 부위를 접촉해야 하는지가 결정되는데, 이 “목표 접촉 위치”들이 곧 대상 손 모션의 필수 제약 조건으로 활용된다. 다음으로, 이러한 접촉 제약을 만족시키는 대상 손의 관절 자세(q)를 찾기 위해 최적화 문제를 설정한다. 이때 목적함수는 크게 네 가지 페널티 항으로 구성된다:</p>
<ul>
<li>마커 정합 오차 <span class="math inline">E_M</span>: 원본 손과 대상 손의 가상 마커 대응점 사이 거리를 최소화. 마커 <span class="math inline">i</span> (총 <span class="math inline">N_M</span>개)에 대해 두 손의 해당 점 사이 거리 제곱 합으로 정의된다[23]. 이를 통해 비접촉 구간이나 손가락 자세가 애매한 경우에도 원본 손 형태를 모방하도록 유도한다.</li>
<li>접촉 정합 오차 <span class="math inline">E_C</span>: 대상 손의 접촉점이 물체의 대응 접촉 위치에 최대한 일치하도록 하는 항. 대응하는 접촉점 <span class="math inline">j</span> (총 <span class="math inline">N_C</span>개) 사이의 거리 제곱합으로 정의되며, 추가적으로 접촉점에서 법선 방향이 뒤집히지 않도록 (손바닥 표면 법선이 물체 표면 법선과 반대 방향을 향하게) 제약을 주는 항도 포함된다. 즉 손이 물체를 바르게 쥐도록 표면 방향까지 고려한 비용을 더한다.</li>
<li>테이블 충돌 페널티 <span class="math inline">E_T</span>: 손이 받침대나 테이블을 뚫고 지나가는 현상을 막기 위한 항. 손의 표면 샘플링 점들(또는 래핑 메시)이 테이블을 관통하면 해당 지점의 Signed Distance Function(SDF) 값이 음수가 되는데, 이때 그 음수 깊이에 비례한 벌점을 준다[26]. 이를 통해 손이 테이블 위에 놓인 물체를 잡을 때 불필요하게 책상 속으로 들어가지 않도록 한다.</li>
<li>자세 사전(prior) 오차 <span class="math inline">E_P</span>: 모션의 부드러움을 위한 정규화 항으로, 현재 프레임의 관절 각도 <span class="math inline">q</span>가 사전에 정의된 기준 값과 크게 벗어나지 않도록 제어한다. 기준값으로는 초기 프레임에서는 손의 기본 휴식 자세(rest pose)를, 이후 프레임들에서는 직전 프레임의 해(solution)를 사용할 수 있다. 따라서 이 항은 프레임 간 급격한 변화나 노이즈를 억제하여 모션을 안정화시킨다. 전체 최적화 문제는 위 항들의 가중합을 최소화하는 비선형 제약 최적화로 표현된다. 수식으로는 다음과 같다: <span class="math display">\min_{q} \; w_M E_M(q) + w_C E_C(q) + w_T E_T(q) + w_P E_P(q),</span> 단, <span class="math inline">q</span> (대상 손의 모든 자유도 벡터)에 대해 관절 가동 범위 제약 <span class="math inline">q_L \le q \le q_U</span>를 만족시킨다는 조건이 붙는다. 여기서 <span class="math inline">w_M, w_C, w_T, w_P</span>는 각 페널티 항의 가중치 하이퍼파라미터이고, <span class="math inline">E_M, E_C, E_T, E_P</span>는 앞서 정의한 페널티 함수들이다. 이 최적화는 프레임별로 수행되며, 해를 구하기 위해 저자들은 NLopt 라이브러리의 MMA (Moving Maximum Asymptotes) 알고리즘이라는 gradient-based solver를 활용했다. 다만 단순히 각 프레임을 개별 최적화하면 시간적으로 일관된 움직임을 보장하기 어렵다. 그래서 저자들은 이 과정을 세 단계(stage)로 나누어 수행하였다. 1단계에서는 초기 추정치를 얻기 위해 각 프레임별로 위 최적화를 수행하되, 주로 마커/접촉 오차에 집중하면서도 rest pose에 대한 약한 prior를 적용하여 대략적인 모션을 얻는다. 2단계에서는 이렇게 얻은 초기 궤적을 부드럽게 다듬기 위해, 앞의 결과를 prior로 삼아 다시 한 번 최적화를 수행하거나 저속도/저가속도 조건을 적용하여 스무딩 처리를 한다[29]. 마지막 3단계에서는 스플라인 곡선을 이용해 개별 프레임을 연속 곡선으로 피팅함으로써 최종 모션을 완성한다. 이러한 다단계 접근 덕분에 세부 조정 없이도 결과 모션이 부드럽고 자연스럽게 연결된다.</li>
</ul>
<p><strong>한 줄 요약</strong></p>
<p>요컨대 본 논문은 “손-물체 접촉”이라는 풍부한 정보를 매개로 소스(hand)의 조작 동작을 임의의 타겟 손에 옮기는 새로운 파이프라인을 제시하였다. 형상 대응(mapping) → 접촉 이전(transfer) → 역기구학 모션 생성으로 이어지는 이 기법은, 복잡한 동적 시뮬레이션 없이도 다양한 형태의 손에서 높은 품질의 모션 재현을 가능케 하는 점이 특징적이다. 저자들은 이러한 접근이 애니메이션, 로보틱스 등 여러 분야에서 범용적으로 활용될 수 있는 표준화된(hand agnostic) 솔루션이 될 수 있음을 강조하고 있다.</p>
</section>
</section>
<section id="기존-연구와의-차별점-및-비교-분석" class="level2">
<h2 class="anchored" data-anchor-id="기존-연구와의-차별점-및-비교-분석">2. 기존 연구와의 차별점 및 비교 분석</h2>
<p>이 연구는 모션 리타게팅, 형상 매칭, 접촉 기반 조작 생성 세 분야의 관련 선행 연구들과 교차하는 지점에 위치한다. 각 분야에서의 기존 접근법과 본 논문의 방법을 비교하면 다음과 같은 차별점이 드러난다.</p>
<section id="손-모션-리타게팅-분야" class="level3">
<h3 class="anchored" data-anchor-id="손-모션-리타게팅-분야">손 모션 리타게팅 분야</h3>
<p>전신(Full-body) 캐릭터의 모션 리타게팅은 비교적 오랜 연구 역사를 가지며, 관절 대응 기반 기법이 일반적이다 (예: 소스와 타겟의 관절을 일대일 대응시켜 각도를 복사하거나 스케일 조정). 그러나 이러한 전통적 기법을 손에 적용할 때 가장 큰 문제는 접촉 처리이다. 전신의 경우 발이나 물체와 몇 군데 점 접촉을 신경 쓰면 되지만, 손-물체 상호작용은 손가락 여러 개가 동시에 복잡하게 접촉하기 때문에 단순 관절 매핑만으로는 현실감 있는 결과를 얻기 어렵다. 실제로 소수의 접촉점만으로는 손-물체 상호작용의 복잡성을 표현하기에 부족하다는 보고가 있으며, 저자들 역시 “접촉 정보가 없다면 고품질 결과를 낼 수 없다”는 문제의식을 밝히고 있다. 기존 손 리타게팅 접근법 중에는 손가락 관절각을 1:1로 이식하는 직접 관절 매핑이나, 소스 손의 몇몇 특징 점(keypoint) 위치(손끝, 손목 등)를 대상 손 IK로 맞추는 방법 등이 있다. 또한 기능적 포즈 등가성(functional pose equivalence)이라고 하여, 손가락 길이 등이 다를 때는 손가락 위치 사이의 상대 벡터나 거리 분포를 맞추도록 하는 기법도 제안되어 왔다. 이러한 기존 기법들은 손 형태가 유사한 경우에는 쓸만하지만, 손 모양이 많이 다르거나 접촉이 많은 작업에서는 본 논문의 저자들이 지적하듯이 유의미한 아티팩트(부자연스런 동작, 접촉 누락 등)가 발생하는 한계가 있었다. 특히 로봇이나 판타지 캐릭터같이 사람과 형태가 다른 손의 경우, 단순 IK나 관절 매핑으로 생성한 모션은 물체를 헛잡거나 손가락이 어긋나는 등 실패 사례가 많았다.</p>
<p>본 논문은 이 점에서 접촉 자체를 1급 정보로 활용한다는 점이 근본적인 차별화다. 기존의 많은 리타게팅 연구는 접촉을 사후에 보정하거나 물리 시뮬레이션으로 충돌을 처리하는 경우가 많았다. 예컨대, Won &amp; Lee(2019)나 Ryu et al.(2021)은 물리기반 시뮬레이션을 섞어 충돌을 완화하고자 했고, Villegas et al.(2021)은 발접지 vs 자가충돌을 구분하여 최적화하는 등 기법을 제안했지만, 이는 전신 동작의 일부 문제를 다룬 것이지 손처럼 동시에 다중 접촉이 이루어지는 섬세한 조작에는 그대로 적용하기 어려웠다. 반면, 본 연구는 처음부터 접촉 분포를 입력 및 제약 조건으로 삼아 대상 손의 모션을 생성하므로, 애니메이터의 수작업 수정 없이도 접촉 일관성이 보존된 결과를 얻을 수 있다. 실제 실험 비교에서도, 접촉 정보를 빼고 오직 마커 대응만으로 리타게팅을 수행한 경우 문 손잡이를 제대로 잡지 못하고 엉뚱한 자세가 되는 등 초기 단계부터 모션 재구성이 실패함을 보여준다. 특히 인간과 유사성이 낮은 형태의 손일수록 이런 마커 기반 접근의 오류가 더 커지는 반면, 제안 기법은 접촉을 함께 고려함으로써 이런 문제를 극복하였다. 요약하면 “마커+IK” 기반의 전통 접근 vs “접촉+형상대응” 기반의 본 연구로 대비되며, 후자가 월등히 자연스러운 조작 모션을 생성함을 검증하였다.</p>
</section>
<section id="형상-매칭-분야" class="level3">
<h3 class="anchored" data-anchor-id="형상-매칭-분야">형상 매칭 분야</h3>
<p>손의 형상이 사람마다 또는 로봇마다 천차만별이라는 점 때문에, 모션 리타게팅에서 이종 메쉬 간 대응(correspondence) 문제는 중요한 도전과제다. 기존에는 동일 토폴로지(mesh connectivity)를 갖는 캐릭터 간에는 비교적 수월하게 좌표나 관절 변환을 할 수 있었으나, 본 논문처럼 삼지(hand) vs 오지(hand)처럼 기하구조가 다른 경우에는 일반적인 등거리 등각 맵핑 기법을 쓰기 어렵다. 저자들은 관련 분야의 기법을 두 가지로 분류하는데, 하나는 등거리(isometric) 매칭으로서 랩라시안 등 고유 모드가 유지되는 변형(주로 동일 캐릭터 포즈 간 비교)에 적용되는 반면, 다른 하나는 비등거리(non-isometric) 매칭으로 완전히 형태가 다른 두 물체 사이의 대응을 찾는 영역이다. 후자는 난이도가 높아 보통 사용자 입력(랜드마크 포인트나 커브 등)을 받아 부분적 대응을 수립하는 방식을 취한다. 본 논문의 손 형상 매핑 역시 이 비등거리 매칭의 한 사례로 볼 수 있다. 기존 연구들에서도 Takayama et al.(2022), Aigerman &amp; Lipman(2016) 등은 사용자가 지정한 랜드마크나 곡선을 경계 조건으로 주어 맵핑을 푸는 방식을 제안했는데[48], 본 연구는 이러한 접근을 손 접촉 분포에 응용한 셈이다. 특히 축 곡선(axial curve)의 활용은 저자들이 이전 연구(2023)에서 소개한 개념으로, 손가락의 중심 경로를 따르는 곡선을 그려 넣으면 그 곡선에 수직인 방향을 따라서 접촉 점들을 자동 대응시키는 국소 chart를 만들 수 있다. 이를테면 사람 손의 검지와 중지가 물체의 한 면을 잡는 접촉들이 있을 때, 만약 대상 손이 세 개 손가락뿐인 외계인 손이라면, 그 중 두 손가락의 축 곡선을 하나의 대상 손가락 축에 매핑함으로써 “두 손가락 분의 접촉을 하나의 손가락으로 통합”하는 식의 대응도 가능하다. 이러한 유연성은 기존 일반적인 메쉬 매칭 기법들에서는 쉽게 다루지 못하는 부분으로, 본 연구의 형태 매칭 기법이 갖는 실용적 장점이다. 또한 일반적인 비등거리 매핑 연구들은 주로 표면의 텍스처나 기능 맵을 이식하는 용도로 초점을 맞추지만, 여기서는 시간에 따라 변하는 점 집합(접촉 시퀀스)을 일관되게 옮긴다는 새로운 목표에 적용되었다는 점에서도 차별화된다. 저자들은 자신들의 로컬 차트 기반 매칭이 연속된 접촉 정보를 예측 가능하고 견고하게 전달해주며, 소수의 입력으로도 충분히 성능을 낼 수 있음을 강조하고 있다. 이는 기존 방식 대비 아티스트의 작업량을 크게 줄여준다는 실용적 이점도 동반한다.</p>
</section>
<section id="접촉-기반-모션-생성-분야" class="level3">
<h3 class="anchored" data-anchor-id="접촉-기반-모션-생성-분야">접촉 기반 모션 생성 분야</h3>
<p>손 조작에서 접촉 정보를 활용하려는 시도는 이전에도 존재했다. 예를 들어, Brahmbhatt et al.(2019) 등의 연구는 접촉맵(어느 부분이 물체를 만졌는지)을 이용해 로봇 그립을 합성하거나 학습하는 방향을 탐색했고, Pollard 연구진의 초기 작업(Li et al., 2007)은 contact-invariant optimization이라는 개념을 통해 접촉이 유지되도록 하는 제스처 생성을 시도한 바 있다[50]. 그러나 이러한 방법들은 주로 새로운 grasp를 합성하거나 물리 시뮬레이션 맥락에서 접촉력을 고려한 최적화를 한 것이지, 이미 존재하는 특정 모션을 다른 손으로 정밀하게 재현하는 데 초점을 두지는 않았다. 또한 최근 로보틱스 분야에서 인간 시演 동작을 로봇 손 정책으로 학습할 때, 우선 키네마틱 리타게팅으로 시演 궤적을 얻은 뒤 강화학습의 레퍼런스로 사용하는 경우가 많다. 하지만 앞서 언급했듯 표준화된 신뢰성 있는 손 모션 리타게팅 솔루션이 부재하여, 리타게팅이 잘못된 경우 학습까지 실패하거나 이상한 보상 함정에 빠질 수 있다는 문제가 보고되어 왔다. 본 연구는 이러한 흐름에서도 상류 단계의 오류를 최소화할 수 있는 방법으로서, 비록 동적 제어는 사용하지 않지만 접촉 정보를 잘 활용한 키네마틱 솔루션만으로도 상당히 물리적으로 그럴듯한 결과를 낼 수 있음을 보여준다. 실제 결과에서 손-물체 간, 손가락 간 관통 현상(intersection)이 거의 발생하지 않고, 발생해도 부피 기준 몇 퍼센트 미만으로 매우 작았다고 보고하는데, 이는 비록 물리엔진 없이도 접촉 제약을 걸었더니 손가락이 자연스레 물체 표면을 따라 움직이며 겹침을 최소화했기 때문이다. 다시 말해, 접촉 영역 자체가 물리적 구속을 일부 대체하여 모션의 현실감을 높여준다는 것으로 해석할 수 있다. 이러한 접근은 기존의 “사후 물리 시뮬레이션 보정”과 대비되며, 사전 접촉 활용의 효과를 잘 보여준다. 요약하면, 본 논문은 기존 기법들이 간과하거나 부분적으로만 다룬 접촉 정보를 중심에 놓고, 형상 매칭 기술과 결합하여 손 모션 리타게팅 문제를 해결한 점에서 차별성을 지닌다. 이러한 통합 접근으로 인해 얻는 이점은 실험적 비교를 통해서도 분명하게 나타나며 (예: 접촉 미고려 방식의 실패 사례 제시), 이는 곧 본 연구가 동 분야의 새로운 표준 방안을 제시하는 것으로 평가될 수 있다.</p>
</section>
</section>
<section id="실험-설정-및-결과에-대한-평가" class="level2">
<h2 class="anchored" data-anchor-id="실험-설정-및-결과에-대한-평가">3. 실험 설정 및 결과에 대한 평가</h2>
<section id="실험-설정" class="level3">
<h3 class="anchored" data-anchor-id="실험-설정">실험 설정</h3>
<p>저자들은 자신들이 개발한 알고리즘을 검증하기 위해 다양한 형태의 손에 여러 조작 동작을 리타게팅하는 실험을 수행했다. 구체적으로는, GRAB 데이터셋에 포함된 인간 손의 조작 시퀀스 중 6가지 접촉-풍부한 동작(예: 물건 잡기, 문손잡이 돌리기, 망치질, 휴대전화 잡기 등 서로 다른 물체 대상 동작)을 선택하였다. 이 원본 시퀀스의 주체(hand)는 MANO 모델에 기반한 가상의 인간 손으로서 5손가락의 표준 형태다[56]. 그런 다음 타겟 손으로는 총 5가지를 준비했는데, 각각</p>
<ol type="a">
<li>일반적인 다른 인간 손 (형상/비율만 상이),</li>
<li>마녀 손 (가늘고 마디가 긴 판타지 캐릭터 손),</li>
<li>외계인 손 (손가락 3개짜리 비인간형 손),</li>
<li>커스텀 의수 디자인 (손가락 관절 수 일부 제한 또는 특수 형태),</li>
<li>Allegro 로봇 손 (실제 로봇 플랫폼, 4손가락 및 고정된 관절 구조)이다.</li>
</ol>
<p>Figure 1에 이들 손 모습이 제시되어 있으며, 원본 손까지 포함한 6가지 손들이 대비된다. 각 타겟 손 모델에는 사전에 아티스트가 가상 마커와 축 곡선을 설정하여, 원본 손과의 형상 대응 정보를 입력해 두었다. 중요한 것은 이때 손의 형태나 위상 차이가 있더라도 (예: 삼지 vs 오지) 최대한 직관적으로 대응되도록 곡선을 그렸다는 점이며, 필요한 경우 한 손가락에 두 개 이상의 곡선을 대응시켜 여러 손가락의 접촉을 합치는 등의 조정을 했다. 이러한 조정은 부가적으로 가능하지만, 실험 전반에서는 모든 손에 동일한 알고리즘 파라미터와 동일한 설정을 사용하여 결과를 생성했다는 점을 저자들이 강조한다. 즉, 손마다 혹은 동작마다 특별한 미세 조정 없이도 잘 작동하는지를 보기 위해 가중치나 최적화 설정을 일률적으로 적용했고, 그럼에도 불구하고 전반적으로 양호한 결과가 얻어졌다고 보고하고 있다.</p>
</section>
<section id="성과-지표" class="level3">
<h3 class="anchored" data-anchor-id="성과-지표">성과 지표</h3>
<p>실험 결과는 정량 평가와 정성 평가로 나뉘어 제시되었다. 정량적으로는, 리타게팅된 모션에서 발생한 교차/충돌 정도를 측정하였다. 구체적으로 손-물체 간의 관통(손이 물체를 지나치게 파고든 경우), 손 자체의 자기 관통 (손가락 끼리 겹침), 그리고 손-테이블 간의 충돌(예: 물건을 집기 위해 테이블에 손이 박히는 경우) 세 가지를 계산하였다. 계산 방법은 각 결과 모션에서 손 메시에 대해 레이캐스팅을 수행하여 물체나 자기 자신과 겹친 부분의 볼륨을 클러스터 단위로 산출한 다음, 그것을 손 전체 부피 대비 백분율로 표현하는 방식이다. 이러한 방식으로 30개 모든 사례(5손 * 6동작)에 대해 평균적인 관통 비율을 구한 결과, 손-물체, 자가 충돌, 테이블 충돌 모두 대체로 극소수 퍼센트 이하로 측정되었다고 한다. Figure 10에서 각 사례별 수치를 그래프로 보여주는데, 전반적으로 아무런 후처리 없이도 충돌이 거의 발생하지 않는 안정적인 모션이 생성되었음을 알 수 있다. 이는 본 방법이 명시적으로 물리 충돌 회피 최적화를 하지 않았음에도 접촉 제약을 통해 암묵적으로 현실성을 확보했음을 시사한다. 저자들은 “접촉 영역 자체가 자연스러운 파지(grasp) 상태를 암묵적으로 인코딩하기 때문에, 물리 시뮬레이션 없이도 충돌 최소화에 효과를 보였다”라고 해석하고 있다.</p>
<p>정성 평가 측면에서, 최종 생성된 모션들의 시각적 품질을 사람의 눈으로 평가하였다. 저자들은 모든 결과 모션의 동영상을 부록으로 제공하였고, 논문 내 Figures 11-13 등을 통해 몇 가지 흥미로운 사례를 캡쳐하여 보여준다. 예를 들어, 손가락 길이 설계 변화 실험에서, 원본 디자인의 엄지 길이로는 손전등의 스위치에 도달하지 못하지만 엄지를 약간 길게 설계한 수정안은 충분히 스위치에 닿는 동작을 구현해낸 모습을 Figure 11에서 볼 수 있다. 이는 동일한 접촉 시퀀스를 사용했을 때 손가락 길이에 따라 과제 수행 가능 여부가 어떻게 달라지는지를 잘 보여주는 사례다. 또 다른 예로, 외계인 손(3손가락)에게 스마트폰을 쥐는 인간 손 모션을 리타게팅할 때, 기본적으로는 세 손가락에 인간의 다섯 손가락 접촉을 분배하도록 곡선을 그렸지만, 이를 다르게 설정해보는 실험도 했다. Figure 12에는 한 손가락에 두 개의 축 곡선을 할당하여 인간의 검지+중지 역할을 외계인의 하나의 손가락이 수행하도록 매핑한 경우를 보여주는데, 그 결과 다소 독특한 “스팍(Vulcan) 경례” 모양 비슷한 파지 형태가 나왔음을 볼 수 있다. 이러한 대안적 매핑도 가능하다는 것은 본 프레임워크의 융통성을 나타내며, 상황에 따라 사용자가 접촉 대응을 의도적으로 조정해볼 수 있음을 시사한다.</p>
<p>또한 객체 치환(Object substitution) 실험으로서, 원본의 사과를 건네주는(hand-off) 동작을 감자 객체로 바꿔서 리타게팅하는 예를 시도했다. 이때는 물체 형태도 달라지기 때문에 원본 사과 표면의 접촉 분포를 감자 모델에 옮겨야 하는 추가 단계가 있었다. 저자들은 이를 위해 레이캐스트 기반의 접촉 전이 방식을 활용했다고 한다. 즉 원본 손-사과 접촉점에서 사과 표면 법선 방향으로 광선을 쏴 감자 표면과 교차하는 지점을 찾고, 그 지점을 대상 접촉점으로 삼아 전 프레임에 걸쳐 접촉 시퀀스를 변환한 것이다. 이러한 기법을 통해 새로운 객체에 대해서도 손의 파지가 적응하도록 만들 수 있었으며, Figure 13과 부록 영상에서 감자로 바뀐 상황에서도 손가락들이 미세하게 위치를 조정하며 사과를 쥘 때와 유사한 동작을 수행하는 것을 확인할 수 있다.</p>
</section>
<section id="결과-평가" class="level3">
<h3 class="anchored" data-anchor-id="결과-평가">결과 평가</h3>
<p>전체적으로 30개의 리타게팅 결과는 높은 품질을 보여주었으며, 저자들은 특히 놀라운 점으로 단일 파라미터 셋으로 모든 손과 동작에 대응했다는 점을 들고 있다. 이는 본 기법의 일반화 성능을 뒷받침하는 것으로, 특정 케이스별로 가중치를 재튜닝하거나 하지 않고도 다양한 형태에 잘 적용되었음을 의미한다. 물론 몇 가지 한계 사례도 관찰되었다고 한다. 예를 들어, 마녀 손처럼 손가락이 매우 길고 가느다란 손의 경우, 테이블 위에 놓인 물체(예: 스테이플러)를 집을 때 손가락이 과도하게 뒤틀리거나 어색한 포즈를 잠깐 취하는 현상이 있었다. 이는 테이블 관통을 피하려는 제약과 긴 손가락의 자유도가 맞물리며 발생한 현상으로, 저자들은 이럴 경우 특정 관절을 고정하거나 하는 추가 처리로 완화할 수 있다고 언급한다. 또한 Allegro 로봇 손처럼 크기가 매우 크고 자유도가 제한된 손의 경우, 사람 손의 접촉 분포를 그대로 맞추려 하면 자기 손가락끼리 부딪히는 경우가 상대적으로 늘어났다. 예컨대 Allegro 손은 사람보다 덩치가 크다 보니 동일한 물체를 쥘 때 손가락 간섭이 증가하고, 또 두 마디(knuckle)밖에 없는 손가락으로 다섯 손가락의 섬세한 움직임을 흉내내려니 어려움이 있었다는 것이다. 이러한 경우는 애초에 원본 인간의 접촉 패턴을 100% 고수하는 것이 적절하지 않을 수도 있다고 저자들은 지적한다. 즉, 타겟 손이 원본 손과 상호작용 방식 자체가 달라야 하는 상황(예: 사람은 물건을 주로 쥐지만, 특정 로봇 손은 집는 방식이 다를 때)이면, 접촉 분포도 그에 맞게 조정되어야 하는데 본 연구는 거기까지는 다루지 못했다는 것이다. 이런 부분은 향후 연구로 남아있지만, 그 밖의 범위에서는 전반적으로 일관되게 성공적인 결과를 보였다고 평가할 수 있다. 한편, 비교 평가로서 기존 기법(베이스라인)과의 차이를 보여준 것도 주목할 만하다. 앞서 설명한 접촉 미고려 마커기반 리타게팅 실험에서, 문손잡이를 돌리는 시나리오의 경우 접촉 정보를 사용하지 않은 모션은 손가락이 손잡이를 정확히 파지하지 못하고 헛도는 장면이 연출되었다. 반면 제안 기법은 동일 프레임에서 손가락이 정확히 손잡이 표면을 따라 밀착되어 회전하는 모션을 보여준다. 이 비교는 정 kiepoint기반 접근의 한계를 극명히 보여주는 사례로, 논문의 Figure 19에 해당 장면이 제시되어 있다. 이러한 결과를 통해 저자들은 “접촉 정보 없이는 손-물체 상호작용 모션의 섬세함을 재현하기 어렵다”는 주장을 실험적으로 입증하였다. 종합하면, 본 논문의 실험은 제안 기법의 범용성, 정확성, 품질을 다각도로 확인한 것으로 볼 수 있다. 다양한 손과 동작에의 적용 결과, 별다른 튜닝 없이도 물리적 개연성이 높고 접촉이 잘 유지된 모션을 얻었으며, 이는 현시점 공개된 손 리타게팅 기법 중 가장 철저한 검증 사례 중 하나로 평가할 만하다. 물론 제한적인 어려움도 관찰되었지만, 그에 대한 논의도 솔직히 제시되어 있어 연구의 신뢰도를 높여준다.</p>
</section>
</section>
<section id="활용-가능성-및-한계점-분석" class="level2">
<h2 class="anchored" data-anchor-id="활용-가능성-및-한계점-분석">4. 활용 가능성 및 한계점 분석</h2>
<p><strong>활용 가능성</strong></p>
<p>이 연구의 성과는 여러 분야에 걸쳐 응용될 수 있다. 우선 컴퓨터 애니메이션/게임 제작 분야에서, 사람의 손 동작 캡처 데이터를 다양한 캐릭터에 재사용하는 데 큰 도움을 줄 수 있다. 예를 들어, 영화나 게임에서 인간 캐릭터가 물체를 다루는 모션을 판타지 생물이나 독특한 프로포션의 캐릭터에게 옮길 때, 지금까지는 애니메이터가 일일이 손가락 위치를 조정해야 했지만 본 기술을 활용하면 상당 부분 자동화하여 제작 비용과 시간을 절약할 수 있을 것으로 기대된다. 저자들도 실제 아티스트가 본 시스템을 활용하여 몇 개의 축 곡선만 그려넣음으로써 다수의 모션을 손쉽게 변환할 수 있음을 보였고, 이러한 인터페이스는 창작 파이프라인의 생산성을 높일 수 있다. 또한 VR/AR 및 텔레프레젠스 영역에서도 응용 가능성이 있는데, 예컨대 VR 챗이나 원격 로봇 조작에서 인간 사용자의 손 동작을 가상 아바타의 손이나 원격 로봇 손으로 실시간(또는 준실시간) 리타게팅하는 데 활용할 수 있다. 현재 제안 기법은 오프라인 배치 처리를 가정하고 있고 몇 시간의 계산을 필요로 하지만, 만약 최적화 알고리즘을 개선하거나 하드웨어 가속을 도입하면 속도를 높일 여지가 있다. 기본 원리는 그대로 두고 속도만 개선한다면, 풍부한 접촉 기반의 정확한 제스처 매핑이 실시간 상호작용에도 사용될 수 있을 것이다.</p>
<p>로보틱스 및 휴먼-로봇 상호작용 측면에서도 본 연구는 큰 시사점을 준다. 로봇 손의 설계자나 연구자는 사람의 시연 동작을 로봇 손으로 따라해보며 그 로봇 손의 조작 잠재력을 평가하고 싶어 한다. 본 방법을 쓰면, 굳이 복잡한 강제 제어나 학습 없이도 인간 데이터셋(GRAB 등)의 풍부한 시나리오를 로봇 손으로 가상 시험(test)해볼 수 있다. 예컨대 어떤 물체를 잡는 데 로봇 손가락 길이가 충분한지, 관절 배치는 적절한지 등을 접촉 분포만으로도 알아볼 수 있다. 논문에서 보여준 엄지 길이 사례는 바로 손 설계 평가 시각화의 좋은 예이다 – 설계안 A와 B의 엄지 길이에 따라 특정 작업(스위치 누르기)의 성공 여부가 리타게팅 결과로 명확히 드러났기 때문이다. 이러한 기능은 의수나 로봇 손 개발자가 디자인 단계에서 피드백을 얻는 도구로 활용될 수 있다. 뿐만 아니라, 이미 언급했듯 강화학습이나 모션 프리미티브 학습 전에 전문 시演 궤적을 생성하는 용도로도 쓰일 수 있다. 인간 데이터로부터 바로 로봇 정책을 학습하기 어려운 경우, 본 기법으로 로봇 형태에 맞춘 전문가 궤적(expert trajectory)을 만들고 이를 학습 초기화나 보상 설계에 활용하면 학습의 안정성과 속도를 높일 잠재력이 있다. 저자들도 이러한 방향 (접촉정보가 정책 학습에 도움을 줄지)에 큰 관심을 보이며 향후 연구를 제안하고 있다. 또 다른 흥미로운 응용은 의료 재활 또는 인간공학 분야다. 서로 다른 손 구조를 가진 사람들이나 환자의 의수에 대해, 동일 작업을 수행할 때의 운동 패턴 차이를 분석하는 연구에 본 기술을 활용할 수 있을 것이다. 예를 들어 특정 동작에서 손가락이 어떤 식으로 적응하는지, 불편함이 생기는지 등을 가시화함으로써 인체공학적 디자인 개선에 아이디어를 줄 수 있다.</p>
<p><strong>한계점</strong></p>
<p>그럼에도 불구하고, 이 접근법에는 몇 가지 제약과 한계가 존재한다.</p>
<p>우선, 순전히 키네마틱한 방법이라는 점이다. 동역학적인 힘이나 마찰 고려는 없고, 오직 기하학적 접촉과 위치 기반으로 모션을 만들기 때문에 실제 물체 무게를 지탱하는 힘 조절이나 미끄러짐 방지 같은 요소는 다루지 못한다. 이는 애니메이션에는 문제가 없지만, 실제 로봇에 이 궤적을 그대로 실행하면 물체를 놓칠 수 있다는 뜻이기도 하다. 향후에는 접촉력까지 고려한 동적 확장이 필요하며, 저자들도 이를 다음 과제로 언급하였다. 다만 현 단계에서는 신뢰성을 위해 동역학을 배제했다고 하며, 이는 “일관된 결과를 얻기 위한 선택”이었음을 강조한다. 두 번째로, 데이터 의존성의 문제가 있다. 본 기법은 충분히 정확한 접촉 정보가 주어질 때를 가정한다. GRAB 같은 데이터셋은 모캡과 보정된 시뮬레이션으로 접촉을 추정했지만, 완벽하지 않을 수 있다. 실제 물리에서의 접촉은 마찰, 접촉면 압력 등 다양하게 정의되는데, 현재의 접촉 데이터는 주로 거리 기반으로 “0/1 접촉”만 표시하는 수준이다. 이 때문에 접촉 위치가 살짝 어긋나거나, 힘이 가해지는 면적과 달라질 수 있다. 저자들은 향후 촉각 센서 등을 활용하여 보다 정확한 접촉+힘 데이터를 얻고, 이를 통해 접촉 기반 리타게팅을 한층 개선할 수 있을 것으로 보고 있다. 현실 세계에서 센서를 통한 접촉 수집이 가능해진다면, 본 기법의 실용성은 더욱 높아질 것이다. 세 번째 한계는 형상 매핑의 불연속성이다. 앞서 말한 축 곡선 기반 매핑은 손을 몇 개의 구획으로 나눠서 각각 매핑하는 아틀라스(atlas) 방식인데, 이 결과 얻어지는 대응 맵은 엄밀히 말해 연속적이지 않고 미분 불가능하다. 이는 현재 접근에서는 큰 문제가 아니지만, 만약 향후 이 매핑 자체를 최적화 변수로 삼아 뭔가 해보고 싶을 때(예: 접촉을 부드럽게 이동시키거나 텍스처를 옮기거나) 제약이 될 수 있다. 하나의 이상적인 전역 매핑 함수를 만들 수 있다면 접촉 이외의 부가 정보도 함께 전이하거나, 그라디언트를 활용한 최적화도 가능해질 것이므로, 저자들은 연속체 매핑으로의 개선 여지를 언급하고 있다. 네번째로, 모든 경우에 접촉 유지가 최선은 아닐 수 있다는 점이다. 앞서 실험 결과 논의에서 언급했듯이, 타겟 손이 소스 손과 지나치게 형태나 동작 양식이 다르면 차라리 접촉 패턴을 조정하는 편이 나을 수 있다. 예를 들어 사람은 물건을 다섯 손가락으로 감싸쥐지만, 어떤 로봇은 두 손가락 집게로 집을 수 있다면 굳이 다섯 군데 접촉을 흉내낼 필요는 없을 수 있다. 그러나 본 방법은 일단 “원본과 동일한 접촉을 모두 재현”하는 방향으로 최적화를 하므로, 때론 부자연스럽거나 비효율적인 동작이 나올 위험이 있다. 이를 방지하려면 어떤 접촉은 포기하거나 대체 전략을 취할 수 있어야 하는데, 이러한 의사결정은 현재는 사람이 축 곡선을 그릴 때 수동으로 해줘야 한다 (예: 불필요한 손가락 곡선을 안 그리면 해당 손가락 접촉은 무시됨). 향후에는 AI가 자동으로 “이 손에는 이 접촉은 생략하자” 또는 “대상 손에 맞게 접촉 분포를 수정하자”를 결정해주면 더 지능적인 리타게팅이 될 것이다. 이는 한계임과 동시에 발전 가능성이라 볼 수 있다. 마지막으로, 연산 비용과 실용성 측면의 한계도 짚고 넘어가야 한다. 논문에 따르면 본 모션 한 시퀀스(数百 프레임 내외)를 리타게팅하는 데 4시간에서 최대 22시간까지 걸렸다고 한다. 대부분의 시간은 수치 최적화에서 유래하는데, 특히 현재 구현은 유도된 그라디언트가 아니라 유한 차분으로 경사를 구해 느리다고 한다. 물론 이는 연구 프로토타입 수준이기에 최적화 여지가 있지만, 상용 툴로 쓰려면 속도 개선이 필수적이다. 병렬처리나 GPU 활용, 또는 분석적 그라디언트 도출 등을 통해 이 시간을 대폭 줄이는 것이 과제다. 또한 아티스트의 작업 측면에서도, 축 곡선과 가상 마커를 손마다 설정해야 하는 수고가 있다. 다행히 논문에서는 이 작업이 상대적으로 적은 편이고 한번 설정한 뒤 여러 모션에 재사용할 수 있다고 언급하지만, 그래도 완전 자동은 아니라는 점에서 초기 세팅 비용이 존재한다. 그러나 이 부분은 현재의 거의 모든 비등거리 매핑 기법들이 갖는 공통점이므로, 본 연구만의 단점이라기보다는 향후 사용자 부담을 줄여야 할 연구과제일 것이다.</p>
</section>
<section id="결론" class="level2">
<h2 class="anchored" data-anchor-id="결론">결론</h2>
<p>Kinematic Motion Retargeting for Contact-Rich Anthropomorphic Manipulations 논문은 접촉을 매개로 한 손 모션 리타게팅의 새 지평을 연 연구로 평가된다. 주요 기여인 형태 매칭 알고리즘과 최적화 파이프라인을 통해, 다양한 손 모델 간에 복잡한 조작 동작을 높은 충실도로 전이할 수 있음을 보였다. 실험을 통해 그 효과와 한계를 균형 있게 제시하였으며, 특히 접촉 정보의 중요성을 부각시켜 관련 커뮤니티에 유의미한 통찰을 제공한다. 향후 이 기법에 물리적 동역학을 접목하거나 학습 분야에 응용한다면, 인간→로봇 복잡 조작 전이와 같은 난제도 해결하는 방향으로 발전할 가능성이 크다. 요약하면, 본 연구는 손 모션 리타게팅의 표준화된 신뢰성 있는 해법을 제시함과 동시에, 향후 확장될 수 있는 다양한 응용 시나리오를 제시했다는 점에서 의의가 크다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>