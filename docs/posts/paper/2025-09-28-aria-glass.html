<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-09-28">
<meta name="description" content="Project Aria - A New Tool for Egocentric Multi-Modal AI Research">

<title>📃Aria Gen 1 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ef56b68f8fa1e9d2ba328e99e439f80.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-b009f778f5cec7f34f624408a2b5b543.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>


</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review">Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review">Detail Review</a>
  <ul class="collapse">
  <li><a href="#기술적-기여와-한계-분석" id="toc-기술적-기여와-한계-분석" class="nav-link" data-scroll-target="#기술적-기여와-한계-분석">기술적 기여와 한계 분석</a></li>
  <li><a href="#기존-연구와의-차별점-비교" id="toc-기존-연구와의-차별점-비교" class="nav-link" data-scroll-target="#기존-연구와의-차별점-비교">기존 연구와의 차별점 비교</a></li>
  <li><a href="#연구-구성-및-실험-설계에-대한-평가" id="toc-연구-구성-및-실험-설계에-대한-평가" class="nav-link" data-scroll-target="#연구-구성-및-실험-설계에-대한-평가">연구 구성 및 실험 설계에 대한 평가</a></li>
  </ul></li>
  <li><a href="#reference" id="toc-reference" class="nav-link" data-scroll-target="#reference">Reference</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃Aria Gen 1 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">aria</div>
    <div class="quarto-category">glasses</div>
    <div class="quarto-category">meta</div>
  </div>
  </div>

<div>
  <div class="description">
    Project Aria - A New Tool for Egocentric Multi-Modal AI Research
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 28, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://arxiv.org/abs/2308.13561">Paper Link</a></li>
<li><a href="https://www.projectaria.com/">Homepage</a></li>
</ul>
<ol type="1">
<li>✨ Project Aria는 Meta Reality Labs Research에서 미래 증강 현실(AR) 기기를 위한 컨텍스트 인식 및 개인화된 AI 연구를 가속화하기 위해 개발한 egocentric 다중 모드 데이터 기록 및 스트리밍 장치입니다.</li>
<li>👓 이 안경 형태의 장치는 다양한 카메라, IMU, 마이크 등을 포함하는 풍부한 센서 스위트를 갖추고 있으며, 녹화 데이터를 처리하고 시각화하기 위한 소프트웨어 도구와 머신 퍼셉션 서비스(MPS)를 제공합니다.</li>
<li>💡 Project Aria는 현실 세계의 생태학적으로 유효한 데이터를 수집하여 egocentric AI 연구의 데이터 부족 문제를 해결하고, 장기 매핑, 객체 상호작용, 활동 인식 등 다양한 응용 분야를 가능하게 하며, 사용자 및 주변인의 프라이버시를 보호하는 원칙을 강조합니다.</li>
</ol>
<hr>
<section id="brief-review" class="level1">
<h1>Brief Review</h1>
<p>본 논문은 Meta Reality Labs Research에서 개발한 Project Aria 디바이스를 소개하며, 이는 미래 증강 현실(AR) 기기에서 예상되는 egocentric, multi-modal 데이터 기반 AI 연구를 촉진하기 위한 도구입니다. 현재 AI 모델들이 주로 allocentric 2D 데이터에 최적화되어 egocentric 3D/4D 공간 추론 및 이해에 취약하다는 한계를 지적하며, Project Aria가 이러한 간극을 메우고 상황 인지적이고 개인화된 AI의 발전을 목표로 합니다.</p>
<p>Project Aria 디바이스는 안경 형태의 데이터 캡처 시스템으로, 장시간 착용 가능할 만큼 가볍고 눈에 띄지 않아 생태학적으로 유효한 데이터를 수집할 수 있습니다. 이 기기는 미래 AR 안경에 필요한 센서 스택을 모방하여 기계 인식을 위한 풍부한 multi-modal 센서 스위트를 통합합니다.</p>
<p>핵심 방법론 및 센서 구성은 다음과 같습니다:</p>
<ol type="1">
<li><strong>Mono Scene Cameras</strong>: 좌우에 위치한 2개의 흑백 글로벌 셔터 카메라로, 640x480 해상도, 150° 수평 시야(HFOV), Fisheye (F-Theta) 렌즈를 사용하여 Visual SLAM 등 기계 인식을 지원합니다.</li>
<li><strong>Point of View (POV) RGB Camera</strong>: 2880x2880 최대 해상도, 롤링 셔터 RGB 카메라로 110° HFOV와 약 4° 아래로 향하는 경사각을 가집니다.</li>
<li><strong>Eye Tracking Cameras</strong>: 2개의 흑백 글로벌 셔터 눈동자 추적 카메라로 320x240 해상도와 80° 대각선 시야(DFOV)를 제공합니다.</li>
<li><strong>IMUs (Inertial Measurement Units)</strong>: 2개(좌우 각 1개)의 가속도계 및 자이로스코프로, 좌측은 800 Hz, 4g, 500°/s, 우측은 1000 Hz, 8g, 1000°/s 사양을 가집니다. 서로 다른 모델을 사용하여 고차 오차 행동의 상관관계를 줄였습니다.</li>
<li><strong>Microphones</strong>: 7개의 마이크 배열로 24비트, 최대 48 kHz의 공간 오디오를 캡처합니다.</li>
<li><strong>Magnetometer</strong>: 3축 자기장 센서로 0.1 μT 해상도, 10 Hz 샘플링 레이트를 가집니다.</li>
<li><strong>Barometer &amp; Thermometer</strong>: 압력 및 온도 센서로 각각 0.66 Pa 및 0.005° C 해상도, 50 Hz 샘플링 레이트를 가집니다.</li>
<li><strong>GNSS receiver</strong>: GPS 및 Galileo를 지원하며 1 Hz로 위도/경도/고도 솔루션을 제공합니다.</li>
<li><strong>Wi-Fi &amp; Bluetooth transceiver</strong>: Wi-Fi 및 Bluetooth 비콘의 수신 신호 강도(RSSI)를 0.1 Hz로 기록합니다.</li>
</ol>
<p>모든 센서 스트림은 고도로 보정되고 시간 정렬되어 하류 기계 인식 작업의 복잡성을 줄입니다. 센서 설정은 전력 및 대역폭 제약과 프라이버시를 고려하여 기록 프로파일을 통해 유연하게 구성할 수 있습니다. 또한, 디바이스 내 센서들은 마그네슘 프레임에 장착되어 높은 강성을 유지하며, 제조 시점에 측정된 공장 캘리브레이션 파라미터와 함께, 착용 중 발생하는 변형을 반영하는 보다 정확한 온라인 캘리브레이션 파라미터가 Machine Perception Services (MPS)를 통해 제공됩니다.</p>
<p>데이터 기록 및 활용을 위한 소프트웨어 도구로는 모바일 컴패니언 앱을 통해 기록 시작/중지 및 센서 구성이 가능하며, 기록된 데이터는 USB 연결을 통해 로컬 머신으로 다운로드하거나 MPS에 업로드하여 처리할 수 있습니다. 모든 센서 데이터는 VRS (Versatile Recording Stream) 파일 형식으로 저장되며, Project Aria tools 오픈 소스 저장소를 통해 데이터 접근, 시각화 및 조작 라이브러리가 제공됩니다.</p>
<p>Machine Perception Services (MPS)는 Project Aria 디바이스에 최적화된 독점 알고리즘을 사용하여 다음과 같은 핵심 기계 인식 기능을 제공합니다: 1. <strong>Trajectories</strong>: 디바이스의 6-DoF 궤적을 제공합니다. 센서 퓨전(카메라, IMU, GNSS, Wi-Fi, 기압계)을 통한 VIO 및 SLAM 시스템으로 높은 정확도와 강건성을 가집니다. 실시간 호환되는 open loop 궤적(누적 변환 드리프트 0.4% 미만)과 사후 처리된 closed loop 궤적(실내 규모에서 전역 RMSE 변환 오차 1.5 cm 미만) 두 가지 유형이 있으며, 다중 기록을 공통 좌표계에 정렬할 수 있습니다. 2. <strong>Online Calibration</strong>: 온도 변화, 노화, 외부 힘 등으로 인한 카메라 및 IMU의 시간 변화 캘리브레이션을 추정하여 하류 3D 인식 작업의 기하학적 정확도를 높입니다. 3. <strong>Semi-Dense Point Cloud</strong>: 환경의 직관적인 이해를 위해 semi-dense 트랙과 포인트 클라우드를 계산합니다. 이는 연속적으로 새로운 포인트를 생성하고 이를 시간 및 좌우 Mono Scene 카메라에 걸쳐 추적하여 환경의 정적 부분을 재구성합니다. 4. <strong>Eye Gaze Tracking</strong>: 착용자의 눈동자 추적 카메라에서 단일 프레임당 3D 시선 방향 레이를 추정하여 제공하며, 개인화된 눈동자 캘리브레이션 적용 시 중앙 시선 레이 오차(median gaze ray error)는 1.5°입니다.</p>
<p>프라이버시 보호는 Project Aria의 중요한 부분으로, Meta의 Responsible Innovation Principles를 따릅니다. 디바이스에는 녹화 중임을 알리는 LED 표시등과 즉시 현재 녹화를 중지하고 삭제하는 프라이버시 스위치가 있습니다.</p>
<p>Project Aria는 생태학적으로 유효한 데이터 캡처와 MPS를 통한 공간 AI 기계 인식 기술 제공을 통해 수명 주기 매핑 및 재현, egocentric 장면 재구성 및 이해, 객체 상호작용 및 조작, 활동 인식 및 주의력 감지, 요약 및 질의응답과 같은 광범위한 연구 애플리케이션을 가능하게 합니다. 궁극적으로 AR의 성공을 위한 새로운 컴퓨팅 및 상호작용 패러다임을 구축하고, 항상 켜져 있는 상황 인지 AI를 향한 길을 열어주는 것을 목표로 합니다.</p>
<hr>
</section>
<section id="detail-review" class="level1">
<h1>Detail Review</h1>
<blockquote class="blockquote">
<p>Project Aria: 자아 중심(Egocentric) 다중 모달 AI 연구를 위한 새로운 도구 – 심층 분석</p>
</blockquote>
<section id="기술적-기여와-한계-분석" class="level2">
<h2 class="anchored" data-anchor-id="기술적-기여와-한계-분석">기술적 기여와 한계 분석</h2>
<p>Project Aria는 Meta Reality Labs Research가 개발한 안경 형태의 자아 중심 다중 모달 데이터 수집·스트리밍 장치다. 이 장치는 경량(~75g)으로 설계되어 장시간 착용해도 사용자의 일상활동을 방해하지 않으며, 모두가 착용 가능한 사회적 수용성을 고려한 디자인을 채택했다. 내부에는 미래의 AR 글래스가 장착할 것으로 예상되는 다양한 센서들이 탑재되었다. 구체적으로, 좌우에 각각 640×480 픽셀 해상도, 수평 시야각 150°의 흑백 모노 렌즈카메라(Mono Scene, 전역셔터)가 있고, 왼쪽에는 2880×2880 픽셀, 수평 시야각 110°의 RGB F-피쉬아이 렌즈 카메라(POV)가 있다. 또한, 사용자의 시선 추적을 위한 320×240 해상도의 양안 시선 카메라가 내장되어 있으며, IMU(관성측정 장치) 2개(좌측 800Hz, 우측 1000Hz), 7채널 마이크 어레이, 자력계, 기압계·온도계, GPS/GNSS 수신기, Wi-Fi/Bluetooth 스캐너 등 다양한 센서가 포함된다. 이러한 광범위한 센서 구성은 단일 카메라에 의존하는 기존 egocentric 연구 플랫폼과 달리 시각·청각·모션·환경 정보 등 다중 모달 관측을 동시에 확보할 수 있다는 점에서 큰 기술적 진보를 의미한다.</p>
<center>
<img src="../../images/2025-09-28-aria-glass/0-1759123933425-1.png" width="100%">
</center>
<blockquote class="blockquote">
<p>Project Aria 기기는 AR 글래스 형태의 다중 모달 센서 플랫폼으로, 실내외 환경 및 사용자 행동을 모두 포착할 수 있다(이미지: Meta; Project Aria 논문).</p>
</blockquote>
<p>소프트웨어 측면에서도 Project Aria는 전용 데이터 툴킷과 머신 퍼셉션 서비스(MPS)를 제공하여 연구자가 수집된 데이터를 효과적으로 활용하도록 지원한다. 기록된 모든 센서 데이터는 크기가 큰 AR 센서 데이터에 최적화된 VRS 파일 포맷으로 저장되며, 이를 읽고 시각화·처리할 수 있는 C++/Python 기반 오픈소스 툴킷이 공개되어 있다. 나아가, Meta는 업로드된 데이터에 대해 6-DoF 자세 추정, 정밀 보정, 준밀도 점군, 시선(eye gaze) 등 고성능 후처리 파이프라인을 제공한다. 이 MPS는 Aria 전용 알고리즘을 활용해 기존의 공개 솔루션보다 더 정확하고 강건한 결과를 산출하도록 설계되었다고 한다. 요약하면, Project Aria는 고해상도 RGB 영상과 광각 흑백 영상, 시선 및 IMU 등 풍부한 센서를 정밀 보정된 상태로 통합 수집하여, egocentric AI 연구를 위한 전천후 데이터 수집 플랫폼을 구축했다.</p>
<p>그러나 기술적 한계도 존재한다. 우선, 배터리 용량과 발열 제약으로 기본 기록 프로파일에서는 약 1~2시간 분량의 데이터만 녹화 가능하다. 장시간 녹화가 필요하면 외부 배터리팩을 연결해야 한다. 또한, Aria 기기는 OIS(광학식 손 떨림 보정)와 오토포커스(AF) 기능이 없다. 이는 스마트폰 카메라에 비해 영상이 흔들리기 쉽고 심도가 고정되어 있는 단점이 되며, 동적 상황 인식시 성능 저하로 이어질 수 있다. 마찬가지로, 온디바이스 컴퓨팅 리소스가 제한적이어서 실시간 영상 처리나 AR 렌더링은 불가능하며, 모든 데이터 분석은 외부 서버나 컴패니언 앱을 거쳐야 한다. 하드웨어적 규모를 위해 무게를 75g으로 최소화했지만, 일반 안경에 비해 무거운 편이고 대규모 설계 변화로 인한 미세한 센서 배치 변동도 발생할 수 있다. 이를 보완하기 위해 Aria는 공장출하 교정 외에 착용 중 변형을 보정하는 온라인 보정 절차를 마련했으나 , 현실적으로 사용자가 뛰거나 부딪히는 등 거친 움직임에는 여전히 취약할 수 있다.</p>
<p>종합하면, Project Aria는 모든 모달리티를 통합하는 차세대 연구용 AR 글래스라는 점에서 egocentric AI 커뮤니티에 큰 기여를 했다. 특히 다중 센서의 동시 기록과 정밀 시간·공간 동기화를 기본으로 두어, 기존 데이터셋으로는 얻기 어려웠던 풍부한 컨텍스트를 제공한다. 반면 현재 시판 AR 글래스보다 기술 성숙도가 낮고 배터리 제약이 큰 점, 그리고 온디바이스 처리 한계 등의 단점이 공존한다는 한계가 있다.</p>
</section>
<section id="기존-연구와의-차별점-비교" class="level2">
<h2 class="anchored" data-anchor-id="기존-연구와의-차별점-비교">기존 연구와의 차별점 비교</h2>
<p>기존 자아 중심 비전 연구 플랫폼 및 데이터셋과 비교할 때, Project Aria는 종합성과 개방성 측면에서 두드러진 차별점을 지닌다. 먼저, 아리아가 제공하는 멀티센서 스펙은 EPIC-Kitchens나 Ego4D 같은 기존 데이터셋을 능가한다. 예를들어 EPIC-Kitchens는 주로 주방에서 음성 내레이션과 함께 수집된 단일 egocentric RGB 영상(약 55시간 분량)에 집중했다. Ego4D는 9개국 923명 참가자가 공통 포즈로 착용한 다양한 카메라(GoPro, Vuzix, Pupil Labs 등)로 3670시간의 비디오를 수집했으나, 센서 종류별로 일관되게 구성된 하나의 하드웨어 플랫폼은 아니다. 반면 Aria는 하나의 정교한 디자인으로 다수의 센서(흑백·RGB 카메라, 시선 카메라, IMU, 마이크, GNSS, Wi-Fi/BT 등)를 통합하여 확보한다. 이는 Ego4D가 제공하는 오디오, 3D 스캔, 시선 등의 일부 모달리티와 비교해도 뒤지지 않는 수준의 정보다. 즉, Aria는 연구자에게 “모든 센서 데이터를 동기화된 상태로 한꺼번에” 제공할 수 있는 인프라를 마련했다는 점에서 플랫폼적 혁신이 있다.</p>
<p>데이터 규모 면에서는 아직 Aria Pilot 데이터셋(2022년 공개, 약 7.5시간 분량)이 Ego4D나 EPIC-Kitchens보다 훨씬 작다. 그러나 Aria는 연구 파트너 기관에 하드웨어를 제공하여 추가 데이터를 지속 생산할 수 있게 했고, 별도의 공개 데이터 툴킷(Aria Data Tools)이 지원되므로 새로운 데이터셋 생성과 확장이 용이하다. 반면 EPICKitchens와 Ego4D는 완성된 대규모 데이터만 공개하고 장비는 오픈하지 않는다. 예를 들어 Ego4D는 학술적 목적의 사용자는 비디오 다운로드만 제공하며, 플랫폼 자체를 빌려주지는 않는다. Project Aria는 하드웨어·소프트웨어·서비스를 묶어 ’연구 키트’를 구성하고, 지속적인 커뮤니티 참여를 유도함으로써 데이터양보다 연구 활성화라는 측면에서 차별성을 보여준다.</p>
<p>또한 공간·시간 정보의 활용에 있어서도 차이가 크다. Aria는 동기화된 시간코드(SMPTE LTC)와 정확한 내장 시계로 여러 장치 간 시계 정합을 지원한다. 예를 들어 Aria Pilot 데이터셋에서는 동시간대에 두 사람이 같은 공간에서 활동할 때 이들의 6-DoF 위치와 시선을 정밀 비교할 수 있는 “공간-시간 기준”을 제공한다. 반면 EPIC-Kitchens는 오직 단일 착용자의 영상과 음성에 집중했으며, Ego4D 역시 다수 영상 간 시간일치가 이루어졌지만 센서 내부 정밀도는 각각 다르기 때문에 보정 과정이 필요하다. 요약하면, Aria는 다중 착용자의 멀티뷰 및 센서 융합을 염두에 둔 플랫폼이라는 점에서 기존 연구 도구와 구분된다. 이러한 특성은 특히 장기간 지도 작성 및 재현 위치 추정 같은 연구에서 빛을 발한다.</p>
<p>마지막으로, Aria는 개방성과 윤리적 디자인에서도 강점을 가진다. 원문에서도 언급했듯이 Project Aria는 메타의 책임있는 혁신 원칙에 따라 투명한 개인정보 보호 기능(LED 녹화 표시등, 녹화 삭제 스위치)과 엄격한 가이드라인을 제시하여 연구자들이 ’현실 세계 데이터’를 다룰 때 윤리적 문제를 준수하도록 독려한다. 이와 비교하면, EPICKitchens나 Ego4D는 대규모 데이터를 수집하는 과정에서 여러 나라의 법규와 윤리 기준에 맞추기 위해 노력했으나, Aria는 처음부터 개인과 주변인을 보호하는 하드웨어/소프트웨어 기능을 내장했다는 점에서 고유하다. 예컨대 Aria Pilot 데이터에서는 마네킹이나 가면을 쓰게 하거나 얼굴을 블러 처리하는 등 사전 조치를 취했음을 공식 문서에서 밝히고 있다.</p>
<p>종합하자면, Aria는 하드웨어-소프트웨어 일체형 연구 플랫폼이라는 점에서 EPIC-Kitchens나 Ego4D 같은 순수 데이터셋 제공체와 차별화된다. 특히 다양한 센서·모달리티의 통합과 연구자 지원 도구·서비스, 윤리적 고려를 동시에 내세운 점이 눈에 띄는 우위다. 반면 아직 데이터 규모는 작고, 일반화된 소비자 AR 글래스는 아니므로 실제 AR 시장 대비 활용 시 제약이 존재한다.</p>
</section>
<section id="연구-구성-및-실험-설계에-대한-평가" class="level2">
<h2 class="anchored" data-anchor-id="연구-구성-및-실험-설계에-대한-평가">연구 구성 및 실험 설계에 대한 평가</h2>
<p>Project Aria의 연구 구성과 실험 설계는 전반적으로 정교하면서도 실용적이다. 데이터 수집 방식은 연구 장비(안경)와 모바일 앱의 연계로 이루어진다. 연구 참여자는 스마트폰 앱을 통해 녹화를 시작·종료할 수 있으며, 녹화 프로파일(사용할 센서, 해상도, 프레임레이트 등)을 선택하여 맞춤형 데이터 수집이 가능하다. 이는 가령 배터리 소모가 높은 설정을 피하거나, 노출되는 정보의 범위를 조정하는 등 연구 목적에 따라 유연하게 적용할 수 있다. 녹화가 완료되면 사용자는 USB로 기기와 연동해 로컬 PC로 데이터를 다운로드하거나, 원하면 Meta의 MPS 서버에 업로드하여 후처리 결과를 받을 수 있다.</p>
<p>데이터 정합을 위한 보정 절차도 체계적이다. 모든 Aria 기기는 출고 시 정밀한 공장 내 캘리브레이션(기기 내부 센서 간의 상대 위치·자세와 내부 파라미터)을 수행받는다. 또한 MPS는 온라인 캘리브레이션 결과를 자동으로 제공하는데, 이것은 착용 중에 발생할 수 있는 미세 변형까지 보정해준다. 시간 동기화의 경우 기기 자체 클럭과 SMPTELTC, 혹은 TicSync 프로토콜을 통해 다중 기기 간 타임스탬프를 정밀하게 일치시킨다. 이러한 시간·공간 동기화 설계 덕분에 다수의 녹화 파일을 비교·결합하여 연구할 때 데이터 일관성이 높아진다. 예를 들어 Aria Everyday Activities(AEA) 데이터셋에서는 복수 착용자가 동시에 같은 공간에서 활동한 데이터를 ’공유 공간 시간 기준’으로 제공하였고 , Desktop Activities 서브셋에서는 실제 모션캡처 시스템과의 동기화(외부 시뮬레이션)로 고정밀 비교 실험이 가능하도록 준비했다.</p>
<p>개인정보 보호와 윤리적 고려도 연구 설계의 핵심 요소로 포함되었다. Aria 기기는 녹화 중임을 알리는 LED와 녹화 즉시 삭제 기능을 내장해, 비디오/오디오 기록이 이뤄지는 사실을 착용자와 주변인 모두 쉽게 인지하게 한다. Meta는 모든 연구 파트너에게 Aria 커뮤니티 가이드라인을 따르도록 요구하며, 원문에서도 착용자 및 주변인의 동의 및 익명처리 절차를 거쳤음을 강조했다. 예를 들어 파일럿 데이터 수집 시 가면을 착용하거나 얼굴 블러링을 적용함으로써 사생활 침해 가능성을 낮췄다. 이러한 윤리적 고려는 일반적인 egocentric 연구에서 후처리 단계에서 이루어지는 것과는 달리, 수집 단계부터 의도적으로 설계에 반영되었다는 점에서 의미가 있다.</p>
<p>연구툴 측면에서 Aria는 모듈화된 툴셋을 제공한다. Aria Data Tools 리포지토리에는 VRS 데이터 제공자와 시각화 인터페이스가 포함되어 있어, 연구자가 녹화 데이터를 직접 읽고 처리하기 쉽다. 예를 들어 파이썬 라이브러리를 통해 동기화된 센서 데이터를 손쉽게 추출하거나, MPS 출력(위치, 시선, 점군 등)을 연동하는 것이 가능하다. 이러한 툴체인은 오픈소스이며 PyPI 패키지 형태로 배포되어 있어, 다양한 연구 프로젝트에서 재현성과 확장성을 높인다.</p>
<p>전체적으로 볼 때 Aria의 실험설계는 과학적 엄격성과 사용자 편의성 간 균형이 잘 잡혀 있다. 사용자 인터페이스(모바일 앱)로 직관적인 녹화 설정이 가능하고, 연구자는 하드웨어 제약(배터리, 메모리) 내에서 다양한 프로파일을 선택하여 실험을 계획할 수 있다. 데이터는 표준화된 형식과 도구를 통해 공유되며, MPS를 통한 일괄 후처리가 가능해 데이터 품질을 일정 수준으로 유지할 수 있다. 그 결과 여러 연구기관에서 Aria를 활용한 다양한 사례(예: 장기간 SLAM, 시선기반 객체 조작 연구, 음향 방향성 분석 등)가 이미 보고되고 있으며 , 이는 설계의 실용성이 입증된 것으로 볼 수 있다.</p>
<p>한편 한계점으로는, 아직 연구 커뮤니티 외부에는 장치 자체가 널리 배포되지 않았다는 점이 있다. 즉, 현재 Aria는 Meta와 협력하는 기관 중심으로 사용되고 있으며, 일반 개발자나 연구자가 장치를 구매하여 자유롭게 사용할 수 있는 단계는 아니다. 또한, 플랫폼 내부의 많은 부분(예: MPS 서버 처리)은 Meta 인프라에 의존하고 있어 완전히 독립적인 환경에서는 동일한 결과를 내기 어렵다. 마지막으로, Aria Pilot 데이터 구축은 통제된 시나리오(실내 활동 중심)에서 이루어졌기 때문에, 보다 복잡한 야외 환경이나 다양한 참여자를 포함한 데이터셋은 추가적으로 필요하다. 그러나 이러한 제약들은 Project Aria의 초기 연구단계에서는 이해할 만한 부분이며, 향후 Open Science의 차원에서 점진적으로 보완될 것으로 기대된다.</p>
</section>
</section>
<section id="reference" class="level1">
<h1>Reference</h1>
<ul>
<li><a href="https://ai.meta.com/blog/aria-gen-2-research-glasses-under-the-hood-reality-labs/">Gen2 Glasses</a></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>