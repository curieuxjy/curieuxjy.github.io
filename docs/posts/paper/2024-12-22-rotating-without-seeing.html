<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2024-12-22">
<meta name="description" content="Towards In-hand Dexterity through Touch">

<title>📃Rotating without Seeing 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-1e438c382a17f6d88d3993662a872df6.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-a37c72dd2dbac68997fcdc15a3622e78.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-b009f778f5cec7f34f624408a2b5b543.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    window.setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      window.setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    window.hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(darkModeDefault) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const darkModeDefault = false;
    document.querySelector('link.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !window.hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
    };
    // Switch to dark mode if need be
    if (window.hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#learning-touch-dexterity" id="toc-learning-touch-dexterity" class="nav-link" data-scroll-target="#learning-touch-dexterity"><span class="header-section-number">2</span> Learning Touch Dexterity</a>
  <ul class="collapse">
  <li><a href="#problem-formulation" id="toc-problem-formulation" class="nav-link" data-scroll-target="#problem-formulation"><span class="header-section-number">2.1</span> Problem Formulation</a>
  <ul class="collapse">
  <li><a href="#state" id="toc-state" class="nav-link" data-scroll-target="#state"><span class="header-section-number">2.1.1</span> State</a></li>
  <li><a href="#action" id="toc-action" class="nav-link" data-scroll-target="#action"><span class="header-section-number">2.1.2</span> Action</a></li>
  <li><a href="#reward" id="toc-reward" class="nav-link" data-scroll-target="#reward"><span class="header-section-number">2.1.3</span> Reward</a></li>
  <li><a href="#reset" id="toc-reset" class="nav-link" data-scroll-target="#reset"><span class="header-section-number">2.1.4</span> Reset</a></li>
  </ul></li>
  <li><a href="#domain-randomization" id="toc-domain-randomization" class="nav-link" data-scroll-target="#domain-randomization"><span class="header-section-number">2.2</span> Domain Randomization</a></li>
  <li><a href="#training-procedure" id="toc-training-procedure" class="nav-link" data-scroll-target="#training-procedure"><span class="header-section-number">2.3</span> Training Procedure</a></li>
  </ul></li>
  <li><a href="#tactile-dexterous-manipulation-system" id="toc-tactile-dexterous-manipulation-system" class="nav-link" data-scroll-target="#tactile-dexterous-manipulation-system"><span class="header-section-number">3</span> Tactile Dexterous Manipulation System</a>
  <ul class="collapse">
  <li><a href="#real-world-system-setup" id="toc-real-world-system-setup" class="nav-link" data-scroll-target="#real-world-system-setup"><span class="header-section-number">3.1</span> Real-world System Setup</a></li>
  <li><a href="#simulation-setup" id="toc-simulation-setup" class="nav-link" data-scroll-target="#simulation-setup"><span class="header-section-number">3.2</span> Simulation Setup</a></li>
  <li><a href="#benchmark-in-hand-rotation" id="toc-benchmark-in-hand-rotation" class="nav-link" data-scroll-target="#benchmark-in-hand-rotation"><span class="header-section-number">3.3</span> Benchmark: In-hand Rotation</a></li>
  </ul></li>
  <li><a href="#reference" id="toc-reference" class="nav-link" data-scroll-target="#reference"><span class="header-section-number">4</span> Reference</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃Rotating without Seeing 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">paper</div>
    <div class="quarto-category">tactile</div>
    <div class="quarto-category">rl</div>
    <div class="quarto-category">hand</div>
  </div>
  </div>

<div>
  <div class="description">
    Towards In-hand Dexterity through Touch
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 22, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<center>
<img src="../../images/2024-11-30-rotating-without-seeing/1.png" alt="22" width="100%">
</center>
<p>이번 포스팅에서 리뷰할 논문은 <a href="https://arxiv.org/abs/2303.10880">Rotating without Seeing: Towards In-hand Dexterity through Touch</a> 입니다. RSS(Robotics: Science and Systems) <a href="https://roboticsconference.org/2023/">2023 학회</a>에서 발표된 해당 논문은 사람이 <strong>시각 없이 촉각만으로</strong> 손안에서 물체를 정교하게 조작하는 능력을 로봇 핸드에 구현하고자, 손바닥, 손가락 관절, 손끝 전체에 넓게 분포된 <strong>저비용의 이진 촉각 센서를 활용</strong>하여, 시뮬레이션에서 <strong>강화학습으로 학습한 정책을 실제 로봇 손에 적용</strong>하고, 이를 통해 학습한 물체뿐만 아니라 <strong>학습하지 않은 새로운 물체까지 조작</strong>할 수 있는 시스템인 <strong><code>Touch Dexterity</code></strong>를 제안합니다.</p>
<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>대다수의 기존 연구들은 점점 더 <code>고품질</code>의 센서를 활용하여 <code>정밀하고 세밀한 접촉</code>을 다루는 데 초점을 맞추었습니다. 하지만 이러한 연구들은 대개 <code>비싼 센서를 그리퍼나 손의 손가락 끝부분에만 부착</code>할 수 있어, <strong>조작기 전체를 감지하지 못한다는 한계</strong>를 가지고 있습니다. 이로 인해 수행할 수 있는 작업의 범위가 제한됩니다. 또한 복잡한 작업을 위해 대량의 학습 데이터를 필요로 하지만, 고정밀의 센서들을 사용하는 경우 더욱더 벌어지는 Sim2Real 간의 차이로 인해 시뮬레이터를 활용하기 어려운 문제가 존재합니다.</p>
<p>Touch Dexterity는 물체를 “보고” 조작하는 대신 단순히 <strong>접촉만으로 물체를 회전하거나 조작하는 기술</strong>입니다. 이 접근법은 <strong>손의 한쪽 면(손가락 끝, 링크, 손바닥)에 부착된 저비용의 binary force 센서를 활용</strong>합니다. 이러한 <strong>센서는 접촉 여부만을 판단</strong>하며, 이를 통해 물체의 상태를 “느낄 수” 있게 합니다. 16개의 센서를 조합하면 최대 2¹⁶가지 상태를 표현할 수 있어 강력한 표현력을 가질 수 있고, 또한 Sim2Real 격차는 시뮬레이션을 통해 충분한 데이터를 확보함으로써 해결 가능하며, 이 때 binary 센서는 단순한 구조로 인해 노이즈에 덜 민감하다는 장점이 있습니다.</p>
<center>
<img src="../../images/2024-11-30-rotating-without-seeing/3.png" alt="22" width="100%">
<figcaption>
Amazon에서 약 8달러 정도로 저렴하게 판매되고 있는 FSR 센서를 부착한 모습
</figcaption>
</center>
<p>Touch Dexterity는 다중 손가락 로봇 손을 사용하여 <strong>“보이지 않는” 물체를 x, y, z 축으로 회전시키는 작업</strong>에 초점을 맞추고 있으며, 이는 in-hand re-orientation task의 단순화된 버전으로 볼 수 있습니다. 여기서 <code>보이지 않는</code> 물체란 단순히 시각 센서가 없는 것을 의미할 뿐만 아니라, 학습 중에 보지 못한 물체들을 의미하기도 합니다. 강화 학습(RL) 정책은 binary touch sensing 정보와 로봇의 내부 상태를 입력으로 받아 각 시간 단계에서 폐루프(closed loop) 제어를 위한 행동을 예측합니다. 강화학습 Agent는 물체의 3D 구조와 자세를 암묵적으로 학습하여 이를 기반으로 회전을 수행하며 실제 로봇 시스템 테스트에서는 10개의 다양한 물체를 활용하여 실험을 진행했습니다. 아래의 그림은 Unseen 물체였던 오리 인형을 real world에서 in-hand manipulation을 하는 장면입니다.</p>
<center>
<img src="../../images/2024-11-30-rotating-without-seeing/2.png" alt="22" width="100%">
<figcaption>
Rotate the rubber duck for two cycles without falling, even if it is never presented in training
</figcaption>
</center>
<p><strong>Dexterous Manipulation</strong></p>
<p>기존의 분석적 모델 기반 접근법은 물체와 컨트롤러에 대한 지나치게 많은 가정을 필요로 하여 복잡한 문제로 확장하는 데 한계가 있습니다. 모방 학습(imitation learning)은 주로 시각 입력에 의존하며, proprioception 데이터 내에 포함된 암묵적인 촉각 정보를 통해 물체의 정보를 추론할 수 있지만, 주로 손가락 끝에서의 물체 회전이나 제한된 물체 집합의 회전에만 초점을 맞춥니다. 반면, Touch Dexterity는 촉각 센서를 사용하여 손과 물체 간의 상호작용을 명시적으로 인지하고, 다양한 종류의 물체에 대해 손바닥 위에서의 물체 회전 문제를 풉니다. 이는 복잡한 물체의 움직임을 포함하며, 훨씬 더 도전적인 문제를 다룰 수 있고 학습되지 않은 새로운 물체에 대해서도 일반화가 가능하다는 장점을 가지고 있습니다.</p>
<p><strong>Tactile Robotic Manipulation</strong></p>
<p><code>What type of touch information is essential?</code></p>
<p>기존 연구들은 다양한 센서를 활용하여 조작을 지원하기 위해 국소적인 형상 정보(local geometry), 힘과 토크, 접촉 이벤트, 물질 특성을 추출하는 방법을 제안해왔습니다. 심지어 간단한 binary 접촉 신호를 sparse sensor array로 제공받는 경우에도 high-dimensional manipulation task에서 유용할 수 있습니다. 일례로, <a href="https://en.wikipedia.org/wiki/Shadow_Hand">Shadow Hand</a>에 손바닥에 밀집된 센서 레이아웃을 활용한 <a href="https://ieeexplore.ieee.org/document/7353568">연구</a>도 있었습니다.</p>
<p><code>How can tactile events be simulated to facilitate Sim2Real transfer?</code></p>
<p>일반적으로 접촉 표면(contact surface)에서 normal &amp; shear tactile force field을 시뮬레이션합니다. 반면, Touch Dexterity는 별도의 시뮬레이션 설계를 요구하지 않고, 기존 물리 시뮬레이터의 내장된 contact 시뮬레이션을 활용할 수 있다는 점에서 효율적이라고 볼 수 있습니다.</p>
</section>
<section id="learning-touch-dexterity" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Learning Touch Dexterity</h1>
<p>논문에서 제안된 Touch Dexterity의 AI 모듈이 학습되는 과정에 대해 살펴보겠습니다.</p>
<section id="problem-formulation" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="problem-formulation"><span class="header-section-number">2.1</span> Problem Formulation</h2>
<p>Touch Dexterity는 강화학습 방법으로 제어를 하기 때문에 강화학습의 문제 정의 방식인 MDP(Markov Decision Process)의 요소들, State, Action, Reward 순으로 확인해보겠습니다.</p>
<section id="state" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="state"><span class="header-section-number">2.1.1</span> State</h3>
<p>State는 Hand Robot Agent의 상태를 나타내는 요소들로 이루어집니다. Allegro hand 로봇의의 joint position(16 차원), sensor observation(16차원), 이전 position target(16차원), 그리고 rotation axis(2차원)로 구성되어 있습니다. 핸드 로봇의 관절(joint) 부분들이 작은 모터들 16개로 이루어져 있고, FSR(<a href="https://en.wikipedia.org/wiki/Force-sensing_resistor">Force Sensing Resistor</a>) 센서들도 총 16개가 아래 그림처럼 손가락과 손바닥에 분포되어 있어 State 벡터의 차원들이 다음과 같이 구성되게 됩니다. 이렇게 구성된 State가 학습 시에 Policy Network의 Input으로 들어가게 되는데 1 time step 정보만으로는 학습하기에 부족한 정보량이기 때문에 현재 시점 기준 이전 스텝 2 time step을 합쳐(concatenation), 총 <strong>3 time step 을 쌓아서</strong> policy network에 input으로 넣어줍니다.</p>
<center>
<img src="../../images/2024-11-30-rotating-without-seeing/4.png" alt="22" width="100%">
<figcaption>
State 구성요소
</figcaption>
</center>
</section>
<section id="action" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="action"><span class="header-section-number">2.1.2</span> Action</h3>
<p>Hand Agent가 움직이는 Action은 로봇의 각 관절(joint) 모터들이 움직이는 것으로 생각할 수 있습니다. 따라서 Policy network에서는 16차원의 모터와 관련된 어떠한 command 정보가 나오게 됩니다. 하지만 Policy network의 output인 <span class="math inline">a_t</span>를 바로 쓰는 것이 아닌 <a href="https://en.wikipedia.org/wiki/Proportional%E2%80%93integral%E2%80%93derivative_controller">PD Controller</a>에 적용하기 위한 값으로 변환하는 과정을 거치게 됩니다. 결과적으로 PD Controller에서 사용하는 값은 <span class="math inline">\tilde{q}_{t+1}</span> (현재 time step이 <span class="math inline">t</span> 이므로 앞으로 제어할 position의 time step 첨자는 <span class="math inline">t+1</span>)인 것 입니다.</p>
<p>하지만 여기서 <span class="math inline">\tilde{q}_{t+1}</span>을 바로 적용할 경우 생기는 문제가 있습니다. policy network output 값들이 연속적인 시간 순으로 봤을때 갭이 큰 값들이 나타나게 되면 부드러운 움직임을 가질 수 없습니다. 따라서 해당연구에서는 <a href="https://en.wikipedia.org/wiki/Moving_average">Exponential moving average</a> 방법을 사용하여 smoothing하는 과정을 거치게 됩니다.</p>
<center>
<img src="../../images/2024-11-30-rotating-without-seeing/5.png" alt="22" width="100%">
<figcaption>
Action이 적용되는 과정
</figcaption>
</center>
<p>아래 그래프는 논문에서 제시한 파라미터(<span class="math inline">\eta</span>, 2 consecutive steps)로 랜덤한 포인트들을 가지고 smoothing하는 모습을 보여줍니다.</p>
<div id="e03ac505" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co"># Parameters</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>eta <span class="op">=</span> <span class="fl">0.8</span>  <span class="co"># Smoothing factor</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>steps <span class="op">=</span> <span class="dv">2</span>  <span class="co"># Step size for x-axis</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>n_points <span class="op">=</span> <span class="dv">200</span>  <span class="co"># Number of points</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co"># Generate data</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>x <span class="op">=</span> np.arange(<span class="dv">0</span>, n_points, steps)</span>
<span id="cb1-11"><a href="#cb1-11"></a>data <span class="op">=</span> np.sin(x <span class="op">/</span> <span class="dv">5</span>) <span class="op">+</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.3</span>, <span class="bu">len</span>(x))  <span class="co"># Random data with noise</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>ema <span class="op">=</span> []</span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="co"># Calculate EMA</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="cf">for</span> i, point <span class="kw">in</span> <span class="bu">enumerate</span>(data):</span>
<span id="cb1-16"><a href="#cb1-16"></a>    <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-17"><a href="#cb1-17"></a>        ema.append(point)  <span class="co"># Initialize EMA with the first data point</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>    <span class="cf">else</span>:</span>
<span id="cb1-19"><a href="#cb1-19"></a>        ema.append(eta <span class="op">*</span> point <span class="op">+</span> (<span class="dv">1</span> <span class="op">-</span> eta) <span class="op">*</span> ema[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="co"># Plot</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">3</span>))</span>
<span id="cb1-23"><a href="#cb1-23"></a>plt.plot(x, data, label<span class="op">=</span><span class="st">"Data"</span>, marker<span class="op">=</span><span class="st">"o"</span>, linestyle<span class="op">=</span><span class="st">"--"</span>, alpha<span class="op">=</span><span class="fl">0.6</span>)</span>
<span id="cb1-24"><a href="#cb1-24"></a>plt.plot(x, ema, label<span class="op">=</span><span class="st">"Exponential Moving Average (EMA)"</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb1-25"><a href="#cb1-25"></a>plt.xlabel(<span class="st">"Step"</span>)</span>
<span id="cb1-26"><a href="#cb1-26"></a>plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb1-27"><a href="#cb1-27"></a>plt.title(<span class="ss">f"Exponential Moving Average (eta=</span><span class="sc">{</span>eta<span class="sc">}</span><span class="ss">, step=</span><span class="sc">{</span>steps<span class="sc">}</span><span class="ss">) "</span>)</span>
<span id="cb1-28"><a href="#cb1-28"></a>plt.legend()</span>
<span id="cb1-29"><a href="#cb1-29"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb1-30"><a href="#cb1-30"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="2024-12-22-rotating-without-seeing_files/figure-html/cell-2-output-1.png" width="675" height="302" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>이렇게 최종적으로 계산된 Action 값으로 Hand Agent의 모션이 만들어지게 됩니다.</p>
</section>
<section id="reward" class="level3" data-number="2.1.3">
<h3 data-number="2.1.3" class="anchored" data-anchor-id="reward"><span class="header-section-number">2.1.3</span> Reward</h3>
<p>보상함수는 아래와 같이 6개의 term들로 구성되어 있습니다. 각 6개의 reward term들은 linear weighted sum이 되어 해당 timestep에서의 최종 reward가 됩니다.</p>
<center>
<img src="../../images/2024-11-30-rotating-without-seeing/6.jpg" alt="22" width="100%">
<figcaption>
Reward Function
</figcaption>
</center>
<ol type="1">
<li>Reward of rotation <span class="math inline">r_{rot}</span>
<ul>
<li>회전 축 <span class="math inline">k</span>의 법선 평면 <span class="math inline">\Pi</span>에서 샘플링된 단위 벡터의 회전 각도 <span class="math inline">\Delta \theta</span>로 정의된 회전 보상입니다.
<center>
<img src="../../images/2024-11-30-rotating-without-seeing/7.jpg" width="100%">
<figcaption>
Reward Function
</figcaption>
</center></li>
<li>계산하는 과정
<ul>
<li>법선 평면 <span class="math inline">\Pi</span>에서 단위 벡터 <span class="math inline">v</span>를 임의로 샘플링하며, 이 벡터는 object에 부착된 것으로 간주할 수 있습니다.</li>
<li>다음 상태에서의 해당 벡터 <span class="math inline">v'</span>를 가져와 <span class="math inline">\Pi</span>에 투영(projection)합니다: <span class="math inline">v'_p = \text{Proj}(v', \Pi)</span></li>
<li><span class="math inline">\Delta \theta \in [-\pi, \pi)</span>는 축 <span class="math inline">k</span>에 대해 <span class="math inline">v'_p</span>와 <span class="math inline">v</span> 사이의 부호 있는 거리로 정의됩니다.</li>
</ul></li>
<li>object의 움직임이 매우 복잡한 경우, 시뮬레이터가 제공하는 각속도가 매우 노이즈가 심하기 때문에 보상에 이 각속도를 보상함수에 사용할 경우 특정 자세에서 진동하는 등 바람직하지 않은 object 움직임 패턴이 나타날 수 있습니다.</li>
<li>이 유한 차분(finite difference)을 보상으로 사용하는 것이 서로 다른 실행에서도 일관된 회전 동작을 생성할 수 있습니다.</li>
</ul></li>
<li>Penalty of object’s velocity <span class="math inline">r_{vel}</span>
<ul>
<li>손이 object를 안정적으로 회전시키도록 장려하며, 훈련된 정책의 transferability을 향상시킵니다.</li>
</ul></li>
<li>Penalty of falling <span class="math inline">r_{fall}</span>
<ul>
<li>object가 손바닥에서 떨어질 때 적용되는 negative penalty입니다.</li>
</ul></li>
<li>Penalty of the work controller <span class="math inline">r_{work}</span>
<ul>
<li>컨트롤러의 일(work)의 양을 패널티로 부과합니다. 이 reward term의 torque <span class="math inline">\tau</span>는 <span class="math inline">t</span>에서 PD 컨트롤러가 출력한 토크입니다. 이 페널티는 손가락 움직임의 부드러움을 향상시키는 데 도움을 줍니다.</li>
</ul></li>
<li>Penalty of torque <span class="math inline">r_{torque}</span>
<ul>
<li>큰 토크 출력값에 패널티를 부과합니다.</li>
</ul></li>
<li>Reward of distance <span class="math inline">r_{dist}</span>
<ul>
<li>거리 보상으로, 손끝이 객체에 가까이 가서 상호작용하도록 장려합니다.
<ul>
<li><span class="math inline">d(x_{\text{tip}}, x_{\text{obj}})</span>는 손끝 위치 <span class="math inline">x_{\text{tip}}</span>와 객체 위치 <span class="math inline">x_{\text{obj}}</span> 사이의 거리입니다.</li>
<li><span class="math inline">\epsilon</span>은 작은 양으로, 분모가 0이 되는 것을 방지합니다.</li>
<li><span class="math inline">c_2</span>와 <span class="math inline">c_3</span>는 보상의 클리핑 범위를 정의하는 하한과 상한입니다.</li>
</ul></li>
</ul></li>
</ol>
</section>
<section id="reset" class="level3" data-number="2.1.4">
<h3 data-number="2.1.4" class="anchored" data-anchor-id="reset"><span class="header-section-number">2.1.4</span> Reset</h3>
<p>불필요한 exploration를 줄이고 학습 과정을 가속화하기 위해 object가 초기 위치(즉, 손바닥의 중심)에서 너무 많이 벗어날 경우 에피소드를 리셋합니다. 또한, object의 주요 축이 회전 축에서 너무 많이 벗어날 경우에도 에피소드를 리셋합니다.</p>
</section>
</section>
<section id="domain-randomization" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="domain-randomization"><span class="header-section-number">2.2</span> Domain Randomization</h2>
<p>강화학습의 Sim2Real Gap을 줄이기 위해 학습 단계에서 Domain Randomization을 적용하는데 해당 연구에서는 2가지 Domain Randomization을 진행합니다.</p>
<ol type="1">
<li><p><strong>물리적 랜덤화</strong>:</p>
<ul>
<li>rotation하는 object의 초기 위치, 질량, 형태, 마찰을 랜덤화하여 학습된 정책이 다양한 종류의 객체를 처리할 수 있도록 합니다.</li>
<li>PD 컨트롤러의 게인을 랜덤화하여 실제 환경에서 PD 컨트롤러의 불확실성을 모델링합니다.</li>
<li>각 촉각 센서를 랜덤화하는 것도 고려합니다. 활성화된 접촉 센서(출력이 1인 경우)에 대해, 확률 <span class="math inline">p</span>로 출력을 0으로 뒤집습니다.</li>
<li>지수 지연 모델(exponential delay)을 통해 접촉 센서의 신호 지연을 모델링합니다.</li>
</ul></li>
<li><p><strong>비물리적 랜덤화</strong></p>
<ul>
<li>policy의 observation과 출력된 action에 화이트 노이즈를 주입하여 작은 외란에도 강인하도록 만듭니다.</li>
</ul></li>
</ol>
</section>
<section id="training-procedure" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="training-procedure"><span class="header-section-number">2.3</span> Training Procedure</h2>
<p>Proximal Policy Optimization (PPO) 알고리즘을 사용하며 policy 네트워크와 value 네트워크 모두에 다층 퍼셉트론(MLP)을 사용했습니다.</p>
<ul>
<li><strong>훈련 설정</strong>:
<ul>
<li>이점(advantage) 클립 임계값 ϵ=0.2= 0.2와 KL 발산 임계값 0.020.02를 사용</li>
<li>네트워크에서 활성화 함수로 ELU를 사용</li>
<li>정책 네트워크는 학습 가능한 상태 독립적인 표준편차를 가지는 가우시안 분포를 출력</li>
</ul></li>
<li><strong>비대칭 관찰(asymmetric observation)</strong>:
<ul>
<li>정책 및 가치 네트워크의 학습 난이도를 줄이기 위해 asymmetric observation 을 사용
<ul>
<li><strong>가치 네트워크</strong>: 입력에 접촉력, object의 ground-truth pose, 물리적 파라미터와 같은 특권 정보를 추가</li>
<li><strong>정책 네트워크</strong>: 현재 상태와 함께 3개의 과거 상태를 입력으로 사용하며, 특권 정보는 접근할 수 없음</li>
</ul></li>
</ul></li>
<li><strong>시뮬레이션 설정</strong>:
<ul>
<li>IsaacGym 시뮬레이션에서 시간 간격(<span class="math inline">dt</span>)은 0.01667초로 설정하고, 2 sub step을 사용</li>
<li>8192개의 병렬 환경에서 시뮬레이션을 실행</li>
<li>정책 네트워크가 출력하는 행동(제어 목표)은 6단계 동안 실행되며, 이는 실제 환경에서 10Hz의 제어 주파수에 해당</li>
</ul></li>
</ul>
<center>
<img src="../../images/2024-11-30-rotating-without-seeing/10.jpg" width="100%">
<figcaption>
Training Process
</figcaption>
</center>
</section>
</section>
<section id="tactile-dexterous-manipulation-system" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Tactile Dexterous Manipulation System</h1>
<section id="real-world-system-setup" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="real-world-system-setup"><span class="header-section-number">3.1</span> Real-world System Setup</h2>
<center>
<img src="../../images/2024-11-23-rotating-without-seeing/flow.png" width="70%">
<figcaption>
Overview
</figcaption>
</center>
<p>하드웨어 구성은 XArm 로봇 팔과 16자유도(16-DOF)를 가진 Allegro Hand에 접촉 센서 배열을 장착한 형태로 이루어져 있습니다. 손바닥과 손가락 끝을 포함한 Allegro Hand의 여러 부위에 부착된 16개의 접촉 센서로 구성됩니다.</p>
<p>사용된 접촉 센서는 외부 힘이 표면에 가해질 때 저항이 변하는 Force-Sensing Resistor(FSR) 기반입니다. STM32F 마이크로컨트롤러를 사용하여 각 센서의 아날로그 전압 신호를 수집하고, 이를 디지털 신호로 변환하여 호스트로 전달합니다. 이 접촉 센서는 연속적인 접촉력 측정을 출력할 수 있지만, 신호는 일반적으로 비선형적이고 노이즈가 많습니다. 따라서 이를 제어에 사용하기 전에 적절한 전처리가 필요합니다. 선택된 임계값 <span class="math inline">\theta_{\text{th}}</span>에 따라 이 측정값을 이진화(binarize)하고 이 신호를 사용합니다.</p>
<p><strong>이진 신호를 사용하는 장점</strong>:</p>
<ul>
<li>시뮬레이션과 실제 로봇 간의 차이를 줄이고, Sim2Real 전이 절차를 단순화할 수 있습니다.</li>
<li>이진화된 측정값은 임계값을 조정하여 쉽게 보정(calibrate)할 수 있습니다.</li>
</ul>
</section>
<section id="simulation-setup" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="simulation-setup"><span class="header-section-number">3.2</span> Simulation Setup</h2>
<p>이 논문에서는 IsaacGym 시뮬레이터 사용합니다. 각 접촉 센서는 손가락과 손바닥 링크의 고정된 링크로 시뮬레이션됩니다. 시뮬레이터는 매 시뮬레이션 단계에서 각 센서 링크에 대한 순 접촉력 <span class="math inline">F=[Fx,Fy,Fz]F = [F_x, F_y, F_z]</span>를 제공합니다. <span class="math inline">\|F\|</span>을 시뮬레이션된 접촉력 측정값으로 사용한 다음, 이 측정값을 다른 임계값 <span class="math inline">\tilde{\theta}_{\text{th}}</span>으로 이진화합니다.</p>
<center>
<img src="../../images/2024-11-30-rotating-without-seeing/9.jpg" width="100%">
</center>
<p>중요한 점은 센서의 부모 링크에서 제공되는 힘은 순 접촉력에 기여하지 않는다는 것입니다. 시뮬레이션에서 실제 환경과 유사한 동작을 보장하기 위해 이 센서들의 임계값 <span class="math inline">\tilde{\theta}_{\text{th}}</span>을 조정합니다. 시뮬레이션에서는 <span class="math inline">\tilde{\theta}_{\text{th}} = 0.01N</span>을 사용합니다.</p>
</section>
<section id="benchmark-in-hand-rotation" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="benchmark-in-hand-rotation"><span class="header-section-number">3.3</span> Benchmark: In-hand Rotation</h2>
<p>이 논문에서는 시스템의 손재주(dexterity)를 연구하기 위해, 시스템을 사용하여 손 안에서 회전하는 작업(<code>in-hand rotation task</code>)을 목표로 합니다. 이 task는 object가 손바닥에 초기화된 상태로 시작하며, 로봇 손은 주어진 회전 축을 따라 객체를 회전시켜야 합니다. 손 안에서 객체를 회전하는 동안, object의 움직임은 손끝 회전(<code>finger-tip rotation</code>)보다 훨씬 더 복잡하며 특히, 손 안에서 조작하는 동안 객체는 손바닥에서 미끄러지거나 구를 수 있습니다.</p>
<p>이와 같은 복잡한 움직임 패턴 때문에, 성공적인 조작을 위해 촉각 센서나 비전(vision) 시스템의 명시적인 피드백이 필요합니다. 그렇지 않으면, 현재 객체의 상태를 추론할 수 없으며, 객체를 안전하게 밀거나 회전시키는 데 실패할 수 있습니다.</p>
<!--


## Discussion

# Experiments

-->
</section>
</section>
<section id="reference" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Reference</h1>
<ul>
<li><a href="https://arxiv.org/abs/2303.10880">Original Paper</a></li>
<li><a href="https://touchdexterity.github.io/">Project Homepage</a></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    window.setColorSchemeToggle(window.hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>