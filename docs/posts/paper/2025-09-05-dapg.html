<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-09-05">
<meta name="description" content="Learning Complex Dexterous Manipulation withDeep Reinforcement Learning and Demonstrations">

<title>📃DAPG 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ef56b68f8fa1e9d2ba328e99e439f80.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-b009f778f5cec7f34f624408a2b5b543.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review"><span class="header-section-number">1</span> Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review"><span class="header-section-number">2</span> Detail Review</a>
  <ul class="collapse">
  <li><a href="#주요-기여-요약" id="toc-주요-기여-요약" class="nav-link" data-scroll-target="#주요-기여-요약"><span class="header-section-number">2.1</span> 주요 기여 요약</a>
  <ul class="collapse">
  <li><a href="#npg의-한계" id="toc-npg의-한계" class="nav-link" data-scroll-target="#npg의-한계"><span class="header-section-number">2.1.1</span> NPG의 한계</a></li>
  <li><a href="#behavior-cloningbc으로-초기-정책-학습" id="toc-behavior-cloningbc으로-초기-정책-학습" class="nav-link" data-scroll-target="#behavior-cloningbc으로-초기-정책-학습"><span class="header-section-number">2.1.2</span> Behavior Cloning(BC)으로 초기 정책 학습</a></li>
  <li><a href="#강화학습-파인튜닝-시범-보조-손실-포함-정책-그래디언트" id="toc-강화학습-파인튜닝-시범-보조-손실-포함-정책-그래디언트" class="nav-link" data-scroll-target="#강화학습-파인튜닝-시범-보조-손실-포함-정책-그래디언트"><span class="header-section-number">2.1.3</span> 강화학습 파인튜닝 (시범 보조 손실 포함 정책 그래디언트)</a></li>
  </ul></li>
  <li><a href="#실험-결과-및-분석" id="toc-실험-결과-및-분석" class="nav-link" data-scroll-target="#실험-결과-및-분석"><span class="header-section-number">2.2</span> 실험 결과 및 분석</a>
  <ul class="collapse">
  <li><a href="#강화학습-단독으로는-한계" id="toc-강화학습-단독으로는-한계" class="nav-link" data-scroll-target="#강화학습-단독으로는-한계"><span class="header-section-number">2.2.1</span> 강화학습 단독으로는 한계</a></li>
  <li><a href="#dapg-vs.-ddpgfd-등-다른-방법과의-비교" id="toc-dapg-vs.-ddpgfd-등-다른-방법과의-비교" class="nav-link" data-scroll-target="#dapg-vs.-ddpgfd-등-다른-방법과의-비교"><span class="header-section-number">2.2.2</span> DAPG vs.&nbsp;DDPGfD 등 다른 방법과의 비교</a></li>
  </ul></li>
  <li><a href="#결론-및-향후-전망" id="toc-결론-및-향후-전망" class="nav-link" data-scroll-target="#결론-및-향후-전망"><span class="header-section-number">2.3</span> 결론 및 향후 전망</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃DAPG 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">il</div>
    <div class="quarto-category">rl</div>
    <div class="quarto-category">dapg</div>
  </div>
  </div>

<div>
  <div class="description">
    Learning Complex Dexterous Manipulation withDeep Reinforcement Learning and Demonstrations
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 5, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://arxiv.org/abs/1709.10087">Paper Link</a></li>
<li><a href="https://sites.google.com/view/deeprl-dexterous-manipulation">Homepage</a></li>
</ul>
<ol type="1">
<li>이 논문은 고차원 로봇 손으로 복잡한 손 조작 작업을 학습하는 심층 강화 학습(DRL) 방법을 제시하지만, 기존 DRL은 샘플 효율성이 낮아 실제 시스템 적용에 어려움이 있습니다.</li>
<li>저자들은 적은 수의 인간 데모를 활용하여 심층 강화 학습(DAPG)의 샘플 복잡성을 극적으로 줄이는 방법을 제안하며, 이는 몇 시간 분량의 로봇 경험만으로도 학습을 가능하게 합니다.</li>
<li>이 방법은 물체 재배치, 도구 사용 등 복잡한 손 조작 작업을 학습할 수 있게 하며, 학습된 정책은 데모로부터 자연스럽고 강건한 움직임을 보여줍니다.</li>
</ol>
<center>
<img src="../../images/2025-09-05-dapg/natural_motion_dapg.gif" width="100%">
</center>
<center>
<img src="../../images/2025-09-05-dapg/01.png" width="60%">
</center>
<hr>
<section id="brief-review" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Brief Review</h1>
<p>고차원 민첩한(dexterous) 다지 로봇 손 제어는 복잡하고 접촉이 많아 어렵습니다. 심층 강화 학습(DRL)은 모델에 구애받지 않는 접근 방식이지만, 고차원 민첩 조작에 확장되는 것을 보여주지 못했습니다. 또한, 샘플 비효율성 때문에 실제 시스템에 적용하기 어렵습니다. 이 연구는 24-DoF의 고차원 손으로 복잡한 조작 작업을 모델 프리(model-free) DRL로 스크래치부터 해결할 수 있음을 시뮬레이션에서 보여줍니다. 샘플 비효율성을 극복하기 위해 소수의 인간 데모를 사용합니다. 데모를 활용하면 샘플 복잡성을 크게 줄여 몇 시간 분량의 로봇 경험만으로 학습할 수 있게 됩니다. 또한 데모 사용은 자연스럽고 강건한(robust) 정책을 만듭니다. 이 연구는 객체 재배치(object relocation), 손 안 조작(in-hand manipulation), 도구 사용(tool use), 문 열기(door opening) 작업에 대한 성공적인 정책을 시뮬레이션에서 보여줍니다.</p>
<p>연구에서는 로봇이 숙달해야 할 4가지 대표적인 민첩 조작 작업 세트를 제안합니다.</p>
<ol type="1">
<li>Object Relocation: 객체를 집어 목표 위치로 옮깁니다.</li>
<li>In-hand Manipulation (Pen Repositioning): 손 안에서 객체(펜)의 방향을 조정합니다.</li>
<li>Manipulating Environmental Props (Door Opening): 환경의 일부(문)를 조작합니다.</li>
<li>Tool Use (Hammer): 도구(망치)를 사용하여 못을 박습니다.</li>
</ol>
<p>실험에는 24-DoF ADROIT 손과 MuJoCo 시뮬레이터를 사용했습니다. 인간 데모는 VR 시스템을 통해 수집되었습니다.</p>
<p>핵심 방법론은 데모 강화 정책 경사법(Demo Augmented Policy Gradient, DAPG)입니다. 이는 강화 학습과 모방 학습을 결합합니다. 제어 문제는 MDP <span class="math inline">\mathcal{M} = \{\mathcal{S}, \mathcal{A}, R, \mathcal{T}, \rho_0, \gamma\}</span>로 모델링됩니다. 정책 <span class="math inline">\pi_\theta</span>는 기대 총 보상 <span class="math inline">\eta(\pi) = E_{\pi, \mathcal{M}}[\sum_{t=0}^\infty \gamma^t r_t]</span>를 최대화하도록 최적화됩니다. 연구는 Natural Policy Gradient(NPG)를 기반으로 합니다.</p>
<p>NPG는 바닐라 정책 경사(vanilla policy gradient) <span class="math display">\mathbf{g} = \frac{1}{N T} \sum_{i=1}^N \sum_{t=1}^T \nabla_\theta \log \pi_\theta(a^i_t|s^i_t) \hat{A}^\pi(s^i_t, a^i_t, t)</span>를 계산하고, Fisher Information Matrix <span class="math display">\mathbf{F}_\theta = \frac{1}{N T} \sum_{i=1}^N \nabla_\theta \log \pi_\theta(a^i_t|s^i_t) \nabla_\theta \log \pi_\theta(a^i_t|s^i_t)^T</span>의 역행렬로 사전 조건화하여</p>
<p>업데이트 <span class="math display">\theta_{k+1} = \theta_k + \sqrt{\frac{\delta}{\mathbf{g}^T \mathbf{F}_{\theta_k}^{-1} \mathbf{g}}} \mathbf{F}_{\theta_k}^{-1} \mathbf{g}</span>를 수행합니다.</p>
<p>DAPG는 <strong>데모 데이터셋 <span class="math inline">\rho_D</span>를 활용하여 RL을 강화</strong>합니다.</p>
<ul>
<li>첫째, 행동 복제(Behavior Cloning, BC)를 사용하여 정책을 <span class="math inline">\max_\theta \sum_{(s,a) \in \rho_D} \ln \pi_\theta(a|s)</span>를 통해 데모를 모방하도록 사전 학습(pretraining)하여 탐색에 도움을 줍니다.</li>
<li>둘째, 증강된 손실(augmented loss)을 사용한 RL 미세 조정(fine-tuning)을 수행합니다. 정책 경사 업데이트에 데모 데이터를 활용하는 항을 추가합니다. 증강된 경사 <span class="math display">\mathbf{g}_{\text{aug}} = \sum_{(s,a) \in \rho_\pi} \nabla_\theta \ln \pi_\theta(a|s)A^\pi(s, a) + \sum_{(s,a) \in \rho_D} \nabla_\theta \ln \pi_\theta(a|s)w(s, a)</span>를 사용하며, 여기서 <span class="math display">w(s, a) = \lambda_0 \lambda_1^k \max_{(s',a') \in \rho_\pi} A^\pi(s',a')</span>는 데모에 대한 어드밴티지 정보를 근사하기 위한 휴리스틱 가중치로, 학습이 진행됨에 따라 감소합니다.</li>
</ul>
<p>실험 결과, sparse 보상으로는 NPG와 DDPG 모두 학습하지 못했습니다 (in-hand 작업 제외). shaped 보상으로는 NPG는 높은 성공률을 달성했지만 샘플 비효율적이고(몇백 로봇 시간 소요), 부자연스러우며 환경 변화에 강건하지 않았습니다. DDPG는 성공적인 정책 학습에 실패했습니다.</p>
<p>반면, <strong>DAPG</strong>는 희소한 보상 설정에서 다른 데모 활용 방법인 DDPGfD보다 훨씬 뛰어난 성능을 보였습니다. DAPG는 모든 작업에서 몇 로봇 시간 안에 정책을 학습할 수 있었으며, Object Relocation 작업에서 스크래치 학습보다 약 30배 빨랐습니다. DAPG로 학습된 정책은 데모를 통해 인간 전략의 강건함을 포착하여 환경 변화에 더 강건하며, 더 인간적인 동작을 보여주었습니다. 다양한 환경 앙상블(ensemble)에 대해 학습할 때도 DAPG가 스크래치 RL보다 더 강건한 정책을 학습할 수 있었습니다.</p>
<p>이 연구는 고차원 민첩 조작 작업을 위한 DRL 가능성을 보여주었습니다. DAPG는 데모를 통해 샘플 효율성, 정책의 강건성 및 자연스러움을 크게 향상시켰습니다. 몇 시간 안에 학습이 가능하여 실제 시스템 적용 가능성을 제시합니다.</p>
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/KIuZs5rqN1c?si=y-7mNMUCpsh97Nyv" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<hr>
</section>
<section id="detail-review" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Detail Review</h1>
<p>##소개 및 배경</p>
<p>다수의 관절을 가진 다지 손 로봇(multi-fingered dexterous hand)은 인간 환경에서 다양한 작업을 수행할 잠재력을 지니지만, 제어의 난이도가 매우 높습니다. 손가락이 여러 개인 로봇 손은 고차원 관절 공간과 복잡한 접촉 상호작용을 갖고 있으며, 물체를 쥐거나 조작하는 과정에서 접촉 지점이 수시로 바뀌고 동역학이 불연속적으로 변화합니다. 이런 이유로, 기존 연구에서는 손 로봇 제어를 쉽게 만들기 위해 구조적으로 단순한 손이나 제한된 동작에 집중하곤 했습니다.</p>
<p>예를 들어, 손가락을 두세 개로 제한하거나 특수 기계적 구조를 설계하여 문제를 단순화하거나, 파지(grasping)나 물체를 손 안에서 간단히 회전시키는 정도의 비교적 단순한 작업을 주로 다루었습니다. 모델 기반 최적화 방법으로 이러한 기본 동작들을 성공시킨 사례도 있었지만, 현실 세계의 복잡한 접촉이 있는 상황에선 정확한 모델링이 어려워 한계를 보였습니다.</p>
<p>강화학습(RL)은 동역학 모델 없이 시도-오차를 통해 정책을 학습하므로, 복잡한 로봇 제어 문제에 유연하게 적용할 수 있다는 장점이 있습니다. 하지만 딥 강화학습(DRL)을 다지 손 조작에 적용한 선행 연구들은 거의 없었고, 주로 7-DoF 로봇 팔 등 비교적 간단한 조작이나 보행 같은 다른 분야에 국한되어 있었습니다. 심지어 표준적인 RL 벤치마크 과제들은 차원이 낮아, 선형 정책으로도 쉽게 해결되는 경우가 있을 정도로 단순하여, 고차원 손 조작의 난제를 대변하지 못했습니다. 모델 프리 RL이 이렇게 복잡한 손 조작 작업에 직접 적용되어 성공한 사례는 논문 발표 시점까지 전례가 없었습니다.</p>
<p>본 리뷰의 대상인 Rajeswaran et al.(2018)의 논문은 이러한 간극을 메우기 위해 고차원 로봇 손의 복잡한 조작 작업을 딥 RL로 해결한 최초의 연구 중 하나입니다. 특히, 소수의 인간 시범(demonstrations) 데이터를 활용하여 강화학습의 탐색 문제와 표본 효율 문제를 크게 개선하였음을 보여주었습니다. 그 결과, 과거에는 시뮬레이션에서 수백 시간 걸리던 학습을 불과 몇 시간의 로봇 경험(몇 회의 에피소드)으로 단축하였고, 학습된 정책의 동작이 더 인간처럼 자연스럽고 환경 변화에 견고해지는 효과도 확인하였습니다. 이 리뷰에서는 해당 논문의 핵심 기여와 기술적 아이디어, 제안한 알고리즘 DAPG (Demo Augmented Policy Gradient)의 구체적인 동작 원리, 그리고 실험 설정 및 결과를 중점적으로 깊이 있게 분석합니다. 또한 기존 관련 연구들과 비교하여 본 논문의 차별점도 함께 짚어보겠습니다.</p>
<section id="주요-기여-요약" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="주요-기여-요약"><span class="header-section-number">2.1</span> 주요 기여 요약</h2>
<p>이 논문에서 저자들은 복잡한 다지 손 조작 학습 분야에 다음과 같은 주요 기여를 하였습니다:</p>
<ul>
<li><strong>모델 프리 딥 RL로 고차원 손 조작 작업 성공</strong>: 인간 손과 유사한 5-손가락 24자유도 로봇 손을 이용해, 물체 옮기기, 손안에서 물체 재배치, 도구 사용, 문 열기와 같은 다양한 접촉이 있는 복잡한 작업들을 모델 기반 사전지식 없이 RL만으로 학습하여 성공적으로 시연하였습니다. 이는 이론적으로나 실험적으로 최초의 성과로서, 고차원 손 조작에도 모델 프리 강화학습을 적용할 수 있음을 보였습니다.</li>
<li><strong>시범 데이터 활용을 통한 학습 효율 비약적 향상</strong>: 각 작업마다 *25개 정도의 인간 시범을 가상현실(VR) 인터페이스를 통해 수집하고 활용함으로써, 탐색 문제를 완화하고 학습에 필요한 샘플(데이터) 양을 드라마틱하게 감소시켰습니다. 그 결과, 시뮬레이터 상에서 몇 시간에 불과한 로봇 경험(예: 5시간 가량)만으로도 학습이 가능해졌습니다. 이는 해당 작업들을 실제 로봇에도 적용할 수 있을 만큼 실용적인 시간 내에 학습시킬 수 있는 수준으로 샘플 효율을 개선한 것입니다.</li>
<li><strong>시범으로 얻은 자연스러움 및 강인성 향상</strong>: 시범 데이터를 통해 학습한 정책들은 *보상함수 설계를 최소화해도 성공률이 높았을 뿐 아니라, 사람의 동작을 닮은 부드럽고 자연스러운 움직임을 보였습니다. 또한 동일한 작업이라도 환경 조건(예: 물체 질량이나 마찰 등)을 바꾸었을 때 성능 저하가 덜하고 견고하게 동작하여, 시범을 통해 인간 전략의 내재된 강인성이 정책에 스며들었음을 확인했습니다.</li>
<li><strong>새로운 표준 과제 세트 제안</strong>: 저자들은 향후 연구에 활용할 수 있도록, 앞서 언급한 4가지 *다양한 손 조작 작업 환경을 정식으로 구축하여 제시하였습니다. 이 작업들은 고차원, 풍부한 접촉 상호작용, 과업의 다양성 측면에서 실제 인간 환경의 과제를 잘 대표하며, 로봇 조작과 머신러닝 교차 분야 연구자들에게 도전적인 벤치마크로 활용될 수 있습니다.</li>
</ul>
<p>요약하면 이 논문은, “고차원 로봇 손도 딥 RL로 학습시킬 수 있다. 그리고 소량의 시범을 더하면 학습 속도와 정책 품질 모두 극적으로 향상된다.”는 것을 최초로 증명하며, 그 방법으로 DAPG 알고리즘을 제시한 것입니다.</p>
<p><strong>실험 환경:</strong> 복잡한 다지 손 조작 과제들저자들은 인간형 5-손가락 로봇 손 (24 DoF)의 난이도를 충분히 체감할 수 있는 네 가지 대표 작업을 시뮬레이션 환경에 구현하였습니다. 이 작업들은 일상에서 사람이 손으로 하는 다양한 조작 기술을 반영하며, 가상 현실(VR) 장치를 통해 사람으로부터 시범 데이터를 수집할 수 있게 설계되었습니다. 각 작업에는 환경의 무작위성이 도입되어 초기 상태나 대상의 속성이 에피소드마다 달라지며, 최종 성공 여부만으로 보상이 주어지는 이진 성공 기준(sparsereward)을 갖습니다.</p>
<p>네 가지 과제는 다음과 같습니다:</p>
<ol type="1">
<li><strong>물체 옮기기 (Object Relocation)</strong>: 테이블 위에 놓인 파란 공을 집어 들어서 초록색 목표 지점까지 옮기는 작업입니다. 에피소드마다 공과 목표 위치가 테이블 위 임의의 곳으로 설정되며, 공이 목표 지점의 반경 ε 이내에 놓이면 성공으로 간주됩니다. 이 과제는 기본적인 파지 및 이송 능력을 평가하며, 손-물체 간 다중 접촉이 필요한 대표적 작업입니다.</li>
<li><strong>손 안에서 물체 조작 (In-hand Manipulation</strong>): 손에 쥔 펜의 방향을 재조정하여 주어진 목표 방향(녹색 표시)에 맞추는 작업입니다. 손목은 고정된 채 손가락들만 이용하며, 매 에피소드마다 펜의 초기 자세와 목표 자세가 무작위로 주어집니다. 펜의 방향이 목표와 일정 허용 오차 이내로 일치하면 성공입니다. 이 과제는 손가락들의 협조적인 미세 조작 능력을 필요로 하며, 연속적 접촉 및 재그립(re-grasping) 등이 요구됩니다.</li>
<li><strong>문 열기 (Door Opening)</strong>: 손으로 문 손잡이의 걸쇠(latch)를 해제하고 문을 밀어 열기까지 수행하는 작업입니다. 문의 초기 닫힌 각도와 걸쇠의 상태가 무작위로 설정되며, 걸쇠에는 마찰력과 문을 닫히도록 잡아당기는 토크(스프링)가 존재해 손잡이를 어느 정도 힘줘 돌려야 열립니다. 문이 완전히 열려 문턱(stopper)에 닿으면 성공으로 판정됩니다. 이 과제는 복잡한 도구-환경 상호작용과 다단계 행동 시퀀스(걸쇠 풀기 → 밀기)를 포함하여, 손 조작의 탐색 난이도를 크게 높인 경우입니다.</li>
<li><strong>도구 사용 (Tool Use – Hammering)</strong>: 바닥에 고정된 못을 망치로 내리쳐 박는 작업입니다. 테이블 위에 놓인 망치를 손으로 집어 들어 목표 못의 머리를 여러 차례 두드려서, 결국 못 전체를 나무 판자에 박아 넣으면 성공입니다. 못은 마찰로 약 15N의 힘까지 버티도록 설계되어, 충분한 타격 힘을 가해야 합니다. 이 과제는 물체 파지 → 근력 동작으로 이어지는 복잡한 활용이며, 비연속적인 충격 접촉과 도구의 정확한 조작이 요구되는 난도 높은 환경입니다.</li>
</ol>
<center>
<img src="../../images/2025-09-05-dapg/dapg1.png" width="80%">
</center>
<blockquote class="blockquote">
<p>DAPG 알고리즘으로 학습된 로봇 손의 도구 사용 (망치질) 과제 수행 장면. 로봇 손이 책상 위의 망치를 집어 들고 바닥의 못을 여러 차례 타격하여 끝까지 박는 복잡한 동작을 성공시켰다. 각 작업마다 약 25개의 인간 시범으로 초기정책을 학습시킨 후, 강화학습을 통해 몇 시간 만에 이러한 행동이 가능해졌다. 해당 정책은 사람 시범을 참고하여 학습되었기 때문에 동작이 비교적 자연스럽고, 환경 변화에도 강건한 특징을 보였다.</p>
</blockquote>
<p>각 작업은 서로 다른 기술적 도전요소를 갖고 있어서, 하나의 알고리즘이 다양한 측면에서 성능을 검증받도록 합니다. 예를 들어, 물체 옮기기는 접근 및 파지(grasp &amp; lift) 능력, 손내 조작은 정교한 자세 제어, 문 열기는 다단계 상호작용 및 힘 조절, 망치질은 공구 활용 및 충격력 제어라는 식으로, 손재주(hand dexterity)의 폭넓은 범위를 아우르도록 구성되었습니다. 특히 망치질이나 문 열기 등의 작업은 이전 연구들에서 다루지 않았던 복합 과제로서, 실제 가정환경에서 로봇 손이 해야 할 유용한 작업들에 가깝습니다. 저자들은 이러한 표준 과제 세트를 구축함으로써, 향후 연구자들이 로봇 손+강화학습 분야에서 공통으로 도전할 수 있는 벤치마크를 제공하였습니다.</p>
<section id="npg의-한계" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="npg의-한계"><span class="header-section-number">2.1.1</span> NPG의 한계</h3>
<p>Demo Augmented Policy Gradient (DAPG) 알고리즘 핵심 아이디어는 강화학습(RL)과 모방학습(시범)을 효과적으로 결합하여, 탐색 어려움과 샘플 비효율 문제를 동시에 해결하는 것입니다. 기본적으로 저자들은 온-폴리시(on-policy) 정책 그래디언트 기반의 강화학습 알고리즘을 사용하였는데, 이는 Natural Policy Gradient (NPG) 방법으로 구현되었습니다.</p>
<p>NPG는 정책 파라미터 공간에서 Fisher Information Matrix로 그래디언트를 정규화하여 업데이트하는 기법으로, 고차원 연속 제어 문제에서 기존 방법들보다 안정적이고 성능이 좋은 것으로 알려져 있습니다. 저자들은 먼저 이 기본 강화학습 알고리즘을 사용하여 작업을 푸는 것을 시도해보았는데, 다음과 같은 한계를 확인했습니다:</p>
<ul>
<li><strong>보상 설계의 어려움</strong>: 순수 RL로는 성공/실패에 대한 이진 보상(sparse reward)만 주었을 때 학습이 진행되지 않았습니다. 무작위 탐색으로는 성공 사례를 거의 못 찾아내기 때문입니다. 결국 작업별로 사람이 세밀한 shaping 보상(힌트성 중간 보상)을 설계해주어야 학습이 겨우 가능했습니다. 이러한 보상 설계는 많은 노력과 휴리스틱을 필요로 합니다.</li>
<li><strong>샘플 요구량 문제</strong>: 보상을 잘 설계해 주어 RL이 학습에 성공하더라도, 수백만 스텝에 달하는 경험이 필요하여 학습 시간이 매우 길었습니다. 논문 결과에 따르면 어떤 작업은 100 시간분에 해당하는 시뮬레이션 데이터가 필요했는데, 이는 실제 로봇에 적용하기엔 비현실적으로 많은 양입니다 (로봇을 100시간 연속 구동하며 학습시키는 것은 안전이나 비용 면에서 쉽지 않습니다).</li>
<li><strong>학습된 정책 품질 문제</strong>: 순수 RL로 겨우 얻어진 정책들조차 동작이 어색하고 비효율적이며, 환경 조건이 조금만 달라져도 실패할 정도로 취약성을 보였습니다. 예를 들어, 사람이라면 하지 않을 불필요한 손가락 움직임을 반복하거나 비정상적인 자세로 물체를 잡는 등 인간 공감대와 동떨어진 행동들이 나타났고, 약간 다른 물체 크기나 마찰조건에서는 성공률이 급격히 떨어졌습니다.</li>
</ul>
<p>DAPG (Demo Augmented Policy Gradient) 알고리즘은 이러한 문제들을 해결하기 위해 인간 시범 데이터를 강화학습 과정에 체계적으로 통합합니다.</p>
<p>핵심 구성은 두 가지 단계로 이루어집니다: <strong>(1) Behavior Cloning을 통한 정책 초기화와 (2) 시범 정보가 포함된 보조 손실로 강화학습 파인튜닝</strong>입니다. 아래에서는 이 두 단계를 상세히 설명합니다.</p>
</section>
<section id="behavior-cloningbc으로-초기-정책-학습" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="behavior-cloningbc으로-초기-정책-학습"><span class="header-section-number">2.1.2</span> Behavior Cloning(BC)으로 초기 정책 학습</h3>
<p>먼저 소량의 전문가 시범 데이터셋 <span class="math inline">\rho_D</span>를 모아 Behavior Cloning으로 초기 정책을 학습시킵니다. 시범 데이터셋 <span class="math inline">\rho_D={(s_t^{(i)}, a_t^{(i)}, \dots)}</span>는 여러 에피소드 <span class="math inline">i</span>에서 시간 단계 <span class="math inline">t</span>별로 상태 <span class="math inline">s</span>, 전문가 행동 <span class="math inline">a</span> (그리고 보상 <span class="math inline">r</span>, 다음 상태 등)을 모아둔 것입니다. Behavior Cloning은 이를 <code>지도학습 문제</code>로 보아, 주어진 상태에서 전문가의 행동을 모방하도록 정책 파라미터를 학습합니다. 수식으로 표현하면 다음과 같습니다: <span class="math display"> \max_{\theta} \sum_{(s,a)\in \rho_D} \ln \pi_\theta(a \mid s)\,. \tag{1} </span></p>
<p>위 식은 시범 데이터에서 정책 <span class="math inline">\pi_\theta</span>의 로그 확률을 최대화하는 문제입니다. 즉, 시범 상태 <span class="math inline">s</span>에서 전문가가 취한 행동 <span class="math inline">a</span>를 가장 그럴듯하게 선택하도록 정책의 파라미터 <span class="math inline">\theta</span>를 조정합니다. 이 과정을 통해 얻어진 모방 정책은 전문가 경로를 따라가는 초기 전략을 제공합니다. Behavior Cloning으로 초기화를 하면, <code>완전히 무작위 정책으로 시작하는 것에 비해 탐색을 훨씬 효율적으로 만들 수 있습니다.</code> 일반적인 정책 그래디언트 방법은 정책의 확률적 탐색 노이즈에만 의존하여 새로운 동작을 시도하는데, 고차원 문제에서는 무작위 시도로는 의미 있는 상태에 도달하기 어렵습니다. <code>반면, 시범 경로를 따라하도록 초기 정책을 잡아주면 초반부터 유망한 상태-행동 영역을 탐색하게 되어, 흔히 필요했던 복잡한 보상 shaping 없이도 학습을 시작할 수 있습니다.</code> 실제 논문 결과에서도, 시범을 활용하지 않은 경우에는 각 작업마다 사람이 일일이 추가 보상 신호를 설계해줘야 했지만, DAPG는 시범 덕분에 이런 보상 없이도 학습이 가능했음을 보여줍니다.</p>
<p>하지만, Behavior Cloning만으로 최종 정책을 얻기에는 <strong>한계가 있습니다.</strong> <code>시범 데이터의 양이 많지 않으면 모방 학습된 정책은 분포 이동(distributional shift) 문제로 새로운 상태에 대응하지 못해 실패하게 됩니다.</code> 실제로 저자들의 실험에 서도 BC만으로 학습한 정책은 대부분 작업을 끝까지 성공적으로 수행하지 못했습니다. 이는 시범 경로를 조금만 벗어나도 정책이 어떻게 행동해야 할지 모르기 때문입니다. 더욱이, <code>모방학습만으로는 전문가를 넘어서 성능을 향상시킬수도 없습니다</code> – 기본적으로 주어진 시범을 따라하기만 하므로 과업 성공에 대한 피드백이 없기 때문입니다. 따라서 모방으로 초기화한 후에도 강화학습을 통해 보상 신호로 정책을 향상시키는 단계가 필요합니다.</p>
</section>
<section id="강화학습-파인튜닝-시범-보조-손실-포함-정책-그래디언트" class="level3" data-number="2.1.3">
<h3 data-number="2.1.3" class="anchored" data-anchor-id="강화학습-파인튜닝-시범-보조-손실-포함-정책-그래디언트"><span class="header-section-number">2.1.3</span> 강화학습 파인튜닝 (시범 보조 손실 포함 정책 그래디언트)</h3>
<p>초기 정책을 얻었다면, 이후에는 <strong>온-폴리시 강화학습으로 정책을 계속 파인튜닝</strong>합니다. 이때 일반적인 정책 그래디언트 방식과 차별화되는 점은, <code>시범 데이터로부터 추가로 얻는 그래디언트 항(term)을 손실 함수에 포함시킨다</code>는 것입니다. 이를 통해 학습 내내 정책이 시범의 유익한 행동들을 참고하도록 만들고, 중간 단계 행동들에 대한 가이던스를 제공합니다. 저자들은 이 접근을 <strong>“데모 증강 정책 그래디언트(Demo Augmented Policy Gradient, DAPG)”</strong>라 명명하였습니다.</p>
<p>구체적으로, 정책 그래디언트를 계산할 때 사용되는 목적 함수를 확장합니다. 기본이 되는 RL 목표는 정책의 기대 총 보상 <span class="math inline">J(\pi_\theta) = \mathbb{E}_\pi \left[\sum_t \gamma^t r_t\right]</span>를 최대화하는 것으로, 이에 대응하는 정책 그래디언트는 REINFORCE 공식을 통해 아래처럼 주어집니다:</p>
<p><span class="math display"> g_{\text{RL}} \;=\; \mathbb{E}{(s,a)\sim \rho\pi}!\Big[ \nabla_\theta \ln \pi_\theta(a|s)\; A^\pi(s,a) \Big]
\,, </span></p>
<p>여기서 <span class="math inline">\rho_\pi</span>는 현재 정책 <span class="math inline">\pi</span>로부터 수집한 온-폴리시 데이터 분포이고, <span class="math inline">A^\pi(s,a)</span>는 현재 정책에 대한 어드밴티지(advantage) 값입니다. <span class="math inline">A^\pi(s,a)</span>는 해당 상태-행동이 평균적인 상태 대비 얼마나 더 좋은 결과를 내는지를 나타내는 값으로, 보상 <span class="math inline">Q^\pi(s,a)</span>와 가치함수 <span class="math inline">V^\pi(s)</span>의 차이로 정의됩니다. DAPG에서는 이 정책 그래디언트에 추가로 시범 데이터 방향의 그래디언트를 더해줍니다. 즉, 최종 증강 그래디언트 <span class="math inline">g_{\text{aug}}</span>는 다음과 같이 구성됩니다:</p>
<p><span class="math display"> g_{\text{aug}} \;=\; \sum_{(s,a)\in \rho_\pi} \nabla_\theta \ln \pi_\theta(a|s)\; A^\pi(s,a)\;+\; \sum_{(s,a)
\in \rho_D} \nabla_\theta \ln \pi_\theta(a|s)\; w(s,a)\,. \tag{2} </span></p>
<p>첫 번째 항은 온-폴리시 RL 그래디언트(앞서 설명한 <span class="math inline">g_{\text{RL}}</span>)이고, <strong>두 번째 항이 시범 데이터로부터 오는 추가 그래디언트입니다.</strong> 이 추가 항은 시범 데이터 분포 <span class="math inline">\rho_D</span>에 대해, 그 상태에서 정책이 시범 행동 <span class="math inline">a</span>를 취하도록 확률을 높이는 방향으로 작용합니다. 단, 모든 시범 데이터를 동일하게 사용하기보다는 각각에 가중치 <span class="math inline">w(s,a)</span>를 부여하여 얼마나 신뢰할지 조절합니다. 이런 방식으로 시범을 활용하면 모방 학습과 강화학습을 연속적으로 접목할 수 있습니다.</p>
<p>몇 가지 극단적인 경우를 살펴보면, 만약 모든 <span class="math inline">(s,a)\in\rho_D</span>에 대해 <strong><span class="math inline">w(s,a)=0</span>이라면</strong> 두 번째 항이 없어지고 <strong>순수한 RL 학습과 동일</strong>해집니다. 반대로 <strong><span class="math inline">w(s,a)</span>가 매우 큰 상수</strong>로 설정되어 시범 항이 지배적이라면, 이는 사실상 <strong>Behavior Cloning만을 수행</strong>하는 것과 가까워집니다. DAPG의 목표는 <span class="math inline">w(s,a)</span>를 적절히 조절하여 RL의 성능 향상 효과와 시범의 가이드 효과를 동시에 얻는 것입니다.</p>
<hr>
<p>저자들은 <strong>이상적인 <span class="math inline">w(s,a)</span> 설계</strong>에 대해 고찰하면서, <strong><span class="math inline">\rho_\pi</span>와 <span class="math inline">\rho_D</span>의 혼합 분포 관점에서 분석</strong>합니다.</p>
<p>분석에 따르면, 이론적으로는 시범 데이터에서도 현재 정책의 Advantage를 계산하여 <span class="math inline">w(s,a) = A^\pi(s,a)</span>로 두는 것이 합리적입니다. 즉, 시범에서의 행동이 현재 정책보다 얼마나 이득인지에 따라 가중치를 주는 것이 최선이라는 것이죠. 하지만 현실적으로 시범 각 상태의 <span class="math inline">A^\pi(s,a)</span> 값을 얻으려면 추가적인 시뮬레이션이나 가정이 필요하여 곧바로 계산하기 어렵습니다. 그래서 저자들은 경험적인 휴리스틱으로서 다음과 같은 단순한 형태의 가중치를 제안합니다 :</p>
<p><span class="math display"> w(s,a) \;=\; \lambda_0 \,\lambda_1^k \; \max_{(s',a')\in \rho_\pi} A^\pi(s',a') \qquad \forall (s,a) \in \rho_D\,, </span></p>
<p>여기서 <span class="math inline">\lambda_0</span>는 초기 가중치 스케일, <span class="math inline">\lambda_1</span>은 감쇄율(decay factor), <span class="math inline">k</span>는 학습이 진행된 iteration 횟수를 나타냅니다. 즉, 현재 정책으로 모은 온-폴리시 데이터에서의 최대 advantage 값 (현 정책이 얻 은 가장 좋은 행동의 advantage)을 하나의 기준 상수로 삼아서, 모든 시범 샘플에 동일한 가치로 할당합니다. 그리고 학습이 거듭될수록 <span class="math inline">\lambda_1^k</span> 항을 통해 이 가중치를 지수적으로 감소시킵니다.</p>
<p>이 설계의 의도는 명확합니다: 초기 학습 단계에서는 시범이 정책보다 훨씬 우수한 행동들을 담고 있으므로 시범의 영향을 강하게 주어야 합니다. 반면 후기 단계에서는 정책이 이미 웬만한 성능에 도달했기 때문에 시범과 정책의 수준이 비슷해집니다. 이때까지도 시범에 끌려다니면 정책이 더 나아지기 어렵기 때문에, 후반으로 갈수록 시범의 비중을 줄여 정책이 스스로 성능을 최대로 끌어올리도록 합니다. 이렇게 함으로써 초반엔 시범 위주 학습 → 후반엔 RL 위주 학습으로 점진적으로 전환되어, 전체적으로 시범+RL의 시너지를 얻는 것이 DAPG의 목표입니다. 논문에서는 <span class="math inline">\lambda_0=0.1</span>, <span class="math inline">\lambda_1=0.95</span>로 설정하여 모든 실험을 진행했으며, 적절한 범위 내에서는 결과가 크게 민감하지는 않았다고 보고합니다.</p>
<p>이러한 개념을 종합하여 DAPG 알고리즘의 흐름을 단계별로 정리하면 다음과 같습니다:</p>
<ol type="1">
<li>시범 수집: 전문가(휴먼)가 VR 장치를 통해 각 작업을 수행하여 성공 trajectories를 <span class="math inline">N</span>개 (논문 실험에서는 약 25개) 기록합니다. 이로부터 시범 데이터셋 <span class="math inline">\rho_D</span>를 구성합니다.</li>
<li>Behavior Cloning 초기화: 식 (1)의 최대우도 추정 문제를 풀어 시범을 모방하는 초기 정책 <span class="math inline">\pi_{\theta_0}</span>를 얻습니다. (실제로는 딥러닝 옵티마이저를 활용하여 손실 함수를 최소화하는 방식으로 학습합니다.)</li>
<li>강화학습 반복: <span class="math inline">k=1,2,\dots</span> 에 대해 다음을 수행합니다.
<ol type="1">
<li>현재 정책 <span class="math inline">\pi_{\theta_{k-1}}</span>을 사용하여 시뮬레이터에서 여러 에피소드의 on-policy 데이터 <span class="math inline">\rho_\pi</span>를 샘플링합니다. (논문 구현은 한 iteration에 200 에피소드씩 수집하여 사용.)</li>
<li>수집한 데이터로부터 각 state-action의 advantage <span class="math inline">\hat{A}^\pi(s,a)</span> 값을 추정합니다 (가치함수 baseline 등을 이용). 정책 그래디언트 <span class="math inline">g_{\text{RL}}</span> (온-폴리시 부분)와 시범 그래디언트 항을 포함한 증강 그래디언트 <span class="math inline">g_{\text{aug}}</span>를 식 (2)에 따라 계산합니다.</li>
<li><span class="math inline">g_{\text{aug}}</span>를 사용하여 정책 파라미터 업데이트를 수행합니다. 이때 Natural Policy Gradient 방법을 사용하므로, 그래디언트에 Fisher 정보 행렬의 역을 곱해 스텝 크기를 조절한 업데이트를 적용합니다. (즉, $ <em>k = </em>{k-1} + , F^{-1} g_{} $ 형태로, <span class="math inline">\alpha</span>는 적절한 스텝 크기입니다.)</li>
<li>시범 그래디언트의 가중치 계수 <span class="math inline">\lambda_1^k</span>를 다음 iteration을 위해 감소시킵니다.</li>
</ol></li>
<li>수렴 또는 충분한 성능 달성 시 종료: 정책을 평가하여 성공률 등이 기준을 넘으면 학습을 종료합니다.</li>
</ol>
<p>이 전체 알고리즘에서, 시범 데이터는 초기 학습에서는 탐색을 크게 가속하고, 학습 중반에는 정책이 놓치고 있는 행동들을 보강하는 가이드 역할을 하며, 학습 후반에는 비중을 줄여 최종 성능을 RL이 주도하게 합니다. 저자들이 든 예를 다시 상기해 보면, Behavior Cloning 단계에서는 망치를 드는 것까지 겨우 배우지만 못을 치지는 못했습니다. 이후 강화학습이 망치 드는 부분을 자체적으로 개선하고 나면, 여전히 어려운 못 치는 동작을 시범 데이터가 뒷받침해주어 정책이 이를 습득하도록 만든 것입니다. 이렇게 시범의 정보가 전 학습 과정에 걸쳐 활용되기 때문에, 초기 시범에서 담지못한 복잡한 행동까지 최종 정책이 얻게 되는 것이 DAPG의 장점입니다.</p>
<blockquote class="blockquote">
<p>참고: DAPG와 대비되는 접근으로, <strong>off-policy 방법인 DDPGfD (DDPG from Demonstrations)</strong>가 있습니다. DDPGfD는 Q러닝 기반 연속제어 알고리즘인 DDPG에 리플레이 버퍼 초기화 형태로 시범을 넣고, 우선순위 경험 재생(PER), n-step 보상, 네트워크 가중치 정규화 등 여러 기법을 조합하여 시범을 활용하는 방법입니다. off-policy 방법은 동일한 데이터로 반복 학습하므로 표본 효율은 높을 수 있지만, 훈련이 불안정하고 특히 고차원 환경에서는 민감도가 높다는 단점이 있습니다. 반면 DAPG는 on-policy 업데이트로 안정성을 확보하고 시범으로 효율 향상까지 얻은 방법으로, 논문 실험에서도 DDPGfD보다 우수한 성능을 보였습니다. (자세한 비교는 뒤의 실험 결과에서 다룹니다.)</p>
</blockquote>
</section>
</section>
<section id="실험-결과-및-분석" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="실험-결과-및-분석"><span class="header-section-number">2.2</span> 실험 결과 및 분석</h2>
<section id="강화학습-단독으로는-한계" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="강화학습-단독으로는-한계"><span class="header-section-number">2.2.1</span> 강화학습 단독으로는 한계</h3>
<p>우선 시범을 사용하지 않고 순수 RL만으로 앞서 소개한 네 가지 작업을 학습시켜 본 결과, 여러 문제점이 나타났습니다. Sparse reward (최종 성공 여부만 보상) 설정에서는 대다수 작업에서 아무런 학습 진전이 없었는데, 이는 앞서 언급한대로 무작위 탐색으로는 성공 사례를 만나지 못해 정책이 옳은 방향으로 갱신되지 않기 때문이었습니다. 예외적으로 펜 돌리기 (in-hand) 작업은 매우 간단한 성공 조건 덕에 극히 드물게 성공 에피소드가 발생하여 조금이나마 학습이 진행되었으나, 다른 작업들은 전혀 성공을 경험하지 못한 채 보상이 0으로 머물렀습니다.</p>
<p>이 때문에 저자들은 RL을 학습시키기 위해 부득이하게 각 작업별로 세밀한 shaped reward를 설계하여 투입했습니다. 예컨대 문 열기 작업의 경우 “걸쇠를 어느 정도 돌리면 +보상, 문을 살짝 열면 +보상” 등의 중간 보상을 단계별로 주는 식입니다. 이러한 휴리스틱 보상 덕분에 NPG 알고리즘은 모든 작업에서 정책을 어느 정도 학습할 수 있었습니다. 최종 성능을 100회 시도 중 성공률(%)로 평가했을 때, NPG는 각 과제에서 상당히 높은 성공률을 보여주었습니다.</p>
<center>
<img src="../../images/2025-09-05-dapg/dapg2.png" width="100%">
</center>
<p>Figure 7에 제시된 결과에 따르면 NPG의 경우 네 작업 모두 약 80~100%에 수렴하는 성능을 보인 반면, DDPG 알고리즘은 광범위한 튜닝에도 불구하고 어떠한 작업도 성공적으로 학습하지 못했습니다. (DDPG는 오프폴리시의 장점으로 데이터 효율은 높지만, 고차원 연속제어에서는 파라미터 민감도와 불안정성으로 학습 실패할 때가 많다는 지적이 있습니다. 이 실험에서도 복잡한 손 환경에 적합하지 않음이 확인되었습니다.) 비록 NPG로 shaped 보상 하에 학습이 되긴 했지만, 학습 속도와 정책 품질 면에서 문제가 남았습니다. 우선 학습에 요구되는 표본 수가 매우 컸는데, 논문 부속자료의 Table I에 정리된 바에 따르면 시범 없이 shaped 보상으로 학습한 경우 수백 회의 정책 업데이트(하나의 업데이트당 200 에피소드 샘플) 후에야 90% 성공률에 도달했습니다. 이를 실제 로봇 시간으로 환산하면 수십~수백 시간에 이르는 분량입니다. 아래 표는 각 작업에 대해 DAPG vs.&nbsp;순수 RL의 학습 소요 시간을 비교한 것으로, DAPG가 얼마나 학습을 가속했는지 잘 보여줍니다:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">작업 (Task)</th>
<th style="text-align: center;">DAPG (시범 + sparse 보상)</th>
<th style="text-align: center;">RL (NPG) – shaped 보상</th>
<th style="text-align: center;">RL (NPG) – sparse 보상</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Relocation (물체 옮기기)</td>
<td style="text-align: center;">52회 업데이트 <br> (~5.8 시간)</td>
<td style="text-align: center;">880회 <br> (~98 시간)</td>
<td style="text-align: center;">실패 (학습 불가)</td>
</tr>
<tr class="even">
<td style="text-align: center;">Hammer (망치질)</td>
<td style="text-align: center;">55회 업데이트 <br> (~6.1 시간)</td>
<td style="text-align: center;">448회 <br> (~50 시간)</td>
<td style="text-align: center;">실패 (학습 불가)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Door (문 열기)</td>
<td style="text-align: center;">42회 업데이트 <br> (~4.7 시간)</td>
<td style="text-align: center;">146회 <br> (~16.2 시간)</td>
<td style="text-align: center;">실패 (학습 불가)</td>
</tr>
<tr class="even">
<td style="text-align: center;">Pen (펜 회전)</td>
<td style="text-align: center;">30회 업데이트 <br> (~3.3 시간)</td>
<td style="text-align: center;">864회 <br> (~96 시간)</td>
<td style="text-align: center;">2900회 <br> (~322 시간)</td>
</tr>
</tbody>
</table>
<blockquote class="blockquote">
<p>표 1: 시범 활용 여부에 따른 학습 소요 비교 (논문 Table I 기반 재구성).</p>
</blockquote>
<p>DAPG는 시범 덕분에 sparse 보상만으로도 각 작업을 수 시간 내에 학습을 완료한 반면, 순수 RL (NPG)는 shaped 보상이 있어도 수십~수백 시간의 경험을 필요로 했습니다. 특히 sparse 보상만 주는 경우, Pen 작업을 제외하면 RL은 아예 학습 진행이 안 되어 무한대(∞)로 표시되었고, Pen도 300시간 이상의 방대한 경험을 쌓아야 겨우 성공률 기준을 만족시켰습니다. 또한 정책의 행동 품질도 큰 차이가 나타났습니다. 순수 RL로 학습된 정책들은 정의된 보상만 극대화하려다 보니 종종 엉뚱한 방식으로 과제를 수행했습니다. 예를 들어, 물체를 옮기는 작업에서 사람이라면 편하게 쥘 공을 매우 이상한 손가락 꼬임 자세로 쥔다든지, 망치질 작업에서 망치를 비틀어서 잡는 등 비효율적이거나 부자연스러운 동작이 관찰되었습니다 (논문 Figure 8 참조).</p>
<center>
<img src="../../images/2025-09-05-dapg/dapg3.png" width="60%">
</center>
<p>이러한 정책은 사소한 변화에도 쉽게 실패했는데, 저자들이 정책의 강인성(robustness)을 실험한 결과 순수 RL 정책은 환경 파라미터가 조금만 달라져도 성공 확률이 급격히 떨어진 반면, DAPG로 학습한 정책은 변화된 상황에서도 높은 성능을 유지했습니다.</p>
<center>
<img src="../../images/2025-09-05-dapg/dappg4.png" width="60%">
</center>
<p>Figure 9에 제시된 그래프에서, 예를 들어 DAPG 정책은 공의 질량이나 마찰계수가 달라져도 성공률 곡선이 완만하게 유지되지만, 순수 RL 정책은 기준 환경에서 벗어나면 성능이 크게 저하되거나 아예 학습 자체가 안 되는 모습이 확인되었습니다.</p>
<ul>
<li>DAPG의 성능:
<ul>
<li>빠른 학습과 향상된 동작 품질 시범을 도입한 DAPG 알고리즘은 위의 문제들을 극적으로 개선하였습니다. 가장 큰 개선은 학습 효율로, Table 1에서 보듯이 모든 작업에서 RL 단독 대비 월등히 적은 시간 내에 정책을 학습했습니다. 특히 Pen (펜 돌리기)의 경우 shaped 보상으로 96시간 걸리던 것이 3.3시간으로 단축되어 약 30배의 가속이 달성되었습니다. 다른 작업들도 8배에서 20배 이상의 속도 향상을 보여, 전반적으로 “시범 + RL” 조합의 효과가 입증되었습니다. 저자들은 DAPG가 아니었다면 수 일(또는 수 주) 걸릴 학습을 몇 시간 수준으로 줄임으로써, 강화학습으로 복잡한 손 기술을 배우는 것이 현실적인 시간 스케일에서 가능함을 보였다고 강조합니다. 실제 논문에서 DAPG는 모든 작업을 5시간 이내에 학습시켰으며, 이는 곧 충분한 병렬화나 시뮬레이터 고속화를 통해 실제 로봇으로도 학습을 돌려볼 수 있는 수준입니다. (물론 아직 시뮬레이션에서만 검증되었지만, “few hours of robot experience”라는 표현에서 시사하듯이 저자들은 DAPG의 효율이라면 실제 로봇 학습도 도전해볼 만하다고 언급합니다.)</li>
<li>다음으로 정책의 성공률과 견고성 측면에서도 DAPG는 뛰어난 성능을 보였습니다. 시범 덕분에 별도 보상 shaping 없이도 충분한 탐색이 이루어져, 저자들은 DAPG 실험에서는 최종 성공 여부에 대한 sparse 보상만 사용하여도 학습이 가능하도록 설정하였습니다. 그럼에도 불구하고 DAPG 정책은 최종 성공률 면에서 앞서 shaped 보상으로 학습한 NPG 정책에 버금가거나 더 나은 수준을 달성했습니다. 또한 흥미롭게도 정책의 강인성이 크게 향상되었는데, DAPG로 얻은 정책은 환경 변화(무게, 마찰, 초기 조건 등)에 훨씬 둔감하여 폭넓은 상황에서 성공을 거두었습니다. 논문에서는 이를 “인간 전략의 내재적 강인성(intrinsic robustness of human strategies)”이 시범을 통해 학습되었기 때문이라고 해석하고 있습니다. 인간 시범 제공자는 작업을 성공하기 위해 다양한 요인을 보정하며 행동하는데, 이런 휴리스틱 노하우가 정책 네트워크에 반영되어 특정 환경에 오버피팅되지 않는 일반적 해결책을 얻게 되었다는 것입니다.</li>
<li>마지막으로 정책 동작의 자연스러움과 관련해, DAPG는 눈에 띄게 인간과 유사한 움직임을 보여주었습니다. 이는 정량적 지표로 측정하기는 어렵지만, 논문 저자들이 함께 공개한 비디오에서 DAPG 정책이 수행하는 동작은 시범 제공 자(인간)가 했을 법한 방식과 유사한 부분이 많음을 알 수 있습니다. 예를 들어, 공을 집어 옮길 때 손가락을 모아서 쥐는 모양새나, 망치를 휘두르는 속도와 궤적 등이 비교적 자연스럽습니다. 반면 보상 함수를 잘못 설계한 RL 정책은 때로 관절 가동 범위를 이상하게 쓰거나 목적에 맞지 않는 손가락 움직임을 보였는데, DAPG 정책에는 그런 엉뚱한 행동이 현저히 줄어든 것을 확인할 수 있습니다. 저자들은 “정책이 학습 과정에서 명시적으로 주지 않았던 ’인간스러움’의 특성을 시범을 통해 얻게 되었다”고 평합니다. 물론 이는 사이드 이펙트이긴 하지만, 향후 인간과 함께 작업하는 로봇손이라면 이러한 사람다운 움직임이 주는 신뢰성과 안전성 이점도 무시할 수 없을 것입니다.</li>
</ul></li>
</ul>
</section>
<section id="dapg-vs.-ddpgfd-등-다른-방법과의-비교" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="dapg-vs.-ddpgfd-등-다른-방법과의-비교"><span class="header-section-number">2.2.2</span> DAPG vs.&nbsp;DDPGfD 등 다른 방법과의 비교</h3>
<p>DAPG의 효과를 더 입증하기 위해, 저자들은 기존의 시범 활용 RL 기법들과 정량 비교를 수행했습니다. 그 중 한 가지 대표 비교 대상은 앞서 언급한 DDPGfD 알고리즘입니다. 실험 조건을 맞추기 위해 DAPG와 DDPGfD 모두 동일한 시범 데이터(25개)를 사용하고, sparse 보상만으로 각 작업을 학습시켰습니다.</p>
<center>
<img src="../../images/2025-09-05-dapg/dapg5.png" width="100%">
</center>
<p>결과는 Figure 10에 학습 곡선으로 제시되어 있는데, DAPG가 모든 작업에서 DDPGfD보다 현저히 빠르고 높은 성능을 보였음을 알 수 있습니다. 구체적으로, DDPGfD는 학습 초반 거의 진전이 없다가 나중에서야 겨우 성공률이 오르는 양상을 보인 반면, DAPG는 매우 초기부터 급격히 성능이 향상되어 일정 에피소드 후에는 두 방법 간 큰 격차가 벌어졌습니다. 예를 들어 물체 옮기기의 경우, DAPG는 수십 회의 업데이트 내에 성공률 곡선이 가파르게 상승하여 목표 성능에 도달했지만, DDPGfD는 같은 시간 내 거의 0% 근처에 머물렀다가 한참 후에야 상승하는 모습을 보였습니다. 최종적으로 DAPG는 앞서 언급한 대로 5시간 내외로 모든 작업을 끝냈지만, DDPGfD는 문 열기 등의 몇몇 작업은 그보다 훨씬 느리거나 끝내 충분한 성능에 도달하지 못한 것으로 나타났습니다.</p>
<p>이러한 결과는 온-폴리시 정책 그래디언트 방식과 오프-폴리시 Q러닝 방식의 차이를 보여주는 것이기도 합니다. 저자들은 DDPGfD가 근본적으로 off-policy 수렴 불안정성과 고차원에서의 튜닝 어려움 때문에 초반 탐색에서 헤매는 경향을 보인다고 분석합니다. 반대로 DAPG는 on-policy의 안정된 개선에 시범의 도움까지 더해져 초반 탐색 난관을 빠르게 탈출할 수 있었다는 것입니다. 또한 DDPGfD는 시범을 활용하긴 해도 경험 재생 버퍼에 섞어주는 방식이기 때문에, 학습과정에서 시범이 정책에 미치는 영향력이 점차 희석됩니다. 반면 DAPG는 학습 내내 명시적인 시범 그래디언트를 줬다는 점도 성능 차이의 요인으로 볼 수 있습니다.</p>
<p>관련하여, 논문에서는 그 밖에도 몇 가지 시범+RL 방법들을 소개하고 차이점을 언급합니다. 예를 들어 Hester et al.(2018)의 DQfD (Deep Q-learning from Demonstrations) 는 값 함수 기반에서 시범을 활용한 초기 연구이고, 최근에는 시범을 보상 함수에 통합하거나 (IRL/보상 shaping 방식), 시범 데이터에 노이즈나 실패 사례가 포함되어 있을 때의 학습법 등도 연구되고 있습니다. Guided Policy Search (GPS) 기반으로 시범을 활용한 사례도 있는데, 주로 저차원 손 작업(예: 막대기 돌리기 등)에 한정되어 있고 모형 기반 기법이라 실제 적용에 제약이 있습니다. DAPG는 이러한 선행 연구들과 달리, 고차원 정책 신경망을 끝까지 end-to-end로 학습하면서도 샘플 효율과 안정성을 확보했다는 점에서 차별화됩니다. 또한 시범의 활용 방식에 있어서도 DAPG는 사전 학습 + 학습 중 보조신호라는 두 단계 결합을 명확히 제시하여, 복잡한 행동의 단계별 학습을 가능케 한 점이 특징입니다.</p>
</section>
</section>
<section id="결론-및-향후-전망" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="결론-및-향후-전망"><span class="header-section-number">2.3</span> 결론 및 향후 전망</h2>
<p>Rajeswaran 등(2018)의 이 논문은 딥 강화학습과 인간 시범 데이터의 결합이 복잡한 로봇 손 조작 학습에 매우 효과적임을 보여준 사례로서, 이후 많은 관련 연구에 영감을 주었습니다. 저자들은 “DAPG”로 명명된 이 알고리즘이 30배에 달하는 샘플 효율 향상과 정책 품질 개선을 이루었음을 실험으로 입증하였고, 특히 인간 수준의 복잡한 작업들도 RL로 풀 수 있다는 가능성을 열어주었습니다. 이는 로봇 공학 및 강화학습 분야 모두에 의미 있는 성취로, 과거에는 어려움 때문에 시도되지 않던 고차원 다관절 조작 문제를 학습 기반 접근으로 다룰 수 있음을 보여준 것입니다.</p>
<p>물론 한계도 있습니다. 본 연구는 시뮬레이션에서 수행되었으며, 현실 로봇에 직접 적용하기까지는 여전히 넘어야 할 장애물이 있습니다. 예컨대 실제 로봇 손의 물리적 한계, 센서 노이즈, 충돌 처리, 그리고 무엇보다 실시간 학습에서의 안정성 등이 해결되어야 합니다. 그러나 논문 결과에 따르면 DAPG 알고리즘으로는 5시간 이내의 데이터로도 충분히 학습이 가능하므로, 이를 그대로 실제 로봇에 이식한다면 하루 작업으로 정책을 학습시킬 수도 있을 것입니다. 저자들도 결론에서, 시뮬레이션 결과와 샘플 효율 향상을 바탕으로 실제 복잡한 손 조작 학습에 한 발 다가섰다고 밝히고 있으며, 향후에는 실제 하드웨어 상에서 DAPG를 검증하는 것을 목표로 하고 있습니다.</p>
<p>이 논문의 발표 이후, 도메인 랜덤화(domain randomization) 등을 통해 시뮬레이터에서 학습한 손 정책을 실제 로봇에 적용한 사례(예: OpenAI의 Rubik’s Cube 해법)나, 진화 전략과 모델 기반 강화학습으로 샘플 효율을 높이는 연구 등 다양한 후속 연구들이 진행되었습니다. 그 중심에는 “어떻게 하면 복잡한 로봇 행동을 현실적으로 학습시킬 것인가?”라는 큰 질문이 있습니다. DAPG는 그 질문에 대해 “우선 인간에게 배워라, 그리고 스스로 향상시켜라”라는 통찰을 준 방법이라 할 수 있습니다. 이는 인간과 로봇의 협력 학습이라는 관점에서도 흥미로운 방향입니다. 앞으로도 시범학습과 강화학습의 조합은 로봇에게 새로운 능력을 가르치는 강력한 수단으로 계속 연구될 것이며, 본 논문은 그 효과를 극적으로 보여준 선구적인 예시로 오래 회자될 것입니다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>