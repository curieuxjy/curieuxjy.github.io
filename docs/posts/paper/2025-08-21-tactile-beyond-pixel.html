<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-08-19">
<meta name="description" content="Multisensory Touch Representations for Robot Manipulation">

<title>📃Tactile Beyond Pixel 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-bc185b5c5bdbcb35c2eb49d8a876ef70.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-5a614c35f1f90bfd0a5b2992298a8538.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review">Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review">Detail Review</a>
  <ul class="collapse">
  <li><a href="#논문의-주요-내용-요약" id="toc-논문의-주요-내용-요약" class="nav-link" data-scroll-target="#논문의-주요-내용-요약">1. 논문의 주요 내용 요약</a></li>
  <li><a href="#기술적-기여-및-한계-분석" id="toc-기술적-기여-및-한계-분석" class="nav-link" data-scroll-target="#기술적-기여-및-한계-분석">2. 기술적 기여 및 한계 분석</a></li>
  <li><a href="#관련-연구와의-비교" id="toc-관련-연구와의-비교" class="nav-link" data-scroll-target="#관련-연구와의-비교">3. 관련 연구와의 비교</a></li>
  <li><a href="#실제-응용-가능성-평가" id="toc-실제-응용-가능성-평가" class="nav-link" data-scroll-target="#실제-응용-가능성-평가">4. 실제 응용 가능성 평가</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃Tactile Beyond Pixel 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">tactile</div>
    <div class="quarto-category">digit360</div>
    <div class="quarto-category">multlimodal</div>
  </div>
  </div>

<div>
  <div class="description">
    Multisensory Touch Representations for Robot Manipulation
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 19, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://arxiv.org/abs/2506.14754">Paper Link</a></li>
</ul>
<ol type="1">
<li>👉 이 논문은 로봇 조작을 위한 최초의 멀티모달 촉각 표현 학습 모델인 Sparsh-X를 제시하며, 이는 Digit 360 센서에서 얻은 이미지, 오디오, 모션, 압력 등 네 가지 촉각 양상을 자체 지도 학습을 통해 하나의 통합된 표현으로 융합합니다.</li>
<li>📚 약 100만 건의 접촉 상호작용 데이터로 학습된 Sparsh-X는 물체의 물리적 특성 및 접촉 역학을 효과적으로 포착하며, 다양한 작업에서 이러한 정보를 활용할 수 있음을 입증합니다.</li>
<li>🚀 실험 결과, Sparsh-X는 모방 학습 및 Sim-to-Real 촉각 적응을 통해 로봇 조작 성공률을 63% 향상시키고, 물리적 특성 추정 정확도를 기존 방식 대비 48% 개선하여 견고한 미세 조작 성능을 제공합니다.</li>
</ol>
<hr>
<section id="brief-review" class="level1">
<h1>Brief Review</h1>
<p>이 논문은 로봇 조작을 위한 일반 목적의 다중 감각 촉각 표현(multisensory touch representations) 모델인 Sparsh-X를 제안합니다. Sparsh-X는 Digit 360 센서에서 수집된 이미지, 오디오, 모션(IMU), 압력의 네 가지 촉각 모달리티를 활용하여 약 100만 건의 접촉 기반 상호작용 데이터로 자가 지도 학습(self-supervised learning)되었습니다. 이 모델은 다양한 시간적, 공간적 스케일의 상호 보완적인 촉각 신호들을 단일화된 표현으로 융합하여 물리적 특성을 포착합니다.</p>
<p>Sparsh-X의 핵심 방법론은 transformer 기반의 백본 아키텍처에 있습니다(그림 2 참조).</p>
<center>
<img src="../../images/2025-08-21-tactile-beyond-pixel/Screenshot 2025-08-21 at 11.27.27 AM.png" width="100%">
</center>
<p>입력 신호는 먼저 <span class="math inline">L_f</span>개의 레이어(<span class="math inline">L_f = 8</span>)에서 각 모달리티별로 독립적인 self-attention을 통해 처리됩니다. 이후 <span class="math inline">L_b</span>개의 블록(<span class="math inline">L_b = 4</span>)에서는 attention bottlenecks [35]를 사용하여 cross-modal 정보 흐름이 이루어집니다. 이를 위해 <span class="math inline">B</span>개의 bottleneck fusion tokens(<span class="math inline">B = 4</span>)이 각 모달리티의 embedding에 연결되며, 각 cross-modal 업데이트 후 fusion tokens는 모달리티 전반에 걸쳐 평균화되어 정보 공유를 촉진합니다. 총 transformer 레이어 수는 <span class="math inline">L = L_f + L_b = 12</span>로 설정되었습니다.</p>
<p>입력 모달리티는 다음과 같이 전처리되고 토큰화됩니다:</p>
<ul>
<li><strong>Image</strong>: 30fps로 샘플링된 촉각 이미지를 5의 temporal stride로 채널 차원에 따라 연결합니다. hyper-fisheye 이미지는 224x224x3 크기로 자르고 리사이즈되며, 16x16 크기의 패치(patch)로 분할된 후 linear projection layer를 통해 768차원의 embedding으로 토큰화됩니다.</li>
<li><strong>Audio</strong>: 48kHz로 샘플링된 두 개의 접촉 마이크에서 얻은 0.55초의 오디오 신호는 5ms Hamming window와 2.5ms의 hop length로 128채널의 log-mel spectogram으로 변환됩니다. 두 마이크의 spectogram이 연결되어 224x256 오디오 입력이 되며, 16 크기의 패치로 토큰화됩니다.</li>
<li><strong>IMU (Accelerometer)</strong>: 400Hz로 샘플링된 3축 가속도계 데이터는 0.55초 창으로 통합되어 224x3 temporal signal로 토큰화됩니다.</li>
<li><strong>Pressure</strong>: 200Hz로 샘플링된 압력 신호는 1.1초 창으로 통합되어 224x1 temporal signal로 토큰화됩니다.</li>
</ul>
<p>Sparsh-X는 자가 지도 학습을 위해 <code>teacher-student self-distillation</code> 접근 방식 [40, 11]을 사용합니다. 인코더와 예측 헤드로 구성된 두 브랜치에서, 학생 입력 토큰에 마스킹을 적용하고 (로컬 마스크의 경우 10-50%, 전역 마스크의 경우 50-100% 신호 유지), 교사 토큰을 pseudo-label로 사용하여 클러스터링 예측 작업을 수행합니다. 최적화 목표는 교사와 학생 네트워크의 softmax 출력 간 cross-entropy입니다.</p>
<p>평가 실험은 세 가지 주요 영역에서 진행되었습니다:</p>
<ol type="1">
<li><strong>물리적 특성 추론 (Inferring physical properties)</strong>: 객체-행동-표면 분류(object-action-surface classification), 재료-양 추정(material-quantity estimation), 법선력 추정(normal force estimation)과 같은 지도 학습(supervised learning) 작업을 통해 Sparsh-X 표현의 품질을 평가했습니다. Sparsh-X의 인코더 가중치는 고정된 상태로 task-specific attentive decoder를 훈련시켜 순수하게 표현의 품질을 측정했습니다. 그 결과, 다중 모달리티를 함께 사용했을 때 촉각 이미지 단독 사용 대비 분류 정확도가 현저히 향상되었으며, end-to-end 모델보다 데이터 효율성과 일반화 성능이 우수함을 보였습니다.</li>
<li><strong>정책 학습을 위한 Sparsh-X 통합 (Sparsh-X for Policy Learning)</strong>:
<ul>
<li><strong>모방 학습(Imitation Learning)을 통한 플러그 삽입</strong>: 로봇이 Allegro hand와 Digit 360 센서를 사용하여 플러그를 소켓에 삽입하는 작업에서, Sparsh-X를 활용한 다중 감각 촉각 피드백이 정책 성공률을 크게 향상시켰습니다. 외부 시각 정보만 사용했을 때보다 500%, 촉각 이미지만 사용한 end-to-end 정책보다 63%의 성공률 향상을 보였습니다.</li>
<li><strong>시뮬레이션에서 실제 세계로의 촉각 적응(Sim-to-Real Tactile Adaptation)을 통한 손안 객체 회전</strong>: Hora [51]와 같은 시뮬레이션 훈련된 기본 정책 위에 ControlNet [52]을 활용하여 촉각 적응 모듈을 학습시켰습니다. 이는 객체의 물리적 특성(질량, 마찰 등) 변화에 대한 정책의 견고성을 높여 수직 표류(vertical drift)를 90% 감소시키고, 객체 슬립을 줄여 회전 안정성을 향상시켰습니다.</li>
</ul></li>
</ol>
<p>Sparsh-X는 다중 감각 촉각 정보를 통합함으로써 로봇 조작의 정밀성과 견고성을 크게 향상시킬 수 있음을 입증하며, 촉각 센싱 분야의 foundation models 개발에 중요한 발걸음을 내디뎠습니다.</p>
<hr>
</section>
<section id="detail-review" class="level1">
<h1>Detail Review</h1>
<section id="논문의-주요-내용-요약" class="level2">
<h2 class="anchored" data-anchor-id="논문의-주요-내용-요약">1. 논문의 주요 내용 요약</h2>
<center>
<img src="../../images/2025-08-21-tactile-beyond-pixel/Screenshot 2025-08-21 at 11.27.55 AM.png" width="100%">
</center>
<blockquote class="blockquote">
<p>Sparsh-X의 멀티센서 촉각 표현 융합 구조 예시. 이 구조는 Digit 360 센서로부터 얻은 촉각 이미지, 진동(오디오), 관성모션, 압력 신호를 입력으로 받아, 트랜스포머 기반 백본에서 이들을 융합하여 물체의 물리적 특성 및 접촉 상태를 나타내는 통합 표현을 학습한다.</p>
</blockquote>
<p>본 논문에서는 Meta/FAIR가 개발한 초고해상도 촉각 센서 Digit 360을 활용하여 4가지 촉각 모달리티(이미지, 오디오, 관성, 압력)를 통합하는 Sparsh-X라는 표현 학습 백본을 제안한다. 저자들은 약 100만 건의 접촉-조작 데이터(삽입, 미끄럼, 두드림, 회전 등 다양한 조작 행동)를 수집하여 자기 지도 학습으로 Sparsh-X를 사전학습시켰다. 이렇게 학습된 표현은 물체의 질량, 마찰, 힘 등의 물리적 특성을 추론할 수 있는 정보를 포함한다.</p>
<ul>
<li>제안 방식: Sparsh-X는 각 모달리티를 독립적인 트랜스포머 블록으로 인코딩한 후, 병목(Bottleneck) 토큰을 매개로 크로스-모달 퓨전을 수행하는 구조를 갖는다. 이를 통해 고해상도 촉각 이미지뿐 아니라 초음속 진동음, 가속도/자이로 센서 정보, 압력 신호 등 이질적인 데이터를 하나의 잠재 공간에 효과적으로 융합한다.</li>
<li>데이터: 양팔 로봇 손가락과 수동 집게에 장착한 Digit 360으로 다양한 환경에서 수집한 약 1M의 비라벨 접촉 데이터를 사용했다. 이 대규모 무라벨 데이터셋은 향후 유사한 연구를 위한 벤치마크로도 활용될 수 있다.</li>
<li>실험 과제: 학습된 표현은 두 가지 주요 실험에 적용되었다.
<ol type="1">
<li>흉내 학습(imitation learning)을 통한 플러그 삽입 과제(Allegro 로봇 손에 플러그를 꽂는 작업)와,</li>
<li>시뮬레이션-현실 간 촉각 적응을 통한 손안 회전 과제(컵 모양 물체를 손 안에서 회전시키는 작업)이다.</li>
</ol>
<ul>
<li>또한 물리적 속성 추론 과제(물체-행동 분류, 재질·질량·양 추정, 가해진 힘 추정 등)도 병행하여 평가했다.</li>
</ul></li>
<li>주요 결과:
<ul>
<li>Sparsh-X를 활용한 정책은 (a) 외부 카메라 정보만 사용한 정책 대비 성공률이 약 500%(즉 5배) 높고, (b) 촉각 이미지만 단독으로 사용한 종단간(end-to-end) 학습 대비 63% 높은 성공률을 보였다.</li>
<li>특히, 플러그 삽입 실험에서는 Sparsh-X 기반 정책이 20회 시도 중 90%의 성공률을 기록했으며, 기존 비전·촉각 방식 대비 성능이 크게 향상되었다.</li>
<li>손안 회전 과제에서는 Sparsh-X를 이용해 시뮬레이터에서 훈련된 정책을 적응시킨 결과, 물체의 수직 이동이 약 90% 감소하는 등 안정성이 크게 개선되었다.</li>
<li>물리 속성 추론에서는 Sparsh-X 표현을 사용해 48% 높은 정확도를 기록해, 기존 종단 학습 방식 대비 물리적 특성 이해 능력이 크게 향상됨을 보였다. 예를 들어, 모든 모달리티를 결합하면 힘 추정 오차가 평균 35mN로 촉각 영상만 사용했을 때보다 17% 감소했다.</li>
</ul></li>
</ul>
</section>
<section id="기술적-기여-및-한계-분석" class="level2">
<h2 class="anchored" data-anchor-id="기술적-기여-및-한계-분석">2. 기술적 기여 및 한계 분석</h2>
<ul>
<li>통합 멀티모달 백본: 본 논문의 핵심 기여는 Sparsh-X라는 최초의 멀티센서 촉각 표현 백본이다. 이전까지 촉각 표현 학습은 대부분 단일 모달리티(예: GelSight류 촉각 영상)나 모달리티별 개별 학습에 그쳤다. Sparsh-X는 네 가지 모달리티를 병목 기반 트랜스포머로 융합함으로써, 다양한 촉각 신호 간의 상호 보완적 정보를 포착한다. 특히, 단순 토큰 병합 방식을 사용한 기존 멀티모달 트랜스포머(MULSA)보다 계산 복잡도를 크게 낮추고, 네 가지 입력을 하나의 잠재 공간으로 압축할 수 있다.</li>
<li>대규모 자기 지도 학습: 약 100만 건의 실제 접촉 데이터를 활용한 SSL(자기 지도 학습)을 수행했다. 이를 통해 데이터 라벨링 비용 없이 일반화 가능한 촉각 표현을 학습하였다. 사전학습된 Sparsh-X 표현은 downstream 학습 시 데이터 효율을 크게 높여, 적은 레이블 샘플로도 안정적인 정책 학습이 가능하다.</li>
<li>정밀한 물리특성 학습: Sparsh-X는 물체의 질량, 마찰계수, 적용 힘 등 다양한 물리 속성을 포착하며, 이러한 속성 예측 성능이 크게 향상되었다. 실제로 본 논문에서는 물체-행동-면 분류, 재질·양 예측, 가해진 힘 추정 실험을 통해 Sparsh-X가 48% 더 높은 분류 정확도를 보임을 확인했다. 또한 정상(normal) 힘 추정 실험에서 모든 모달리티를 결합할 때 평균 오차가 17% 감소하여 힘 추정 정확도가 향상되었다.</li>
<li>정책 학습과 시뮬레이터 적응: Sparsh-X 표현은 실제 로봇 조작 정책 학습에도 적용되었다. 예를 들어, 플러그 삽입 과제에서 이미지+촉각의 조합으로 행동을 예측하는 종단간 모델에 Sparsh-X를 추가하자 성공률이 63% 증가했다. 또한, 시뮬레이터에서 훈련된 손안 물체 회전 정책에 Sparsh-X 기반의 촉각 적응 모듈(ControlNet)을 적용하자 물체의 미끄러짐이 현저히 줄어들었으며, 기존 방법 대비 수직 이동량 90% 감소 효과를 보였다. 이처럼 멀티센서 촉각 표현은 시뮬-실전 전이(sim-to-real) 문제 해결에도 기여함을 보였다.</li>
<li>한계점: 이 논문은 멀티센서 촉각의 잠재력을 보여주었으나 다음과 같은 한계도 지적한다. 첫째, 현재 사용된 데이터셋은 Digit 360 센서가 포함된 특정 플랫폼(예: Allegro 손, 수동 집게)에서 수집되었기 때문에 촉각 영상 모달리티의 다양성이 제한적일 수 있다. 센서별 광학적 특성 차이로 인해 일반화 성능이 제한될 우려가 있다. 둘째, 모든 실험에서 Sparsh-X 표현을 고정(frozen) 상태로 사용했으며, 다운스트림 과제별로 파인튜닝을 하지 않았다. 실제 적용 시 파인튜닝을 허용하면 개별 모달리티의 데이터 부족 문제를 보완하고 성능을 더욱 높일 수 있다. 셋째, 힘 추정 실험은 정상 방향 힘에 한정되었고, 다양한 접촉 기하나 전단력 추정은 다루지 않았다. 전단력은 Digit 360 구조(탄성돔) 때문에 모델링이 복잡하며, 본 논문에서는 별도 고려되지 않았다. 마지막으로, 대용량 트랜스포머를 학습하는 데 필요한 계산 자원과 데이터 수집 노력이 커서, 실제로 적용하는 데 비용 부담이 있다.</li>
</ul>
</section>
<section id="관련-연구와의-비교" class="level2">
<h2 class="anchored" data-anchor-id="관련-연구와의-비교">3. 관련 연구와의 비교</h2>
<ul>
<li>기존 촉각 기반 조작 연구: 전통적으로 로봇 촉각 연구에서는 GelSight, DIGIT 등 비전 기반 촉각 센서가 주로 사용되었다. 이런 센서는 고해상도 촉각 이미지를 제공해 물체 형상, 힘, 마찰 등을 추정할 수 있다. 그러나 대부분 작업은 단일 촉각 이미지에 의존하거나, 외부 카메라와 연계하는 방식이었다. 예를 들어, 다양한 조립, 표면 식별, 경로 추적 과제에서 GelSight류 센서가 활용되었지만, 영상 촉각만으로는 연속적인 접촉 동작의 미세한 변화를 완전히 포착하기 어렵다는 한계가 있다.</li>
<li>오디오 및 기타 모달리티 활용: 일부 연구에서는 접촉 시 발생하는 진동음(오디오)이나 외부 카메라 영상을 함께 이용하여 물체 특성을 추정하려 했다. 예컨대, 접촉 마이크를 이용해 재질을 식별하거나, 영상-오디오 합성 학습을 시도한 바 있다. 하지만 오디오 단일 모달로는 접촉과정의 복잡한 힘·변형 정보를 온전히 얻기 어렵고, 멀티모달 학습을 하더라도 주로 시각과 청각에만 국한되었다.</li>
<li>기존 멀티모달 접근: MULSA 등 최근 연구는 비전, 촉각 영상, 오디오를 함께 Transformer로 학습하는 방식으로 멀티모달 촉각 표현을 시도했다. 그러나 MULSA는 단순히 모든 토큰을 이어붙여(attention concatenation) 처리하기 때문에 계산 복잡도가 매우 커지는 문제가 있다. 또한 MimicTouch (Yu et al., 2024)와 같은 연구는 영상 촉각과 오디오를 개별적으로 SSL로 학습했지만, 모달리티 간 융합을 수행하지 않아 촉각 간 상호작용을 충분히 활용하지 못했다.</li>
<li>본 논문의 차별점: Sparsh-X는 네 가지 모달리티(이미지, 오디오, 관성, 압력)를 통합하는 점에서 기존 연구와 뚜렷한 차별성을 가진다. 특히, 병목 토큰 기반의 멀티모달 트랜스포머를 도입해 모달리티 간 정보를 효율적으로 융합하며, 종래 방식보다 계산 효율성과 표현력 모두 개선했다. 이는 기존 음성 기반 접근이나 단일센서 기반 모델이 다루지 못한 다양한 촉각 신호를 통합하여, 더 풍부한 촉각 표현을 학습할 수 있게 한다. 즉, 종전 연구가 해결하지 못했던 멀티센서 융합 방식을 제안함으로써, 로봇의 촉각 인지가 한층 발전되었다.</li>
</ul>
</section>
<section id="실제-응용-가능성-평가" class="level2">
<h2 class="anchored" data-anchor-id="실제-응용-가능성-평가">4. 실제 응용 가능성 평가</h2>
<ul>
<li>센서 및 하드웨어 측면: 제안된 방법은 Digit 360 센서를 전제로 한다. Digit 360은 Meta FAIR와 GelSight가 공개한 최첨단 촉각 센서로, 지름 14mm의 인조 손가락 모양이며 18개 이상의 센싱 기능을 통합한다[16]. 물리적 변형과 압력, 진동을 초고해상도로 감지하여 인간 수준의 정밀도로 터치를 디지털화할 수 있다[16]. GelSight 측은 이 센서를 내년부터 본격 공급할 예정이므로, 향후 산업용 로봇에도 장착이 가능해질 것으로 보인다. 그러나 현재는 비교적 실험실용 프로토타입 수준이므로, 실제 공장이나 서비스 환경에 배치하려면 추가적인 내구성 검증과 비용 고려가 필요하다.</li>
<li>시스템 요구 사항: Sparsh-X는 대규모 사전학습이 전제되므로 상당한 계산 자원과 데이터 수집이 필요하다. 산업 현장에서 도입하려면 개별 작업에 맞춰 추가 학습 또는 미세 조정(fine-tuning)이 필수적이다. 또한, Digit 360을 로봇 손가락에 부착하고 실시간으로 데이터를 처리하려면 고속 데이터 처리와 연산 하드웨어가 요구된다. 예를 들어 삽입 조립 작업에서는 센서-행동 반응 지연(latency)을 줄여야 하며, 산업용 로봇 암에 정확히 맞도록 센서 장착 방식을 고려해야 한다.</li>
<li>적용 가능성: 그럼에도 불구하고, Sparsh-X의 촉각 표현은 고정밀 작업에 유리하다. 플러그 삽입, 나사 체결 등 카메라로는 어려운 정밀 조립 작업이나, 조리 로봇의 섬세한 조작, 복잡 형상의 부품 검사 등에 활용할 수 있다. 또한, 센서 데이터와 학습을 병행하면 비전 정보가 불충분한 어둡거나 부분 가려진 환경에서도 안정적인 조작이 가능하다. 예컨대, 복잡한 회로기판 위 작은 부품을 집거나, 의료용 로봇이 미세한 조직을 다루는 작업 등에 응용될 수 있다. 실제로 본 논문에서도 플러그 삽입과 같은 산업적 의미가 있는 조작에서 큰 성능 향상이 관찰되었다.</li>
<li>제약 및 전망: 현재 연구 단계에서는 다양한 접촉 형태(경사진 표면, 전단력 등)에 대한 검증이 부족하며, 대량의 촉각 데이터 구축도 필요한 상태이다. 또한 실제 산업 환경에서는 센서의 내구성, 잡음·오염 문제, 모델의 추론 속도 등이 추가 과제가 될 수 있다. 그럼에도 불구하고 Sparsh-X는 촉각에 기반한 ‘기초 모델(Foundation Model)’ 접근의 가능성을 보여준다. 즉, 다양한 로봇 작업에 재사용 가능한 촉각 표현을 제공함으로써, 추후 도메인별 미세 조정으로 적용 범위를 확장할 수 있는 잠재력이 크다. 실제로 GelSight 측은 Digit 360을 로봇 촉각 연구의 다음 단계로 평가하며, 의료·가상현실·휴머노이드 등 다양한 분야에 응용할 수 있을 것으로 전망한다. 따라서 충분한 데이터와 연산 자원이 확보된다면, Sparsh-X 방식은 산업용·서비스용 로봇에서 섬세한 조작을 필요로 하는 다수 과제에 적용 가능할 것이다.</li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>