<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-10-30">
<meta name="description" content="Imitation Bootstrapped Reinforcement Learning">

<title>📃IBRL 리뷰 – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-bc185b5c5bdbcb35c2eb49d8a876ef70.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-5a614c35f1f90bfd0a5b2992298a8538.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#brief-review" id="toc-brief-review" class="nav-link active" data-scroll-target="#brief-review">Brief Review</a></li>
  <li><a href="#detail-review" id="toc-detail-review" class="nav-link" data-scroll-target="#detail-review">Detail Review</a>
  <ul class="collapse">
  <li><a href="#배경-및-동기" id="toc-배경-및-동기" class="nav-link" data-scroll-target="#배경-및-동기">1. 배경 및 동기</a></li>
  <li><a href="#ibrl-알고리즘-개요" id="toc-ibrl-알고리즘-개요" class="nav-link" data-scroll-target="#ibrl-알고리즘-개요">2. IBRL 알고리즘 개요</a></li>
  <li><a href="#이론적-기초" id="toc-이론적-기초" class="nav-link" data-scroll-target="#이론적-기초">3. 이론적 기초</a></li>
  <li><a href="#실험-설정" id="toc-실험-설정" class="nav-link" data-scroll-target="#실험-설정">4. 실험 설정</a></li>
  <li><a href="#시뮬레이션-실험-결과" id="toc-시뮬레이션-실험-결과" class="nav-link" data-scroll-target="#시뮬레이션-실험-결과">5. 시뮬레이션 실험 결과</a>
  <ul class="collapse">
  <li><a href="#robomimic-태스크" id="toc-robomimic-태스크" class="nav-link" data-scroll-target="#robomimic-태스크">5.1 Robomimic 태스크</a></li>
  <li><a href="#meta-world-태스크" id="toc-meta-world-태스크" class="nav-link" data-scroll-target="#meta-world-태스크">5.2 Meta-World 태스크</a></li>
  <li><a href="#주요-결과-요약" id="toc-주요-결과-요약" class="nav-link" data-scroll-target="#주요-결과-요약">5.3 주요 결과 요약</a></li>
  </ul></li>
  <li><a href="#실제-로봇-실험-및-적용성" id="toc-실제-로봇-실험-및-적용성" class="nav-link" data-scroll-target="#실제-로봇-실험-및-적용성">6. 실제 로봇 실험 및 적용성</a></li>
  <li><a href="#기여-한계-및-향후-연구-방향" id="toc-기여-한계-및-향후-연구-방향" class="nav-link" data-scroll-target="#기여-한계-및-향후-연구-방향">7. 기여, 한계 및 향후 연구 방향</a></li>
  <li><a href="#결론" id="toc-결론" class="nav-link" data-scroll-target="#결론">8. 결론</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📃IBRL 리뷰</h1>
  <div class="quarto-categories">
    <div class="quarto-category">rl</div>
    <div class="quarto-category">il</div>
  </div>
  </div>

<div>
  <div class="description">
    Imitation Bootstrapped Reinforcement Learning
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 30, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://arxiv.org/abs/2502.13406">Paper Link</a></li>
<li><a href="https://github.com/hengyuan-hu/ibrl">Code</a></li>
</ul>
<ol type="1">
<li>모방 학습(IL)과 강화 학습(RL)의 장점을 결합한 IBRL(Imitation Bootstrapped Reinforcement Learning)은 샘플 효율성을 높이는 새로운 RL 프레임워크를 제안합니다.</li>
<li>이 방법은 전문가 시연으로 훈련된 별도의 IL 정책을 활용하여 온라인 상호작용에서 더 나은 액션을 제안하고, RL 훈련 시 Q-함수의 목표 값 추정을 부트스트랩하여 탐색과 학습 효율을 크게 가속화합니다.</li>
<li>IBRL은 6가지 시뮬레이션 및 3가지 실제 로봇 작업에서 기존 방법들을 크게 능가하며, 특히 어려운 작업에서 탁월한 성능과 샘플 효율성을 입증했습니다.</li>
</ol>
<center>
<img src="../../images/2025-10-30-ibrl/0.png" width="100%">
</center>
<hr>
<section id="brief-review" class="level1">
<h1>Brief Review</h1>
<p>본 논문은 모방 학습(Imitation Learning, IL)과 강화 학습(Reinforcement Learning, RL)의 장점을 결합하여 샘플 효율성을 높이는 새로운 프레임워크인 IBRL(Imitation Bootstrapped Reinforcement Learning)을 제안합니다. 로봇 제어 태스크에서 IL은 샘플 효율성 때문에 널리 사용되지만, 모든 시나리오에 일반화할 수 있는 포괄적인 전문가 시연(demonstrations) 데이터를 수집하는 것은 비용이 많이 들고, 분포 변화(distribution shift) 발생 시 데이터 재수집이 필요하다는 단점이 있습니다. 반면 RL은 자율적인 자기 개선 절차로서 IL을 기반으로 발전할 수 있다면 매력적입니다.</p>
<p>IBRL의 핵심 방법론은 다음과 같습니다.</p>
<ol type="1">
<li><strong>독립적인 모방 정책 (<span class="math inline">\mu_\psi</span>) 훈련</strong>: 제공된 시연 데이터를 사용하여 별도의 독립적인 모방 학습 정책 <span class="math inline">\mu_\psi</span>를 먼저 훈련합니다. 이 IL 정책은 온라인 RL에서 일반적으로 사용되는 것보다 더 깊고 강력한 신경망을 활용할 수 있습니다.</li>
<li><strong>두 단계에서의 IL 정책 활용</strong>: 훈련된 IL 정책은 RL 훈련을 가속화하기 위해 두 가지 주요 단계에서 명시적으로 사용됩니다.
<ul>
<li><strong>온라인 상호작용 (Actor Proposal)</strong>: 온라인 환경과의 상호작용 단계에서, IL 정책과 현재 훈련 중인 RL 정책 (<span class="math inline">\pi_\theta</span>)은 각각 행동(<span class="math inline">a^{IL}, a^{RL}</span>)을 제안합니다. 에이전트는 학습 중인 Q-함수(Q-function)의 타겟 Q-함수 <span class="math inline">Q_{\phi'}</span>에 따라 더 높은 Q-값을 가지는 행동을 실행합니다. 즉, 다음 행동 <span class="math inline">a^*</span>는 다음과 같이 결정됩니다. <span class="math display">a^* = \underset{a \in \{a^{IL}, a^{RL}\}}{\text{argmax}} Q_{\phi'}(s, a)</span></li>
<li><strong>RL 훈련 (Bootstrap Proposal)</strong>: RL의 Q-값 업데이트를 위한 타겟 값을 계산할 때, 단순히 RL 정책의 타겟 네트워크 <span class="math inline">\pi_{\theta'}</span>에서 샘플링된 행동 <span class="math inline">a^{RL}_{t+1}</span>만 사용하는 대신, IL 정책에서 샘플링된 행동 <span class="math inline">a^{IL}_{t+1}</span>과 RL 정책에서 샘플링된 <span class="math inline">a^{RL}_{t+1}</span> 중 더 높은 Q-값을 가지는 행동을 사용하여 부트스트랩합니다. <span class="math display">Q_\phi(s_t, a_t) \leftarrow r_t + \gamma \underset{a' \in \{a^{IL}_{t+1}, a^{RL}_{t+1}\}}{\text{max}} Q_{\phi'}(s_{t+1}, a')</span></li>
<li>또한, 다른 선행 연구와 유사하게, RL 리플레이 버퍼(replay buffer)를 시연 데이터로 미리 채워서 정책이 첫 번째 온라인 성공을 거두기 전에 학습 신호를 제공합니다.</li>
</ul></li>
</ol>
<p>IBRL는 IL 정책을 RL 정책과 별도로 유지함으로써, 치명적인 망각(catastrophic forgetting)을 방지하기 위한 명시적인 정규화 손실(regularization loss)이나 복잡한 하이퍼파라미터 튜닝 없이 RL과 IL이 각자의 태스크에 가장 적합한 네트워크 아키텍처와 손실 함수를 사용할 수 있도록 합니다. 이를 통해 RL 정책이 초기 단계에서 미흡할 때 탐색(exploration) 품질과 가치 추정(value estimation)을 크게 향상시킬 수 있습니다.</p>
<p>본 논문은 또한 IBRL의 성능을 더욱 향상시키기 위한 아키텍처적 개선 사항들을 제안합니다:</p>
<ul>
<li><strong>Actor Dropout</strong>: 정책 네트워크(actor) <span class="math inline">\pi_\theta</span>에 Dropout을 적용하여 안정성과 샘플 효율성을 개선합니다.</li>
<li><strong>개선된 Vision Encoder 및 Critic 디자인</strong>: 이미지 입력으로부터 학습할 때, 기존의 얕은 ConvNet 대신 얕은 ViT(Vision Transformer) 기반 아키텍처를 사용하여 더 복잡한 태스크에서 성능 병목 현상을 해결합니다.</li>
</ul>
<p>IBRL은 6개의 시뮬레이션 태스크(Meta-World 및 Robomimic)와 3개의 실제 로봇 태스크(Lift, Drawer, Hang)에 걸쳐 다양한 난이도 수준에서 평가되었습니다. 모든 태스크는 희소한 0/1 보상(sparse 0/1 reward)을 사용합니다. IBRL은 모든 태스크에서 기존의 강력한 방법들을 능가하거나 동등한 성능을 보였으며, 특히 어려운 태스크에서 그 개선 폭이 두드러졌습니다. 예를 들어, 가장 어려운 시뮬레이션 태스크에서는 두 번째로 좋은 방법보다 거의 두 배의 성능을 보였고, 까다로운 실제 천 걸기(deformable cloth hanging) 태스크에서는 두 번째로 좋은 RL 방법보다 2.4배 더 나은 성능을 달성했습니다.</p>
</section>
<section id="detail-review" class="level1">
<h1>Detail Review</h1>
<blockquote class="blockquote">
<p>Imitation Bootstrapped Reinforcement Learning (IBRL) 논문 심층 리뷰</p>
</blockquote>
<section id="배경-및-동기" class="level2">
<h2 class="anchored" data-anchor-id="배경-및-동기">1. 배경 및 동기</h2>
<p>강화학습(RL)은 복잡한 제어 문제에서 뛰어난 성능을 보이지만, 샘플 효율성 및 탐색 어려움 때문에 실제 로봇 제어에는 널리 쓰이지 못해 왔다. 반면 모방학습(IL, 예: 행동 클로닝)은 전문가 시연 데이터를 통해 초기 정책을 효율적으로 학습할 수 있지만, 시연 데이터를 모두 커버하기 힘들고 배포 시 분포 차이 문제로 재수집이 필요하다. 따라서 소수의 시연만으로 시작해 자율적으로 성능을 개선할 수 있는 학습 기법이 요구된다.</p>
<p>기존 연구들은 대개 (1) 시연 데이터를 리플레이 버퍼에 삽입하여 학습 시 과대 샘플링하는 방식(RLPD: Reinforcement Learning from Prior Demonstrations), (2) 시연으로 RL 정책을 사전학습하고 이후 미세조정 시 추가 규제(loss)를 적용하는 방식, 또는 (3) 모델 기반 방법(MoDem)으로 시연을 통해 정책·비평자·모델을 모두 사전학습한 후, 모델 예측 제어로 강화학습하는 방식 등이 있다.</p>
<p>그러나 (1)의 방식은 IL이 일반화한 유익한 행동을 충분히 활용하지 못하고, (2)의 방식은 RL 과정에서 초기 지식을 잃지 않기 위한 하이퍼파라미터 튜닝이나 동일한 네트워크 구조 사용 제약이 필요하며, (3)의 모델 기반 접근은 계산 비용이 크다. 본 논문은 이러한 한계를 극복하기 위해 <strong>모방 학습 정책(IL 정책)</strong>을 강화학습에 직접 통합하여 샘플 효율을 높이는 새로운 프레임워크 <strong>IBRL</strong>을 제안한다.</p>
</section>
<section id="ibrl-알고리즘-개요" class="level2">
<h2 class="anchored" data-anchor-id="ibrl-알고리즘-개요">2. IBRL 알고리즘 개요</h2>
<p>IBRL의 핵심 아이디어는 (그림 1) 우선 전문가 시연으로 모방학습 정책(<span class="math inline">\mu_\psi</span>)을 학습하고, 이 정책을 RL 학습의 <strong>두 단계</strong>에 활용하는 것이다.</p>
<p>첫째, <strong>온라인 상호작용 단계(Actor Proposal)</strong>에서는 매 시점마다 IL 정책과 현재 학습 중인 RL 정책(<span class="math inline">\pi_\theta</span>)이 각각 행동 <span class="math display">a_{IL} \sim \mu_{\psi}(s),</span> <span class="math display">a_{RL} \sim \pi_{\theta}(s)</span>를 제안한다. 이 두 후보 행동을 타깃 Q-네트워크 <span class="math inline">Q_{\phi'}</span>로 평가하여 더 높은 Q값을 갖는 행동 <span class="math display">a^{*} = \arg\max_{a \in \{ a_{IL},a_{RL}\}}Q_{\phi'}(s,a)</span>를 실제 행동으로 선택한다(식 (1)). 이 방식으로 IL 정책이 초기 탐색에서 신뢰할 수 있는 행동을 지속적으로 제공함으로써, 희소 보상 환경에서 빠른 성공 경험을 얻을 수 있다.</p>
<p>둘째, <strong>RL 학습 단계(Bootstrap Proposal)</strong>에서는 Q-함수 업데이트 시 다음 상태에서의 최대 Q값을 계산할 때 IL 정책과 RL 정책이 제안하는 행동 중 더 높은 Q값을 갖는 쪽을 사용한다. 즉, 일반적인 TD 타깃 <span class="math display">r + \gamma Q'\left( s',\pi'(s') \right)</span> 대신에 <span class="math display">r + \gamma\max\{ Q'\left( s',a_{IL} \right),Q'\left( s',a_{RL} \right)\}</span> 형태로 값 함수를 부트스트래핑한다.</p>
<p>이를 통해 IL 정책이 제안하는 고품질 행동이 Q-값 학습에 직접 반영되어 학습 속도가 개선된다. 모듈화된 구조 덕분에 IL 정책과 RL 정책은 각자 최적화된 네트워크(예: ResNet-18 vs.&nbsp;ViT)로 독립적 학습이 가능하며, RL에 의한 초기 IL 지식 소실(catastrophic forgetting)을 우려하지 않아도 된다. 또한 초기 학습 신호를 제공하기 위해 리플레이 버퍼를 전문가 시연으로 미리 채우는 것은 종전 방법과 유사하게 적용된다.</p>
</section>
<section id="이론적-기초" class="level2">
<h2 class="anchored" data-anchor-id="이론적-기초">3. 이론적 기초</h2>
<p>IBRL은 표준 MDP <span class="math display">\left( \mathcal{S},\mathcal{A},T,R,\gamma \right)</span>를 가정하며, 오프-폴리시 RL(TD3/SAC)을 기반으로 한다. 비평자(<span class="math inline">Q_\varphi</span>) 네트워크는 강화학습 손실 <span class="math display">L(\varphi) = \left( r_{t} + \gamma Q_{\phi'}\left( s_{t + 1},\pi_{\theta'}\left( s_{t + 1} \right) \right) - Q_{\varphi}\left( s_{t},a_{t} \right) \right)^{2}</span>를 최소화하며, 정책(Actor) <span class="math inline">\pi_\theta</span>는 <span class="math display">L(\theta) = - Q_{\varphi}\left( s,\pi_{\theta}(s) \right)</span> 손실로 학습된다.</p>
<p>모방학습(IL) 정책 <span class="math inline">\mu_\psi</span>는 전문가 데이터 <span class="math inline">\mathcal{D}</span>에서 최대우도 또는 평균제곱오차로 행동을 복제하여 학습된다. IBRL은 먼저 이 데이터셋으로 <span class="math inline">\mu_\psi</span>를 학습하고, 그 후 강화학습 과정에 <span class="math inline">\mu_\psi</span>를 <code>참조 정책(reference policy)</code>으로 활용한다.</p>
<p>기존 연구 중 비슷한 아이디어로는, 사람이 만든 참조 정책을 온/오프-라인에서 사용하는 PEX, EfficientImitate 등이 있으나, 이들은 주로 탐색 보조에만 IL 정책을 사용하거나 저차원 관측에 제한되며 실험도 시뮬레이션에 한정되었다. IBRL은 IL 정책을 탐색과 학습 두 단계에 모두 적극적으로 활용하며 실제 로봇 태스크까지 평가한 점에서 차별화된다.</p>
</section>
<section id="실험-설정" class="level2">
<h2 class="anchored" data-anchor-id="실험-설정">4. 실험 설정</h2>
<p>저자들은 6가지 시뮬레이션 태스크와 3가지 실제 로봇 태스크에서 IBRL을 평가했다. 시뮬레이션에서는 희소 보상의 연속제어 문제를 다루며, 주로 <strong>픽&amp;플레이스</strong> 계열 과제를 사용하는 Robomimic 벤치마크(Stanford)와 Meta-World 벤치마크 환경을 선택했다.</p>
<ul>
<li><p><strong>Robomimic 태스크 (Lift, PickPlaceCan, NutAssemblySquare)</strong>: 블록을 들어올리기, 캔을 픽&amp;플레이스, 너트 조립이라는 3단계로 난이도가 증가한다. Lift는 간단하여 1개, Can은 보통하여 10개, Square는 어려워 50개의 전문가 시연을 사용했다. 관측은 이미지(픽셀) 및 로우-스테이트(로봇 관절 상태)를 병행하여 실험했다.</p></li>
<li><p><strong>Meta-World 태스크 (Assembly, BoxClose, CoffeePush, StickPull)</strong>: 주어진 실험군에서 무작위로 4개를 선정했다. 각각 어셈블리, 박스 닫기, 커피 푸시, 막대 잡아당기기로, 태스크당 3개의 스크립트 기반 전문가 시연을 사용했다. 상태공간은 이미지(픽셀)이다.</p></li>
</ul>
<p>비교 대상은 아래와 같다. Robomimic에서는 <strong>RLPD+</strong>(TD3 기반 구현, 데모 과대샘플링)와, BC 사전학습 후 규제 강화학습(BC+RLreg), SQIL(Synthetic Q-infilling) 등을 사용했다. Meta-World에서는 <strong>MoDem</strong>(모델 기반 RL with demonstrations) 및 RLPD+를 함께 비교했다. 모든 방법은 동일한 네트워크 구조와 하이퍼파라미터를 공유하여 공정 비교하였다.</p>
<p>실제 로봇 실험에서는 Franka 로봇팔을 사용하여 <strong>Lift, Drawer, Hang</strong> 과제를 수행했다. 각 과제별로 10~30회의 시연을 수집하였고, 매 방법에 동일한 상호작용 예산(스텝 수)과 정책 업데이트 횟수를 부여했다. 성공 여부는 룰 기반의 sparse 보상(성공 시 1, 아니면 0)으로 측정하였다.</p>
</section>
<section id="시뮬레이션-실험-결과" class="level2">
<h2 class="anchored" data-anchor-id="시뮬레이션-실험-결과">5. 시뮬레이션 실험 결과</h2>
<section id="robomimic-태스크" class="level3">
<h3 class="anchored" data-anchor-id="robomimic-태스크">5.1 Robomimic 태스크</h3>
<p>그림 1은 Robomimic의 Lift, PickPlaceCan(Can), NutAssemblySquare(Square) 과제에서 픽셀/스테이트 관측으로 IBRL과 RLPD+(기준선)를 비교한 학습 곡선이다. 그래프에서 빨간색 선이 IBRL, 파란색 선이 RLPD+를 나타내며, 점선은 IBRL 기본 변형(안티-사양)을 의미한다. Lift와 Can 환경에서는 IBRL이 훨씬 빠르게 성공률을 끌어올림을 볼 수 있다. 특히 단순한 Lift에서는 10K 단계 미만에서 100% 성공률에 도달하며, RLPD+보다 약 3배 빠른 수렴을 보인다.</p>
<p>그림 1의 오른쪽 상단 그래프(Can)는 IBRL이 20K 단계 내에 과제를 해결한 반면, RLPD+는 더 많은 단계가 필요함을 보여준다. Square는 가장 어려운 환경으로, 초기 학습이 매우 느리지만 IBRL이 계속 우세하다. 전반적으로 IBRL은 모든 Robomimic 과제에서 RLPD+를 크게 앞서며, 같은 시연 수로도 RLPD+보다 월등한 샘플 효율을 보인다.</p>
<center>
<img src="../../images/2025-10-30-ibrl/x3.png" width="80%">
</center>
<blockquote class="blockquote">
<p><em>그림 1:</em> Robomimic Lift, PickPlaceCan, NutAssemblySquare 과제에서 IBRL(빨간)과 RLPD+(파란)의 학습 성능 비교. 각 그래프는 성능(성공률)을 상호작용 스텝 수에 대해 보여준다. 모든 환경에서 IBRL이 더 빠르게 수렴하며 높은 성공률을 달성함을 확인할 수 있다.</p>
</blockquote>
<p>또한 표 1에 나타난 바와 같이, IBRL로 학습된 정책은 인간 시연보다도 평균 에피소드 길이가 짧아지는 경향을 보였다. 예를 들어 IBRL은 Lift, Can, Square에서 인간 전문가(48.3, 116.0, 150.8 스텝)보다 각각 3~2.2배 빠르게 과제를 완료했으며, 평균적으로는 약 2.3 스텝을 단축했다. 이는 IBRL이 RL을 통해 시연에서 본 동작을 넘어 효율적인 행동을 학습했음을 시사한다.</p>
<p>한편, 픽셀 기반 학습에서는 랜덤 쉬프트 데이터 증강과 손목 카메라 활용 덕분에 Lift와 Can에서 오히려 스테이트 기반보다 빠른 수렴이 관찰되었다. Square는 시야가 제한되는 복잡도로 인해 픽셀 학습이 어려웠지만, 그나마 IBRL은 다른 방법들보다 더 빠르게 정책을 개선했다.</p>
<p>예를 들어 Robomimic의 PickPlaceCan에서는 단 10회의 시연과 10만 단계의 상호작용만으로도, IBRL은 RLPD 대비 성공률이 약 6.4배 높게 나타났다. 이처럼 IBRL은 적은 시연 데이터로도 강화학습을 효과적으로 진행하여, 특히 난이도가 높은 과제에서 큰 성능 향상을 보인다.</p>
</section>
<section id="meta-world-태스크" class="level3">
<h3 class="anchored" data-anchor-id="meta-world-태스크">5.2 Meta-World 태스크</h3>
<p>그림 2는 Meta-World의 4개 과제(Assembly, Box Close, Coffee Push, Stick Pull)에서 IBRL(빨간), IBRL Basic(빨간 점선), MoDem(초록), RLPD+(파랑)의 성능을 비교한 것이다. 모든 그래프에서 가로축은 상호작용 스텝, 세로축은 성공률을 나타낸다. 결과를 보면 IBRL(빨간 실선)이 네 가지 과제 모두에서 다른 방법들을 앞선다. 특히 어려운 과제인 Assembly나 Stick Pull에서는 IBRL이 거의 100% 성공률에 근접하는 반면, MoDem과 RLPD+는 상당히 낮은 성공률에 머물렀다.</p>
<p>IBRL Basic(점선)은 인코더를 간단화한 변형으로, 단순 환경에서는 오히려 IBRL보다 우수하나, 복잡한 작업에서는 깊은 구조의 IBRL이 더 안정적임을 보여준다. 전반적으로 IBRL과 그 변형은 모든 Meta-World 과제를 성공적으로 해결했으나, MoDem은 4개 중 3개 환경에서 신뢰할 수 있는 해결률을 달성하지 못했다. 아울러 MoDem은 모델 학습 및 계획 단계 때문에 시간 비용이 150시간 이상 소요되지만, IBRL은 단순히 정책 학습만으로 더 빠르게 수렴하였다.</p>
<center>
<img src="../../images/2025-10-30-ibrl/1.png" width="100%">
</center>
<blockquote class="blockquote">
<p><em>그림 2:</em> Meta-World 과제(Assembly, Box Close, Coffee Push, Stick Pull)에서의 IBRL, MoDem, RLPD+ 성능 비교. 빨간색 실선이 IBRL, 점선이 IBRL Basic, 초록이 MoDem, 파랑이 RLPD+이다. 모든 과제에서 IBRL(빨간)이 빠르고 높은 성능을 보이며, 특히 난이도 높은 환경에서 격차가 두드러진다.</p>
</blockquote>
</section>
<section id="주요-결과-요약" class="level3">
<h3 class="anchored" data-anchor-id="주요-결과-요약">5.3 주요 결과 요약</h3>
<p>요약하면, IBRL은 6개 시뮬레이션 과제에서 두드러진 샘플 효율 개선을 보여준다. RLPD+와 같은 단순한 데모 과대샘플링 기법에 비해, IL 정책을 적극적으로 활용함으로써 초기 단계부터 고품질의 행동 후보를 얻고 더 빠른 탐색을 가능케 했다. 또한 IBRL Basic을 포함하여 다양한 구조에서도 안정적으로 우수한 성능을 내며, 모델 기반 MoDem보다 계산 효율성 측면에서도 유리하다. 이러한 결과는 <em>IBRL이 기존 기법 대비 더 높은 샘플 효율성과 최종 성능을 달성</em>했음을 뒷받침한다.</p>
</section>
</section>
<section id="실제-로봇-실험-및-적용성" class="level2">
<h2 class="anchored" data-anchor-id="실제-로봇-실험-및-적용성">6. 실제 로봇 실험 및 적용성</h2>
<p>IBRL의 실제 적용 가능성을 검증하기 위해 저자들은 3가지 실제 로봇 조작 과제를 설정했다. 과제는 Franka Panda 로봇팔로 수행되며, Lift(블록 들어올리기), Drawer(서랍 열기), Hang(천 걸기)으로 난이도가 증가한다. 초기 조건이나 로봇 시작 위치에 변이가 있으며, 각 과제별로 10~30회의 시연 데이터를 수집했다. Lift에서는 손목 카메라 시점을, Hang에서는 3인칭 카메라를 사용했다. 모든 방법은 동일한 네트워크 구조와 파라미터를 사용하고, 상호작용 예산도 과제 난이도에 맞추어 부여했다.</p>
<div style="display: flex; justify-content: center; align-items: center; gap: 5px;">
<p><img src="../../images/2025-10-30-ibrl/01.png" width="48%"> <img src="../../images/2025-10-30-ibrl/02.png" width="48%"></p>
</div>
<p>그림 8 및 표 I에 따르면, IBRL은 세 과제 모두에서 RLPD(RFT) 및 행동 복제(BC) 대비 우수한 성능을 보였다. <strong>Lift</strong> 과제에서는 8K 상호작용 단계 만에 IBRL이 100% 성공률을 달성했고, RLPD와 RFT는 각각 95%, 90%로 뒤를 이었다. 더 어려운 <strong>Lift Hard Eval</strong> 상황(블록이 손목 카메라 시야 가장자리에 놓임)에서도 IBRL은 95%의 성공률을 유지한 반면, BC는 0%로 성능이 급락했다. 이는 IBRL이 학습 중 다양한 초기 상태를 경험하며 분포 차이를 극복했음을 의미한다.</p>
<p><strong>Drawer</strong> 과제(서랍 열기)에서는 16K 단계 상호작용에서 IBRL이 95% 성공률로 가장 높았다. 실험을 조기 중단한 10K 단계 지점에서도 IBRL은 이미 100%에 도달했으나, RLPD와 RFT는 15% 이하로 극히 낮은 성공률이었다. IBRL은 데모가 충분하더라도 실제 환경의 세밀한 조작이 필요함을 빠르게 학습했음을 보여준다.</p>
<p>가장 어려운 <strong>Hang</strong> 과제(변형 천 걸기)에서는 IBRL만이 강건함을 증명했다. 30K 단계 상호작용 후 IBRL은 85% 성공률을 달성하여 BC(65%)보다 20%p 높았으나, RLPD와 RFT는 각각 15%, 25%에 머물렀다. 이는 천의 변형성을 예측하기 힘들어 랜덤 탐색이 거의 불가능한 상황에서, IBRL이 IL 정책으로부터 얻은 우수한 초기 행동을 꾸준히 활용해 정책을 빠르게 개선한 결과다. 그림 9의 롤아웃 예시에서도 IBRL은 더 적은 스텝 내에 성공했으며, BC가 실패하는 초기 조건에서도 성공함을 확인할 수 있다.</p>
<p>요약하면, 실제 환경에서도 IBRL은 단시간 내에 높은 성공률을 획득하여, 다른 RL 기법보다 상당히 높은 샘플 효율성을 입증했다. 특히 BC 기반 정책의 한계를 넘어서는 성능으로, 분포 변화나 노이즈에 의한 성능 저하 상황에서도 빠르게 회복할 수 있음을 보였다. 이는 IBRL이 실제 로봇 응용에서 <em>기존 IL 정책을 크게 뛰어넘는 성능 개선</em>을 신속히 가능케 한다는 것을 의미한다.</p>
</section>
<section id="기여-한계-및-향후-연구-방향" class="level2">
<h2 class="anchored" data-anchor-id="기여-한계-및-향후-연구-방향">7. 기여, 한계 및 향후 연구 방향</h2>
<p>IBRL은 로봇 강화학습 연구에 다음과 같은 기여를 한다. 첫째, <em>모방학습 정책을 명시적으로 강화학습에 통합</em>함으로써 시연 데이터의 이점을 극대화하고 RL 탐색 문제를 완화했다. 둘째, IL과 RL 정책의 분리로 각자 최적의 네트워크와 학습법을 사용할 수 있어, 보다 유연하고 효율적인 설계가 가능하다. 셋째, 폭넓은 시뮬레이션 및 실제 실험에서 SoTA 성능을 달성하여, 로봇 샘플 효율적 학습의 새로운 기준을 제시했다.</p>
<p>그러나 한계점도 존재한다. 본 연구의 실제 실험에서는 자동 초기화(autonomous reset)를 적용하지 않고 수동 리셋을 사용하여 안정적 평가를 보장했다. 실제 대규모 배포를 위해서는 자동 리셋 메커니즘이 필요하며, 이는 향후 과제로 남는다. 또한 본 연구에서는 BC를 사용한 단일 형태의 IL 정책을 실험했지만, IBRL 프레임워크는 이론상 어떠한 IL 기법과도 결합 가능하다. 향후에는 <strong>확산 정책(diffusion policies)</strong> 등 최신 IL 방법을 도입하거나, PEX/PILCO 등과의 비교 연구를 통해 성능을 더욱 개선할 수 있다.</p>
</section>
<section id="결론" class="level2">
<h2 class="anchored" data-anchor-id="결론">8. 결론</h2>
<p>IBRL은 제한된 전문가 시연 데이터를 바탕으로 <em>모방학습 정책을 참조 정책</em>으로 활용하여 샘플 효율적인 강화학습을 실현한 새로운 방법론이다. 실험 결과, IBRL은 기존 방법보다 적은 상호작용으로 높은 성공률을 달성했으며 특히 어려운 과제에서 효과가 두드러졌다. 실제 로봇 실험에서도 타 방법을 크게 앞서며, 로봇 제어 정책의 빠른 향상을 가능케 한다. 따라서 IBRL은 로봇 강화학습 연구에 있어 <strong>시연 학습과 강화학습의 결합</strong>을 새로운 방향으로 제시하며, 실제 로봇 적용 측면에서도 효율성과 성능을 크게 개선할 수 있는 방법으로 평가된다.</p>
<!--
- [[논문리뷰] Imitation Bootstrapped Reinforcement Learning](https://ropiens.tistory.com/265)
-->


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>