<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-05-29">
<meta name="description" content="Comparison of Tactile Sensors">

<title>ğŸ§©uSkin vs ReSkin â€“ Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-bc185b5c5bdbcb35c2eb49d8a876ef70.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-5a614c35f1f90bfd0a5b2992298a8538.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>


</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#ì„œë¡ -allegro-handì™€-ì´‰ê°-ì„¼ì„œì˜-ì¤‘ìš”ì„±" id="toc-ì„œë¡ -allegro-handì™€-ì´‰ê°-ì„¼ì„œì˜-ì¤‘ìš”ì„±" class="nav-link active" data-scroll-target="#ì„œë¡ -allegro-handì™€-ì´‰ê°-ì„¼ì„œì˜-ì¤‘ìš”ì„±">ì„œë¡ : Allegro Handì™€ ì´‰ê° ì„¼ì„œì˜ ì¤‘ìš”ì„±</a></li>
  <li><a href="#uskin-vs-reskin-ì£¼ìš”-íŠ¹ì„±-ë¹„êµ" id="toc-uskin-vs-reskin-ì£¼ìš”-íŠ¹ì„±-ë¹„êµ" class="nav-link" data-scroll-target="#uskin-vs-reskin-ì£¼ìš”-íŠ¹ì„±-ë¹„êµ">uSkin vs ReSkin: ì£¼ìš” íŠ¹ì„± ë¹„êµ</a></li>
  <li><a href="#ìµœê·¼-ì—°êµ¬-ë™í–¥-uskin-ë°-reskin-í™œìš©-ì‚¬ë¡€-20222025" id="toc-ìµœê·¼-ì—°êµ¬-ë™í–¥-uskin-ë°-reskin-í™œìš©-ì‚¬ë¡€-20222025" class="nav-link" data-scroll-target="#ìµœê·¼-ì—°êµ¬-ë™í–¥-uskin-ë°-reskin-í™œìš©-ì‚¬ë¡€-20222025">ìµœê·¼ ì—°êµ¬ ë™í–¥: uSkin ë° ReSkin í™œìš© ì‚¬ë¡€ (2022â€“2025)</a>
  <ul class="collapse">
  <li><a href="#uskin-ì„¼ì„œ-í™œìš©-ì—°êµ¬-ì‚¬ë¡€" id="toc-uskin-ì„¼ì„œ-í™œìš©-ì—°êµ¬-ì‚¬ë¡€" class="nav-link" data-scroll-target="#uskin-ì„¼ì„œ-í™œìš©-ì—°êµ¬-ì‚¬ë¡€">uSkin ì„¼ì„œ í™œìš© ì—°êµ¬ ì‚¬ë¡€</a></li>
  <li><a href="#reskin-ì„¼ì„œ-í™œìš©-ì—°êµ¬-ì‚¬ë¡€" id="toc-reskin-ì„¼ì„œ-í™œìš©-ì—°êµ¬-ì‚¬ë¡€" class="nav-link" data-scroll-target="#reskin-ì„¼ì„œ-í™œìš©-ì—°êµ¬-ì‚¬ë¡€">ReSkin ì„¼ì„œ í™œìš© ì—°êµ¬ ì‚¬ë¡€</a></li>
  </ul></li>
  <li><a href="#ê²°ë¡ -ë°-ì‹œì‚¬ì " id="toc-ê²°ë¡ -ë°-ì‹œì‚¬ì " class="nav-link" data-scroll-target="#ê²°ë¡ -ë°-ì‹œì‚¬ì ">ê²°ë¡  ë° ì‹œì‚¬ì </a></li>
  <li><a href="#comparison-of-uskin-and-reskin-tactile-sensors-for-the-allegro-hand" id="toc-comparison-of-uskin-and-reskin-tactile-sensors-for-the-allegro-hand" class="nav-link" data-scroll-target="#comparison-of-uskin-and-reskin-tactile-sensors-for-the-allegro-hand">Comparison of uSkin and ReSkin Tactile Sensors for the Allegro Hand</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#overview-of-the-tactile-sensors" id="toc-overview-of-the-tactile-sensors" class="nav-link" data-scroll-target="#overview-of-the-tactile-sensors">Overview of the Tactile Sensors</a>
  <ul class="collapse">
  <li><a href="#uskin-sensor-xela-robotics" id="toc-uskin-sensor-xela-robotics" class="nav-link" data-scroll-target="#uskin-sensor-xela-robotics">uSkin Sensor (XELA Robotics)</a></li>
  <li><a href="#reskin-sensor-meta-ai-cmu" id="toc-reskin-sensor-meta-ai-cmu" class="nav-link" data-scroll-target="#reskin-sensor-meta-ai-cmu">ReSkin Sensor (Meta AI &amp; CMU)</a></li>
  </ul></li>
  <li><a href="#comparison-of-performance-and-design" id="toc-comparison-of-performance-and-design" class="nav-link" data-scroll-target="#comparison-of-performance-and-design">Comparison of Performance and Design</a>
  <ul class="collapse">
  <li><a href="#sensitivity-and-resolution" id="toc-sensitivity-and-resolution" class="nav-link" data-scroll-target="#sensitivity-and-resolution">Sensitivity and Resolution</a></li>
  <li><a href="#accuracy-of-force-measurement" id="toc-accuracy-of-force-measurement" class="nav-link" data-scroll-target="#accuracy-of-force-measurement">Accuracy of Force Measurement</a></li>
  <li><a href="#reliability-and-durability" id="toc-reliability-and-durability" class="nav-link" data-scroll-target="#reliability-and-durability">Reliability and Durability</a></li>
  <li><a href="#response-time-and-sampling-rate" id="toc-response-time-and-sampling-rate" class="nav-link" data-scroll-target="#response-time-and-sampling-rate">Response Time and Sampling Rate</a></li>
  <li><a href="#fabrication-methods-and-integration" id="toc-fabrication-methods-and-integration" class="nav-link" data-scroll-target="#fabrication-methods-and-integration">Fabrication Methods and Integration</a></li>
  <li><a href="#sensing-principle-magnetic-field-based-detection" id="toc-sensing-principle-magnetic-field-based-detection" class="nav-link" data-scroll-target="#sensing-principle-magnetic-field-based-detection">Sensing Principle: Magnetic Field-Based Detection</a></li>
  </ul></li>
  <li><a href="#recent-research-applications-20222025" id="toc-recent-research-applications-20222025" class="nav-link" data-scroll-target="#recent-research-applications-20222025">Recent Research Applications (2022â€“2025)</a>
  <ul class="collapse">
  <li><a href="#studies-utilizing-uskin-in-robotics-research-20222025" id="toc-studies-utilizing-uskin-in-robotics-research-20222025" class="nav-link" data-scroll-target="#studies-utilizing-uskin-in-robotics-research-20222025">Studies Utilizing uSkin in Robotics Research (2022â€“2025)</a></li>
  <li><a href="#studies-utilizing-reskin-in-robotics-research-20222025" id="toc-studies-utilizing-reskin-in-robotics-research-20222025" class="nav-link" data-scroll-target="#studies-utilizing-reskin-in-robotics-research-20222025">Studies Utilizing ReSkin in Robotics Research (2022â€“2025)</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ğŸ§©uSkin vs ReSkin</h1>
  <div class="quarto-categories">
    <div class="quarto-category">tactile</div>
    <div class="quarto-category">sensor</div>
    <div class="quarto-category">magneto</div>
  </div>
  </div>

<div>
  <div class="description">
    Comparison of Tactile Sensors
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 29, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="ì„œë¡ -allegro-handì™€-ì´‰ê°-ì„¼ì„œì˜-ì¤‘ìš”ì„±" class="level2">
<h2 class="anchored" data-anchor-id="ì„œë¡ -allegro-handì™€-ì´‰ê°-ì„¼ì„œì˜-ì¤‘ìš”ì„±">ì„œë¡ : Allegro Handì™€ ì´‰ê° ì„¼ì„œì˜ ì¤‘ìš”ì„±</h2>
<p>Allegro HandëŠ” ì¸ê°„ ì†ì²˜ëŸ¼ ì •êµí•œ ì¡°ì‘ì„ ëª©í‘œë¡œ ê°œë°œëœ ë¡œë´‡ ì†ìœ¼ë¡œ, ì„¬ì„¸í•œ ë¬¼ì²´ ì¡°ì‘ì„ ìœ„í•´ <strong>ì´‰ê° ì„¼ì„œ</strong>ì˜ í†µí•©ì´ ì¤‘ìš”í•©ë‹ˆë‹¤. ìµœê·¼ ë§ì€ ì—°êµ¬ì—ì„œëŠ” ë¡œë´‡ ì†ê°€ë½ì— <strong>ì „ì í”¼ë¶€</strong>ë¥¼ ë¶€ì°©í•´ ì ‘ì´‰ í˜ê³¼ ë¯¸ë„ëŸ¬ì§ ë“±ì„ ê°ì§€í•˜ë ¤ê³  ì‹œë„í•˜ê³  ìˆìŠµë‹ˆë‹¤. íŠ¹íˆ Allegro Handì—ëŠ” XELA Roboticsì‚¬ì˜ <strong>uSkin</strong> ì„¼ì„œì™€ Meta AIê°€ ê°œë°œí•œ <strong>ReSkin</strong> ì„¼ì„œê°€ ì‚¬ìš©ë˜ê³  ìˆëŠ”ë°, ë‘ ì„¼ì„œëŠ” <strong>ìê¸°ì¥ ê¸°ë°˜ì˜ ì´‰ê° ì„¼ì„œ</strong>ë¼ëŠ” ê³µí†µì ì´ ìˆì§€ë§Œ ì„¤ê³„ ëª©ì ê³¼ êµ¬í˜„ ë°©ì‹ì—ì„œ ì°¨ì´ê°€ ìˆìŠµë‹ˆë‹¤. ì•„ë˜ì—ì„œëŠ” ì´ ë‘ ì„¼ì„œì˜ ê°ë„, ì •í™•ë„, ì‹ ë¢°ì„±, ì‘ë‹µì†ë„, ì œì¡° ë°©ì‹, ìê¸°ì¥ ê°ì§€ ì›ë¦¬ ì¸¡ë©´ì—ì„œ íŠ¹ì§•ì„ ë¹„êµí•˜ê³ , ìµœê·¼ 3ë…„ê°„(2022â€“2025) í•´ë‹¹ ì„¼ì„œë“¤ì„ í™œìš©í•œ ìµœì‹  ì—°êµ¬ ì‚¬ë¡€ë“¤ì„ ì •ë¦¬í•©ë‹ˆë‹¤.</p>
</section>
<section id="uskin-vs-reskin-ì£¼ìš”-íŠ¹ì„±-ë¹„êµ" class="level2">
<h2 class="anchored" data-anchor-id="uskin-vs-reskin-ì£¼ìš”-íŠ¹ì„±-ë¹„êµ">uSkin vs ReSkin: ì£¼ìš” íŠ¹ì„± ë¹„êµ</h2>
<p>Allegro Handì— í†µí•©ëœ uSkinê³¼ ReSkinì˜ í•µì‹¬ ì‚¬ì–‘ì„ ë¹„êµí•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤. uSkinì€ ë‹¤ìˆ˜ì˜ <strong>ì˜êµ¬ìì„-í™€ ì„¼ì„œ ë°°ì—´</strong>ë¡œ êµ¬ì„±ëœ ìƒìš© ì´‰ê° í”¼ë¶€ì´ê³ , ReSkinì€ <strong>ìì„± ì…ì ê¸°ë°˜ì˜ ìœ ì—°í•œ ì„¼ì„œ</strong>ë¡œ ê°œë°œë˜ì–´ ê³µê°œëœ ì €ë¹„ìš© ì´‰ê° í”¼ë¶€ì…ë‹ˆë‹¤. ë‘ ì„¼ì„œì˜ íŠ¹ì„±ì„ ë…¼ë¬¸ ê¸°ë°˜ ìë£Œë¡œ í•­ëª©ë³„ë¡œ ë¹„êµí•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 9%">
<col style="width: 39%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th><strong>ë¹„êµ í•­ëª©</strong></th>
<th><strong>uSkin (XELA Robotics)</strong></th>
<th><strong>ReSkin (Meta AI &amp; CMU)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>ê°ë„ (Sensitivity)</strong></td>
<td>ì•½ <strong>10&nbsp;mN(0.45&nbsp;kPa)</strong> ìˆ˜ì¤€ì˜ ë¯¸ì„¸í•œ í˜ê¹Œì§€ ê°ì§€ ê°€ëŠ¥ â€“ ì¸ê°„ í”¼ë¶€ì— ë¹„í•˜ë©´ ë–¨ì–´ì§€ì§€ë§Œ, ë¡œë´‡ ì´‰ê° ì„¼ì„œë¡œëŠ” ë§¤ìš° ë†’ì€ ê°ë„. ì‘ì€ ì ‘ì´‰ë„ ê²€ì¶œ ê°€ëŠ¥í•˜ì—¬ ì„¬ì„¸í•œ ë¬¼ì²´ ì·¨ê¸‰ì— ìœ ë¦¬.</td>
<td>ìˆ˜ì‹­&nbsp;mN ~ <strong>0.1â€“0.2&nbsp;N</strong> ì •ë„ì˜ í˜ ë³€í™”ë¥¼ êµ¬ë³„ ê°€ëŠ¥ â€“ ì˜ˆë¥¼ ë“¤ì–´ ì•½ <strong>20&nbsp;mL ë¬¼ì˜ ë¬´ê²Œ (~0.2&nbsp;N)</strong> ì¦ê°€ë„ ì„¼ì„œ ì¶œë ¥ ë³€í™”ë¡œ í¬ì°©. ì´ˆê¸° ì„¤ê³„ ëª©í‘œëŠ” 0.1&nbsp;Nì˜ í˜ ë¶„í•´ëŠ¥ì´ë©°, ì‹¤í—˜ì ìœ¼ë¡œë„ ê·¸ì— ì¤€í•˜ëŠ” ì‘ì€ í˜ì„ ê°ì§€í•¨ì„ ì‹œì—°.</td>
</tr>
<tr class="even">
<td><strong>ì •í™•ë„ (Accuracy)</strong></td>
<td>ê° ì´‰ê° ì†Œì(taxel)ë³„ <strong>3ì¶• í˜ ì¸¡ì •ì˜ ì •í™•ë„</strong>ê°€ ë†’ìŒ. ê°œë³„ ì„¼ì„œ ë‹¨ìœ„ ë³´ì • ì‹œ X,&nbsp;Y,&nbsp;Zì¶• í‰ê·  ì ˆëŒ€ì˜¤ì°¨ê°€ ì•½ <strong>0.2&nbsp;N</strong> ìˆ˜ì¤€ê¹Œì§€ ë‹¬ì„±ëœ ì‚¬ë¡€ê°€ ë³´ê³ ë¨. ê³µê°„ í•´ìƒë„ëŠ” taxel ê°„ê²© ~4.7&nbsp;mmë¡œ ì´˜ì´˜í•˜ì—¬ ì ‘ì´‰ ìœ„ì¹˜ë„ ë¹„êµì  ì •í™•íˆ íŒŒì•… ê°€ëŠ¥.</td>
<td><strong>ë¨¸ì‹ ëŸ¬ë‹ ë³´ì •</strong>ì„ í†µí•´ ë†’ì€ ì˜ˆì¸¡ ì •í™•ë„ í™•ë³´. ì˜ˆë¥¼ ë“¤ì–´ ìê°€-ë³´ì •(self-supervised) ê¸°ë²• ì ìš© ì‹œ <strong>ì ‘ì´‰ ì§€ì  ìœ„ì¹˜ ì˜¤ì°¨ ì•½ 0.7&nbsp;mm</strong>, í˜ í¬ê¸° ì¶”ì • ì˜¤ì°¨ ì•½ <strong>0.44&nbsp;N</strong> ìˆ˜ì¤€ê¹Œì§€ ì„±ëŠ¥ í–¥ìƒì´ ë³´ê³ ë¨. ì´ˆê¸° ì„¼ì„œ ê°„ í¸ì°¨ê°€ í¬ì§€ë§Œ, ë‹¤ì¤‘ ì„¼ì„œ í•™ìŠµê³¼ ë³´ì •ìœ¼ë¡œ <strong>84%</strong> ì´ìƒì˜ ë¶„ë¥˜ ì •í™•ë„ì™€ ë‚®ì€ MSEë¥¼ ë‹¬ì„±í•¨.</td>
</tr>
<tr class="odd">
<td><strong>ì‹ ë¢°ì„± (Reliability)</strong></td>
<td><strong>ì¼ê´€ëœ ì¶œë ¥ê³¼ ë‚´êµ¬ì„±</strong>ì„ ê°–ì¶˜ í¸ì´ë‚˜, <strong>ê°•í•œ ì™¸ë¶€ ìê¸°ì¥</strong>ì— ë¯¼ê°í•˜ì—¬ êµë€ì„ ë°›ì„ ìˆ˜ ìˆìŒ. ê° ì„¼ì„œëŠ” ê²¬ê³ í•˜ê²Œ íŒ¨í‚¤ì§•ë˜ì–´ ì¥ê¸°ê°„ ì‚¬ìš© ê°€ëŠ¥í•˜ë‚˜, ìì„-ì„¼ì„œì˜ ì¡°ë¦½ í¸ì°¨ë¡œ ì„¼ì„œë§ˆë‹¤ ë³´ì •ê°’ ì°¨ì´ê°€ ë°œìƒí•  ìˆ˜ ìˆìŒ. ì œì¡° ê³µì •ìƒ ìˆ˜ì‘ì—… ì¡°ë¦½ìœ¼ë¡œ ì¸í•œ ê°œì²´ê°„ ì„±ëŠ¥ í¸ì°¨ë¥¼ ì •ë°€ ë³´ì •í•˜ì—¬ ì‚¬ìš©.</td>
<td><strong>ë‚´êµ¬ì„±ê³¼ êµì²´ ìš©ì´ì„±</strong>ì„ ê³ ë ¤í•œ ì„¤ê³„. ë¶€ë“œëŸ¬ìš´ ì„¼ì„œ ì¸µì´ ë§ˆëª¨ë˜ë©´ ì‰½ê²Œ <strong>êµì²´</strong>í•  ìˆ˜ ìˆê³ , í•œ ê°œì˜ ì„¼ì„œ íŒ¨ë“œê°€ <strong>5ë§Œ íšŒ ì´ìƒì˜ ì ‘ì´‰</strong>ì—ë„ ì„±ëŠ¥ì´ í¬ê²Œ ì €í•˜ë˜ì§€ ì•ŠìŒì„ ê²€ì¦. ë‹¤ë§Œ ìƒˆë¡œìš´ ì„¼ì„œ ë§‰ êµì²´ ì‹œë§ˆë‹¤ ë¯¸ì„¸í•œ íŠ¹ì„± ì°¨ì´ê°€ ìˆìœ¼ë¯€ë¡œ, ìì²´ MLê¸°ë°˜ ë³´ì •ìœ¼ë¡œ ì„¼ì„œ ê°„ í¸ì°¨ì™€ ì‹œê°„ì— ë”°ë¥¸ ë³€í™”ì— ëŒ€ì‘í•¨.</td>
</tr>
<tr class="even">
<td><strong>ì‘ë‹µì†ë„ (Response Time)</strong></td>
<td><strong>ì „ìì‹ Hall ì„¼ì„œ</strong>ë¡œ ì‹¤ì‹œê°„ ì—°ì† ì¸¡ì •ì´ ê°€ëŠ¥í•˜ì—¬ ì‘ë‹µì†ë„ê°€ ë§¤ìš° ë¹ ë¦„. ì´ë¡ ì ìœ¼ë¡œ kHz ëŒ€ì—­ê¹Œì§€ë„ ì¸¡ì • ê°€ëŠ¥í•˜ë©°, ì¼ë°˜ì ì¸ ë¹„ì „ ê¸°ë°˜ ì´‰ê°ì„¼ì„œ(30â€“60&nbsp;Hz)ì— ë¹„í•´ ì›”ë“±íˆ ë†’ì€ <strong>ìƒ˜í”Œë§ ì£¼íŒŒìˆ˜</strong>ë¥¼ ì§€ì›. ì—¬ëŸ¬ ê°œì˜ taxelì„ ë™ì‹œì— ì½ì„ ë•Œë„ ìˆ˜ë°±&nbsp;Hz ì´ìƒì˜ ì†ë„ë¥¼ ìœ ì§€í•˜ì—¬ ë¡œë´‡ ì œì–´ì— í™œìš©í•  ìˆ˜ ìˆìŒ.</td>
<td><strong>ê³ ì† ìƒ˜í”Œë§ ê°€ëŠ¥</strong> (ì„¤ê³„ ëª©í‘œ â‰¥100&nbsp;Hz). ì‹¤ì œ ì‘ìš©ì—ì„œ <strong>250&nbsp;Hz</strong>ë¡œ ë°ì´í„° ìˆ˜ì§‘ì„ ì‹œì—°í•œ ë°” ìˆìœ¼ë©°, ë‹¤ìˆ˜ ì„¼ì„œë¥¼ ì—°ê²°í•œ ê²½ìš°ì—ë„ 100â€“200&nbsp;Hz ìˆ˜ì¤€ìœ¼ë¡œ ì•ˆì •ì ìœ¼ë¡œ ë™ì‘í•¨. ì‘ë‹µ ì‹œê°„ì€ ìˆ˜ ms ë‹¨ìœ„ë¡œ ì¸ê°„ ì´‰ê°ë³´ë‹¤ë„ ë¹ ë¥¸ í¸ì´ì–´ì„œ ì‹¤ì‹œê°„ í”¼ë“œë°± ì œì–´ì— í™œìš©í•  ìˆ˜ ìˆìŒ.</td>
</tr>
<tr class="odd">
<td><strong>ì„¼ì„œ ì œì¡° ë°©ì‹</strong> <br> (Fabrication)</td>
<td>ê° ì´‰ê° íŒ¨ë“œë§ˆë‹¤ <strong>ì˜êµ¬ìì„ì„ í¬í•¨í•œ ì—°ì„± ê³ ë¬´ì¸µ</strong>ê³¼ ê·¸ ì•„ë˜ <strong>ì†Œí˜• Hall IC ì¹©</strong>ìœ¼ë¡œ êµ¬ì„±. 4Ã—4 ê²©ì ë“±ì˜ ëª¨ë“ˆ í˜•íƒœë¡œ ì œì‘ë˜ì–´ ê³¡ë©´ìš©(ì†ê°€ë½ ë 30 taxel)ê³¼ í‰ë©´ìš©(16 taxel ë“±) íŒ¨ë“œë¡œ ì œê³µë¨. ìì„-ì—˜ë¼ìŠ¤í† ë¨¸ ë¶€ì°©ê³¼ ì¹© íŒ¨í‚¤ì§• ê³µì •ì— <strong>ìˆ˜ì‘ì—… ì¡°ë¦½</strong>ì´ í•„ìš”í•˜ë©°, ì´ë¡œ ì¸í•´ ìƒì‚° ë‹¨ê°€ì™€ ê°œì²´ ê°„ íŠ¹ì„± í¸ì°¨ê°€ ë°œìƒí•˜ëŠ” ë¬¸ì œê°€ ì§€ì ë¨.</td>
<td><strong>ìœ ì—°í•œ ì‹¤ë¦¬ì½˜ í”¼ë¶€</strong>ì— <strong>ë¬´ì‘ìœ„ ìì„± ì…ì</strong>ë¥¼ í˜¼í•©Â·ê²½í™”í•˜ì—¬ ë§Œë“œëŠ” ì–‡ì€ íŒ¨ì¹˜í˜• ì„¼ì„œ. ì œì‘ì‹œ 3D í”„ë¦°íŒ…ëœ ëª°ë“œì— ì…ì-ì‹¤ë¦¬ì½˜ í˜¼í•©ë¬¼ì„ ë¶“ê³  <strong>ì™¸ë¶€ì—ì„œ ê²©ì í˜•íƒœë¡œ ìí™”</strong>í•˜ì—¬ ìê¸° ì„±ì§ˆì„ ë¶€ì—¬. ê²½í™”ëœ í”¼ë¶€ë¥¼ íšŒë¡œ ê¸°íŒ ìœ„ì— ë¶€ì°©í•˜ì—¬ ì‚¬ìš©í•˜ë©°, ê¸°íŒì—ëŠ” ì†Œí˜• <strong>3ì¶• ìë ¥ê³„ ì¹©</strong>(5ê°œ ë°°ì—´)ì´ ì¥ì°©ë˜ì–´ ìˆìŒ. ì „ì²´ ì„¤ê³„ íŒŒì¼ê³¼ ì œì¡°ë²•ì´ ì˜¤í”ˆì†ŒìŠ¤ë¡œ ê³µê°œë˜ì–´ ìˆì–´ ì†ì‰¬ìš´ ì œì‘ê³¼ ìˆ˜ì •ì´ ê°€ëŠ¥í•˜ë©°, <strong>ì„¼ì„œë§‰ê³¼ íšŒë¡œë¥¼ ë¶„ë¦¬</strong>í•˜ì—¬ ì†ìƒ ì‹œ í”¼ë¶€ë§Œ êµì²´í•˜ë„ë¡ ì„¤ê³„ë¨.</td>
</tr>
<tr class="even">
<td><strong>ìê¸°ì¥ ë³€í™” ì¸ì‹ ì›ë¦¬</strong> <br> (Magnetic sensing principle)</td>
<td><strong>ì˜êµ¬ìì„</strong>ì´ ì™¸ë ¥ì— ë”°ë¼ ë¯¸ì„¸ ì´ë™í•˜ë©´ì„œ ë°œìƒí•˜ëŠ” <strong>ìê¸°ì¥ ë³€í™”</strong>ë¥¼ ë°”ë¡œ ì•„ë˜ì˜ <strong>í™€ íš¨ê³¼ ì„¼ì„œ</strong>ê°€ ê°ì§€í•˜ëŠ” ë°©ì‹. ìì„ì´ ëˆŒë¦¬ê±°ë‚˜ ë°€ë¦¬ë©´ X,&nbsp;Y,&nbsp;Z ë°©í–¥ ìê¸°ì¥ ì„¸ê¸°ê°€ ë³€í•˜ê³ , ì´ë¥¼ 3ì¶• í˜ (ë²•ì„ ì•• + ì „ë‹¨ë ¥) ì‹ í˜¸ë¡œ ë³€í™˜í•˜ì—¬ ì¶œë ¥í•¨. ê° taxelì´ êµ­ë¶€ì ì¸ ì ‘ì´‰ë ¥ì„ ë²¡í„° í˜•íƒœë¡œ ì¸¡ì •í•˜ë¯€ë¡œ ë¬¼ì²´ì˜ ë¯¸ë„ëŸ¬ì§ ë°©í–¥ì´ë‚˜ ì ‘ì´‰ ì§€í˜•ì„ íŒŒì•…í•  ìˆ˜ ìˆìŒ.</td>
<td><strong>ë¶„ë§ ìì„</strong>ë“¤ì´ í¬í•¨ëœ íƒ„ì„±ì²´ ë§‰ì´ ë³€í˜•ë  ë•Œ ì£¼ë³€ì— í˜•ì„±ëœ <strong>ìê¸°ì¥ì˜ ë°€ë„ ë¶„í¬ ë³€í™”</strong>ë¥¼ <strong>ìë ¥ ì„¼ì„œ</strong>ë“¤ì´ ì½ì–´ë‚´ëŠ” ë°©ì‹. ë§ë‘í•œ í”¼ë¶€ ìì²´ê°€ ìì„±ì„ ë ê³  ìˆì–´ ì ‘ì´‰ì— ì˜í•´ â€œì°Œê·¸ëŸ¬ì§€ë©´â€ ìë ¥ê³„ì— ì½íˆëŠ” ìê¸° ì‹ í˜¸ê°€ ë³€í•˜ë©°, ì´ë¥¼ ì‚¬ì „ì— í•™ìŠµëœ ëª¨ë¸ì´ ë¶„ì„í•´ í˜ì˜ í¬ê¸°ì™€ ìœ„ì¹˜ë¥¼ ì¶”ì •í•¨. ì„¼ì„œë§‰ì´ ì—°ì†ì  ë¶„í¬ì²´ì´ë¯€ë¡œ <strong>ë„“ì€ ë©´ì </strong>ì—ì„œë„ ì—¬ëŸ¬ ì ‘ì ì˜ ìœ„ì¹˜ë¥¼ ê³„ì‚°ì ìœ¼ë¡œ <strong>ì¶”ë¡ </strong>í•  ìˆ˜ ìˆë‹¤ëŠ” ì¥ì ì´ ìˆìŒ.</td>
</tr>
</tbody>
</table>
<p><strong>ì£¼ì„:</strong> ìœ„ í‘œì˜ ë‚´ìš©ì€ã€9ã€‘ã€13ã€‘ã€17ã€‘ã€19ã€‘ã€21ã€‘ã€22ã€‘ã€25ã€‘ã€32ã€‘ ë“±ì˜ ì¶œì²˜ì—ì„œ ë°œì·Œ ë° ìš”ì•½í•œ ê²ƒì…ë‹ˆë‹¤.</p>
</section>
<section id="ìµœê·¼-ì—°êµ¬-ë™í–¥-uskin-ë°-reskin-í™œìš©-ì‚¬ë¡€-20222025" class="level2">
<h2 class="anchored" data-anchor-id="ìµœê·¼-ì—°êµ¬-ë™í–¥-uskin-ë°-reskin-í™œìš©-ì‚¬ë¡€-20222025">ìµœê·¼ ì—°êµ¬ ë™í–¥: uSkin ë° ReSkin í™œìš© ì‚¬ë¡€ (2022â€“2025)</h2>
<p>ìµœê·¼ 3ë…„ê°„ uSkin ë˜ëŠ” ReSkin ì„¼ì„œë¥¼ í™œìš©í•œ ëŒ€í‘œì ì¸ ì—°êµ¬ë“¤ì„ ë¶„ì•¼ë³„ë¡œ ì •ë¦¬í•˜ë©´ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤. ê° ì—°êµ¬ëŠ” ì´‰ê° ì„¼ì„œì˜ ë°ì´í„°ë¥¼ í™œìš©í•˜ì—¬ ë¡œë´‡ì˜ ë¬¼ì²´ ì¸ì§€ë‚˜ ì¡°ì‘ ëŠ¥ë ¥ì„ í–¥ìƒì‹œí‚¤ëŠ” ë°©í–¥ìœ¼ë¡œ ì´ë£¨ì–´ì§€ê³  ìˆìœ¼ë©°, íŠ¹íˆ <strong>ìê¸°ì¥ ê¸°ë°˜ ì´‰ê°ì„¼ì„œ + ë¨¸ì‹ ëŸ¬ë‹</strong>ì˜ ê²°í•©ì´ë¼ëŠ” ê³µí†µëœ íë¦„ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
<section id="uskin-ì„¼ì„œ-í™œìš©-ì—°êµ¬-ì‚¬ë¡€" class="level3">
<h3 class="anchored" data-anchor-id="uskin-ì„¼ì„œ-í™œìš©-ì—°êµ¬-ì‚¬ë¡€">uSkin ì„¼ì„œ í™œìš© ì—°êµ¬ ì‚¬ë¡€</h3>
<ul>
<li><p><strong>ë¡œë´‡ ê·¸ë¦½ ë¯¸ë„ëŸ¼ ê°ì§€ (ê·¸ë¦½ ì•ˆì •ì„± íŒë‹¨)</strong> â€“ <em>â€œA Model-Free Approach to Fingertip Slip and Disturbance Detection for Grasp Stability Inferenceâ€</em> (Kitouni ë“±, 2023). ì´ ì—°êµ¬ì—ì„œëŠ” Allegro Handì˜ ëª¨ë“  ì†ê°€ë½ì— uSkin ì´‰ê° í”¼ë¶€ë¥¼ ë¶€ì°©í•˜ì—¬ <strong>ë¬¼ì²´ë¥¼ ì¡ì€ ìƒíƒœì—ì„œ ë°œìƒí•˜ëŠ” ë¯¸ë„ëŸ¼(Slip) ë° ì™¸ë¶€ ë°©í•´</strong>ë¥¼ ê°ì§€í•˜ì˜€ìŠµë‹ˆë‹¤. ì´ 368ê°œì˜ 3ì¶• ì´‰ê° ì†Œìê°€ ì†ë°”ë‹¥ê³¼ ì†ê°€ë½ ë§ˆë””, ì†ê°€ë½ ëì„ ë®ë„ë¡ ë°°ì¹˜ë˜ì—ˆìœ¼ë©°, ë³„ë„ì˜ ë³µì¡í•œ ë³´ì • ì—†ì´ <strong>ì„¼ì„œ ì¶œë ¥ ì‹ í˜¸ì˜ ë³€í™” íŒ¨í„´</strong>ë§Œìœ¼ë¡œ ë¯¸ë„ëŸ¼ ì—¬ë¶€ë¥¼ íŒë³„í•˜ëŠ” <strong>ëª¨ë¸ í”„ë¦¬ ì ‘ê·¼ë²•</strong>ì„ ì œì•ˆí–ˆìŠµë‹ˆë‹¤. ë‹¤ì–‘í•œ <strong>ì •ë°€ ì¥ê¸° ì‹¤í—˜</strong>ì„ í†µí•´ ì œì•ˆëœ ì§€í‘œê°€ ì†ê°€ë½ë³„ ë¯¸ë„ëŸ¼ ë¶ˆì•ˆì •ì„±ì„ ì˜ ë‚˜íƒ€ëƒ„ì„ ë³´ì˜€ê³ , ì´ë¥¼ í™œìš©í•´ ê°œë³„ ì†ê°€ë½ì— <strong>ëŠ¥ë™ì ì¸ ì•ˆì •í™” í”¼ë“œë°±</strong>ì„ ì¤„ ìˆ˜ ìˆìŒì„ í™•ì¸í•˜ì˜€ìŠµë‹ˆë‹¤. í•´ë‹¹ ê²°ê³¼ëŠ” ë¡œë´‡ì´ ë¬¼ì²´ë¥¼ ë†“ì¹˜ê¸° ì „ì— <strong>ì´‰ê°ìœ¼ë¡œ ë¯¸ë„ëŸ¬ì§ì„ íƒì§€</strong>í•˜ì—¬ ê·¸ë¦½ì„ ì¡°ì •í•˜ëŠ” ì „ëµì— ê¸°ì—¬í•©ë‹ˆë‹¤.</p></li>
<li><p><strong>ì „ì²´ ì† ì´‰ê° í˜ ì¶”ì • ë° ì œì–´</strong> â€“ <em>â€œInteraction force estimation for tactile sensor arrays: toward tactile-based interaction control for robotic fingersâ€</em> (Chelly ë“±, 2024). ë³¸ ì—°êµ¬ëŠ” Allegro Handì— ë¶€ì°©ëœ ë‹¤ìˆ˜ì˜ uSkin ì„¼ì„œë¥¼ <strong>ì¼ê´„ ë³´ì •í•˜ì—¬ ì „ì—­ì ì¸ 3ì°¨ì› í˜ ë¶„í¬</strong>ë¥¼ ì¶”ì •í•˜ê³ , ì´ë¥¼ ë¡œë´‡ ì œì–´ì— ì§ì ‘ í†µí•©í•œ ì‚¬ë¡€ì…ë‹ˆë‹¤. ì €ìë“¤ì€ í‰ë©´ íŒ¨ë“œì™€ ê³¡ë©´ íŒ¨ë“œê°€ í˜¼í•©ëœ ë³µì¡í•œ ë°°ì—´ì˜ <strong>Xela uSkin ì´‰ê° í”¼ë¶€</strong>ë¥¼ í•œ ë²ˆì˜ ë°ì´í„° ìˆ˜ì§‘ìœ¼ë¡œ íš¨ìœ¨ì ìœ¼ë¡œ ë³´ì •í•˜ëŠ” <strong>ë°ì´í„° íš¨ìœ¨ì  ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ê¸°ë²•</strong>ì„ ì œì•ˆí•˜ì˜€ìŠµë‹ˆë‹¤. ë³´ì •ëœ ì´‰ê°ì„¼ì„œ ë°°ì—´ë¡œë¶€í„° ì–»ì€ <strong>ì •í™•í•œ ì ‘ì´‰ë ¥ ì¶”ì •ì¹˜</strong>ë¥¼ ë¡œë´‡ ì†ê°€ë½ì˜ ìƒí˜¸ì‘ìš© í˜ ì œì–´(loop)ì— ì…ë ¥í•˜ì—¬, ì™¸ë¶€ í˜ì„ ì¼ì •í•˜ê²Œ ìœ ì§€í•˜ê±°ë‚˜ ì œí•œí•˜ëŠ” <strong>í˜ ì œì–´ ì‘ì—…</strong>ì„ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤. ì‹¤í—˜ ê²°ê³¼, ì œì•ˆ ê¸°ë²•ì€ ì„¼ì„œ ë°°ì—´ ì „ë°˜ì— ê±¸ì³ í‰ê·  <strong>0.1â€“0.2&nbsp;N ìˆ˜ì¤€ì˜ ì˜¤ì°¨</strong>ë¡œ í˜ì„ ì¬êµ¬ì„±í•  ìˆ˜ ìˆì—ˆê³ , ì´ë¥¼ ì´ìš©í•œ í˜ ì¡°ì ˆì´ ê°€ëŠ¥í•œ ê²ƒì„ ë³´ì—¬ì£¼ì–´ ì„¬ì„¸í•œ í˜ ì¡°ì ˆì´ ìš”êµ¬ë˜ëŠ” ì‘ì—…(ì˜ˆ: ê¹¨ì§€ê¸° ì‰¬ìš´ ë¬¼ì²´ ì¡ê¸°)ì— ìœ ìš©í•œ ì ‘ê·¼ì„ì„ ì‹œì‚¬í–ˆìŠµë‹ˆë‹¤.</p></li>
<li><p><strong>ìê°€ ì§€ë„í•™ìŠµ ê¸°ë°˜ ì´‰ê°í‘œí˜„ í•™ìŠµ</strong> â€“ <em>â€œSelf-supervised perception for tactile skin covered dexterous hands (Sparsh-skin)â€</em> (Sharma ë“±, 2025). ì´ ì—°êµ¬ëŠ” <strong>ìê¸°ì¥ ê¸°ë°˜ ì´‰ê° í”¼ë¶€ì˜ ë³µì¡í•œ ì‹œê³„ì—´ ì‹ í˜¸</strong>ë¡œë¶€í„° ì˜ë¯¸ ìˆëŠ” í‘œí˜„ì„ í•™ìŠµí•˜ê¸° ìœ„í•œ <strong>ìê¸° ì§€ë„(self-supervised) í•™ìŠµê¸°ë²•</strong>ì„ ì œì•ˆí–ˆìŠµë‹ˆë‹¤. Allegro Handì˜ ì†ë°”ë‹¥, ì†ê°€ë½ ë§ˆë””, ì†ê°€ë½ ëì— ê±¸ì³ Xela uSkin ì„¼ì„œë¥¼ ë¶„ì‚° ë°°ì¹˜í•˜ì—¬ ì•½ 4ì‹œê°„ ë¶„ëŸ‰ì˜ ë‹¤ì–‘í•œ ì ‘ì´‰ ë°ì´í„°ë¥¼ ìˆ˜ì§‘í•œ ë’¤, ì´ë¥¼ <strong>í‘œì¤€í™”ëœ í‘œí˜„ ê³µê°„</strong>ìœ¼ë¡œ ì¸ì½”ë”©í•˜ëŠ” <strong>í”„ë¦¬íŠ¸ë ˆì¸ë“œ(tactile encoder) ëª¨ë¸</strong>ì¸ <strong>Sparsh-skin</strong>ì„ ê°œë°œí•˜ì˜€ìŠµë‹ˆë‹¤. í•™ìŠµëœ ì´‰ê° ì¸ì½”ë”ëŠ” unlabeled ë°ì´í„°ë¡œ ì‚¬ì „í•™ìŠµë˜ì—ˆê¸° ë•Œë¬¸ì— ì´í›„ ìƒˆë¡œìš´ ì‘ì—…ì— ì†ŒëŸ‰ì˜ í•™ìŠµ ë°ì´í„°ë¡œ ë¹ ë¥´ê²Œ ì ì‘í•  ìˆ˜ ìˆë‹¤ëŠ” ì¥ì ì„ ë³´ì˜€ìŠµë‹ˆë‹¤. ì‹¤ì œë¡œ ë¬¼ì²´ ì‹ë³„ ë“±ì˜ ë‹¤ìš´ìŠ¤íŠ¸ë¦¼ ê³¼ì œì—ì„œ <strong>ê¸°ì¡´ ì—”ë“œíˆ¬ì—”ë“œ í•™ìŠµ ëŒ€ë¹„ 41% ë†’ì€ ì„±ëŠ¥</strong>ê³¼ í–¥ìƒëœ ë°ì´í„° íš¨ìœ¨ì„ ë‹¬ì„±í•˜ì—¬, <strong>ì´‰ê° ê¸°ë°˜ ê°ì²´ ì¸ì‹</strong>ì´ë‚˜ ë¯¸ì„¸ ë™ì‘ ì œì–´ì— ìœ ìš©í•œ <strong>ì¼ë°˜ ëª©ì  ì´‰ê° í‘œí˜„</strong>ì„ ì–»ì„ ìˆ˜ ìˆìŒì„ ì…ì¦í–ˆìŠµë‹ˆë‹¤. ì´ëŠ” ë³µì¡í•œ ìê¸°ì¥ ì´‰ê°ì„¼ì„œ ì‹ í˜¸ë¥¼ í•´ì„í•˜ëŠ” ë° ìˆì–´ <strong>í•™ìŠµ ê¸°ë°˜ ì ‘ê·¼</strong>ì˜ ê°€ëŠ¥ì„±ì„ ë³´ì—¬ì£¼ë©°, í–¥í›„ ì¸ê°„ ìˆ˜ì¤€ì˜ ì´‰ê°ì¸ì§€ ëŠ¥ë ¥ì„ ë¡œë´‡ì— ë¶€ì—¬í•˜ëŠ” ë° ì¤‘ìš”í•œ ë‹¨ê³„ë¥¼ ì œì‹œí•©ë‹ˆë‹¤.</p></li>
</ul>
</section>
<section id="reskin-ì„¼ì„œ-í™œìš©-ì—°êµ¬-ì‚¬ë¡€" class="level3">
<h3 class="anchored" data-anchor-id="reskin-ì„¼ì„œ-í™œìš©-ì—°êµ¬-ì‚¬ë¡€">ReSkin ì„¼ì„œ í™œìš© ì—°êµ¬ ì‚¬ë¡€</h3>
<ul>
<li><p><strong>íŒ¨ë¸Œë¦­(ì²œ) ë‹¤ì¸µ ë¶„ë¦¬ ì¡°ì‘</strong> â€“ <em>â€œLearning to Singulate Layers of Cloth using Tactile Feedbackâ€</em> (Tirumala ë“±, IROS&nbsp;2022). ì´ ì—°êµ¬ëŠ” <strong>ì˜·ê°ì´ë‚˜ ì²œ ì—¬ëŸ¬ ì¥ì´ í¬ê°œì§„ ë”ë¯¸</strong>ì—ì„œ ë¡œë´‡ì´ ë§¨ ìœ—ì¥ í•œë‘ ì¥ë§Œ ì§‘ì–´ì˜¬ë¦¬ëŠ” ì–´ë ¤ìš´ ì‘ì—…ì— ì´‰ê° ì„¼ì„œ ReSkinì„ í™œìš©í•œ ì‚¬ë¡€ì…ë‹ˆë‹¤. í”„ë‘ì¹´(Franka) ë¡œë´‡ íŒ”ì˜ ê·¸ë¦¬í¼ ì†ê°€ë½ ì¤‘ í•˜ë‚˜ì— <strong>ReSkin ì´‰ê° íŒ¨ë“œ</strong>ë¥¼ ë¶€ì°©í•˜ê³ , í•´ë‹¹ ì„¼ì„œë¡œë¶€í„° ì–»ì€ <strong>ì´‰ê° ë°ì´í„°</strong>ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í˜„ì¬ ì¡ì€ ì²œì˜ **ê²¹ ìˆ˜(layer ìˆ˜)**ë¥¼ íŒë³„í•˜ëŠ” ë¨¸ì‹ ëŸ¬ë‹ <strong>ë¶„ë¥˜ê¸°</strong>ë¥¼ í•™ìŠµí–ˆìŠµë‹ˆë‹¤. í•™ìŠµëœ ë¶„ë¥˜ê¸°ë¥¼ ë¡œë´‡ ì œì–´ì— í†µí•©í•˜ì—¬, ê·¸ë¦¬í¼ê°€ ë„ˆë¬´ ë§ì€ ì¸µì„ ì¡ì•˜ì„ ë•Œ ì‚´ì§ ë†“ì•„ì„œ í•œ ì¸µë§Œ ì¡ë„ë¡ ë†’ì´ë¥¼ ìë™ ì¡°ì •í•˜ëŠ” ì •ì±…ì„ ì‹¤í–‰í–ˆìŠµë‹ˆë‹¤. ì´ 180íšŒì˜ ì‹¤ì œ ë¡œë´‡ ì‹¤í—˜ ê²°ê³¼, <strong>ì´‰ê°ì„ í™œìš©í•˜ì§€ ì•Šì€</strong> ê¸°ì¡´ ì‹œê° ê¸°ë°˜ ì ‘ê·¼ë³´ë‹¤ í›¨ì”¬ ë†’ì€ ì •í™•ë„ë¡œ <strong>í•œ ê²¹ í˜¹ì€ ë‘ ê²¹ì˜ ì²œì„ êµ¬ë¶„í•˜ì—¬ ì§‘ì–´ì˜¬ë¦¬ëŠ” ë° ì„±ê³µ</strong>í–ˆê³ , ë³´ì§€ ëª»í•œ ìƒˆë¡œìš´ ì¢…ë¥˜ì˜ ì²œì— ëŒ€í•´ì„œë„ ì¼ë°˜í™” ì„±ëŠ¥ì´ í–¥ìƒë˜ì—ˆìŒì„ ë³´ì˜€ìŠµë‹ˆë‹¤. ì´ëŠ” <strong>ReSkinì˜ ë¯¸ì„¸í•œ ì´‰ê° ì‹ í˜¸ê°€ ì˜·ê°ì˜ ë‘ê»˜ë‚˜ ê²°í•© ìƒíƒœë¥¼ ì˜ ê°ì§€</strong>í•¨ì„ ë³´ì—¬ì£¼ë©°, ê¸°ì¡´ì— ì‹œê°ìœ¼ë¡œ ì–´ë ¤ì› ë˜ ì„¬ì„¸í•œ ì„¬ìœ  ì¡°ì‘ ì‘ì—…ì— ì´‰ê° ì„¼ì„œê°€ ìœ ìš©í•¨ì„ ì…ì¦í•œ ì‚¬ë¡€ì…ë‹ˆë‹¤.</p></li>
<li><p><strong>ReSkinì˜ ê°œì„  ë° ì¼ë°˜í™” (AnySkin)</strong> â€“ <em>â€œAnySkin: Plug-and-play Skin Sensing for Robotic Touchâ€</em> (Bhirangi ë“±, arXiv&nbsp;2024). ì´ ì—°êµ¬ëŠ” ReSkinì˜ ê°œë…ì„ ë°œì „ì‹œì¼œ <strong>ë” ê°•í•œ ìì¥, ë¶€ì°© í¸ì˜ì„±, ì„¼ì„œ ê°„ ì¼ê´€ì„±</strong>ì„ í–¥ìƒì‹œí‚¨ <strong>AnySkin</strong>ì´ë¼ëŠ” ì‹ í˜• ì´‰ê° ì„¼ì„œë¥¼ ì†Œê°œí•˜ì˜€ìŠµë‹ˆë‹¤. AnySkinì€ ReSkinê³¼ ë™ì¼í•˜ê²Œ <strong>ìê¸° ì…ì ê¸°ë°˜</strong>ì´ì§€ë§Œ, <strong>ìì²´ ì •ë ¬ë˜ê³  ì ‘ì°©ì œ ì—†ì´ ë¶€ì°© ê°€ëŠ¥í•œ ì„¤ê³„</strong>ë¥¼ ë„ì…í•˜ì—¬ ë¡œë´‡ í‘œë©´ ì–´ë””ì—ë‚˜ ë¶™ì´ê¸° ì‰½ê²Œ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤. ë˜í•œ ì„¼ì„œ ê°„ ì‘ë‹µ í¸ì°¨ë¥¼ ì¤„ì—¬, í•œ ì„¼ì„œì—ì„œ í•™ìŠµëœ ëª¨ë¸ì´ <strong>ë³„ë„ ì¬ë³´ì • ì—†ì´ ë‹¤ë¥¸ ì„¼ì„œì—ë„ ë°”ë¡œ ì ìš©</strong>ë  ìˆ˜ ìˆìŒì„ ì‹œì—°í•˜ì˜€ìŠµë‹ˆë‹¤ (cross-instance generalization). ë…¼ë¬¸ì—ì„œëŠ” AnySkinì„ ì´ìš©í•œ <strong>ë¯¸ë„ëŸ¬ì§ ê°ì§€</strong>ì™€ ê°•í™”í•™ìŠµ ê¸°ë°˜ <strong>ì ‘ì´‰ ì •ì±… í•™ìŠµ</strong> ì‹¤í—˜ì„ ìˆ˜í–‰í•˜ì—¬, ì´ì „ ReSkin ëŒ€ë¹„ <strong>í–¥ìƒëœ ê°ë„ì™€ ë‚´êµ¬ì„±</strong>ì„ ë³´ì´ë©° ë™ì‹œì— <strong>ë°ì´í„° ì¬ì‚¬ìš©ì„±</strong>ì„ êµ¬í˜„í•¨ì„ ë³´ì˜€ìŠµë‹ˆë‹¤. ì´ ê²°ê³¼ëŠ” ReSkinì´ ì œì‹œí•œ <strong>ì €ê°€í˜• ì´‰ê° í”¼ë¶€</strong>ì˜ ê°€ëŠ¥ì„±ì„ í•œì¸µ í™•ì¥í•œ ê²ƒìœ¼ë¡œ, <strong>ë¡œë´‡ ì´‰ê° ì„¼ì„œì˜ ë²”ìš©ì„±</strong>ì„ ë†’ì´ëŠ” ë°©í–¥ì˜ ì¤‘ìš”í•œ ì§„ì „ìœ¼ë¡œ í‰ê°€ë©ë‹ˆë‹¤.</p></li>
</ul>
</section>
</section>
<section id="ê²°ë¡ -ë°-ì‹œì‚¬ì " class="level2">
<h2 class="anchored" data-anchor-id="ê²°ë¡ -ë°-ì‹œì‚¬ì ">ê²°ë¡  ë° ì‹œì‚¬ì </h2>
<p>uSkinê³¼ ReSkinì€ ê°ê° <strong>ì •ë°€ë„ ë†’ì€ ìƒìš© ì´‰ê°ì„¼ì„œ</strong>ì™€ <strong>ì €ë¹„ìš© ìœ ì—° ì´‰ê°í”¼ë¶€</strong>ë¥¼ ëŒ€í‘œí•˜ë©°, ìµœê·¼ ì—°êµ¬ë“¤ì€ ì´ë“¤ ì„¼ì„œë¥¼ ë¡œë´‡ì— ì ìš©í•˜ì—¬ <strong>ì„¬ì„¸í•œ ì¡°ì‘ ê¸°ìˆ </strong>ì„ í–¥ìƒì‹œí‚¤ëŠ” ë°©í–¥ìœ¼ë¡œ ì „ê°œë˜ê³  ìˆìŠµë‹ˆë‹¤. ìš”ì•½í•˜ë©´, uSkinì€ ë†’ì€ í•´ìƒë„ì˜ 3ì¶• í˜ ì¸¡ì • ëŠ¥ë ¥ì„ ë°”íƒ•ìœ¼ë¡œ <strong>ë¡œë´‡ì†ì˜ ì ‘ì´‰ë ¥ ì œì–´</strong>ë‚˜ <strong>ë¯¸ë„ëŸ¼ ê°ì§€</strong>ì™€ ê°™ì€ ë¬¸ì œì— í™œìš©ë˜ê³  ìˆìœ¼ë©°, ReSkinì€ ì €ë ´í•˜ê³  êµì²´ê°€ ì‰¬ìš´ ê°•ì ì„ ì‚´ë ¤ <strong>ë³µì¡í•œ ë³€í˜• ë¬¼ì²´ì˜ ì´‰ê° ì¸ì§€</strong>ë‚˜ <strong>ì›¨ì–´ëŸ¬ë¸” ë¡œë´‡í”¼ë¶€</strong> ë“± <strong>í™•ì¥ì„± ìˆëŠ” ì‘ìš©</strong>ì— ì“°ì´ê³  ìˆìŠµë‹ˆë‹¤. ë”ìš±ì´ ë‘ ì„¼ì„œ ëª¨ë‘ <strong>ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë²•ê³¼ ê²°í•©</strong>ë˜ë©´ì„œ ì„¼ì„œ ì‹ í˜¸ ë³´ì •, íŠ¹ì§• í‘œí˜„ í•™ìŠµ, ì •ì±… í•™ìŠµ ë“± ë‹¤ì–‘í•œ ì¸¡ë©´ì—ì„œ í˜ì‹ ì´ ì´ë£¨ì–´ì§€ê³  ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ë™í–¥ì€ í–¥í›„ ë¡œë´‡ì´ <strong>ì‚¬ëŒì²˜ëŸ¼ ì„¬ì„¸í•œ ì´‰ê°ì„ í™œìš©</strong>í•˜ê³ , ì—¬ëŸ¬ í˜•íƒœì˜ ì´‰ê° ì„¼ì„œë¥¼ <strong>íš¨ê³¼ì ìœ¼ë¡œ í†µí•©</strong>í•˜ì—¬ <strong>ë³´ë‹¤ ì§€ëŠ¥ì ì¸ ìƒí˜¸ì‘ìš©</strong>ì„ êµ¬í˜„í•˜ëŠ” ë° ì¤‘ìš”í•œ ë°‘ê±°ë¦„ì´ ë  ê²ƒìœ¼ë¡œ ê¸°ëŒ€ë©ë‹ˆë‹¤.</p>
<p><strong>ì°¸ê³  ìë£Œ:</strong> ë³¸ ë‹µë³€ì—ì„œëŠ” arXiv, IEEE, Science Robotics ë“± ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ì¶œì²˜ì˜ ë…¼ë¬¸ ë° ê¸°ì‚¬ã€9ã€‘ã€11ã€‘ã€13ã€‘ã€17ã€‘ã€19ã€‘ã€21ã€‘ã€22ã€‘ã€25ã€‘ã€27ã€‘ã€31ã€‘ã€32ã€‘ã€37ã€‘ã€39ã€‘ã€42ã€‘ã€49ã€‘ë¥¼ ì¸ìš© ë° ì°¸ê³ í•˜ì˜€ìŠµë‹ˆë‹¤. ê° ë²ˆí˜¸ëŠ” í•´ë‹¹ ì¶œì²˜ë¥¼ ê°€ë¦¬í‚¤ë©°, ìì„¸í•œ ë‚´ìš©ì€ ì¸ìš©ë¬¸ ì˜† ê´„í˜¸ì˜ ë²ˆí˜¸ë¥¼ í†µí•´ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
<details>
<summary>
<b>English</b>
</summary>
<p>Got it. Iâ€™ll translate the full content into English, including the detailed comparison of uSkin and ReSkin sensors, recent research cases using them, and all structured content like tables and analyses.</p>
<p>Iâ€™ll present the translated report shortly.</p>
</details></section>
<section id="comparison-of-uskin-and-reskin-tactile-sensors-for-the-allegro-hand" class="level1">
<h1>Comparison of uSkin and ReSkin Tactile Sensors for the Allegro Hand</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Tactile sensing is crucial for dexterous robotic manipulation, providing rich feedback about contact forces, textures, and object properties that vision alone cannot capture. The Allegro Hand â€“ a four-fingered, 16-DOF robotic hand â€“ has become a popular platform for evaluating advanced tactile sensors in research. Two notable tactile skin technologies used with the Allegro Hand are <strong>uSkin</strong> (developed by XELA Robotics) and <strong>ReSkin</strong> (developed by Meta AI in collaboration with Carnegie Mellon University). This report presents a detailed comparison of uSkin and ReSkin in terms of sensitivity, accuracy, reliability, response speed, fabrication methods, and their underlying magnetic field sensing principles. It also reviews recent research (2022â€“2025) that employs each sensor, highlighting applications and outcomes. The goal is to provide robotics researchers with a clear understanding of each sensorâ€™s capabilities and trade-offs in an academic, technical context.</p>
</section>
<section id="overview-of-the-tactile-sensors" class="level2">
<h2 class="anchored" data-anchor-id="overview-of-the-tactile-sensors">Overview of the Tactile Sensors</h2>
<section id="uskin-sensor-xela-robotics" class="level3">
<h3 class="anchored" data-anchor-id="uskin-sensor-xela-robotics">uSkin Sensor (XELA Robotics)</h3>
<p>uSkin is a high-density 3-axis tactile sensor system packaged in a thin, soft silicone skin. It integrates an array of small sensing units (taxels) that can each detect forces in three dimensions: normal pressure (Z-axis) and shear forces (X and Y axes). The uSkin design embeds tiny magnets in the soft skin and uses underlying magnetometers (or Hall-effect sensors) to track the magnetsâ€™ movements under deformation. Each taxelâ€™s magnetic field readings in X, Y, Z change as forces are applied, allowing the system to compute a 3-axis force vector at that point. Because the sensors are distributed in a grid, uSkin provides <strong>spatially localized force data</strong> across the contact surface (for example, an Allegro fingertip can be covered with ~24 taxel units). The sensor outputs are digital, minimizing noise and eliminating the need for bulky analog wiring or external ADC boards. In practice, uSkin can be integrated into new or existing robots with minimal wiring and straightforward mounting (e.g.&nbsp;glued onto robot fingers or palm). XELA offers flat patch sensors, curved fingertip sensors, and other form factors to cover various robot hand surfaces. Overall, uSkin provides a <strong>turnkey tactile sensing solution</strong> with high resolution and direct force readouts per taxel, making it suitable for precise manipulation tasks.</p>
</section>
<section id="reskin-sensor-meta-ai-cmu" class="level3">
<h3 class="anchored" data-anchor-id="reskin-sensor-meta-ai-cmu">ReSkin Sensor (Meta AI &amp; CMU)</h3>
<p>ReSkin is an open-source tactile â€œskinâ€ that uses a flexible polymer embedded with magnetic particles to sense touch. The ReSkin concept is to create a low-cost, replaceable tactile layer that can be applied to robot hands (or other surfaces) like an electronic skin. The sensor consists of a thin (~2â€“3â€¯mm) silicone elastomer sheet with randomly distributed microscopic magnetic particles. This magnetic sheet is placed over a small <strong>magnetometer</strong> chip. When the skin is pressed or deformed, the pattern of magnetic field at the magnetometer changes because the particles move (â€œsquooshedâ€) within the elastomer. <strong>Machine learning</strong> is then used to map these field distortions to contact force magnitudes and locations. ReSkinâ€™s design prioritizes simplicity and versatility: the sensing hardware (magnetometer and electronics) is kept separate from the soft skin. The skin contains no wires or electronics; it can be <strong>peeled off and replaced</strong> like a Band-Aid when worn out. This makes the part most susceptible to damage very easy and cheap to replace (each skin costs on the order of &lt;$30 in materials). ReSkin can be cut or shaped to cover different surfaces â€“ from a robot fingertip to an entire glove or even a dogâ€™s paw â€“ providing a conformal tactile sensing layer. The open-source release includes instructions for fabrication (mixing and curing the magnetic silicone) and pre-trained models for interpreting the sensor signals. In summary, ReSkin offers a <strong>flexible, low-cost tactile sensing approach</strong> that leverages magnetic field changes and learned models to detect touch across a continuous surface.</p>
</section>
</section>
<section id="comparison-of-performance-and-design" class="level2">
<h2 class="anchored" data-anchor-id="comparison-of-performance-and-design">Comparison of Performance and Design</h2>
<p>To clearly contrast uSkin and ReSkin, this section compares their key specifications and performance metrics:</p>
<section id="sensitivity-and-resolution" class="level3">
<h3 class="anchored" data-anchor-id="sensitivity-and-resolution">Sensitivity and Resolution</h3>
<p><strong>Sensitivity</strong> refers to the smallest force the sensor can reliably detect, and <strong>resolution</strong> includes the spatial granularity of touch detection. uSkin is engineered for <strong>high sensitivity</strong> â€“ it can detect forces as light as about <em>0.1&nbsp;gram-force (gf)</em> (â‰ˆ0.001â€¯N). This extremely low force threshold means uSkin can register very slight touches or contact, making it suitable for delicate manipulation where precise force control is needed. In contrast, ReSkinâ€™s target sensitivity is on the order of <em>&lt;0.1&nbsp;N</em> (â‰ˆ10â€¯gf) for force detection. However, with careful calibration and machine learning models, ReSkin can achieve very fine force resolution: experiments have demonstrated force measurement errors as low as ~0.005â€¯N (5â€¯mN) in controlled settings. This indicates that ReSkin, despite its simple hardware, can discern minute forces after training, although its <em>native</em> (untrained) sensitivity may be lower than uSkinâ€™s.</p>
<p>In terms of <strong>spatial resolution</strong>, uSkin provides a grid of discrete sensing points (taxels). For example, each uSkin â€œ4x4â€ patch contains 16 sensing points, and a curved uSkin on an Allegro fingertip uses 24 sensor chips covering the finger pad. The spacing between taxels (a few millimeters apart) defines how finely the contact location can be distinguished â€“ essentially on the order of the taxel pitch. ReSkin, by contrast, behaves like a continuous skin. A single ReSkin patch (roughly the size of a coin) can localize contacts with a spatial accuracy of about <em>1&nbsp;mm</em> (with ~90% accuracy) after training. In a benchmark test, ReSkin achieved ~99.6% accuracy in classifying contact locations within Â±1â€¯mm on its surface. This suggests that, when calibrated, ReSkin can provide <strong>very high spatial detail</strong> of where a touch occurs, potentially finer than the discrete spacing of uSkinâ€™s taxels. The trade-off is that uSkinâ€™s taxels give <strong>direct physical correspondence</strong> to locations, whereas ReSkinâ€™s localization comes from an inference model. In summary, both sensors offer excellent sensitivity and spatial resolution for robotics use: uSkin has an ultra-low force threshold and inherently structured high-density sensing points, while ReSkin achieves comparable force and location resolution through machine-learning-assisted sensing.</p>
</section>
<section id="accuracy-of-force-measurement" class="level3">
<h3 class="anchored" data-anchor-id="accuracy-of-force-measurement">Accuracy of Force Measurement</h3>
<p>Accuracy encompasses how reliably the sensor can quantify the magnitude and direction of applied forces. uSkinâ€™s design yields direct 3-axis force readings at each taxel, but these raw readings require calibration to map sensor units to physical force values. When properly calibrated, uSkin can measure forces in Newtons and serve in control feedback loops. For instance, a recent study calibrated an Allegro Handâ€™s uSkin sensors against a force-torque sensor and achieved force estimation errors of around <em>0.12&nbsp;N (Â±0.08&nbsp;N)</em> in a closed-loop grasping task. This indicates that uSkin can accurately measure and regulate contact forces to within a few hundred millinewtons during manipulation. Its <strong>repeatability and linearity</strong> benefit from the stable positioning of magnets and sensors in each module. Moreover, uSkinâ€™s on-board digital electronics reduce noise, improving measurement consistency. One challenge for accuracy, however, is dealing with external magnetic interference or drift (addressed later), which XELA mitigates via software compensation for certain models.</p>
<p>ReSkinâ€™s accuracy heavily relies on its learned model. The raw magnetic readings from a ReSkin patch are not directly interpretable as force without a mapping. With a well-trained neural network, ReSkin has demonstrated impressively accurate force reconstruction: in one evaluation, the mean squared error in normal force prediction was on the order of <em>(5&nbsp;Ã—&nbsp;10<sup>âˆ’3&nbsp;N)</sup>2</em>, corresponding to just a few millinewtons error. Additionally, ReSkin is capable of sensing shear forces; a test for dynamic shear contact showed it could predict tangential forces (F_x, F_y) with MSE ~0.0011&nbsp;N^2, while maintaining normal force error ~0.003&nbsp;N^2. These results underscore that ReSkin, despite using a single magnetometer, can accurately capture multi-axis force information when aided by machine learning. The <strong>limitation</strong> is that the accuracy is only as good as the modelâ€™s calibration and training data â€“ any change in the skin (replacement or drift over time) can degrade performance if not accounted for. The original ReSkin paper noted that models trained on one sensor did not generalize to other sensors without adaptation, due to instance variability. Recent improvements (see â€œAnySkinâ€ below) aim to reduce this variability. In summary, uSkin offers <em>direct, hardware-defined accuracy</em> which can be high after one-time calibration, whereas ReSkin offers <em>model-based accuracy</em> which can reach very high levels but requires ongoing calibration and learning algorithms to maintain.</p>
</section>
<section id="reliability-and-durability" class="level3">
<h3 class="anchored" data-anchor-id="reliability-and-durability">Reliability and Durability</h3>
<p><strong>Reliability</strong> covers the sensorâ€™s longevity and consistency of performance over time, especially under repetitive use. uSkin is built as a <strong>durable tactile array</strong>: its soft silicone and internal structure are designed to handle repetitive contacts and even overload conditions without permanent damage. The silicone skin not only protects the internal sensor elements but also allows slight conformity, distributing stress. XELA specifies that uSkin can sustain up to a certain maximum normal force (e.g.&nbsp;450&nbsp;gf for one model, or up to 1500&nbsp;gf for newer models) without damage. In manipulation tasks, uSkin-covered fingers have been shown to handle fragile objects reliably without harming them. <strong>Wear and tear</strong> on uSkin is relatively low since the sensor is an integrated unit â€“ there are no loose particles or fluids â€“ and itâ€™s sealed to prevent dust or moisture ingress. Many researchers have used the same uSkin sensors for thousands of grasp cycles; as long as the silicone and wiring remain intact, the performance remains stable. On the other hand, if a uSkin module does fail or break, it is a specialized hardware piece that must be replaced (which can be costly, as high-end tactile sensors often are). XELA advertises their product as more affordable than some competitors like the BioTac (&gt;$1000) while still not compromising performance, but it is certainly more expensive than DIY solutions.</p>
<p>ReSkin emphasizes <strong>replaceability</strong> as a core feature of reliability. The magnetic skin can undergo many touches: tests showed the machine learning model remained accurate even after <em>50,000 interactions</em> on the same piece of skin. Eventually, however, the silicone skin will degrade (e.g.&nbsp;tiny cracks, particle loss, or reduced elasticity) after extensive use. Instead of requiring a complex sensor replacement, the worn skin can simply be peeled off and a new one attached, restoring the sensor to like-new performance. This concept makes ReSkin robust in a <em>maintainable</em> way â€“ any damage to the surface (cuts, abrasion) is not catastrophic, because the skin is a cheap consumable. Another aspect of reliability is the sensorâ€™s consistency <strong>over time and across units</strong>. Early versions of ReSkin saw variability between different fabricated skins and drift in signals over time (as the elastomer properties changed slightly). To combat this, the designers suggest periodic re-calibration (collecting a zero-load magnetic reading occasionally) and have developed improved fabrication methods. In 2024, an improved variant called <strong>â€œAnySkinâ€</strong> introduced a post-curing magnetization process and self-aligning skins to achieve more uniform magnetic particle distribution and secure attachment to the magnetometer. These improvements greatly reduced variability between sensor instances and prevented performance loss due to misalignment or peeling over time. In summary, ReSkinâ€™s reliability comes from its easy <strong>renewability</strong> and ongoing model adaptation, whereas uSkinâ€™s reliability stems from a <strong>robust physical design</strong> that maintains performance over a long service life with minimal intervention.</p>
</section>
<section id="response-time-and-sampling-rate" class="level3">
<h3 class="anchored" data-anchor-id="response-time-and-sampling-rate">Response Time and Sampling Rate</h3>
<p>Rapid response and high sampling frequency are important for capturing dynamic contact events (e.g.&nbsp;slip, impact) and for tight control loops. uSkin provides real-time readings via a digital interface (often CAN or USB converter) and supports high sampling rates. The standard uSkin modules can sample at <strong>up to 500&nbsp;Hz</strong> (2&nbsp;ms interval) on certain models. In many experiments, users run uSkin at 100&nbsp;Hz due to external constraints or sufficient bandwidth, but the hardware is capable of faster updates for more demanding applications. The internal latency of uSkinâ€™s sensors is low, since it uses direct electrical readings of magnetic field changes with minimal filtering. This allows reactive control â€“ for example, a 100&nbsp;Hz control loop using uSkin feedback was successfully implemented for force control in a dexterous hand.</p>
<p>ReSkin is also designed for <strong>high temporal resolution</strong>. The magnetometer can be read at rates up to around <strong>400&nbsp;Hz</strong> (as reported in the initial paper), and potentially faster with optimized hardware. The actual throughput may depend on the microcontroller or interface used, but the goal was to exceed 100&nbsp;Hz, which ReSkin achieved. Because ReSkin uses a learning pipeline, one consideration is the computational delay for the model to infer forces from magnetic readings. In practice, this inference can be made lightweight (e.g.&nbsp;a small multi-layer perceptron) and run in a few milliseconds, so the <strong>end-to-end latency</strong> remains low. The ReSkin authors demonstrated real-time use of the sensor (e.g.&nbsp;detecting slips or impacts) without lag, suggesting the response is fast enough for most robotic tasks. Both uSkin and ReSkin thus meet the requirements for <strong>real-time tactile feedback</strong>, with high-frequency data streams. If comparing, uSkinâ€™s fixed hardware sampling (500&nbsp;Hz digital output) might offer a slight edge in raw speed and noise immunity, whereas ReSkinâ€™s practical speed (~400&nbsp;Hz) is comparable and has been validated in closed-loop tasks as well. In either case, both sensors can capture fine contact events (on the order of a few milliseconds), far exceeding slower vision-based tactile sensors (which often run at 30â€“60&nbsp;Hz).</p>
</section>
<section id="fabrication-methods-and-integration" class="level3">
<h3 class="anchored" data-anchor-id="fabrication-methods-and-integration">Fabrication Methods and Integration</h3>
<p>The fabrication and integration process for these sensors differ markedly due to one being a commercial product and the other a DIY solution. <strong>uSkinâ€™s fabrication</strong> is proprietary to XELA Robotics â€“ it involves assembling small PCBs or sensor chips with embedded magnets and encapsulating them in silicone. Each taxel likely contains a tri-axial magnetometer or Hall sensor aligned with a small magnet in the silicone layer above. The exact manufacturing steps (e.g.&nbsp;how the magnets are embedded and calibrated) are not publicly detailed, but the outcome is a durable sensor sheet with built-in wiring. uSkin modules come with connectors and can be daisy-chained or attached around a robotic finger. Integration is straightforward: the sensors output digital data (e.g.&nbsp;via I2C or SPI through a hub) so one only needs to attach a lightweight cable from the robot hand to a data acquisition board (like XELAâ€™s CAN-to-USB interface). Mechanically, uSkin patches can be glued onto robot surfaces or affixed with screws/brackets depending on the model. The ability to customize shapes (flat, curved, wrap-around) means one can cover complex geometries (fingertips, phalanges, palm) by using multiple uSkin pieces. For example, covering an Allegro Hand might use a curved uSkin on each fingertip and flat patches on each finger link and palm. Because uSkin is a commercial solution, robotics labs often opt for it when they need a <strong>plug-and-play tactile array</strong> with vendor support, rather than investing time in sensor fabrication.</p>
<p><strong>ReSkinâ€™s fabrication</strong> is deliberately simple and accessible. To create a ReSkin sensor, one mixes a two-part silicone rubber with microscopic magnetic particles (like iron oxide or neodymium powder) in a mold to form a thin sheet. After curing, this elastomer is magnetized â€“ early methods involved curing in a magnetic field to align particles, but this was tricky and led to variability. Updated methods use a <strong>pulse magnetizer after curing</strong> to uniformly magnetize the particles without needing a field during the curing process. The result is a flexible skin with randomly oriented magnetic dipoles. The <strong>electronics</strong> for ReSkin consist of a small PCB with a magnetometer (typically a 3-axis magnetometer chip) and possibly a microcontroller to read the magnetometer and stream data. This PCB is placed directly under the silicone skin (it can even be embedded or held by a fixture). A critical integration aspect is keeping the skin positioned relative to the sensor â€“ AnySkin research introduced <em>self-adhering skins</em> that clip or snap in place, avoiding glue that can peel. In practice, attaching ReSkin to a robot might involve mounting the tiny magnetometer board on a robot finger and then stretching or securing the silicone patch over it like a thimble or sleeve. The flexibility of ReSkinâ€™s form means it can cover curved or large areas by using multiple magnetometers under one continuous skin, or tiling multiple units. Fabrication time is short (a few hours to mold and cure a batch of skins), and the cost is very low per skin (tens of dollars or less). This makes ReSkin attractive for projects that need <em>many sensors or large areas</em>, as one can fabricate and replace skins as needed. The trade-off is that integrating ReSkin also requires developing or using a ML model for the specific robot application, which adds a layer of complexity in software.</p>
</section>
<section id="sensing-principle-magnetic-field-based-detection" class="level3">
<h3 class="anchored" data-anchor-id="sensing-principle-magnetic-field-based-detection">Sensing Principle: Magnetic Field-Based Detection</h3>
<p>Both uSkin and ReSkin rely on <strong>magnetic field sensing</strong> at their core, but the configuration and principles of operation differ:</p>
<ul>
<li><p><strong>uSkin:</strong> Each taxel in uSkin is essentially a miniaturized magnetic tactile sensor: a small magnet is embedded in the deformable skin, and directly beneath it is a magnetometer that measures the magnetâ€™s field in 3 axes. In the undisturbed state, the magnetâ€™s field at the sensor has a known baseline. When an external force presses on the skin at that taxel, the magnet moves (e.g.&nbsp;gets displaced or tilted) relative to the sensor. This causes changes in the magnetic field readings (Î”B_x, Î”B_y, Î”B_z). These changes are correlated to the force vector applied â€“ for instance, a normal press might move the magnet closer to the sensor (increasing |B_z|), while a shear force might shift it laterally (changing B_x, B_y). Through calibration, uSkin converts the raw magnetic readings into an X, Y, Z force reading for each taxel. The key aspect is <strong>direct physical mapping</strong>: the sensor is designed so that magnetic field changes correspond in a roughly one-to-one manner with force components. Because the magnets are fixed in known positions and each taxel is independent, the interpretation of the signals is straightforward (often a polynomial or linear map for each axis). uSkinâ€™s use of magnetics provides a <em>contactless</em> sensing mechanism (no electrical contacts at the surface) and allows the sensor to be thin and compliant. However, it also means the readings can be affected by external magnetic fields or nearby ferromagnetic objects. XELA addresses this by offering <strong>magnetic interference compensation</strong>, using reference sensors or software filters to subtract out background field disturbances. In essence, uSkinâ€™s principle is a <strong>localized magnetic displacement sensor</strong> at each grid point.</p></li>
<li><p><strong>ReSkin:</strong> The ReSkin approach uses a <strong>distributed magnetic field perturbation</strong> principle. Instead of discrete magnets, the entire elastomer sheet contains a random dispersion of tiny magnetic particles. The magnetometer under the skin measures the combined magnetic field from all these particle dipoles. When the skin is not touched, this field has a stable baseline profile. When contact occurs, a region of the skin deforms â€“ particles in that region get slightly closer to the sensor or reorient, altering the field. Crucially, the relationship between a given touch (with certain force and location) and the magnetometer reading is <em>highly complex</em>, since many particles contribute to the field signal. Therefore, ReSkin relies on a <strong>learned mapping</strong>: a data-driven model (often a neural network) is trained on known indentations to predict the contact location and force from the raw magnetic field readings. The model effectively decodes the pattern of field changes into meaningful tactile information. The benefit of this method is that a single small sensor can cover a relatively large area of skin and sense forces at any point in that area. The drawback is that the magnetic field signal is an entangled representation â€“ without the model, one cannot directly obtain force/position. ReSkinâ€™s magnetic sensing principle is thus a <strong>global sensing</strong> mode: every touch influences the overall field measurement, but in different ways, and the ML model disentangles them. This principle also means that if the skin shifts relative to the magnetometer or if the magnetic particle distribution changes (due to wear or a new skin), the mapping might need recalibration. Recent efforts like AnySkin aim to make the field more consistent (e.g.&nbsp;uniform particle distribution via post-magnetization) so that the same model can work across replacements. Another consideration is environmental magnetic noise â€“ like uSkin, ReSkin can be affected by strong external magnets or fields. Users must ensure the sensorâ€™s baseline is recorded and possibly apply filtering for stray field fluctuations (some approaches include taking a no-contact reading before each use to serve as a reference). In summary, ReSkinâ€™s magnetic detection principle is a <strong>one-to-many mapping</strong> (one sensor reading to many possible contacts, resolved by learning), whereas uSkinâ€™s is <strong>many one-to-one mappings</strong> (each taxel sensor responds to forces mostly at its own location).</p></li>
</ul>
<p>The table below summarizes the key differences between uSkin and ReSkin:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 5%">
<col style="width: 44%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Aspect</strong></th>
<th><strong>uSkin (XELA)</strong></th>
<th><strong>ReSkin (Meta/CMU)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Sensing Principle</strong></td>
<td>Local magnetic displacement at many discrete 3-axis taxels (each taxel: magnet + Hall sensor). Direct mapping from magnet movement to force per taxel.</td>
<td>Global magnetic field distortion measured by one/few magnetometers. Requires ML model to infer contact force and position.</td>
</tr>
<tr class="even">
<td><strong>Sensitivity</strong></td>
<td>~0.1 gf (0.001 N) threshold for force detection (very light touch). High sensitivity due to precise magnet sensor coupling.</td>
<td>Aimed for &lt;0.1 N detectable force; with calibration, achieved ~0.005 N force resolution in tests. Slightly less sensitive natively, but improved by ML averaging.</td>
</tr>
<tr class="odd">
<td><strong>Spatial Resolution</strong></td>
<td>Discrete taxel spacing (e.g.&nbsp;16â€“24 sensors per fingertip) gives a few mm resolution; each taxel provides localized 3D force data.</td>
<td>Continuous skin with ~1&nbsp;mm contact localization accuracy after training. Can detect multiple contact points if using multiple magnetometers or sequential touches, but typically one contact at a time per patch.</td>
</tr>
<tr class="even">
<td><strong>Accuracy</strong></td>
<td>Outputs calibrated force readings per taxel; requires calibration but then reliable (e.g.&nbsp;~0.1â€“0.2 N error in practice). Minimal drift; interference compensated via software.</td>
<td>High accuracy with trained model (99% location accuracy, few mN force error in controlled settings). Must retrain or adapt model if skin changes or drifts over long term.</td>
</tr>
<tr class="odd">
<td><strong>Response Time</strong></td>
<td>Up to 500 Hz sampling rate (2 ms); low-latency digital output. Suitable for fast control loops (used at 100 Hz in hand control experiments).</td>
<td>Tested up to ~400 Hz update rate; real-time ML inference feasible (few ms). Effective for dynamic tasks (slip detection, impacts) with slight computational overhead.</td>
</tr>
<tr class="even">
<td><strong>Reliability &amp; Durability</strong></td>
<td>Robust build â€“ soft but resilient; handles overloads without damage. Long-lived hardware; no consumable parts (aside from eventual wear on skin after extensive use). Susceptible to strong external magnetic fields (mitigated by compensation).</td>
<td>Skin lasts ~50k interactions before degradation. Inexpensive, <strong>user-replaceable skins</strong> make maintenance easy. Performance consistent if skin is replaced and model updated occasionally. Sensitive to magnetic misalignment or drift; new designs (AnySkin) improve consistency.</td>
</tr>
<tr class="odd">
<td><strong>Fabrication &amp; Integration</strong></td>
<td>Proprietary manufacturing; purchase from XELA. Available in flat, curved, bendable formats for integration. Attaches via glue or brackets; requires XELA interface for data. Higher cost per unit, but ready to use out-of-box.</td>
<td>DIY fabrication from silicone + magnetic powder (open-source specs). Simple electronics (1 magnetometer + microcontroller per patch). Highly affordable (&lt;$30 per sensor). Flexible placement on robot, but requires ML software integration for use.</td>
</tr>
</tbody>
</table>
<p><em>Table: Feature comparison of uSkin and ReSkin tactile sensors.</em></p>
</section>
</section>
<section id="recent-research-applications-20222025" class="level2">
<h2 class="anchored" data-anchor-id="recent-research-applications-20222025">Recent Research Applications (2022â€“2025)</h2>
<p>Both uSkin and ReSkin have been employed in a variety of research projects in robotics, particularly in areas like object manipulation, force control, and haptic perception. Below we summarize selected recent studies that showcase each sensor in use, including the research context, how the sensor was implemented, and key findings:</p>
<section id="studies-utilizing-uskin-in-robotics-research-20222025" class="level3">
<h3 class="anchored" data-anchor-id="studies-utilizing-uskin-in-robotics-research-20222025">Studies Utilizing uSkin in Robotics Research (2022â€“2025)</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 15%">
<col style="width: 7%">
<col style="width: 29%">
<col style="width: 48%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Study &amp; Year</strong></th>
<th><strong>Application / Field</strong></th>
<th><strong>Experimental Setup with uSkin</strong></th>
<th><strong>Key Outcomes</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Kulkarni et al., 2024</strong> â€“ <em>â€œTactile Object Property Recognition Using Geometrical Graph Edge Features and MT-GCNâ€</em> (RA-L/IROS 2024)</td>
<td>Object property recognition (shape/texture stiffness classification)</td>
<td>Allegro Hand fully covered with uSkin sensors on all fingertips, phalanges, and palm. Tactile readings (1168 channels total) fed into a multi-thread Graph Convolutional Network to learn object features.</td>
<td>Integrating high-density uSkin data enabled the GCN to recognize objectsâ€™ properties with high accuracy. The proposed method outperformed baseline models, confirming that rich tactile input (3-axis forces from uSkin) improves multi-fingered object classification. It demonstrated effective identification of various object features solely through touch, validating uSkinâ€™s value for complex perception tasks.</td>
</tr>
<tr class="even">
<td><strong>Chelly et al., 2024</strong> â€“ <em>â€œTactile-based Force Estimation for Interaction Control with Robot Fingersâ€</em> (arXiv preprint 2024)</td>
<td>Precision force control in dexterous manipulation</td>
<td>Allegro Hand instrumented with Xela uSkin on each finger. The uSkin taxels were calibrated against an ATI Nano17 force/torque sensor to learn mapping from magnetic readings to actual force (per taxel). Used in a closed-loop admittance controller at 100&nbsp;Hz.</td>
<td>Achieved reliable real-time force feedback control: the robot maintained desired contact forces with only ~0.12&nbsp;N error margin. Demonstrated that uSkin can provide accurate enough force sensing to serve in feedback loops for delicate tasks (e.g., holding an object with constant force). Validated the stability and responsiveness of uSkin-based control, highlighting the sensorâ€™s utility in enhancing manipulation precision.</td>
</tr>
<tr class="odd">
<td><em>Funabashi et al., 2022</em> â€“ â€œCovering a Robot Hand with uSkin for Object Manipulationâ€ (previous study referenced in Kulkarni 2024)</td>
<td>General grasping and tactile sensing integration</td>
<td>(Details inferred from context) Allegro Hand with uSkin on all contact surfaces, similar to above. Focus on integrating tactile data into manipulation strategies.</td>
<td>Provided early evidence that full-hand tactile coverage with uSkin improves manipulation. Likely showed the feasibility of retrofitting Allegro Hand with uSkin and using its readings for tasks like grip adjustment or slip detection. Paved the way for later methods (e.g., graph-based learning) by establishing baseline techniques and highlighting challenges of managing large tactile data streams.</td>
</tr>
</tbody>
</table>
<p><em>Table: Selected research using uSkin sensors on Allegro Hand (2022â€“2025). Each study leveraged uSkinâ€™s dense tactile feedback for perception or control, demonstrating improved performance in manipulation tasks.</em></p>
</section>
<section id="studies-utilizing-reskin-in-robotics-research-20222025" class="level3">
<h3 class="anchored" data-anchor-id="studies-utilizing-reskin-in-robotics-research-20222025">Studies Utilizing ReSkin in Robotics Research (2022â€“2025)</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 10%">
<col style="width: 4%">
<col style="width: 32%">
<col style="width: 52%">
</colgroup>
<thead>
<tr class="header">
<th><strong>Study &amp; Year</strong></th>
<th><strong>Application / Field</strong></th>
<th><strong>Experimental Setup with ReSkin</strong></th>
<th><strong>Key Outcomes</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Bhirangi et al., 2021</strong> (Meta AI &amp; CMU) â€“ <em>â€œReSkin: Versatile, Replaceable, Lasting Tactile Skinsâ€</em> (CoRL 2021, published 2022)</td>
<td>Tactile sensor development &amp; benchmarking</td>
<td>Introduced ReSkin and evaluated it in lab tests. A small ReSkin patch (~2&nbsp;cm) was indented at various locations and forces using a precise indenter and an ATI Nano17 F/T sensor for ground truth. Trained an MLP model to predict contact position (X,Y) and force (Z, and later X,Y) from magnetometer data.</td>
<td>Validated ReSkinâ€™s core capabilities: contact localization error ~0.5&nbsp;mm and force error ~5&nbsp;mN, with 99.6% contact accuracy in controlled conditions. Demonstrated high temporal resolution (up to 400&nbsp;Hz) and longevity &gt;50,000 presses without model degradation. Established ReSkin as an inexpensive (&lt;$30) yet high-performance tactile sensor, laying groundwork for its adoption in various robot tasks.</td>
</tr>
<tr class="even">
<td><strong>Tirumala, Weng, Seita et al., 2022</strong> â€“ <em>â€œLearning to Singulate Layers using Tactile Feedbackâ€</em> (IROS&nbsp;2022)</td>
<td>Deformable object manipulation (cloth layer separation)</td>
<td>A Franka arm with a custom two-finger gripper was instrumented with a ReSkin sensor on one fingertip. The robot attempted to pinch and lift one or two layers from a stack of fabrics. A classifier was trained on ReSkin data to infer the number of layers grasped. 180 trials were conducted comparing tactile-informed strategy vs vision-only baselines.</td>
<td>The ReSkin-enabled gripper successfully distinguished between one vs.&nbsp;two cloth layers by touch, <strong>outperforming vision-only methods</strong> that failed on transparent or patterned fabrics. Tactile feedback from ReSkin allowed the robot to adjust its pinch depth in real time, greatly improving reliability in grasping the correct number of layers. This study showcased ReSkinâ€™s thin profile and sensitivity â€“ the sensor could be inserted between layers without bulky hardware, enabling a task (layer separation) that was not feasible with prior optical or larger tactile sensors. It highlighted the potential of ReSkin for fine manipulation in cloth handling and other delicate tasks.</td>
</tr>
<tr class="odd">
<td><strong>Singh et al., 2023</strong> â€“ <em>â€œAnySkin: Plug-and-play Skin Sensing for Robotic Touchâ€</em> (arXiv 2023)</td>
<td>Sensor design improvement (robust tactile skin)</td>
<td>An extension of ReSkinâ€™s design addressing its drawbacks. Proposed fabrication changes: magnetize the elastomer after curing (using a pulse magnetizer) for uniform particle distribution, use finer magnetic particles to avoid sedimentation, and introduce a <strong>self-aligning mount</strong> that locks the skin to the magnetometer without adhesives. Evaluated signal consistency across multiple skin instances and under cyclic loading.</td>
<td>Produced a new â€œAnySkinâ€ sensor that maintained signal strength and consistency better than original ReSkin. Variability in readings across different skins was greatly reduced (normalized std. deviation ~0.1 vs &gt;0.5 before). The self-adhesive design prevented peeling or shifting during use, enhancing durability. AnySkin preserved ReSkinâ€™s advantages (flexibility, low cost) while improving repeatability and ease-of-use. This research indicates the <strong>evolution</strong> of ReSkin technology to be more robust for practical deployment, thereby benefiting any robotic applications that rely on such magnetic skin sensors.</td>
</tr>
</tbody>
</table>
<p><em>Table: Selected research using ReSkin tactile skins (2021â€“2025). These works range from the initial demonstration of ReSkinâ€™s capabilities to its application in challenging tasks (fabric manipulation) and further improvements in the sensor design.</em></p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Both uSkin and ReSkin represent significant advances in tactile sensing for robotic hands, but they are optimized for different priorities. <strong>uSkin</strong> offers a ready-made, high-density sensor array with excellent sensitivity and straightforward output of rich 3-axis force data at each contact point. It excels in scenarios demanding precision and reliability, such as controlled manipulation and experiments requiring accurate force measurements out-of-the-box. Its integration into the Allegro Hand has enabled researchers to achieve fine force control and detailed object recognition by leveraging the structured tactile information. The main downsides are the higher cost and the need to manage many sensor channels, as well as careful handling of magnetic interference (though mitigated by design).</p>
<p><strong>ReSkin</strong>, on the other hand, offers an incredibly flexible and low-cost approach to spreading touch sensation over robot surfaces. Its strength lies in adaptability: it can conform to unique shapes, be replaced easily, and scale to larger areas without prohibitive cost. ReSkin has enabled innovative applications like sensing multiple layers of cloth â€“ tasks previously impractical â€“ thanks to its thinness and compliance. It leverages data-driven methods to extract a wealth of information (contact point, normal and shear forces) from minimal hardware. The trade-off is the added complexity of model training and the need for occasional recalibration when the â€œskinâ€ changes or environmental conditions shift. Its accuracy can be superb, but only under a well-trained modelâ€™s regime; generalizing that performance broadly is an active area of improvement (e.g., AnySkin making strides in consistency).</p>
<p>In sum, uSkin and ReSkin are <strong>complementary</strong> tactile technologies. uSkin provides a <em>benchmark for precision and ease-of-integration</em> in research labs, delivering high-quality data for each taxel suitable for analytical approaches. ReSkin provides a <em>vision of scalable, affordable tactile coverage</em>, inviting creative uses and rapid prototyping of â€œsensitive skinâ€ for robots. For the Allegro Hand, which has been used as a testbed, uSkin offers immediate high-resolution touch sensing on each finger, while ReSkin offers a path to cover the entire hand (and arms or tools) with a continuous sensing layer. The choice between them depends on the use-case: if one needs robust, plug-in sensors for fine control (and budget allows), uSkin may be preferable; if one needs wide-area coverage, easy replacement, or has cost constraints, ReSkin is extremely attractive. Future developments may even hybridize these approaches â€“ using structured arrays of ReSkin-like cells, or adding more intelligence to uSkinâ€™s data â€“ to further enhance tactile sensing. What is clear from recent research is that <strong>both sensors greatly advance a robot handâ€™s ability to â€œfeelâ€</strong>, bringing robotic manipulation closer to the dexterity of human touch by different means. Each has proven effective in various studies, and continued improvements (higher density uSkin, more stable ReSkin) are likely to expand their applications. In conclusion, uSkin and ReSkin represent two state-of-the-art solutions in tactile sensing, each with unique strengths, and both are instrumental in the ongoing development of tactile intelligence in robotic hands.</p>



</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>