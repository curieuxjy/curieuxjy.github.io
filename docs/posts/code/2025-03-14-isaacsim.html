<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-03-16">
<meta name="description" content="IsaacSim 4.5.0">

<title>Curieux.JY - 👩‍💻IsaacSim Installation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#어떤-로봇-시뮬레이터를-선택해야-할까" id="toc-어떤-로봇-시뮬레이터를-선택해야-할까" class="nav-link active" data-scroll-target="#어떤-로봇-시뮬레이터를-선택해야-할까">어떤 로봇 시뮬레이터를 선택해야 할까?</a></li>
  <li><a href="#isaacsim-vs.-isaacgym" id="toc-isaacsim-vs.-isaacgym" class="nav-link" data-scroll-target="#isaacsim-vs.-isaacgym">IsaacSim VS. IsaacGym</a>
  <ul class="collapse">
  <li><a href="#isaacgymenvs-및-omniisaacgymenvs" id="toc-isaacgymenvs-및-omniisaacgymenvs" class="nav-link" data-scroll-target="#isaacgymenvs-및-omniisaacgymenvs">IsaacGymEnvs 및 OmniIsaacGymEnvs</a></li>
  </ul></li>
  <li><a href="#isaac-lab" id="toc-isaac-lab" class="nav-link" data-scroll-target="#isaac-lab">Isaac Lab</a>
  <ul class="collapse">
  <li><a href="#isaac-lab의-핵심-특징" id="toc-isaac-lab의-핵심-특징" class="nav-link" data-scroll-target="#isaac-lab의-핵심-특징"><strong>Isaac Lab의 핵심 특징</strong></a></li>
  <li><a href="#isaac-lab에서-새롭게-추가된-기능" id="toc-isaac-lab에서-새롭게-추가된-기능" class="nav-link" data-scroll-target="#isaac-lab에서-새롭게-추가된-기능"><strong>Isaac Lab에서 새롭게 추가된 기능</strong></a></li>
  </ul></li>
  <li><a href="#installation" id="toc-installation" class="nav-link" data-scroll-target="#installation"><strong>Installation</strong></a>
  <ul class="collapse">
  <li><a href="#isaac-sim-설치" id="toc-isaac-sim-설치" class="nav-link" data-scroll-target="#isaac-sim-설치"><strong>Isaac Sim 설치</strong></a></li>
  <li><a href="#isaac-lab-설치" id="toc-isaac-lab-설치" class="nav-link" data-scroll-target="#isaac-lab-설치"><strong>Isaac Lab 설치</strong></a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#reference" id="toc-reference" class="nav-link" data-scroll-target="#reference">Reference</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">👩‍💻IsaacSim Installation</h1>
  <div class="quarto-categories">
    <div class="quarto-category">isaacsim</div>
    <div class="quarto-category">code</div>
  </div>
  </div>

<div>
  <div class="description">
    IsaacSim 4.5.0
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 16, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>이번 포스팅에서는 대표적인 로봇 시뮬레이터 중 하나인 IsaacSim에 대해서 알아보고 이를 Local에 설치하는 과정을 진행해보겠습니다.</p>
<center>
<img src="https://isaac-sim.github.io/IsaacLab/main/_images/isaaclab.jpg" width="67%">
<figcaption>
H1 Humanoid example using Isaac Lab
</figcaption>
</center>
<section id="어떤-로봇-시뮬레이터를-선택해야-할까" class="level1">
<h1>어떤 로봇 시뮬레이터를 선택해야 할까?</h1>
<p>로봇 시뮬레이션을 위한 소프트웨어는 매우 다양하며, 각 시뮬레이터는 특정한 목적과 활용 사례에 맞춰 발전해 왔습니다. 가장 오랫동안 사용되어 온 <a href="https://gazebosim.org/home">Gazebo</a>를 비롯해, 특정 로봇 태스크(task) 개발에 적합한 <a href="https://pybullet.org/wordpress/">PyBullet</a>, <a href="https://mujoco.org/">MuJoCo</a>, 그리고 Google에서 개발한 초고속 GPU 기반 시뮬레이터 <a href="https://github.com/google/brax">Brax</a> 등 다양한 시뮬레이터들이 있습니다. 더 많은 로봇 시뮬레이터에 대한 정보를 알고 싶으시다면 <a href="https://simulately.wiki/">Simulately Wiki</a>를 한번 살펴보시는 것도 좋습니다.</p>
<p>그렇다면 어떤 시뮬레이터를 선택해야 할까요? 아래 표에서 볼 수 있듯이, <strong>사용하는 물리 엔진</strong>, <strong>ROS2와의 연동 가능 여부</strong>, <strong>AI/ML 프레임워크와의 통합 용이성</strong> 등에 따라 선택 기준이 달라집니다. 예를 들어, Gazebo는 ROS(로봇 운영 체제)와의 연동이 강력한 반면, MuJoCo나 PyBullet은 강화 학습 및 AI 기반 로봇 학습에 더 적합한 환경을 제공합니다. 로봇 연구와 개발을 위해서는 <strong>목표하는 작업(Task)에 적합한 시뮬레이터를 선택하는 것이 핵심</strong>입니다.</p>
<center>
<img src="../../images/2025-03-14-isaacsim/1.jpg" width="100%">
<figcaption>
다양한 로봇 시뮬레이터 비교표
</figcaption>
</center>
<p>앞서 다양한 로봇 시뮬레이터가 존재한다는 점을 살펴보았는데, 오늘은 그중에서도 <strong>NVIDIA에서 개발하고 있는 Isaac Sim</strong>이라는 시뮬레이터에 대해 자세히 알아보겠습니다. 또한, <strong>Isaac Sim을 기반으로 로봇 프로그래밍을 더욱 쉽게 만들어주는 프레임워크인 Isaac Lab</strong>도 함께 소개하려 합니다.</p>
<p>사실 NVIDIA는 예전부터 로봇 시뮬레이터 개발에 꾸준히 투자해 왔으며, 다양한 이름으로 여러 오픈 소스 프로젝트를 공개해 왔습니다. 그래서 <strong>“Isaac”</strong>이라는 이름을 가진 프로젝트들이 여럿 존재하는데요. 대표적인 예로, <strong>Isaac Gym, Isaac Sim, 그리고 과거 Orbit 프로젝트</strong>가 있습니다. 흥미롭게도, 오늘 소개할 <strong>Isaac Lab</strong>도 원래는 <strong>2023년까지만 해도 <a href="https://arxiv.org/abs/2301.04195">Orbit</a>이라는 이름의 프로젝트</strong>였습니다. 하지만 최근 NVIDIA의 <strong>GR00T 프로젝트</strong>와 함께 통합되면서, 새로운 이름인 <strong>Isaac Lab</strong>으로 재탄생하게 되었습니다.</p>
<p>(사실 저도 이전에 정리했던 <a href="https://curieuxjy.github.io/posts/code/2023-04-04-install-orbit.html">Orbit 설치 가이드</a> 포스팅이 한순간에 무용지물이 되어버렸다는 안타까운 사연이 있습니다…😅 하지만, 당시 Omniverse, Isaac Sim, Orbit의 관계를 정리했던 부분은 여전히 유효하기 때문에 지금도 도움이 되는 자료이긴 합니다.)</p>
</section>
<section id="isaacsim-vs.-isaacgym" class="level1">
<h1>IsaacSim VS. IsaacGym</h1>
<p><strong>Isaac Gym/Sim 무엇이 다를까?</strong></p>
<p>Isaac Sim을 처음 접하시는 분들 중에는 연구 논문에서 더 자주 등장하는 <strong>Isaac Gym</strong>과 혼동하는 경우가 많습니다. 사실, 두 시뮬레이터는 서로 밀접한 관련이 있지만, <strong>목적과 기능이 다릅니다.</strong> 따라서 본격적으로 Isaac Sim을 살펴보기 전에, 먼저 <strong>Isaac Gym과 Isaac Sim의 차이점</strong>을 이해하는 것이 중요합니다.</p>
<center>
<img src="../../images/2025-03-14-isaacsim/2.jpg" width="100%">
<figcaption>
Isaac Sim VS. IsaacGym
</figcaption>
</center>
<p><strong>1. Isaac Gym: 강화 학습을 위한 고성능 GPU 시뮬레이터</strong></p>
<p>먼저, <strong>Isaac Gym</strong>은 강화 학습(RL)을 위한 <strong>GPU 기반의 고성능 물리 시뮬레이터</strong>입니다. NVIDIA의 <strong>PhysX 엔진</strong> 위에 구축되어 있으며, CPU 기반의 기존 물리 엔진과 비교했을 때 <strong>훨씬 빠른 시뮬레이션 속도</strong>를 자랑합니다. Isaac Gym의 가장 큰 특징은 <strong>GPU를 활용한 병렬 연산</strong>을 통해 <strong>수많은 환경을 동시에 실행할 수 있다는 점</strong>입니다. 덕분에 로봇 학습을 위한 데이터 수집이 매우 빠르게 이루어지며, CPU 기반 시뮬레이션에서는 불가능했던 <strong>대규모 병렬 시뮬레이션</strong>이 가능합니다.</p>
<p>이러한 강력한 성능 덕분에, Isaac Gym은 로봇 강화 학습 연구에서 널리 사용되어 왔습니다. 예를 들어, <strong>다리 달린 로봇의 보행 학습</strong>, <strong>In-hand Manipulation</strong>, <strong>산업 조립(Industrial Assembly)</strong> 등의 연구에서 성공적으로 활용되었습니다.</p>
<p>하지만 <strong>Isaac Gym은 범용 로봇 시뮬레이터가 아닙니다.</strong> 강화 학습을 위한 최적화가 이루어진 만큼, 몇 가지 기능이 빠져 있습니다.</p>
<ul>
<li><strong>변형체(Soft Body) 시뮬레이션 X</strong> → 강체(Rigid Body) 물리 시뮬레이션만 지원</li>
<li><strong>고품질 렌더링 X</strong> → 사실적인 그래픽 구현이 어려움</li>
<li><strong>ROS/ROS2 지원 X</strong> → 실제 로봇과의 연동이 어려움</li>
</ul>
<p>즉, Isaac Gym은 <strong>“강화 학습을 위한 초고속 물리 시뮬레이터”</strong>이지만, <strong>범용적인 로봇 시뮬레이션에는 한계가 있습니다.</strong></p>
<hr>
<p><strong>2. Isaac Sim: 범용 로봇 시뮬레이션 플랫폼</strong></p>
<p><strong>Isaac Sim</strong>은 <strong>NVIDIA Omniverse 플랫폼 위에 구축된 범용 로봇 시뮬레이터</strong>입니다. Isaac Gym이 물리 시뮬레이션에 초점을 맞췄다면, Isaac Sim은 <strong>보다 폭넓은 로봇 연구와 개발을 지원하는 환경</strong>을 제공합니다. 가장 큰 차이점은 <strong>고품질 렌더링과 다양한 로봇 기능 지원</strong>입니다. Isaac Sim은 최신 RTX 그래픽 기술을 활용하여 <strong>사실적인 3D 시뮬레이션을 제공하며</strong>, 다양한 센서(LiDAR, RGB-D 카메라 등)를 시뮬레이션할 수 있어 <strong>실제 로봇 시스템과의 연동이 용이합니다.</strong> 뿐만 아니라, <strong>ROS/ROS2를 완벽하게 지원</strong>하여, Isaac Sim에서 개발한 로봇 알고리즘을 실제 하드웨어에서도 그대로 실행할 수 있습니다.</p>
<p>또한, <strong>도메인 랜덤화(Domain Randomization)와 합성 데이터 생성 기능</strong>을 활용하여, <strong>Sim2Real</strong> 연구에도 매우 유용합니다. 이러한 기능들은 실제 로봇이 직면할 다양한 환경 변화에 대해 강건한 학습이 가능하도록 도와줍니다.</p>
<p>Isaac Sim의 또 다른 강점은 <strong>클라우드 기반 실행이 가능하다는 점</strong>입니다. NVIDIA의 <strong>Isaac Automator</strong>를 사용하면, 물리적으로 높은 사양의 GPU를 갖춘 장비가 없더라도, 클라우드에서 Isaac Sim을 실행하여 대규모 시뮬레이션을 수행할 수 있습니다.</p>
<p><strong>Isaac Gym과 Isaac Sim, 어떤 것을 선택해야 할까?</strong></p>
<table class="table">
<thead>
<tr class="header">
<th>비교 항목</th>
<th><strong>Isaac Gym</strong></th>
<th><strong>Isaac Sim</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>목적</strong></td>
<td>강화 학습 (RL) 중심</td>
<td>범용 로봇 시뮬레이션</td>
</tr>
<tr class="even">
<td><strong>물리 엔진</strong></td>
<td>GPU 기반 PhysX</td>
<td>PhysX + Omniverse RTX</td>
</tr>
<tr class="odd">
<td><strong>강화 학습 지원</strong></td>
<td>✅ 매우 빠름</td>
<td>✅ 지원하지만 상대적으로 무거움</td>
</tr>
<tr class="even">
<td><strong>ROS/ROS2 지원</strong></td>
<td>❌ 없음</td>
<td>✅ 가능</td>
</tr>
<tr class="odd">
<td><strong>센서 시뮬레이션</strong></td>
<td>❌ 제한적</td>
<td>✅ 다양한 센서 모델 제공</td>
</tr>
<tr class="even">
<td><strong>렌더링 품질</strong></td>
<td>❌ 기본 수준</td>
<td>✅ 고품질 (RTX 지원)</td>
</tr>
<tr class="odd">
<td><strong>클라우드 실행</strong></td>
<td>❌ 지원 X</td>
<td>✅ 가능 (Isaac Automator)</td>
</tr>
</tbody>
</table>
<details>
<summary>
선택 가이드
</summary>
<ul>
<li><strong>강화 학습 중심의 빠른 물리 시뮬레이션이 필요하다면?</strong> → <strong>Isaac Gym</strong><br>
</li>
<li><strong>범용 로봇 시뮬레이션과 ROS/센서 시뮬레이션이 필요하다면?</strong> → <strong>Isaac Sim</strong><br>
</li>
</ul>
</details>
<section id="isaacgymenvs-및-omniisaacgymenvs" class="level2">
<h2 class="anchored" data-anchor-id="isaacgymenvs-및-omniisaacgymenvs">IsaacGymEnvs 및 OmniIsaacGymEnvs</h2>
<p>NVIDIA가 <strong>Isaac Gym과 Isaac Sim</strong>을 공개하면서, 이 두 시뮬레이터를 보다 쉽게 활용할 수 있도록 <a href="https://github.com/isaac-sim/IsaacGymEnvs"><strong>IsaacGymEnvs</strong></a>와 <a href="https://github.com/isaac-sim/OmniIsaacGymEnvs"><strong>OmniIsaacGymEnvs</strong></a>라는 오픈 소스 환경을 함께 제공했습니다. 이 환경들은 각각의 시뮬레이터 위에서 실행되며, 기본적인 시뮬레이션 기능을 테스트하고 로봇 학습이 가능한 범위를 보여주는 소스코드들을 보여줍니다. 즉, <strong>IsaacGymEnvs는 Isaac Gym 기반</strong>, <strong>OmniIsaacGymEnvs는 Isaac Sim 기반</strong>으로 동작하며, 각 시뮬레이터의 장점을 최대한 활용할 수 있도록 설계되었습니다.</p>
<p>이 환경들을 사용하면, <strong>사전 정의된 로봇 태스크를 빠르게 실행하고 학습 성능을 벤치마킹하는 데 유용</strong>합니다. 하지만, 연구자들이 직접 커스텀 환경을 개발하거나 새로운 알고리즘을 테스트하기에는 <strong>구조적으로 한계가 많았습니다.</strong></p>
<p>❌ 특정 태스크에 최적화된 환경 → 새로운 태스크 추가가 어려움</p>
<p>❌ 환경의 확장성이 부족 → 다양한 로봇 실험을 하기에 한계</p>
<p>❌ 연구자가 직접 실험을 설계하기 어려움</p>
<p>결국, 로봇 학습 연구가 점점 복잡해지고 다양한 실험이 필요해지면서, IsaacGymEnvs와 OmniIsaacGymEnvs만으로는 한계를 극복하기 어려워졌고 이 문제를 해결하기 위해 등장한 것이 바로 <strong>Isaac Lab</strong>입니다.</p>
</section>
</section>
<section id="isaac-lab" class="level1">
<h1>Isaac Lab</h1>
<p>NVIDIA는 최근 Isaac Sim을 기반으로 한 통합적인 로봇 학습 프레임워크, Isaac Lab을 발표했습니다. 이는 단순히 기존 환경들을 개선한 것이 아니라, 보다 유연하고 확장 가능한 방식으로 로봇 학습을 지원합니다. 기존의 IsaacGymEnvs, OmniIsaacGymEnvs, Orbit 같은 개별적인 프레임워크들은 특정 환경이나 태스크에 맞춰 설계된 반면, Isaac Lab은 이러한 한계를 극복하고, 연구자들이 직접 원하는 환경과 알고리즘을 쉽게 구축할 수 있도록 설계되었습니다.</p>
<center>
<img src="../../images/2025-03-14-isaacsim/3.jpg" width="100%">
<figcaption>
Isaac Sim Ecosystem
</figcaption>
</center>
<section id="isaac-lab의-핵심-특징" class="level3">
<h3 class="anchored" data-anchor-id="isaac-lab의-핵심-특징"><strong>Isaac Lab의 핵심 특징</strong></h3>
<p>Isaac Lab은 강화 학습(RL), 시연을 통한 학습(LfD), 모션 플래닝 등 다양한 로봇 연구 워크플로우를 단순화하는 것을 목표로 합니다. 이를 위해 모듈형(modular) 구조를 갖추고 있으며, 연구자가 손쉽게 환경을 변경하거나 새로운 태스크를 추가할 수 있도록 확장성을 고려하여 설계되었습니다.</p>
<p>✔️ Isaac Lab이 기존 프레임워크와 다른 점</p>
<p>✅ 사전 구축된 환경 &amp; 태스크 제공 → 바로 사용할 수 있는 샘플 환경 포함</p>
<p>✅ 맞춤형 커스텀 환경 개발 지원 → 사용자가 직접 환경을 설계하고 실험 가능</p>
<p>✅ 강화 학습 &amp; 모션 플래닝 최적화 → 다양한 학습 방법 적용 가능</p>
</section>
<section id="isaac-lab에서-새롭게-추가된-기능" class="level3">
<h3 class="anchored" data-anchor-id="isaac-lab에서-새롭게-추가된-기능"><strong>Isaac Lab에서 새롭게 추가된 기능</strong></h3>
<p>뿐만 아니라, Isaac Sim의 모든 기능을 계승하면서도, 로봇 학습 연구를 위한 새로운 기능들이 추가되었습니다.</p>
<p><strong>🔹 구동기(Actuator) 동역학 시뮬레이션</strong></p>
<p>기존 IsaacGymEnvs에서는 단순한 힘 기반 제어가 주로 사용되었지만, Isaac Lab에서는 모터와 액추에이터의 동역학을 보다 정교하게 반영할 수 있습니다. 이는 실제 로봇의 제어 방식과 더욱 유사한 시뮬레이션을 가능하게 합니다.</p>
<p><strong>🔹 절차적 지형 생성(Procedural Terrain Generation)</strong></p>
<p>학습을 위한 다양한 환경을 자동으로 생성할 수 있도록 프로시저럴(Procedural) 방식의 지형 생성 기능을 지원합니다. 이는 로봇이 다양한 지형을 학습하는 데 유용하며, 일반화 성능 향상에 기여합니다.</p>
<p><strong>🔹 인간 시연 데이터 수집 기능</strong></p>
<p>시연을 통한 학습(LfD: Learning from Demonstration)을 위한 데이터 수집 기능을 포함하여, 사람 시연 데이터 기반의 강화 학습 및 행동 복제(Behavior Cloning)가 가능합니다. 이는 단순한 RL을 넘어, 보다 효율적인 학습 방법론을 연구하는 데 유용합니다.</p>
</section>
</section>
<section id="installation" class="level1">
<h1><strong>Installation</strong></h1>
<p>이제 <strong>Isaac Sim과 그 위에서 동작하는 Isaac Lab을 직접 설치</strong>해 보겠습니다.<br>
많은 로봇 개발이 리눅스 환경에서 진행되기 때문에, 이후 과정은 <strong>리눅스를 기준</strong>으로 설명합니다.</p>
<hr>
<section id="isaac-sim-설치" class="level2">
<h2 class="anchored" data-anchor-id="isaac-sim-설치"><strong>Isaac Sim 설치</strong></h2>
<p><a href="https://developer.nvidia.com/isaac/sim">Isaac Sim</a>은 <code>4.5.0</code> 버전으로 업데이트되면서 설치 과정이 더욱 간편해졌습니다.<br>
하지만, <strong>시뮬레이터를 실행하기 위해서는 고성능 그래픽 카드 및 특정 요구 사항을 충족해야 합니다.</strong></p>
<hr>
<p><strong>📌 시스템 사양 확인: Isaac Sim Compatibility Checker</strong></p>
<p>NVIDIA에서는 <strong>Isaac Sim을 실행할 수 있는지 자동으로 점검할 수 있도록</strong><br>
<strong>Isaac Sim Compatibility Checker</strong> 도구를 제공합니다.</p>
<p>✅ <strong>설치 및 실행 방법</strong><br>
1️⃣ <a href="https://developer.nvidia.com/isaac/sim">Isaac Sim Compatibility Checker 최신 버전 다운로드</a><br>
2️⃣ 압축을 풀어 원하는 폴더에 저장<br>
3️⃣ 아래 명령어로 실행</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="ex">./omni.isaac.sim.compatibility_check.sh</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>4️⃣ 검사 결과 확인 (색상 코드 안내)<br>
- <strong>🟢 Green (최적)</strong>: 모든 요구 사항 충족<br>
- <strong>🟢 Light-green (양호)</strong>: 실행 가능하지만 성능 최적화 가능<br>
- <strong>🟠 Orange (충분하지만 개선 필요)</strong>: 실행은 가능하지만 권장 사양보다 낮음<br>
- <strong>🔴 Red (미지원)</strong>: 실행 불가능</p>
<p>👉 <strong>이 도구를 먼저 실행하여 시스템이 적합한지 확인한 후, 설치를 진행하는 것을 추천합니다.</strong></p>
<hr>
<p><strong>📌 설치 전 요구 사항</strong></p>
<p><strong>💻 최소 요구 사양</strong></p>
<ul>
<li><strong>운영체제</strong>: Ubuntu 20.04 이상<br>
</li>
<li><strong>GPU</strong>: NVIDIA RTX 3060 이상 (RTX 3090 / 4090 권장)<br>
</li>
<li><strong>CUDA 버전</strong>: 11.8 이상<br>
</li>
<li><strong>VRAM</strong>: 최소 8GB (12GB 이상 권장)<br>
</li>
<li><strong>RAM</strong>: 최소 16GB (32GB 이상 권장)<br>
</li>
<li><strong>디스크 공간</strong>: 최소 100GB 이상의 여유 공간</li>
</ul>
<p>👉 <strong>Isaac Sim은 고성능 GPU를 요구하며, 내장 그래픽 카드로는 실행이 어렵습니다.</strong><br>
👉 <strong>최신 NVIDIA 드라이버가 설치되어 있어야 합니다.</strong></p>
<hr>
<p><strong>📌 Isaac Sim 설치 (Standalone 방식)</strong></p>
<p>Isaac Sim은 <strong>Omniverse Launcher 없이 독립 실행형(Standalone) 패키지로 다운로드하여 설치</strong>해야 합니다.</p>
<p>✅ <strong>설치 방법</strong><br>
1️⃣ <a href="https://docs.isaacsim.omniverse.nvidia.com/4.5.0/installation/download.html#">Isaac Sim 다운로드 페이지</a>에서 최신 릴리스 다운로드<br>
2️⃣ 아래 명령어를 실행하여 설치</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a><span class="fu">mkdir</span> ~/isaacsim</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="bu">cd</span> ~/Downloads</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="fu">unzip</span> <span class="st">"isaac-sim-standalone@4.5.0-rc.36+release.19112.f59b3005.gl.linux-x86_64.release.zip"</span> <span class="at">-d</span> ~/isaacsim</span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="bu">cd</span> ~/isaacsim</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="ex">./post_install.sh</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="ex">./isaac-sim.selector.sh</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>3️⃣ 설치 후, <strong>Isaac Sim App Selector</strong>가 실행되며 실행 모드를 선택 가능</p>
<hr>
<p><strong>📌 Isaac Sim 실행하기</strong></p>
<p>설치 후 실행하려면, 아래 명령어를 사용합니다.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1"></a><span class="ex">./isaac-sim.sh</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>👉 <strong>최초 실행 시 셰이더 캐시 로딩(Warmup)이 필요할 수 있습니다.</strong><br>
👉 이 경우, 아래 명령어를 실행하여 셰이더 캐시를 미리 로드합니다.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1"></a><span class="ex">./isaac-sim.sh</span> <span class="at">--warmup</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr>
</section>
<section id="isaac-lab-설치" class="level2">
<h2 class="anchored" data-anchor-id="isaac-lab-설치"><strong>Isaac Lab 설치</strong></h2>
<p>Isaac Lab은 <strong>Isaac Sim이 설치된 환경에서 동작</strong>하므로, 먼저 Isaac Sim을 설치한 후 진행해야 합니다.<br>
Isaac Sim을 <strong>pip 환경에서 사용하기 위해 추가적인 설치 과정이 필요</strong>합니다.</p>
<hr>
<p><strong>📌 설치 전 요구 사항 확인</strong></p>
<p>✅ <strong>GLIBC 버전 확인 (Ubuntu 20.04에서는 추가 조치 필요)</strong></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1"></a><span class="fu">ldd</span> <span class="at">--version</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>👉 <strong>GLIBC 2.34 이상이 필요합니다. Ubuntu 20.04 기본 버전(2.31)과 호환되지 않을 수 있으므로 확인이 필요합니다.</strong></p>
<hr>
<p><strong>📌 Conda 가상환경 설정</strong></p>
<p>Isaac Sim을 활용하기 위해 <strong>Python 3.10 환경을 갖춘 가상 환경을 생성</strong>합니다.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1"></a><span class="ex">conda</span> create <span class="at">-n</span> env_isaaclab python=3.10</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="ex">conda</span> activate env_isaaclab</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr>
<p><strong>📌 PyTorch 설치 (CUDA 버전에 맞게 선택)</strong></p>
<p>CUDA 버전에 맞는 PyTorch를 설치해야 합니다.</p>
<p>✅ <strong>CUDA 11을 사용하는 경우:</strong></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1"></a><span class="ex">pip</span> install torch==2.5.1 <span class="at">--index-url</span> https://download.pytorch.org/whl/cu118</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>✅ <strong>CUDA 12를 사용하는 경우:</strong></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1"></a><span class="ex">pip</span> install <span class="at">--upgrade</span> <span class="at">--pre</span> torch <span class="at">--index-url</span> https://download.pytorch.org/whl/nightly/cu128</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr>
<p><strong>📌 Isaac Sim pip 설치</strong></p>
<p>pip를 이용해 <strong>Isaac Sim을 가상 환경에서 설치</strong>합니다.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1"></a><span class="ex">pip</span> install <span class="at">--upgrade</span> pip</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="ex">pip</span> install <span class="st">'isaacsim[all,extscache]==4.5.0'</span> <span class="at">--extra-index-url</span> https://pypi.nvidia.com</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>✅ <strong>설치 확인</strong></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1"></a><span class="ex">isaacsim</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>✅ <strong>특정 환경 파일 실행</strong></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1"></a><span class="ex">isaacsim</span> isaacsim.exp.full.kit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>⚠️ <strong>첫 실행 시 NVIDIA EULA 동의가 필요합니다.</strong></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1"></a><span class="ex">Do</span> you accept the EULA<span class="pp">?</span> <span class="er">(</span><span class="ex">Yes/No</span><span class="kw">)</span><span class="bu">:</span> Yes</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>👉 <strong>첫 실행 시 모든 확장(extension) 파일이 다운로드되므로 10분 이상 소요될 수 있습니다.</strong></p>
<hr>
<p><strong>📌 Isaac Lab 클론 (소스 코드 다운로드)</strong></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1"></a><span class="fu">git</span> clone https://github.com/isaac-sim/IsaacLab.git</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="bu">cd</span> IsaacLab</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr>
<p><strong>📌 의존성 패키지 설치</strong></p>
<p>Isaac Lab 실행을 위해 필요한 패키지를 설치합니다.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1"></a><span class="fu">sudo</span> apt install cmake build-essential</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>그 후, Isaac Lab의 의존성을 설치합니다.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1"></a><span class="ex">./isaaclab.sh</span> <span class="at">--install</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>👉 <strong>모든 강화 학습 프레임워크를 함께 설치합니다.</strong><br>
👉 특정 프레임워크만 설치하고 싶다면 아래와 같이 실행합니다.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1"></a><span class="ex">./isaaclab.sh</span> <span class="at">--install</span> rl_games  <span class="co"># 특정 프레임워크 (예: rl_games)만 설치</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>✅ <strong>설치 가능한 프레임워크 목록</strong><br>
- <code>rl_games</code> - <code>rsl_rl</code> - <code>sb3</code> - <code>skrl</code> - <code>robomimic</code> - <code>none</code> (학습 프레임워크 제외)</p>
<hr>
<p><strong>📌 Isaac Lab 실행 확인</strong></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1"></a><span class="co"># Option 1: isaaclab.sh 실행</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="ex">./isaaclab.sh</span> <span class="at">-p</span> scripts/tutorials/00_sim/create_empty.py</span>
<span id="cb17-3"><a href="#cb17-3"></a></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="co"># Option 2: Python으로 직접 실행</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="ex">python</span> scripts/tutorials/00_sim/create_empty.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>✅ <strong>정상적으로 실행되면, Isaac Lab이 올바르게 설치된 것입니다! 🎉</strong></p>
<hr>
<p><strong>설치 후 실행 및 검증</strong></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1"></a><span class="ex">isaacsim</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>👉 <strong>GUI가 실행되면서 Isaac Sim을 사용할 수 있습니다.</strong></p>
<p>✅ <strong>강화 학습 예제 실행</strong></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1"></a><span class="ex">./isaaclab.sh</span> <span class="at">-p</span> scripts/tutorials/01_rl/train_policy.py</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>지금까지 <strong>로봇 시뮬레이터의 개요부터 Isaac Sim과 Isaac Lab의 차이점, 그리고 설치 과정까지</strong> 자세히 알아보았습니다. 최근 <strong>Physical AI와 로봇 개발에 대한 관심이 급증</strong>하면서, 로봇 시뮬레이터 역시 중요한 도구로 자리 잡고 있습니다. 그중에서도 <strong>Isaac Sim은 GPU 가속 기반의 강력한 물리 시뮬레이션 기능을 제공하며, 로봇 학습 및 시뮬레이션의 새로운 표준이 되고 있습니다.</strong></p>
<p>Isaac Sim을 활용하면 <strong>고품질 그래픽, 물리 엔진 최적화, ROS/강화 학습 통합</strong> 등 다양한 기능을 효율적으로 사용할 수 있으며, 이를 기반으로 한 <strong>Isaac Lab을 통해 더욱 체계적인 로봇 학습 환경을 구축할 수 있습니다.</strong> 물론, <strong>Isaac Sim을 실행하기 위해서는 고사양의 GPU가 필요하다는 점이 부담</strong>이 될 수 있습니다. 하지만, <strong>로봇 시뮬레이션과 강화 학습에 관심이 있다면 충분히 투자할 가치가 있는 환경</strong>입니다.</p>
<p>다음 포스팅에서는 <strong>Isaac Lab을 활용하여 직접 시뮬레이션을 실행하고, 기본적인 사용법을 익히는 과정</strong>을 다뤄보겠습니다. 이제 본격적으로 <strong>Isaac Lab을 활용한 로봇 학습의 세계로 들어가 볼 준비가 되셨나요?</strong> 🚀</p>
<p>👉 <strong>다음 글에서 만나겠습니다!</strong> 😊</p>
</section>
<section id="reference" class="level1">
<h1>Reference</h1>
<ul>
<li><a href="https://simulately.wiki/docs/category/general-simulators/">Simulately Wiki</a></li>
<li><a href="https://isaac-sim.github.io/IsaacLab/main/source/setup/ecosystem.html">IsaacSim Ecosystem</a></li>
<li><a href="https://isaac-sim.github.io/IsaacLab/main/source/setup/installation/pip_installation.html">IsaacSim Installation</a></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>