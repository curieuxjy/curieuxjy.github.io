<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-09-30">
<meta name="description" content="Note">

<title>📝IsaacLab VS. MjLab – Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-bc185b5c5bdbcb35c2eb49d8a876ef70.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-5a614c35f1f90bfd0a5b2992298a8538.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-23aef1c2a45953e85f3378e7ccfb1407.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>


</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#isaaclab" id="toc-isaaclab" class="nav-link active" data-scroll-target="#isaaclab">IsaacLab</a></li>
  <li><a href="#isaac-lab-생태계" id="toc-isaac-lab-생태계" class="nav-link" data-scroll-target="#isaac-lab-생태계">Isaac Lab 생태계</a>
  <ul class="collapse">
  <li><a href="#isaac-lab-isaac-sim-nvidia-omniverse-생태계에서의-위치" id="toc-isaac-lab-isaac-sim-nvidia-omniverse-생태계에서의-위치" class="nav-link" data-scroll-target="#isaac-lab-isaac-sim-nvidia-omniverse-생태계에서의-위치">Isaac Lab, Isaac Sim, NVIDIA Omniverse 생태계에서의 위치</a>
  <ul class="collapse">
  <li><a href="#isaac-lab은-생태계에서-어디에-위치하는가" id="toc-isaac-lab은-생태계에서-어디에-위치하는가" class="nav-link" data-scroll-target="#isaac-lab은-생태계에서-어디에-위치하는가">Isaac Lab은 생태계에서 어디에 위치하는가?</a></li>
  </ul></li>
  <li><a href="#isaac-lab의-역할과-목표" id="toc-isaac-lab의-역할과-목표" class="nav-link" data-scroll-target="#isaac-lab의-역할과-목표">Isaac Lab의 역할과 목표</a></li>
  <li><a href="#isaac-lab은-시뮬레이터인가" id="toc-isaac-lab은-시뮬레이터인가" class="nav-link" data-scroll-target="#isaac-lab은-시뮬레이터인가">Isaac Lab은 시뮬레이터인가?</a></li>
  <li><a href="#왜-isaac-lab을-사용해야-하나" id="toc-왜-isaac-lab을-사용해야-하나" class="nav-link" data-scroll-target="#왜-isaac-lab을-사용해야-하나">왜 Isaac Lab을 사용해야 하나?</a></li>
  </ul></li>
  <li><a href="#mjlab" id="toc-mjlab" class="nav-link" data-scroll-target="#mjlab">mjlab</a></li>
  <li><a href="#왜-mjlab인가" id="toc-왜-mjlab인가" class="nav-link" data-scroll-target="#왜-mjlab인가">왜 mjlab인가?</a>
  <ul class="collapse">
  <li><a href="#문제점" id="toc-문제점" class="nav-link" data-scroll-target="#문제점">문제점</a></li>
  <li><a href="#해결책" id="toc-해결책" class="nav-link" data-scroll-target="#해결책">해결책</a>
  <ul class="collapse">
  <li><a href="#왜-isaac-lab-newton을-쓰지-않았나" id="toc-왜-isaac-lab-newton을-쓰지-않았나" class="nav-link" data-scroll-target="#왜-isaac-lab-newton을-쓰지-않았나">왜 Isaac Lab + Newton을 쓰지 않았나?</a></li>
  <li><a href="#왜-isaac-lab에-mujoco-warp를-추가하지-않았나" id="toc-왜-isaac-lab에-mujoco-warp를-추가하지-않았나" class="nav-link" data-scroll-target="#왜-isaac-lab에-mujoco-warp를-추가하지-않았나">왜 Isaac Lab에 MuJoCo Warp를 추가하지 않았나?</a></li>
  </ul></li>
  <li><a href="#철학" id="toc-철학" class="nav-link" data-scroll-target="#철학">철학</a></li>
  <li><a href="#언제-mjlab을-써야-하나" id="toc-언제-mjlab을-써야-하나" class="nav-link" data-scroll-target="#언제-mjlab을-써야-하나">언제 mjlab을 써야 하나</a></li>
  <li><a href="#결론" id="toc-결론" class="nav-link" data-scroll-target="#결론">결론</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">📝IsaacLab VS. MjLab</h1>
  <div class="quarto-categories">
    <div class="quarto-category">isaaclab</div>
    <div class="quarto-category">mjlab</div>
    <div class="quarto-category">2025</div>
  </div>
  </div>

<div>
  <div class="description">
    Note
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 30, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="isaaclab" class="level1">
<h1><a href="https://github.com/isaac-sim/IsaacLab">IsaacLab</a></h1>
</section>
<section id="isaac-lab-생태계" class="level1">
<h1>Isaac Lab 생태계</h1>
<p>Isaac Lab은 최신 시뮬레이션 기술을 활용하는 통합적이고 유연한 로봇 학습 프레임워크를 제공하기 위해 Isaac Sim 위에 구축되었습니다. 모듈화 및 확장성을 염두에 두고 설계되었으며, 강화학습(RL), 시범학습(learning from demonstrations), 모션 플래닝과 같은 로보틱스 연구의 일반적인 워크플로우를 단순화하는 것을 목표로 합니다. 일부 미리 만들어진 환경, 센서, 태스크를 포함하고 있지만, 주된 목표는 커스텀 환경과 로봇 학습 알고리즘을 개발·검증하기 위한 오픈소스화된 통일된 사용하기 쉬운 인터페이스를 제공하는 것입니다.</p>
<p>Isaac Lab을 사용하려면 Isaac Sim 설치가 필요합니다. Isaac Sim은 Isaac Lab이 의존하는 핵심 로보틱스 도구들(URDF 및 MJCF 임포터, 시뮬레이션 매니저, ROS 기능 등)을 포함한 패키지로 제공됩니다. 또한 Isaac Sim은 NVIDIA Omniverse 플랫폼 위에서 동작하며, PhysX 기반의 고급 물리 시뮬레이션, 포토리얼리스틱 렌더링 기술, 그리고 장면 생성을 위한 Universal Scene Description(USD)을 활용합니다.</p>
<p>Isaac Lab은 Isaac Sim의 기능을 계승할 뿐만 아니라 로봇 학습 연구와 관련된 여러 새로운 기능을 추가합니다. 예를 들어 작동기(actuator) 동역학 시뮬레이션, 절차적(프로시저럴) 지형 생성, 인간 시연으로부터 데이터 수집 지원 등이 포함됩니다.</p>
<section id="isaac-lab-isaac-sim-nvidia-omniverse-생태계에서의-위치" class="level2">
<h2 class="anchored" data-anchor-id="isaac-lab-isaac-sim-nvidia-omniverse-생태계에서의-위치">Isaac Lab, Isaac Sim, NVIDIA Omniverse 생태계에서의 위치</h2>
<section id="isaac-lab은-생태계에서-어디에-위치하는가" class="level3">
<h3 class="anchored" data-anchor-id="isaac-lab은-생태계에서-어디에-위치하는가">Isaac Lab은 생태계에서 어디에 위치하는가?</h3>
<p>수년간 NVIDIA는 로보틱스와 AI를 위한 여러 도구를 개발해왔습니다. 이 도구들은 GPU의 연산 능력을 활용하여 시뮬레이션의 속도와 사실감을 가속화합니다. 시뮬레이션 기술 분야에서 큰 가능성을 보여주며 전 세계의 많은 연구자와 기업에서 사용되고 있습니다.</p>
<p>Isaac Gym [MWG+21]은 로봇 학습을 위한 고성능 GPU 기반 물리 시뮬레이션을 제공합니다. 이는 PhysX 위에 구축되어 있으며 강체의 GPU 가속 시뮬레이션을 지원하고 물리 시뮬레이션 데이터에 직접 접근할 수 있는 Python API를 제공합니다. 엔드투엔드 GPU 파이프라인을 통해 CPU 기반 물리 엔진에 비해 높은 프레임 레이트를 달성할 수 있습니다. 이 도구는 다지간 보행(legged locomotion) [RHRH22][RHBH22], 핸드 인핸드 조작(in-hand manipulation) [HAM+22][AML+22], 산업 조립(industrial assembly) [NSA+22] 등 여러 연구 프로젝트에서 성공적으로 사용되었습니다.</p>
<p>하지만 Isaac Gym은 범용 로보틱스 시뮬레이터로 설계된 것은 아닙니다. 예를 들어 변형체(deformable)와 강체(rigid) 간의 상호작용, 고충실도 렌더링, ROS 지원 등은 포함되어 있지 않습니다. 이 도구는 기본적으로 기본 물리 엔진의 기능을 보여주기 위한 프리뷰 릴리스로 설계되었습니다. Isaac Sim의 출시와 함께 NVIDIA는 로봇 공학용 범용 시뮬레이터를 구축하고 Isaac Gym의 기능을 Isaac Sim에 통합하고 있습니다.</p>
<p>Isaac Sim은 Omniverse 위에 구축된 로봇 시뮬레이션 툴킷으로, 복잡한 3D 워크플로우를 통합하려는 범용 플랫폼입니다. Isaac Sim은 그래픽스와 물리 시뮬레이션의 최신 발전을 활용해 로보틱스를 위한 고충실도 시뮬레이션 환경을 제공합니다. ROS/ROS2 지원, 다양한 센서 시뮬레이션, 도메인 랜덤화 및 합성 데이터 생성 도구를 지원합니다. Isaac Sim의 타일드 렌더링(tiled rendering) 기능은 환경 전반에 걸친 벡터화된 렌더링을 허용하며, Isaac Automator를 통해 클라우드에서 실행하는 것도 지원합니다. 전반적으로 로보틱스 연구자에게 강력한 도구이며 시뮬레이션 분야에서 큰 진전입니다.</p>
<p>위의 두 도구가 출시되면서 NVIDIA는 Isaac Gym 및 Isaac Sim 위에 빌드된 오픈소스 환경 모음인 IsaacGymEnvs와 OmniIsaacGymEnvs를 공개했습니다. 이 환경들은 기저 시뮬레이터의 가능성을 보여주기 위해 설계되었고, 시뮬레이터로 무엇이 가능한지 이해하기 위한 출발점을 제공합니다. 벤치마크 용도로 사용될 수 있지만, 커스텀 환경과 알고리즘을 개발·검증하기 위한 목적으로 설계된 것은 아닙니다. 여기서 Isaac Lab이 역할을 합니다.</p>
</section>
</section>
<section id="isaac-lab의-역할과-목표" class="level2">
<h2 class="anchored" data-anchor-id="isaac-lab의-역할과-목표">Isaac Lab의 역할과 목표</h2>
<p>Isaac Lab은 최신 시뮬레이션 기술을 활용하는 통합적이고 유연한 로봇 학습 프레임워크를 제공하기 위해 Isaac Sim 위에 구축되었습니다. 모듈화 및 확장성을 염두에 두고 설계되었으며, 강화학습, 시범학습, 모션 플래닝 등 로보틱스 연구의 일반적 워크플로우를 단순화하는 것을 목표로 합니다. 일부 미리 만들어진 환경, 센서, 태스크를 포함하지만, 주요 목표는 커스텀 환경과 로봇 학습 알고리즘을 개발·검증하기 위한 오픈소스화된 통합 인터페이스 제공입니다. Isaac Sim의 기능을 계승함과 동시에 작동기 동역학, 절차적 지형 생성, 인간 시연 데이터 수집 지원 등 로봇 학습 연구에 특화된 여러 기능을 추가합니다.</p>
<p>Isaac Lab은 이전의 IsaacGymEnvs, OmniIsaacGymEnvs 및 Orbit 프레임워크를 대체하며, Isaac Sim용 단일 로봇 학습 프레임워크가 될 예정입니다. 이전에 배포된 프레임워크들은 더 이상 권장되지 않으며, 사용자들은 마이그레이션 가이드를 따라 Isaac Lab으로 전환하는 것을 권장합니다.</p>
</section>
<section id="isaac-lab은-시뮬레이터인가" class="level2">
<h2 class="anchored" data-anchor-id="isaac-lab은-시뮬레이터인가">Isaac Lab은 시뮬레이터인가?</h2>
<p>사람들이 시뮬레이터를 생각할 때 흔히 떠올리는 엔진들(예: MuJoCo, Bullet, Flex)처럼 강력한 물리 엔진들이 있습니다. 이들 엔진은 여러 연구에서 사용되어 왔지만, 이들은 로봇 공학을 위한 범용 시뮬레이터로 설계된 것은 아닙니다. 주로 강체 및 변형체의 동역학을 시뮬레이션하는 물리 엔진이며, 시뮬레이션을 시각화하기 위한 기본 렌더링 기능과 다양한 장면 기술 포맷을 파싱하는 기능을 제공합니다.</p>
<p>최근 작업들 중 일부는 이러한 물리 엔진들을 다양한 렌더링 엔진과 결합하여 보다 완전한 시뮬레이션 환경을 만듭니다. 이들은 물리 및 렌더링 엔진에 대한 입출력 API를 포함하고, 경우에 따라 ROS 및 하드웨어-인-더-루프(hardware-in-the-loop) 시뮬레이션을 지원합니다. 예로는 AirSim, DoorGym, ManiSkill, ThreeDWorld, 그리고 Isaac Sim이 있습니다.</p>
<p>본질적으로 Isaac Lab은 로봇 학습 애플리케이션을 Isaac Sim 위에 구축하기 위한 프레임워크이지, 자체만으로 범용 시뮬레이터는 아닙니다. 이와 동등한 예로는 MuJoCo 위에 구축된 RoboSuite(고정 기반 로봇에 특화) 등이 있습니다. 다른 예로 MuJoCo Playground와 Isaac Gym이 있는데, 각각 MJX와 PhysX를 사용합니다. 이들은 여러 사전 구축 태스크를 포함하지만, 태스크별로 독립적인 구현이 분리되어 있어 코드 중복이 발생하기 쉬우며, 대형 프로젝트나 팀 단위에서 코드 재사용성을 떨어뜨릴 수 있습니다.</p>
<p>Isaac Lab의 주요 목표는 로봇 학습에 필요한 다양한 도구와 기능을 포함하는 통일된 프레임워크를 제공하면서도 사용 및 확장이 용이하도록 하는 것입니다. 로보틱스 연구의 공통된 요구사항을 단순화하는 디자인 패턴을 포함합니다. 예를 들어 서로 다른 주파수의 센서 시뮬레이션, 데이터 수집을 위한 다양한 원격조작(teleoperation) 인터페이스 연결, 정책 학습을 위한 액션 스페이스 전환, 구성 관리를 위한 Hydra 사용, 다양한 학습 라이브러리 지원 등이 있습니다. Isaac Lab은 매니저 기반(모듈화) 패턴과 직접 실행(single-script, Isaac Gym 유사) 패턴을 모두 지원하여 사용자가 사례에 맞는 방식을 선택할 수 있게 합니다. 각 패턴에 대해 벤치마킹과 연구에 사용할 수 있는 여러 사전 구축 태스크도 포함되어 있습니다.</p>
</section>
<section id="왜-isaac-lab을-사용해야-하나" class="level2">
<h2 class="anchored" data-anchor-id="왜-isaac-lab을-사용해야-하나">왜 Isaac Lab을 사용해야 하나?</h2>
<p>Isaac Lab은 커뮤니티가 벤치마크와 로봇 학습 시스템 설계를 위한 통합된 노력을 통해 진보를 이끌 수 있도록 오픈소스 플랫폼을 제공합니다. 이는 기존 구성요소와 알고리즘을 재사용하고 서로의 작업 위에 구축할 수 있게 해줍니다. 이렇게 함으로써 시간과 노력을 절약할 수 있고, 연구의 더 중요한 부분에 집중할 수 있습니다. Isaac Lab의 목표는 로봇 학습 연구의 사실상 표준 플랫폼(데 팍토 플랫폼)과 Isaac Sim을 활용하는 환경 동물원(environment zoo)이 되는 것입니다. 프레임워크가 성숙해짐에 따라(내부 NVIDIA 개발 및 협업 파트너의 최신 시뮬레이션 발전과 함께) 큰 이득을 볼 것으로 기대합니다.</p>
<p>이미 대학 및 연구소의 여러 실험실과 협력하여 그들의 작업을 Isaac Lab에 통합하는 작업을 진행 중이며, 커뮤니티의 다른 이들도 이 노력에 동참하기를 기대합니다. Isaac Lab에 기여하고 싶다면 저희에게 연락해 주세요.</p>
<ul>
<li><a href="https://developer.nvidia.com/blog/train-a-quadruped-locomotion-policy-and-simulate-cloth-manipulation-with-nvidia-isaac-lab-and-newton/">Train a Quadruped Locomotion Policy and Simulate Cloth Manipulation with NVIDIA Isaac Lab and Newton</a></li>
</ul>
</section>
</section>
<section id="mjlab" class="level1">
<h1><a href="https://github.com/mujocolab/mjlab">mjlab</a></h1>
</section>
<section id="왜-mjlab인가" class="level1">
<h1>왜 mjlab인가?</h1>
<section id="문제점" class="level2">
<h2 class="anchored" data-anchor-id="문제점">문제점</h2>
<p>GPU 가속 로보틱스 시뮬레이션에는 훌륭한 도구들이 많지만, 각각 트레이드오프가 존재합니다:</p>
<p><strong>Isaac Lab</strong>: 뛰어난 API와 RL 추상화를 제공하지만, 무거운 설치 과정, 느린 시작 시간, Omniverse 관련 오버헤드 때문에 빠른 반복 실험이 어렵습니다.</p>
<p><strong>MJX</strong>: 빠르고 가볍지만, JAX의 학습 곡선과 충돌(collision) 처리의 확장성 문제로 채택이 제한됩니다.</p>
<p><strong>Newton</strong>: MuJoCo, VBD 등 여러 솔버를 지원하는 새로운 범용 시뮬레이터이며 MJCF/XML 대신 USD 기반 포맷을 사용합니다. 하지만 MuJoCo가 수년간 쌓아온 생태계와 커뮤니티 자원은 아직 갖추지 못했습니다.</p>
</section>
<section id="해결책" class="level2">
<h2 class="anchored" data-anchor-id="해결책">해결책</h2>
<p><strong>mjlab = Isaac Lab의 API + MuJoCo의 단순성 + GPU 가속</strong></p>
<p>우리는 Isaac Lab의 검증된 매니저 기반 아키텍처와 RL 추상화를 가져와 이를 MuJoCo Warp 위에 직접 올렸습니다. 변환 레이어도, Omniverse 오버헤드도 없습니다. 빠르고 투명한 물리입니다.</p>
<section id="왜-isaac-lab-newton을-쓰지-않았나" class="level3">
<h3 class="anchored" data-anchor-id="왜-isaac-lab-newton을-쓰지-않았나">왜 Isaac Lab + Newton을 쓰지 않았나?</h3>
<p>Isaac Lab은 최근 <a href="https://github.com/isaac-sim/IsaacLab/tree/dev/newton">실험적 Newton 지원</a>을 추가했는데, 이는 기존 Isaac 사용자들이 Newton의 백엔드를 통해 MuJoCo를 시도해볼 수 있게 해주어 좋은 선택입니다.</p>
<p>포괄적인 플랫폼(RL, 모방학습, 포토리얼리스틱 렌더링 등)이 필요하면 Isaac Lab을 사용하세요. MuJoCo 기반의 RL 및 sim2real에 집중된 도구가 필요하면 mjlab을 사용하세요.</p>
</section>
<section id="왜-isaac-lab에-mujoco-warp를-추가하지-않았나" class="level3">
<h3 class="anchored" data-anchor-id="왜-isaac-lab에-mujoco-warp를-추가하지-않았나">왜 Isaac Lab에 MuJoCo Warp를 추가하지 않았나?</h3>
<p>에코시스템 차원에서는 멋진 아이디어입니다! NVIDIA 팀도 최근의 <a href="https://github.com/isaac-sim/IsaacLab/tree/dev/newton">실험적 Newton 통합</a>으로 이 가능성을 탐색하고 있어 흥미롭습니다.</p>
<p>하지만 우리는 현실적으로 유지보수할 수 있는, 더 집중된 출발점을 원했습니다. Isaac Lab은 Omniverse/Isaac Sim의 강력한 기능을 중심으로 설계되어 있고, 그만큼 광범위한 사용 사례를 지원합니다. MuJoCo Warp를 그 안에 통합하려면 더 큰 프레임워크 내에서 작업하고, 우리가 목표로 하지 않는 여러 사용 사례까지 지원해야 합니다.</p>
<p>멀티-백엔드 호환성을 유지하려면 자연스럽게 복잡성과 의존성 관리에서의 타협이 필요합니다. 처음부터 새로 시작함으로써 우리는 다음을 할 수 있었습니다:</p>
<ul>
<li>MuJoCo Warp에 최적화된 가벼운 코드베이스 작성</li>
<li>의존성을 최소화하고 설치를 빠르게 유지</li>
<li>사용자들이 익숙한 네이티브 mjModel/mjData 구조에 대한 직접 접근 유지</li>
<li>더 큰 플랫폼의 제약 없이 빠르게 반복 개선</li>
</ul>
<p>mjlab을 Isaac Lab의 훌륭한 API 설계에 바치는 헌사로 생각하세요. 매니저 기반의 추상화를 MuJoCo 중심의 작고 집중된 도구를 원하는 연구자들에게 제공하는 것입니다. 경쟁이 아니라 보완입니다.</p>
</section>
</section>
<section id="철학" class="level2">
<h2 class="anchored" data-anchor-id="철학">철학</h2>
<p><strong>하드웨어 수준의 성능</strong></p>
<ul>
<li>MuJoCo Warp와의 직접 통합 — 중간 변환 레이어 없음</li>
<li>사용자들이 익숙한 네이티브 mjModel/mjData 구조 유지</li>
<li>최소한의 오버헤드로 GPU 가속</li>
</ul>
<p><strong>개발자 경험 우선</strong></p>
<ul>
<li>한 줄 설치: <code>uvx --from mjlab demo</code></li>
<li>매우 빠른 시작 시간</li>
<li>표준 Python 디버깅 가능 (원하는 곳에서 pdb 사용)</li>
<li>빠른 반복 주기</li>
</ul>
<p><strong>명확히 집중된 범위</strong></p>
<ul>
<li>강체(rigid-body) 로보틱스와 RL에 집중 — 모든 것을 하려 하지 않음</li>
<li>기능 남발보다 깔끔하고 유지보수 가능한 코드베이스</li>
<li>범용 래퍼가 아닌 MuJoCo 네이티브 구현</li>
</ul>
</section>
<section id="언제-mjlab을-써야-하나" class="level2">
<h2 class="anchored" data-anchor-id="언제-mjlab을-써야-하나">언제 mjlab을 써야 하나</h2>
<p><strong>mjlab을 사용하세요</strong> — 만약 당신이:</p>
<ul>
<li>빠른 반복과 디버깅을 원하고,</li>
<li>MuJoCo 물리를 직접 제어하고 싶고,</li>
<li>Isaac Lab 스타일의 검증된 RL 추상화를 원하며,</li>
<li>무겁지 않은 의존성으로 GPU 가속을 원하고,</li>
<li>설치 및 배포를 단순하게 유지하고 싶다면</li>
</ul>
<p><strong>Isaac Lab을 사용하세요</strong> — 만약 당신이:</p>
<ul>
<li>포토리얼리스틱 렌더링이 필요하고,</li>
<li>USD 파이프라인 통합이 필요하며,</li>
<li>Omniverse 생태계 기능을 활용해야 한다면</li>
</ul>
<p><strong>Newton을 사용하세요</strong> — 만약 당신이:</p>
<ul>
<li>다중 물리 솔버 지원(예: 변형체 등)이 필요하거나,</li>
<li>미분 가능한 시뮬레이션이 필요하다면</li>
</ul>
</section>
<section id="결론" class="level2">
<h2 class="anchored" data-anchor-id="결론">결론</h2>
<p>mjlab은 모든 것을 대체하려는 목적이 아닙니다. MuJoCo의 단순함을 사랑하고 Isaac Lab의 RL 추상화를 GPU 가속과 함께, 불필요한 오버헤드 없이 원한다면 mjlab은 그들을 위한 도구입니다.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>