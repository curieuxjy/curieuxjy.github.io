<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-09-25">
<meta name="description" content="linked-in positing">

<title>ğŸ“Comparative Analysis of Robotic Simulation Environments â€“ Curieux.JY</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../profile.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ef56b68f8fa1e9d2ba328e99e439f80.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-b009f778f5cec7f34f624408a2b5b543.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-ecf89aac047581c664da7ae53d704519.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2NVZN2MJZT"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-2NVZN2MJZT', { 'anonymize_ip': true});
</script>


</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Curieux.JY</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Post</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../note.html"> 
<span class="menu-text">Note</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Jung Yeon Lee</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#mujoco-multi-joint-dynamics-with-contact" id="toc-mujoco-multi-joint-dynamics-with-contact" class="nav-link active" data-scroll-target="#mujoco-multi-joint-dynamics-with-contact">MuJoCo (Multi-Joint dynamics with Contact)</a></li>
  <li><a href="#nvidia-isaac-lab-physx-ê¸°ë°˜-ì‹œë®¬ë ˆì´ì…˜" id="toc-nvidia-isaac-lab-physx-ê¸°ë°˜-ì‹œë®¬ë ˆì´ì…˜" class="nav-link" data-scroll-target="#nvidia-isaac-lab-physx-ê¸°ë°˜-ì‹œë®¬ë ˆì´ì…˜">NVIDIA Isaac Lab (PhysX ê¸°ë°˜ ì‹œë®¬ë ˆì´ì…˜)</a></li>
  <li><a href="#ê¸°íƒ€-ê´€ë ¨-ë¬¼ë¦¬-ì—”ì§„bullet-ode-brax-ë“±" id="toc-ê¸°íƒ€-ê´€ë ¨-ë¬¼ë¦¬-ì—”ì§„bullet-ode-brax-ë“±" class="nav-link" data-scroll-target="#ê¸°íƒ€-ê´€ë ¨-ë¬¼ë¦¬-ì—”ì§„bullet-ode-brax-ë“±">ê¸°íƒ€ ê´€ë ¨ ë¬¼ë¦¬ ì—”ì§„(Bullet, ODE, Brax ë“±)</a></li>
  <li><a href="#newtonì˜-í†µí•©ê³¼-ê³ ìœ í•œ-ì´ì " id="toc-newtonì˜-í†µí•©ê³¼-ê³ ìœ í•œ-ì´ì " class="nav-link" data-scroll-target="#newtonì˜-í†µí•©ê³¼-ê³ ìœ í•œ-ì´ì ">Newtonì˜ í†µí•©ê³¼ ê³ ìœ í•œ ì´ì </a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">ğŸ“Comparative Analysis of Robotic Simulation Environments</h1>
  <div class="quarto-categories">
    <div class="quarto-category">simulator</div>
    <div class="quarto-category">mujoco</div>
    <div class="quarto-category">isaaclab</div>
    <div class="quarto-category">2025</div>
  </div>
  </div>

<div>
  <div class="description">
    linked-in positing
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 25, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<ul>
<li><a href="https://www.linkedin.com/pulse/comparative-analysis-robotic-simulation-environments-fs-studio-cpjic/">Original Link</a></li>
</ul>
<p>ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ë¬¼ë¦¬ì˜ ì—­í• ê³¼, ì „ë°˜ì ì¸ ì‹œë®¬ë ˆì´ì…˜/ê²Œì„ ì—”ì§„ì—ì„œ í˜„ì¬ ë„ë¦¬ ì“°ì´ëŠ” ë¬¼ë¦¬ ì—”ì§„ì˜ ì§€í˜•ë„ë¥¼ ì¡°ê¸ˆ ë” ê¹Šì´ íŒŒê³ ë“¤ê³ ì í–ˆìŠµë‹ˆë‹¤. ë˜í•œ ì´ë²ˆ ì£¼ì˜ Newton ë°œí‘œì™€ ì´ê²ƒì„ ì—°ê²° ì§€ì–´ ë³´ê³ ì í–ˆìŠµë‹ˆë‹¤.</p>
<p>ë¡œë³´í‹±ìŠ¤ ì‹œë®¬ë ˆì´í„°ëŠ” ê°€ìƒ í™˜ê²½ì—ì„œ ì œì–´ ì•Œê³ ë¦¬ì¦˜ì„ ê°œë°œÂ·í…ŒìŠ¤íŠ¸í•˜ëŠ” ë° í•„ìˆ˜ì ì…ë‹ˆë‹¤. ì—¬ëŸ¬ ëŒ€í‘œì ì¸ ë¬¼ë¦¬ ì—”ì§„ê³¼ ì‹œë®¬ë ˆì´ì…˜ í”„ë ˆì„ì›Œí¬â€”MuJoCo, NVIDIA Isaac Lab(PhysX ê¸°ë°˜), ê·¸ë¦¬ê³  ê¸°íƒ€ ê´€ë ¨ ì—”ì§„ë“¤(Bullet, Brax ë“±)â€”ì„ ì„±ëŠ¥, ì‚¬ìš© ìš©ì´ì„±, í˜¸í™˜ì„±, ì ìš© ë²”ìœ„ ê´€ì ì—ì„œ ë¹„êµí•©ë‹ˆë‹¤. ê° ì‹œë®¬ë ˆì´í„°ëŠ” ì„œë¡œ ë‹¤ë¥¸ ê°•ì ì„ ì§€ë‹ˆê³  ìˆìœ¼ë©°, Nvidia Newtonì€ ì´ëŸ¬í•œ í™˜ê²½ë“¤ ì¤‘ ìµœì„ ì˜ ê²ƒë“¤ê³¼ í†µí•©ë˜ë„ë¡ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
<section id="mujoco-multi-joint-dynamics-with-contact" class="level1">
<h1>MuJoCo (Multi-Joint dynamics with Contact)</h1>
<ul>
<li><strong>ì„±ëŠ¥</strong>: MuJoCoëŠ” íš¨ìœ¨ì ì¸ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ìœ¼ë¡œ ìœ ëª…í•˜ë©°, ì¢…ì¢… CPUë§Œìœ¼ë¡œë„ ì‹¤ì‹œê°„ë³´ë‹¤ ë¹ ë¥´ê²Œ ì‹¤í–‰ë©ë‹ˆë‹¤.</li>
<li><strong>ì‚¬ìš© ìš©ì´ì„±</strong>: MuJoCoëŠ” ì˜ ì„¤ê³„ëœ C APIë¥¼ ì œê³µí•˜ê³  MJCF ë˜ëŠ” URDF í˜•íƒœì˜ ëª¨ë¸ ê¸°ìˆ ì„ ì§€ì›í•˜ì—¬ ë¡œë´‡ê³¼ í™˜ê²½ì„ ë¹„êµì  ì§ê´€ì ìœ¼ë¡œ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
<li><strong>í˜¸í™˜ì„±</strong>: MuJoCoëŠ” í¬ë¡œìŠ¤ í”Œë«í¼ì´ë©° ì´ì œ ì˜¤í”ˆì†ŒìŠ¤ë¡œ ê³µê°œë˜ì–´ í˜¸í™˜ì„±ì´ ë„“ì–´ì¡ŒìŠµë‹ˆë‹¤. ê°•í™”í•™ìŠµ í”„ë ˆì„ì›Œí¬ì™€ë„ ì˜ í†µí•©ë˜ë©°â€”ì˜ˆë¥¼ ë“¤ì–´ OpenAI Gym/Gymnasiumê³¼ DeepMind Control SuiteëŠ” ë²¤ì¹˜ë§ˆí‚¹ì„ ìœ„í•œ í‘œì¤€í™”ëœ MuJoCo í™˜ê²½ì„ ì œê³µí•©ë‹ˆë‹¤. MuJoCo ì—”ì§„ ìì²´ëŠ” ìˆœìˆ˜í•˜ê²Œ ë¬¼ë¦¬ì— ì§‘ì¤‘í•˜ë©°, ë Œë”ë§ì„ ìœ„í•´ ê¸°ë³¸ OpenGL ì‹œê°í™”ë¥¼ ì œê³µí•˜ì§€ë§Œ í¬í† ë¦¬ì–¼ë¦¬ì¦˜ ìˆ˜ì¤€ì€ ì•„ë‹™ë‹ˆë‹¤. ë¡œë³´í‹±ìŠ¤ ì—°êµ¬ì— í•„ìš”í•œ ë‹¤ì–‘í•œ ë¡œë´‡ êµ¬ì„±ìš”ì†Œ(ì¡°ì¸íŠ¸, ì•¡ì¶”ì—ì´í„°, ì„¼ì„œ)ë¥¼ ì§€ì›í•©ë‹ˆë‹¤. DeepMindì˜ ì˜¤í”ˆì†Œì‹±ìœ¼ë¡œ MuJoCo ì½”ë“œëŠ” í™•ì¥í•˜ê±°ë‚˜ ë‹¤ë¥¸ ë„êµ¬(ì˜ˆ: JAX ê¸°ë°˜ ê°€ì†ê¸°ë‚˜ Warp GPU ë°±ì—”ë“œ)ì™€ ê²°í•©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
<li><strong>ì ìš© ë²”ìœ„</strong>: MuJoCoëŠ” í•™ê³„ì™€ ì‚°ì—…ì—ì„œ ë¡œë´‡ í•™ìŠµ, ìš´ë™ ì œì–´, ìƒì²´ì—­í•™ ë¶„ì•¼ì— í­ë„“ê²Œ ì‚¬ìš©ë˜ì–´ ì™”ìŠµë‹ˆë‹¤. ë³µì¡í•œ ì ‘ì´‰ê³¼ ë‹¤ê´€ì ˆ êµ¬ì¡°(ì˜ˆ: ë³´í–‰ ë¡œë´‡, ë§¤ë‹ˆí“°ë ˆì´í„°)ë¥¼ ë†’ì€ ë¬¼ë¦¬ì  ì¶©ì‹¤ë„ë¡œ ì‹œë®¬ë ˆì´ì…˜í•˜ëŠ” ê°•ì  ë•ë¶„ì— ë§ì€ RL í™˜ê²½ì˜ ê¸°ë³¸ ì„ íƒì§€ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.</li>
</ul>
</section>
<section id="nvidia-isaac-lab-physx-ê¸°ë°˜-ì‹œë®¬ë ˆì´ì…˜" class="level1">
<h1>NVIDIA Isaac Lab (PhysX ê¸°ë°˜ ì‹œë®¬ë ˆì´ì…˜)</h1>
<ul>
<li><strong>ì„±ëŠ¥</strong>: Isaac Labì€ NVIDIAì˜ PhysX ì—”ì§„ê³¼ Omniverse ì‹œë®¬ë ˆì´ì…˜ ë„êµ¬ ìœ„ì— êµ¬ì¶•ë˜ì–´ ìˆìŠµë‹ˆë‹¤. PhysXëŠ” (ë§ì€ ê²Œì„ì—ì„œ ì‚¬ìš©ë˜ëŠ”) ì„±ìˆ™í•˜ê³  ê³ ë„ë¡œ ìµœì í™”ëœ ë¬¼ë¦¬ ì—”ì§„ìœ¼ë¡œ, ëŒ€ê·œëª¨ ì‹œë®¬ë ˆì´ì…˜ì„ ì²˜ë¦¬í•  ìˆ˜ ìˆìœ¼ë©° íŠ¹ì • ê¸°ëŠ¥ì—ì„œ GPU ê°€ì†ì„ ì§€ì›í•©ë‹ˆë‹¤. Isaac Lab/Simì—ì„œëŠ” ë¡œë³´í‹±ìŠ¤ë¥¼ ìœ„í•´ PhysXê°€ êµ¬ì„±ë˜ì–´ ìˆì–´ ì •í™•í•œ ê´€ì ˆ(articulation) ì†”ë²„ì™€ ë‹¤ìˆ˜ì˜ ì—ì´ì „íŠ¸ ì§€ì›ì„ ì œê³µí•©ë‹ˆë‹¤. PhysXì˜ CPU ì‹¤í–‰ì€ ë©€í‹°ìŠ¤ë ˆë“œë¡œ ìƒë‹¹íˆ ë¹ ë¥´ì§€ë§Œ, Isaacì˜ ê°•ì  ì¤‘ í•˜ë‚˜ëŠ” NVIDIA GPUë¥¼ ì ê·¹ í™œìš©í•œë‹¤ëŠ” ì ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ Isaac Simì€ ê°•ì²´ ì—°ì‚°ì„ ì˜¤í”„ë¡œë”©í•˜ê³  RTX GPU ë ˆì´ íŠ¸ë ˆì´ì‹±ì„ ì„¼ì„œ ë Œë”ë§ì— ì‚¬ìš©í•˜ì—¬, ë†’ì€ ì¶©ì‹¤ë„ë¥¼ ìœ ì§€í•˜ë©´ì„œë„ ì„±ëŠ¥ ì¢‹ì€ ì‹œë®¬ë ˆì´ì…˜ì„ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.</li>
<li><strong>ì‚¬ìš© ìš©ì´ì„±</strong>: MuJoCo ê°™ì€ ê²½ëŸ‰ ì—”ì§„ê³¼ ë¹„êµí•˜ë©´ Isaac Lab/Simì€ ì„¤ì •ì´ ë” ë³µì¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤â€”ì¼ë°˜ì ìœ¼ë¡œ ê°•ë ¥í•œ NVIDIA GPUì™€(ìƒë‹¹íˆ í° ì†Œí”„íŠ¸ì›¨ì–´ ìŠ¤íƒì¸) Isaac Sim ì„¤ì¹˜ê°€ í•„ìš”í•©ë‹ˆë‹¤. ë‹¤ë§Œ, NVIDIAëŠ” í¸ì˜ ë„êµ¬ë“¤ì„ ì œê³µí•˜ê³  ìˆìœ¼ë©°, Isaac Lab ìì²´ëŠ” ë§ì€ ì €ìˆ˜ì¤€ ë””í…Œì¼ì„ ì¶”ìƒí™”í•œ Python APIë¥¼ ê°–ì¶˜ ì˜¤í”ˆì†ŒìŠ¤ í”„ë ˆì„ì›Œí¬ì…ë‹ˆë‹¤.</li>
<li><strong>í˜¸í™˜ì„±</strong>: Isaac Labì€ NVIDIA ë¡œë³´í‹±ìŠ¤ ìƒíƒœê³„ì™€ ì™„ì „íˆ í˜¸í™˜ë©ë‹ˆë‹¤. í™˜ê²½ê³¼ ë¡œë´‡ í‘œí˜„ì— USD(Universal Scene Description) í¬ë§·ì„ ì‚¬ìš©í•˜ë¯€ë¡œ ìƒí˜¸ ìš´ìš©ì„±ì´ ì¢‹ìŠµë‹ˆë‹¤â€”USDë¥¼ ì§€ì›í•˜ëŠ” CADë‚˜ ë‹¤ë¥¸ ì‹œë®¬ë ˆì´í„°ì—ì„œ ëª¨ë¸ì„ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
<li><strong>ì ìš© ë²”ìœ„</strong>: Isaac Lab/Simì€ ì—”ë“œ íˆ¬ ì—”ë“œ ë¡œë³´í‹±ìŠ¤ ê°œë°œì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤. ì—¬ê¸°ì—ëŠ” ë¡œë´‡ í•™ìŠµ(ê°•í™”í•™ìŠµê³¼ ëª¨ë°©í•™ìŠµ)ë¿ ì•„ë‹ˆë¼ ë¡œë´‡ ì„¤ê³„, ë‚´ë¹„ê²Œì´ì…˜/ì¡°ì‘ ì•Œê³ ë¦¬ì¦˜ í…ŒìŠ¤íŠ¸, ì§€ê° ëª¨ë¸ í•™ìŠµìš© í•©ì„± ë°ì´í„° ìƒì„± ë“±ì´ í¬í•¨ë©ë‹ˆë‹¤. ì¹´ë©”ë¼(RGB, ê¹Šì´, LiDAR)ë¥¼ ì‚¬ì‹¤ì ìœ¼ë¡œ ì‹œë®¬ë ˆì´ì…˜í•˜ëŠ” ëŠ¥ë ¥ì€ ë¡œë´‡ì˜ ì„¼ì„œê°€ ë£¨í”„ì— í¬í•¨ë˜ëŠ” ì‘ì—…(ì˜ˆ: ë¹„ì „ ê¸°ë°˜ ì •ì±… í•™ìŠµ, ê°€ìƒ ì„¸ê³„ì—ì„œ ììœ¨ì£¼í–‰ì°¨ í…ŒìŠ¤íŠ¸)ì—ì„œ í•µì‹¬ ì¥ì ì…ë‹ˆë‹¤. Isaacì€ ì°½ê³  ë¡œë´‡ ì‹œë®¬ë ˆì´ì…˜ë¶€í„° íœ´ë¨¸ë…¸ì´ë“œ ì œì–´, ì‹¤ì œ í™˜ê²½ì˜ ë””ì§€í„¸ íŠ¸ìœˆì— ì´ë¥´ê¸°ê¹Œì§€ ë‹¤ì–‘í•œ ì‘ìš©ì— ì‚¬ìš©ë˜ì–´ ì™”ìŠµë‹ˆë‹¤. ë‰´í„´ì˜ ì—­í• : Nvidia Newtonì€ ì°¨ì„¸ëŒ€ ë¬¼ë¦¬ ì˜µì…˜ìœ¼ë¡œ Isaac Labê³¼ í†µí•©ë  ì˜ˆì •ì…ë‹ˆë‹¤.</li>
</ul>
</section>
<section id="ê¸°íƒ€-ê´€ë ¨-ë¬¼ë¦¬-ì—”ì§„bullet-ode-brax-ë“±" class="level1">
<h1>ê¸°íƒ€ ê´€ë ¨ ë¬¼ë¦¬ ì—”ì§„(Bullet, ODE, Brax ë“±)</h1>
<p>MuJoCoì™€ Isaac/PhysX ì™¸ì—ë„ ë¡œë³´í‹±ìŠ¤ ì‹œë®¬ë ˆì´ì…˜ì—ì„œ í”íˆ ì‚¬ìš©ë˜ëŠ” ì—¬ëŸ¬ ë¬¼ë¦¬ ì—”ì§„ì´ ìˆìœ¼ë©°, ê°ì ì¥ë‹¨ì ì´ ìˆìŠµë‹ˆë‹¤:</p>
<ul>
<li><strong>Bullet Physics(ë° PyBullet)</strong>: Bulletì€ ê²Œì„ê³¼ ë¡œë³´í‹±ìŠ¤ì—ì„œ ë„ë¦¬ ì“°ì´ëŠ” ì˜¤í”ˆì†ŒìŠ¤ ë¬¼ë¦¬ ì—”ì§„ì…ë‹ˆë‹¤. ê°•ì²´ì™€ ì—°ì²´ ì‹œë®¬ë ˆì´ì…˜ì„ ì§€ì›í•˜ë©°, ë¹ ë¥¸ ë¡œë´‡ ì‹œë®¬ë ˆì´ì…˜ í”„ë¡œí† íƒ€ì´í•‘ì— ì¸ê¸° ìˆëŠ” í¸ë¦¬í•œ Python ì¸í„°í˜ì´ìŠ¤(PyBullet)ë¥¼ ì œê³µí•©ë‹ˆë‹¤. Bulletì€ ë¬´ë£Œì´ë©´ì„œ ê¸°ëŠ¥ì´ ê½¤ ì¶©ì‹¤(ì¶©ëŒ, ì¡°ì¸íŠ¸ ë“±)í•˜ë‹¤ëŠ” ì ì´ ì¥ì ì´ê³ , ROS/Gazebo(ì˜µì…˜ ë¬¼ë¦¬ ì—”ì§„)ë‚˜ V-REP/CoppeliaSim ê°™ì€ ë„êµ¬ì—ë„ í†µí•©ë˜ì–´ ì™”ìŠµë‹ˆë‹¤.</li>
<li><strong>ODE(Open Dynamics Engine)</strong>: ODEëŠ” ì˜¤ë˜ëœ ì˜¤í”ˆì†ŒìŠ¤ ë¬¼ë¦¬ ì—”ì§„ ì¤‘ í•˜ë‚˜ë¡œ, ê³¼ê±° ë§ì€ ë¡œë³´í‹±ìŠ¤ ì‹œë®¬ë ˆì´í„°ì—ì„œ ì‚¬ìš©ë˜ì—ˆìŠµë‹ˆë‹¤(Gazeboì˜ ì˜¤ëœ ê¸°ë³¸ ì—”ì§„). ê¸°ë³¸ì ì¸ ê°•ì²´ ë™ì—­í•™ê³¼ ì¡°ì¸íŠ¸ ë¬¼ë¦¬ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ODEëŠ” ë§¤ìš° ê°€ë³ê³  ë‹¨ìˆœí•˜ì§€ë§Œ, ì ‘ì´‰ì´ ë§ê±°ë‚˜ ë³µì¡í•œ ì¡°ì¸íŠ¸ê°€ í¬í•¨ë˜ëŠ” ê²½ìš° ì‹œë®¬ë ˆì´ì…˜ ì•ˆì •ì„±ì´ ë–¨ì–´ì§ˆ ìˆ˜ ìˆì–´, í•©ë¦¬ì ì¸ ë™ì‘ì„ ìœ„í•´ ì¢…ì¢… ë§¤ê°œë³€ìˆ˜(ì˜ˆ: ERP/CFM) íŠœë‹ì´ í•„ìš”í•©ë‹ˆë‹¤. ì„±ëŠ¥ë„ ì¼ë°˜ì ìœ¼ë¡œ ìµœì‹  ì—”ì§„ë“¤ì— ë¹„í•´ ëŠë¦¬ê³  ìµœì í™”ê°€ ëœ ë˜ì–´ ìˆìŠµë‹ˆë‹¤.</li>
<li><strong>Brax(ë° ê¸°íƒ€ ë¯¸ë¶„ ê°€ëŠ¥í•œ ì—”ì§„)</strong>: BraxëŠ” Googleì´ ê°œë°œí•œ JAX(ë° GPU/TPU) ìœ„ì—ì„œ êµ¬ë™ë˜ëŠ” ìµœì‹  ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ, ì™„ì „ ë¯¸ë¶„ ê°€ëŠ¥(differentiable)í•©ë‹ˆë‹¤. í•˜ë“œì›¨ì–´ ê°€ì†ì„ í†µí•´ ê°•í™”í•™ìŠµ ì—ì´ì „íŠ¸ì˜ ë§¤ìš° ë¹ ë¥¸ í›ˆë ¨ì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤. BraxëŠ” ë¬¼ë¦¬ë¥¼ ë‹¨ìˆœí™”í•¨ìœ¼ë¡œì¨ ì†ë„ë¥¼ ì–»ìŠµë‹ˆë‹¤â€”ì£¼ë¡œ êµ¬í˜•/ìº¡ìŠí˜• ì¶©ëŒê³¼ íŒ¨ë„í‹° ê¸°ë°˜ ì ‘ì´‰ ëª¨ë¸ì„ ì‚¬ìš©í•˜ë©°, ì´ëŠ” ì œì•½ ê¸°ë°˜ ì†”ë²„ì— ë¹„í•´ ì •í™•ì„±ì€ ë‚®ì§€ë§Œ ë³‘ë ¬í™”ê°€ ë§¤ìš° ìš©ì´í•©ë‹ˆë‹¤. ì‚¬ìš©ì„±ë„ ë†’ì•„(Python ë…¸íŠ¸ë¶ê³¼ Google Colabì—ì„œ ì‚¬ìš© ê°€ëŠ¥), ê·¸ë˜ë””ì–¸íŠ¸ ê¸°ë°˜ ì œì–´ ì—°êµ¬ì— ë§¤ìš° ì í•©í•©ë‹ˆë‹¤. ë‹¤ë§Œ ì´ëŸ¬í•œ ë‹¨ìˆœí™”ëœ ë¬¼ë¦¬ë¡œ ì¸í•´ ì ìš© ë²”ìœ„ëŠ” ì œí•œì ì´ë©°(ì •ë°€ ì ‘ì´‰ ë™ì—­í•™ì´ë‚˜ ë³µì¡í•œ í˜•ìƒì—ëŠ” ì í•©í•˜ì§€ ì•ŠìŒ), Dojoë‚˜ Tiny Differentiable Simulator ê°™ì€ ë‹¤ë¥¸ ë¯¸ë¶„ ê°€ëŠ¥ ì‹œë®¬ë ˆì´í„°ë“¤ë„ ê°œë°œ ì¤‘ì…ë‹ˆë‹¤. ë‰´í„´ê³¼ì˜ ê´€ê³„: Newton ì—­ì‹œ GPU ì„±ëŠ¥ì„ ê°•ì¡°í•˜ì§€ë§Œ Braxë³´ë‹¤ ë” ë²”ìš©ì„±ì„ ì§€í–¥í•©ë‹ˆë‹¤. Newtonì˜ ë¯¸ë¶„ ê°€ëŠ¥í•œ ë¬¼ë¦¬ëŠ” í˜„ì‹¤ì ì¸ ì ‘ì´‰ ë™ì—­í•™ì„ í†µí•´ ê·¸ë˜ë””ì–¸íŠ¸ë¥¼ ê³„ì‚°í•  ìˆ˜ ìˆì–´, Brax(ì†ë„, ë¯¸ë¶„ ê°€ëŠ¥ì„±)ì˜ ì¥ì ê³¼ MuJoCo ê°™ì€ ì—”ì§„ì˜ í’ë¶€í•œ ë¬¼ë¦¬ë¥¼ ê²°í•©í•©ë‹ˆë‹¤.</li>
<li><strong>PhysX ë° ê¸°íƒ€</strong>: NVIDIAì˜ PhysX(Isaacì„ í†µí•´ ë…¼ì˜í•¨)ëŠ” Isaac ì™¸ë¶€ì—ì„œë„ ì‚¬ìš©ë©ë‹ˆë‹¤â€”ì˜ˆë¥¼ ë“¤ì–´ Unityì™€ Unreal ê°™ì€ ê²Œì„ ì—”ì§„ì€ PhysX ë˜ëŠ” ê·¸ ë³€í˜•ì„ ë¬¼ë¦¬ì— ì‚¬ìš©í•©ë‹ˆë‹¤. ë˜ ë‹¤ë¥¸ ì—”ì§„ì¸ Havokì€ ì—…ê³„ì—ì„œ í”í•˜ì§€ë§Œ, ë§ì¶¤í˜• ë¡œë³´í‹±ìŠ¤ ìš©ë„ë¡œ ì‰½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê²ƒì€ ì•„ë‹™ë‹ˆë‹¤. DART/DrakeëŠ” ë¡œë³´í‹±ìŠ¤ ì¤‘ì‹¬ í”„ë ˆì„ì›Œí¬ë¡œ ë¬¼ë¦¬ë¥¼ í¬í•¨í•˜ê³  ìˆìœ¼ë©°(DARTëŠ” ODE/Bulletì„, DrakeëŠ” ìì²´ ì†”ë²„ë¥¼ ì‚¬ìš©), ì •ë°€ì„± ë° ë¡œë´‡ ëª¨ë¸ í†µí•©ì„ ê°•ì¡°í•©ë‹ˆë‹¤. ì´ë“¤ì€ ê³„íš ë° ì œì–´ ì—°êµ¬ì— ê°•ë ¥í•˜ì§€ë§Œ ë” ëŠë¦¬ê³  ëŒ€ê·œëª¨ ë³‘ë ¬í™”ë¥¼ ì§€í–¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Newtonì˜ ë„ì…ì€ ì´ëŸ¬í•œ ì—”ì§„ë“¤ê³¼ ì§ì ‘ í†µí•©ë˜ëŠ” ê²ƒì€ ì•„ë‹ˆì§€ë§Œ, USDë¥¼ ê³µí†µ ì¥ë©´ í¬ë§·ìœ¼ë¡œ í™•ë¦½í•˜ê³  ì˜¤í”ˆì†ŒìŠ¤ë¡œ ì œê³µí•¨ìœ¼ë¡œì¨ ë‹¤ì–‘í•œ ì»¤ë®¤ë‹ˆí‹°ê°€ Newtonì„ ëŒ€ì•ˆ ë°±ì—”ë“œë¡œ ì±„íƒí•  ìˆ˜ ìˆëŠ” ê¸°ë°˜ì„ ë§ˆë ¨í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ í˜„ì¬ Bulletì´ë‚˜ DARTë¥¼ ì‚¬ìš©í•˜ëŠ” ë¡œë³´í‹±ìŠ¤ ì—°êµ¬ì‹¤ì€ USD íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ ëª¨ë¸ì„ ì´ì „í•˜ì—¬, Newtonì˜ ì„±ìˆ™ë„ê°€ ì˜¬ë¼ê°€ë©´ ë” ë‚˜ì€ ì„±ëŠ¥ì„ ìœ„í•´ Newtonìœ¼ë¡œ ì „í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
</ul>
</section>
<section id="newtonì˜-í†µí•©ê³¼-ê³ ìœ í•œ-ì´ì " class="level1">
<h1>Newtonì˜ í†µí•©ê³¼ ê³ ìœ í•œ ì´ì </h1>
<p>Nvidia Newtonì€ MuJoCoì™€ Isaac Lab ê°™ì€ ê¸°ì¡´ ì‹œë®¬ë ˆì´ì…˜ í™˜ê²½ê³¼ <strong>ì›í™œí•˜ê²Œ í†µí•©</strong>ë˜ë„ë¡ ì„¤ê³„ëœ ê³ ì„±ëŠ¥ ë¬¼ë¦¬ ë°±ì—”ë“œì…ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ê° í™˜ê²½ì— ë‹¤ìŒê³¼ ê°™ì€ ê³ ìœ í•œ ì´ì ì„ ì œê³µí•©ë‹ˆë‹¤:</p>
<ul>
<li><strong>í”„ë ˆì„ì›Œí¬ë¥¼ ê°€ë¡œì§€ë¥´ëŠ” í†µí•© ì—”ì§„</strong>: Newtonì€ ì„œë¡œ ë‹¤ë¥¸ ì‹œë®¬ë ˆì´í„° ë‚´ë¶€ì—ì„œ ì‹¤í–‰ë  ìˆ˜ ìˆëŠ” ê³µí†µ ë¬¼ë¦¬ ì—”ì§„ì„ ì œê³µí•©ë‹ˆë‹¤. ê°œë°œìëŠ” MuJoCo Playgroundë‚˜ Isaac Lab ê°™ì€ í”„ëŸ°íŠ¸ì—”ë“œë¥¼ ì‚¬ìš©í•˜ë©´ì„œë„ ë™ì¼í•œ Newton ë¬¼ë¦¬ ì½”ì–´ì— ì˜ì¡´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
<li><strong>GPU ê°€ì† ì„±ëŠ¥</strong>: Newtonì˜ ì£¼ìš” ì´ì ì€ GPU ìš°ì„ (GPU-first) ì„¤ê³„ì…ë‹ˆë‹¤. NVIDIA Warp ìœ„ì— êµ¬ì¶•ë¨ìœ¼ë¡œì¨ Newtonì€ ë‹¤ìˆ˜ì˜ ë¡œë´‡ì´ë‚˜ ë³µì¡í•œ ìƒí˜¸ì‘ìš©ì„ ë³‘ë ¬ë¡œ ì‹œë®¬ë ˆì´ì…˜í•˜ì—¬ ì‹¤í—˜ ì‹œê°„ì„ ëŒ€í­ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
<li><strong>ë¯¸ë¶„ ê°€ëŠ¥ ë° ê³ ê¸‰ ë¬¼ë¦¬</strong>: Newtonì€ í‘œì¤€ ì—”ì§„ê³¼ ë‹¬ë¦¬ ë¯¸ë¶„ ê°€ëŠ¥í•œ ì‹œë®¬ë ˆì´ì…˜ì„ ê¸°ë³¸ ì œê³µí•˜ë©°, ì…ë ¥ ë§¤ê°œë³€ìˆ˜ë‚˜ í–‰ë™ì— ëŒ€í•œ ë¬¼ë¦¬ ê²°ê³¼ì˜ ê·¸ë˜ë””ì–¸íŠ¸ë¥¼ ê³„ì‚°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</li>
<li><strong>í˜„ì‹¤ê°ê³¼ ì¶©ì‹¤ë„ í–¥ìƒ</strong>: í˜‘ì—…ê³¼ ì „ë¬¸í™”ë¥¼ í†µí•´ Newtonì€ í˜„ì‹¤ì„±ì„ ê°œì„ í•  ì¤€ë¹„ê°€ ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ë””ì¦ˆë‹ˆì˜ ì°¸ì—¬ëŠ” Newtonì´ ì•„ë‚˜íŠ¸ë¡œë‹‰ ìºë¦­í„°ì˜ ë³µì¡í•œ ë©”ì»¤ë‹ˆì¦˜(ê¸°ì–´ë“œ ë§í¬, ì¡°ì¸íŠ¸ì˜ ì»´í”Œë¼ì´ì–¸ìŠ¤ ë“±)ì„ ì¶©ì‹¤íˆ ì‹œë®¬ë ˆì´ì…˜í•  ìˆ˜ ìˆìŒì„ ë³´ì¥í•˜ë©°, ì´ëŠ” ìœ ì‚¬í•œ ë³µì¡ì„±ì„ ê°€ì§„ ë¡œë´‡ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ëŠ” ëª¨ë‘ì—ê²Œ ì´ë“ì´ ë©ë‹ˆë‹¤. Google DeepMindì˜ ì˜í–¥ì€ Newtonì´ ê³¼í•™ì  ì—„ë°€ì„±ì„ ìœ ì§€í•˜ë„ë¡ ë³´ì¥í•©ë‹ˆë‹¤(ì˜ˆ: ì ì ˆí•œ ë™ì—­í•™ ë°©ì •ì‹, í•™ìŠµ ì—ì´ì „íŠ¸ê°€ ì•…ìš©í•  ìˆ˜ ìˆëŠ” ì„ì˜ì˜ í¸ë²• ì—†ìŒ).</li>
<li><strong>í™•ì¥ì„±ê³¼ ì»¤ë®¤ë‹ˆí‹° ì£¼ë„ ê°œë°œ</strong>: ì˜¤í”ˆì†ŒìŠ¤ í”„ë¡œì íŠ¸ë¡œì„œ Newtonì€ ë¡œë³´í‹±ìŠ¤ ì»¤ë®¤ë‹ˆí‹°ì˜ ê¸°ì—¬ë¥¼ í™˜ì˜í•©ë‹ˆë‹¤. ì´ëŠ” OpenAIì˜ Gymì´ë‚˜ DeepMindê°€ ì˜¤í”ˆì†ŒìŠ¤í™”í•œ MuJoCo ì£¼ìœ„ì— ì»¤ë®¤ë‹ˆí‹°ê°€ í˜•ì„±ëœ ê²ƒê³¼ ìœ ì‚¬í•©ë‹ˆë‹¤. ë”°ë¼ì„œ ì‚¬ìš©ìë“¤ì´ ìƒˆë¡œìš´ ê¸°ëŠ¥, ë²„ê·¸ ìˆ˜ì •, ì„±ëŠ¥ ê°œì„ ì„ ê¸°ì—¬í•˜ë©´ì„œ ì—”ì§„ì€ ë¹ ë¥´ê²Œ ì§„í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜¤í”ˆ íŠ¹ì„±ê³¼ ëª¨ë“ˆì‹ ì„¤ê³„ëŠ” ì¥ê¸°ì ìœ¼ë¡œ ìœ ì§€ ë³´ìˆ˜ë¥¼ ì‰½ê²Œ í•˜ê³ , ìƒˆë¡œìš´ í•˜ë“œì›¨ì–´(ì°¨ì„¸ëŒ€ GPU ë“±)ë‚˜ ì—°êµ¬ ë‹ˆì¦ˆì— ì ì‘í•˜ê¸° ì‰½ê²Œ ë§Œë“­ë‹ˆë‹¤. í˜„ì¬ ì„œë¡œ ë‹¤ë¥¸ ì‹œë®¬ë ˆì´í„°ë¥¼ ì‚¬ìš©í•˜ëŠ” ì¡°ì§ì— ëŒ€í•´, Newtonì€ ë…¸ë ¥ì„ í†µí•©í•  ê²½ë¡œë¥¼ ì œê³µí•©ë‹ˆë‹¤: ê° ì—°êµ¬ì‹¤ì´ ì œê°ê° ë¬¼ë¦¬ íŠ¸ìœ…ì„ ì‘ì„±í•˜ê±°ë‚˜ ì‹œë®¬ë ˆì´í„°ë³„ë¡œ ë³„ë„ì˜ ë¬¼ë¦¬ ì½”ì–´ë¥¼ ê°–ëŠ” ëŒ€ì‹ , Newtonì´ í‘œì¤€í™”ëœ ë°±ë³¸ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ìˆ˜ë ´ì€(ë§ì€ ì´ë“¤ì´ í…ŒìŠ¤íŠ¸í•˜ê³  ê°œì„ í•˜ê¸° ë•Œë¬¸ì—) ë” ì˜ ê²€ì¦ëœ ë¬¼ë¦¬ì™€ ë” í’ë¶€í•œ ë„êµ¬ ì„¸íŠ¸(ê³µí†µ íŒŒì¼ í¬ë§·, ë·°ì–´, Newton ì¶œë ¥ê³¼ í•¨ê»˜ ì‘ë™í•˜ëŠ” ë¶„ì„ ìŠ¤í¬ë¦½íŠ¸ ë“±)ë¡œ ì´ì–´ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤. NVIDIA, DeepMind, Disneyê°€ ì´ˆê¸° ì¶”ì§„ë ¥ì„ ì œê³µí•˜ê³  ìˆì§€ë§Œ, ëª©í‘œëŠ” ì§€ì† ê°€ëŠ¥í•œ ì»¤ë®¤ë‹ˆí‹° ì£¼ë„ ì—”ì§„ì…ë‹ˆë‹¤.</li>
</ul>
<p><strong>Nvidia Newton</strong>ì€ ë¡œë³´í‹±ìŠ¤ ì‹œë®¬ë ˆì´ì…˜ì—ì„œ ì˜ë¯¸ ìˆëŠ” í•œ ê±¸ìŒì…ë‹ˆë‹¤. ê° íŒŒíŠ¸ë„ˆ ì¡°ì§ì€ ì´ í”„ë¡œì íŠ¸ì— ê³ ìœ í•œ ê°•ì ì„ ë¶ˆì–´ë„£ì—ˆìŠµë‹ˆë‹¤â€”NVIDIAëŠ” GPU ì—­ëŸ‰ê³¼ í†µí•©ì„, DeepMindëŠ” ë¹ ë¥´ê³  ì •í™•í•œ ì ‘ì´‰ ë¬¼ë¦¬ë¥¼, DisneyëŠ” ê¹Œë‹¤ë¡œìš´ ì‹¤ì„¸ê³„ ë¡œë´‡ ì‘ìš©ì„ ì œê³µí–ˆìŠµë‹ˆë‹¤â€”ê·¸ ê²°ê³¼ ê´‘ë²”ìœ„í•œ ë‹ˆì¦ˆë¥¼ ì¶©ì¡±í•  ì¤€ë¹„ê°€ ëœ ì—”ì§„ì´ íƒ„ìƒí–ˆìŠµë‹ˆë‹¤. ì‹œë®¬ë ˆì´ì…˜ í™˜ê²½ì„ ë¹„êµí•  ë•Œ Newtonì€ MuJoCoë‚˜ Isaacì„ ëŒ€ì²´í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤; ëŒ€ì‹  ì´ë¥¼ ê°•í™”í•˜ê³  í†µí•©í•©ë‹ˆë‹¤. MuJoCoëŠ” ì „ë¡€ ì—†ëŠ” ì†ë„ì™€ ê·¸ë˜ë””ì–¸íŠ¸ë¥¼ ì–»ê³ , Isaac Labì€ ê°œë°©ì„±ê³¼ ê³ ê¸‰ ë¬¼ë¦¬ë¥¼ ì–»ìœ¼ë©°, ë” ë„“ì€ ë¶„ì•¼ëŠ” í˜„ì‹¤ì„±ê³¼ ì„±ëŠ¥ì„ ê²°í•©í•œ í”Œë«í¼ì„ ì–»ê²Œ ë©ë‹ˆë‹¤. Newtonì´ ê³µê°œë¨ì— ë”°ë¼(ì²« ë²„ì „ì€ 2025ë…„ ì¤‘ ì¶œì‹œê°€ ì˜ˆìƒë¨) ì‹œë®¬ë ˆì´ì…˜ê³¼ í˜„ì‹¤ ì‚¬ì´ì˜ ê°„ê·¹ì€ ë”ìš± ì¢í˜€ì§ˆ ê²ƒì´ë©°, í…Œë§ˆíŒŒí¬ì˜ ì• ë‹ˆë§ˆíŠ¸ë¡œë‹‰ ìºë¦­í„°ë¶€í„° ì‚°ì—… í˜„ì¥ì˜ ë²”ìš© íœ´ë¨¸ë…¸ì´ë“œì— ì´ë¥´ê¸°ê¹Œì§€ ë¡œë´‡ ê°œë°œì˜ ì†ë„ê°€ ê°€ì†í™”ë  ê²ƒì…ë‹ˆë‹¤.</p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>We wanted to dive a little deeper into the role of physics in simulation and the landscape of physics engines currently popular within simulation and game engines in general. We also wanted put this in relation to the big Newton announcement this week.</p>
<p>Robotic simulators are crucial for developing and testing control algorithms in a virtual setting. We compare several prominent physics engines and simulation frameworks â€“ MuJoCo, NVIDIA Isaac Lab (PhysX-based), and other relevant engines (like Bullet and Brax) â€“ in terms of performance, ease of use, compatibility, and application scope. Each simulator has different strengths, and Nvidia Newton is designed to integrate with the best of these environments.</p>
<section id="mujoco-multi-joint-dynamics-with-contact-1" class="level1">
<h1>MuJoCo (Multi-Joint dynamics with Contact)</h1>
<ul>
<li><strong>Performance</strong>: MuJoCo is known for its efficient physics simulation, often running faster than real time even on a CPU</li>
<li><strong>Ease of Use</strong>: MuJoCo provides a well-designed C API and supports model descriptions in MJCF or URDF, making it relatively straightforward to define robots and environments</li>
<li><strong>Compatibility</strong>: MuJoCo is cross-platform and now open-source, which broadens its compatibility. It integrates well with reinforcement learning frameworks â€“ for instance, the OpenAI Gym/Gymnasium and DeepMind Control Suite provide standardized MuJoCo environments for benchmarking. The MuJoCo engine itself focuses purely on physics; for rendering, it offers basic OpenGL visualization, though not photorealistic. It supports a range of robotic components (joints, actuators, sensors) needed for robotics research. With DeepMindâ€™s open-sourcing, MuJoCoâ€™s code can be extended or paired with other tools (e.g.&nbsp;JAX-based accelerators or the Warp GPU back-end).</li>
<li><strong>Application Scope</strong>: MuJoCo has been heavily used in academia and industry for robot learning, motor control, and biomechanics. Its strength lies in simulating complex contact and articulated structures (e.g.&nbsp;legged robots, manipulators) with good physical fidelity, which is why it became the go-to for many RL environments</li>
</ul>
</section>
<section id="nvidia-isaac-lab-physx-based-simulation" class="level1">
<h1>NVIDIA Isaac Lab (PhysX-Based Simulation)</h1>
<ul>
<li><strong>Performance</strong>: Isaac Lab is built on NVIDIAâ€™s PhysX engine and Omniverse simulation tools. PhysX is a mature, highly optimized physics engine (used in many games) that can handle large-scale simulations and has support for GPU acceleration in certain features. In Isaac Lab/Sim, PhysX is configured for robotics, including accurate joint articulation solvers and support for many agents. While PhysX on CPU is multi-threaded and quite fast, one of Isaacâ€™s strengths is leveraging NVIDIA GPUs: for example, Isaac Sim can offload rigid body computations and use RTX GPU ray-tracing for rendering sensors, enabling high-fidelity yet still performant simulation</li>
<li><strong>Ease of Use</strong>: Compared to lightweight engines like MuJoCo, Isaac Lab/Sim can be more complex to set up â€“ it typically requires a robust NVIDIA GPU and the installation of Isaac Sim (which is a fairly large software stack). However, NVIDIA has provided convenient tools: Isaac Lab itself is an open-source framework with a Python API that abstracts much of the low-level detail</li>
<li><strong>Compatibility</strong>: Isaac Lab is fully compatible with the NVIDIA robotics ecosystem. It uses the USD (Universal Scene Description) format to represent environments and robots, which promotes interoperability â€“ one can import models from CAD or other simulators that support USD</li>
<li><strong>Application Scope</strong>: Isaac Lab/Sim is aimed at end-to-end robotics development. This includes robot learning (reinforcement learning and imitation learning), but also robot design, testing algorithms for navigation or manipulation, and generating synthetic data for training perception models. Its ability to simulate cameras (RGB, depth, LiDAR) with realistic visuals is a key advantage for tasks where the robotâ€™s sensors are part of the loop (e.g., training a vision-based policy or testing an autonomous vehicle in a virtual world). Isaac has been used in applications from warehouse robot simulation to humanoid control and even digital twins of real environments. Newtonâ€™s role: Nvidia Newton will integrate with Isaac Lab as a next-gen physics option</li>
</ul>
</section>
<section id="other-relevant-physics-engines-bullet-ode-brax-etc." class="level1">
<h1>Other Relevant Physics Engines (Bullet, ODE, Brax, etc.)</h1>
<p>Aside from MuJoCo and Isaac/PhysX, several other physics engines are commonly used in robotics simulation, each with their own pros and cons:</p>
<ul>
<li><strong>Bullet Physics (and PyBullet)</strong>: Bullet is an open-source physics engine widely used in games and robotics. It features rigid body and soft body simulation, and has a convenient Python interface (PyBullet) that became popular for quick robot simulation prototypes. Bullet is appreciated for being free and fairly full-featured (collision, joints, etc.), and it has been integrated into tools like ROS/Gazebo (as an optional physics engine) and V-REP/CoppeliaSim</li>
<li><strong>ODE (Open Dynamics Engine)</strong>: ODE is one of the older open-source physics engines, used historically in many robotics simulators (Gazeboâ€™s default engine for years was ODE). It provides basic rigid body dynamics and joint physics. ODE is quite light and simple, but it struggles with simulation stability when many contacts or complex joints are involved, often requiring parameter tuning (e.g., ERP/CFM settings) to get reasonable behavior. Its performance is generally slower and less optimized compared to newer engines</li>
<li><strong>Brax (and other differentiable engines)</strong>: Brax is a recent physics simulation library from Google that runs on JAX (on GPU/TPU) and is fully differentiable. Itâ€™s designed for extremely fast training of reinforcement learning agents via hardware acceleration. Brax achieves impressive speed by simplifying physics â€“ it uses primarily spherical or capsule collisions and a penalty-based contact model, which is less accurate than constraint-based solvers but very parallelizable. The ease of use is high (Brax can be used via Python notebooks and Google Colab), and being differentiable, itâ€™s great for research into gradient-based control. However, Braxâ€™s simplified physics means itâ€™s limited in scope (not suitable for fine contact dynamics or complex geometries). Other differentiable simulators (like Dojo or Tiny Differentiable Simulator) are in development as well. Newtonâ€™s relation: Newton similarly emphasizes GPU performance but aims for more generality than Brax. Newtonâ€™s differentiable physics will allow computing gradients through realistic contact dynamics, combining the benefits of Brax (speed, differentiability) with the richer physics of engines like MuJoCo</li>
<li><strong>PhysX and Others</strong>: NVIDIAâ€™s PhysX (which we discussed via Isaac) is also used outside Isaac â€“ for example, the Unity and Unreal game engines use PhysX or their variants for physics. Another engine, Havok, is common in industry (but not available for custom robotics use easily). DART/Drake are robotics-focused frameworks that include physics (DART uses ODE/Bullet, Drake has its own solver) and emphasize precision and robot model integration; they are powerful for planning and control research but are slower and not aimed at massive parallelism. Newtonâ€™s introduction does not directly integrate those engines, but by establishing USD as a common scene format and being open source, it opens the door for various communities to adopt Newton as an alternative backend. For instance, a robotics lab currently using Bullet or DART could switch to Newton for better performance once it matures, using the USD pipeline to transfer their models.</li>
</ul>
</section>
<section id="newtons-integration-and-unique-advantages" class="level1">
<h1>Newtonâ€™s Integration and Unique Advantages</h1>
<p>Nvidia Newton is designed to <strong>seamlessly integrate with existing simulation environments</strong> like MuJoCo and Isaac Lab, effectively serving as a high-performance physics backend. By doing so, it brings a set of unique advantages to each:</p>
<ul>
<li><strong>Unified Engine Across Frameworks</strong>: Newton provides a common physics engine that can run within different simulators. Developers can use MuJoCo Playground or Isaac Lab front-ends, yet rely on the same Newton physics core</li>
<li><strong>GPU-Accelerated Performance</strong>: A primary benefit of Newton is its GPU-first design. By building on NVIDIA Warp, Newton can simulate many robots or complex interactions in parallel, drastically reducing experiment time</li>
<li><strong>Differentiable and Advanced Physics</strong>: Newton offers built-in differentiable simulation, unlike standard engines. It can compute gradients of the physics outcomes with respect to input parameters or actions</li>
<li><strong>Improved Realism and Fidelity</strong>: Through collaboration and specialization, Newton is poised to improve realism. Disneyâ€™s input ensures that Newton can faithfully simulate the complex mechanisms of animatronic characters (geared linkages, compliance in joints, etc.), which in turn benefits anyone simulating robots with similar complexity. Google DeepMindâ€™s influence ensures Newton maintains scientific rigor (e.g., proper dynamic equations, no arbitrary hacks that learning agents could exploit</li>
<li><strong>Scalability and Community-Driven Development</strong>: As an open-source project, Newton invites contributions from the robotics community, much like OpenAIâ€™s Gym or DeepMindâ€™s open-sourced MuJoCo have communities around them. This means the engine can evolve quickly with new features, bug fixes, and performance improvements contributed by users. Its open nature and modular design make it easier to maintain in the long run and adapt to new hardware (future GPUs, etc.) or new research needs. For organizations using different simulators today, Newton offers a path to consolidate efforts: instead of each lab writing their own physics tweaks or each simulator having a separate physics core, Newton can become a standardized backbone. This convergence can lead to better validated physics (since many will test and improve it) and a richer set of tools (common file formats, viewers, analysis scripts that work with Newton outputs, etc.). NVIDIA, DeepMind, and Disney are providing the initial momentum, but the intent is a sustainable, community-driven engine</li>
</ul>
<p><strong>Nvidia Newton</strong> represents a significant step forward in robotics simulation. Each partner organization has infused the project with unique strengths â€“ NVIDIA with GPU prowess and integration, DeepMind with fast and accurate contact physics, Disney with demanding real-world robot applications â€“ resulting in an engine poised to serve a wide range of needs. When comparing simulation environments, Newton doesnâ€™t replace MuJoCo or Isaac; instead, it enhances and unifies them. MuJoCo gains unprecedented speed and gradients, Isaac Lab gains openness and advanced physics, and the broader field gains a platform that marries realism with performance. As Newton becomes available (the first version is expected sometime in 2025), we can expect the gap between simulation and reality to narrow, accelerating the development of robots from animated characters in theme parks to general-purpose humanoids in industry.</p>
</section>
</div>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="curieuxjy/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Jung Yeon Lee</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/curieuxjy">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>